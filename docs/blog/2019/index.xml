<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener â€“ 2019</title><link>https://gardener.cloud/blog/2019/</link><description>Recent content in 2019 on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 11 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://gardener.cloud/blog/2019/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Cluster Overprovisioning</title><link>https://gardener.cloud/blog/2019/06.11-cluster-overprovisioning/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/06.11-cluster-overprovisioning/</guid><description>
&lt;p>A tutorial was added that describes how to create an overprovisioning of cluster nodes for scaling and failover. This is desired when you have a work load that you need to scale up quickly without waiting for the new cluster nodes to be created and join the cluster.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/__resources/teaser-2_f90a41.png" alt="teaser">&lt;/p>
&lt;p>A similar problem occurs when crashing a node from the Hyperscaler. This must be replaced by Kubernetes as fast as possible. The solution can be the &lt;strong>overprovisioning&lt;/strong> of nodes.&lt;/p>
&lt;p>Learn more on &lt;a href="https://github.com/freegroup/kube-overprovisioning/blob/master/README.md">Cluster Overprovisioning&lt;/a>.&lt;/p></description></item><item><title>Blog: Feature Flags in Kubernetes Applications</title><link>https://gardener.cloud/blog/2019/06.11-feature-flags-in-kubernetes-applications/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/06.11-feature-flags-in-kubernetes-applications/</guid><description>
&lt;p>Feature flags are used to change the behavior of a program at runtime without forcing a restart.&lt;/p>
&lt;p>Although they are essential in a native cloud environment, they cannot be implemented without significant effort on some platforms. Kubernetes has made this trivial. Here we will implement them through labels and annotations, but you can also implement them by connecting directly to the Kubernetes API Server.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/__resources/teaser-2_642576.gif" alt="teaser">&lt;/p>
&lt;p>&lt;strong>Possible Use Cases&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Turn on/off a specific instance&lt;/li>
&lt;li>Turn on/off the profiling of a specific instance&lt;/li>
&lt;li>Change the logging level, to capture detailed logs during a specific event&lt;/li>
&lt;li>Change caching strategy at runtime&lt;/li>
&lt;li>Change timeouts in production&lt;/li>
&lt;li>Toggle on/off some special verification&lt;/li>
&lt;/ul></description></item><item><title>Blog: Manually Adding a Node to an Existing Cluster</title><link>https://gardener.cloud/blog/2019/06.11-manually-adding-a-node-to-an-existing-cluster/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/06.11-manually-adding-a-node-to-an-existing-cluster/</guid><description>
&lt;p>Gardener has an excellent ability to &lt;a href="https://gardener.cloud/blog/2021/01.25-machine-controller-manager/">automatically scale machines&lt;/a> for the cluster. From the point of view of scalability, there is &lt;strong>no need for manual intervention&lt;/strong>.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/__resources/teaser_5ace31.svg" alt="teaser">&lt;/p>
&lt;p>This tutorial is useful for those end-users who need specifically configured nodes, which are not yet supported by Gardener. For example: an end-user who wants some workload that requires &lt;code>runnc&lt;/code> instead of &lt;code>runc&lt;/code> as container runtime.&lt;/p></description></item><item><title>Blog: Organizing Access Using kubeconfig Files</title><link>https://gardener.cloud/blog/2019/06.11-organizing-access-using-kubeconfig-files/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/06.11-organizing-access-using-kubeconfig-files/</guid><description>
&lt;p>The kubectl command-line tool uses &lt;code>kubeconfig&lt;/code> files to find the information it needs in order to choose a cluster and communicate with its API server.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/__resources/teaser-1_641af2.svg" alt="teaser">&lt;/p>
&lt;h3 id="what-happens-if-the-kubeconfig-file-of-your-production-cluster-is-leaked-or-published-by-accident">What happens if the kubeconfig file of your production cluster is leaked or published by accident?&lt;/h3>
&lt;p>Since there is no possibility to rotate or revoke the initial kubeconfig, there is only one way to protect your infrastructure or application if the kubeconfig has leaked - &lt;strong>delete the cluster&lt;/strong>.&lt;/p>
&lt;p>Learn more on &lt;a href="https://github.com/gardener/documentation/blob/master/website/documentation/guides/client_tools/working-with-kubeconfig/_index.md">Organizing Access Using kubeconfig Files&lt;/a>.&lt;/p></description></item></channel></rss>