<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=canonical type=text/html href=https://gardener.cloud/docs/gardener/development/><link rel=alternate type=application/rss+xml href=https://gardener.cloud/docs/gardener/development/index.xml><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=icon type=image/x-icon href=https://gardener.cloud/images/favicon.ico><link rel=icon type=image/png href=https://gardener.cloud/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://gardener.cloud/images/favicon-16x16.png sizes=16x16><title>Development | Gardener</title><meta name=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:title" content="Development"><meta property="og:description" content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:type" content="website"><meta property="og:url" content="https://gardener.cloud/docs/gardener/development/"><meta itemprop=name content="Development"><meta itemprop=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta name=twitter:card content="summary"><meta name=twitter:title content="Development"><meta name=twitter:description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><link rel=preload href=/scss/main.min.ca2e9ddee7809848b536632b41e4e4df665800778ffe11b75edde5bdd6c78963.css as=style><link href=/scss/main.min.ca2e9ddee7809848b536632b41e4e4df665800778ffe11b75edde5bdd6c78963.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://unpkg.com/lunr@2.3.8/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg width="90" height="90" viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>logo</title><desc>Created with Sketch.</desc><defs><path d="M41.8864954.994901575c.996545099999999-.479910833 2.6164002-.477918931 3.6088091.0L76.8159138 16.0781121C77.8124589 16.5580229 78.8208647 17.8257185 79.0659694 18.8995926l7.7355517 33.8916663C87.0476474 53.8696088 86.6852538 55.4484075 85.9984855 56.3095876L64.3239514 83.4885938C63.6343208 84.3533632 62.1740175 85.0543973 61.0725268 85.0543973H26.3092731c-1.1060816.0-2.5646564-.704623400000003-3.2514246-1.5658035L1.38331434 56.3095876C.693683723 55.4448182.335174016 53.865133.580278769 52.7912589L8.31583044 18.8995926C8.56195675 17.8212428 9.57347722 16.556031 10.5658861 16.0781121L41.8864954.994901575z" id="path-1"/><linearGradient x1="12.7542673%" y1="-18.6617048%" x2="88.2666158%" y2="84.6075483%" id="linearGradient-3"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="50%" y1="4.93673768%" x2="148.756007%" y2="175.514523%" id="linearGradient-4"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="19.1574381%" y1="-9.04800713%" x2="82.2203149%" y2="77.9084293%" id="linearGradient-5"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="57.4403751%" y1="26.3148481%" x2="137.966711%" y2="158.080556%" id="linearGradient-6"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><g id="Rectangle-2" transform="translate(1.000000, 0.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Mask" fill="#009f76" xlink:href="#path-1"/><polygon fill="#000" opacity=".289628623" mask="url(#mask-2)" points="-17.6484375 54.5224609 30.8242188 25.0791016 63.4726562 58.5 24.7324219 92.6689453"/></g><path d="M56.8508631 39.260019C56.4193519 40.443987 55.6088085 41.581593 54.6736295 42.1938694l-8.0738997 5.2861089c-1.3854671.907087099999998-3.6247515.9116711-5.0172201.0L33.50861 42.1938694C32.123143 41.2867823 31 39.206345 31 37.545932V26.4150304c0-.725313.2131118-1.5301454.569268099999999-2.2825772L56.8508631 39.260019z" id="Combined-Shape" fill="url(#linearGradient-3)" transform="translate(43.925432, 36.147233) scale(-1, 1) translate(-43.925432, -36.147233)"/><path d="M56.0774672 25.1412464C56.4306829 25.8903325 56.6425556 26.6907345 56.6425556 27.4119019V38.5428034c0 1.6598979-1.1161415 3.73626640000001-2.50861 4.6479374l-8.0738997 5.286109c-1.3854671.907087000000004-3.6247516.911671000000005-5.0172201.0L32.9689261 43.1907408C32.2918101 42.7474223 31.6773514 42.0238435 31.2260376 41.206007L56.0774672 25.1412464z" id="Combined-Shape" fill="url(#linearGradient-4)" transform="translate(43.821278, 37.246598) scale(-1, 1) translate(-43.821278, -37.246598)"/><path d="M65.0702134 57.1846889C64.5985426 58.2007851 63.8367404 59.1236871 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.1597438 58.7930183 24 56.7816693 24 55.1323495V37.1145303C24 36.3487436 24.249712 35.5060005 24.6599102 34.7400631L65.0702134 57.1846889z" id="Combined-Shape" fill="url(#linearGradient-5)"/><path d="M65.0189476 34.954538C65.3636909 35.6617313 65.5692194 36.42021 65.5692194 37.1145303V55.1323495C65.5692194 56.7842831 64.4072119 58.7943252 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.9237304 59.2341061 25.3159155 58.5918431 24.8568495 57.8487596L65.0189476 34.954538z" id="Combined-Shape" fill="url(#linearGradient-6)"/></g></g></svg></span><span class=text-capitalize>Gardener</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/adopter><span>Adopters</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/blog><span>Blogs</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community><span>Community</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs><span>Documentation</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.2035d9813dafac83fe2a48b18d50f237.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/gardener/development/>Return to the regular view of this page</a>.</p></div><h1 class=title>Development</h1><div class=content></div></div><div class=td-content><h1 id=pg-d3de31ca8fda3468ee64b931363985a9>1 - Changing The Api</h1><h1 id=extending-the-api>Extending the API</h1><p>This document describes the steps that need to be performed when changing the API.
It provides guidance for API changes to both (Gardener system in general or component configurations).</p><p>Generally, as Gardener is a Kubernetes-native extension, it follows the same API conventions and guidelines like Kubernetes itself.
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md>This document</a> as well as <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md>this document</a> already provide a good overview and general explanation of the basic concepts behind it.
We are following the same approaches.</p><h2 id=gardener-api>Gardener API</h2><p>The Gardener API is defined in <code>pkg/apis/{core,extensions,settings}</code> directories and is the main point of interaction with the system.
It must be ensured that the API is always backwards-compatible.
If fields shall be removed permanently from the API then a proper deprecation period must be adhered to so that end-users have enough time adapt their clients.</p><p><strong>Checklist</strong> when changing the API:</p><ol><li>Modify the field(s) in the respective Golang files of all external and the internal version.<ol><li>Make sure new fields are being added as &ldquo;optional&rdquo; fields, i.e., they are of pointer types, they have the <code>// +optional</code> comment, and they have the <code>omitempty</code> JSON tag.</li><li>Make sure that the existing field numbers in the protobuf tags are not changed.</li></ol></li><li>If necessary then implement/adapt the conversion logic defined in the versioned APIs (e.g., <code>pkg/apis/core/v1beta1/conversions*.go</code>).</li><li>If necessary then implement/adapt defaulting logic defined in the versioned APIs (e.g., <code>pkg/apis/core/v1beta1/defaults*.go</code>).</li><li>Run the code generation: <code>make generate</code></li><li>If necessary then implement/adapt validation logic defined in the internal API (e.g., <code>pkg/apis/core/validation/validation*.go</code>).</li><li>If necessary then adapt the exemplary YAML manifests of the Gardener resources defined in <code>example/*.yaml</code>.</li><li>In most cases it makes sense to add/adapt the documentation for administrators/operators and/or end-users in the <code>docs</code> folder to provide information on purpose and usage of the added/changed fields.</li><li>When opening the pull request then always add a release note so that end-users are becoming aware of the changes.</li></ol><h2 id=component-configuration-apis>Component configuration APIs</h2><p>Most Gardener components have a component configuration that follows similar principles to the Gardener API.
Those component configurations are defined in <code>pkg/{controllermanager,gardenlet,scheduler},pkg/apis/config</code>.
Hence, the above checklist also applies for changes to those APIs.
However, since these APIs are only used internally and only during the deployment of Gardener the guidelines with respect to changes and backwards-compatibility are slightly relaxed.
If necessary then it is allowed to remove fields without a proper deprecation period if the release note uses the <code>breaking operator</code> keywords.</p><p>In addition to the above checklist:</p><ol><li>If necessary then adapt the Helm chart of Gardener defined in <code>charts/gardener</code>. Adapt the <code>values.yaml</code> file as well as the manifest templates.</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-58950a0fdac8b00f91fdd5b644642c8f>2 - Dependencies</h1><h1 id=dependency-management>Dependency Management</h1><p>We are using <a href=https://github.com/golang/go/wiki/Modules>go modules</a> for depedency management.
In order to add a new package dependency to the project, you can perform <code>go get &lt;PACKAGE>@&lt;VERSION></code> or edit the <code>go.mod</code> file and append the package along with the version you want to use.</p><h2 id=updating-dependencies>Updating Dependencies</h2><p>The <code>Makefile</code> contains a rule called <code>revendor</code> which performs <code>go mod tidy</code> and <code>go mod vendor</code>.
<code>go mod tidy</code> makes sure go.mod matches the source code in the module. It adds any missing modules necessary to build the current module&rsquo;s packages and dependencies, and it removes unused modules that don&rsquo;t provide any relevant packages.
<code>go mod vendor</code> resets the main module&rsquo;s vendor directory to include all packages needed to build and test all the main module&rsquo;s packages. It does not include test code for vendored packages.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make revendor
</code></pre></div><p>The dependencies are installed into the <code>vendor</code> folder which <strong>should be added</strong> to the VCS.</p><p>⚠️ Make sure that you test the code after you have updated the dependencies!</p><h2 id=exported-packages>Exported Packages</h2><p>This repository contains several packages that could be considered &ldquo;exported packages&rdquo;, in a sense that they are supposed to be reused in other Go projects.
For example:</p><ul><li>Gardener&rsquo;s API packages: <code>pkg/apis</code></li><li>Library for building Gardener extensions: <code>extensions</code></li><li>Gardener&rsquo;s Test Framework: <code>test/framework</code></li></ul><p>There are a few more folders in this repository (non-Go sources) that are reused across projects in the gardener organization:</p><ul><li>GitHub templates: <code>.github</code></li><li>Concourse / cc-utils related helpers: <code>hack/.ci</code></li><li>Development, build and testing helpers: <code>hack</code></li></ul><p>These packages feature a dummy <code>doc.go</code> file to allow other Go projects to pull them in as go mod dependencies.</p><p>These packages are explicitly <em>not</em> supposed to be used in other projects (consider them as &ldquo;non-exported&rdquo;):</p><ul><li>API validation packages: <code>pkg/apis/*/*/validation</code></li><li>Operation package (main Gardener business logic regarding <code>Seed</code> and <code>Shoot</code> clusters): <code>pkg/operation</code></li><li>Third party code: <code>third_party</code></li></ul><p>Currently, we don&rsquo;t have a mechanism yet for selectively syncing out these exported packages into dedicated repositories like kube&rsquo;s <a href=https://github.com/kubernetes/kubernetes/tree/master/staging>staging mechanism</a> (<a href=https://github.com/kubernetes/publishing-bot>publishing-bot</a>).</p><h2 id=import-restrictions>Import Restrictions</h2><p>We want to make sure, that other projects can depend on this repository&rsquo;s &ldquo;exported&rdquo; packages without pulling in the entire repository (including &ldquo;non-exported&rdquo; packages) or a high number of other unwanted dependencies.
Hence, we have to be careful when adding new imports or references between our packages.</p><blockquote><p>ℹ️ General rule of thumb: the mentioned &ldquo;exported&rdquo; packages should be as self-contained as possible and depend on as few other packages in the repository and other projects as possible.</p></blockquote><p>In order to support that rule and automatically check compliance with that goal, we leverage <a href=https://github.com/kubernetes/code-generator/tree/master/cmd/import-boss>import-boss</a>.
The tool checks all imports of the given packages (including transitive imports) against rules defined in <code>.import-restrictions</code> files in each directory.
An import is allowed if it matches at least one allowed prefix and does not match any forbidden prefixes.
Note: <code>''</code> (the empty string) is a prefix of everything.
For more details, see: <a href=https://github.com/kubernetes/code-generator/tree/master/cmd/import-boss>https://github.com/kubernetes/code-generator/tree/master/cmd/import-boss</a></p><p><code>import-boss</code> is executed on every pull request and blocks the PR if it doesn&rsquo;t comply with the defined import restrictions.
You can also run it locally using <code>make check</code>.</p><p>Import restrictions should be changed in the following situations:</p><ul><li>We spot a new pattern of imports across our packages that was not restricted before but makes it more difficult for other projects to depend on our &ldquo;exported&rdquo; packages.
In that case, the imports should be further restricted to disallow such problematic imports, and the code/package structure should be reworked to comply with the newly given restrictions.</li><li>We want to share code between packages, but existing import restrictions prevent us from doing so.
In that case, please consider what additional dependencies it will pull in, when loosening existing restrictions.
Also consider possible alternatives, like code restructurings or extracting shared code into dedicated packages for minimal impact on dependent projects.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-94e3f754736ad20216bc6c1d11abac6f>3 - Getting Started Locally</h1><h1 id=running-gardener-locally>Running Gardener locally</h1><p>This document will walk you through running Gardener on your local machine for development purposes.
If you encounter difficulties, please open an issue so that we can make this process easier.</p><p>Gardener runs in any Kubernetes cluster.
In this guide, we will start a <a href=https://kind.sigs.k8s.io/>KinD</a> cluster which is used as both garden and seed cluster (please refer to the <a href=/docs/gardener/concepts/architecture/>architecture overview</a>) for simplicity.</p><p>The Gardener components, however, will be run as regular processes on your machine (hence, no container images are being built).</p><p><img src=/__resources/getting_started_locally_39a5b3.png alt="Architecture Diagram"></p><h2 id=prerequisites>Prerequisites</h2><ul><li><p>Make sure your Docker daemon is up-to-date, up and running and has enough resources (at least <code>4</code> CPUs and <code>4Gi</code> memory; see <a href=https://docs.docker.com/desktop/mac/#resources>here</a> how to configure the resources for Docker for Mac).</p><blockquote><p>Please note that 4 CPU / 4Gi memory might not be enough for more than one <code>Shoot</code> cluster, i.e., you might need to increase these values if you want to run additional <code>Shoot</code>s.</p></blockquote><p>Additionally, please configure at least <code>120Gi</code> of disk size for the Docker daemon.</p><blockquote><p>Tip: With <code>docker system df</code> and <code>docker system prune -a</code> you can cleanup unused data.</p></blockquote></li><li><p>Make sure that you increase the maximum number of open files on your host:</p><ul><li><p>On Mac, run <code>sudo launchctl limit maxfiles 65536 200000</code></p></li><li><p>On Linux, extend the <code>/etc/security/limits.conf</code> file with</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>* hard nofile 97816
* soft nofile 97816
</code></pre></div><p>and reload the terminal.</p></li></ul></li></ul><h2 id=setting-up-the-kind-cluster-garden-and-seed>Setting up the KinD cluster (garden and seed)</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up KIND_ENV=local
</code></pre></div><p>This command sets up a new KinD cluster named <code>gardener-local</code> and stores the kubeconfig in the <code>./example/gardener-local/kind/kubeconfig</code> file.</p><blockquote><p>It might be helpful to copy this file to <code>$HOME/.kube/config</code> since you will need to target this KinD cluster multiple times.
Alternatively, make sure to set your <code>KUBECONFIG</code> environment variable to <code>./example/gardener-local/kind/kubeconfig</code> for all future steps via <code>export KUBECONFIG=example/gardener-local/kind/kubeconfig</code>.</p></blockquote><p>All following steps assume that your are using this kubeconfig.</p><h2 id=setting-up-gardener>Setting up Gardener</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make dev-setup                                                                <span style=color:green># preparing the environment (without webhooks for now)</span>
kubectl wait --for=condition=ready pod -l run=etcd -n garden --timeout 2m     <span style=color:green># wait for etcd to be ready</span>
make start-apiserver                                                          <span style=color:green># starting gardener-apiserver</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=available apiservice v1beta1.core.gardener.cloud <span style=color:green># wait for gardener-apiserver to be ready</span>
make start-admission-controller                                               <span style=color:green># starting gardener-admission-controller</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make dev-setup DEV_SETUP_WITH_WEBHOOKS=true                                   <span style=color:green># preparing the environment with webhooks</span>
make start-controller-manager                                                 <span style=color:green># starting gardener-controller-manager</span>
</code></pre></div><p>(Optional): In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-scheduler                                                          <span style=color:green># starting gardener-scheduler</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make register-local-env                                                       <span style=color:green># registering the local environment (CloudProfile, Seed, etc.)</span>
make start-gardenlet SEED_NAME=local                                          <span style=color:green># starting gardenlet</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-extension-provider-local                                           <span style=color:green># starting gardener-extension-provider-local</span>
</code></pre></div><p>ℹ️ The <a href=/docs/gardener/extensions/provider-local/><code>provider-local</code></a> is started with elevated privileges since it needs to manipulate your <code>/etc/hosts</code> file to enable you accessing the created shoot clusters from your local machine, see <a href=/docs/gardener/extensions/provider-local/#dnsrecord>this</a> for more details.</p><h2 id=creating-a-shoot-cluster>Creating a <code>Shoot</code> cluster</h2><p>You can wait for the <code>Seed</code> to be ready by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=gardenletready --for=condition=extensionsready --for=condition=bootstrapped seed local --timeout=5m
</code></pre></div><p>Alternatively, you can run <code>kubectl get seed local</code> and wait for the <code>STATUS</code> to indicate readiness:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME    STATUS   PROVIDER   REGION   AGE     VERSION       K8S VERSION
local   Ready    local      local    4m42s   vX.Y.Z-dev    v1.21.1
</code></pre></div><p>In order to create a first shoot cluster, just run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f example/provider-local/shoot.yaml
</code></pre></div><p>You can wait for the <code>Shoot</code> to be ready by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=apiserveravailable --for=condition=controlplanehealthy --for=condition=everynodeready --for=condition=systemcomponentshealthy shoot local -n garden-local --timeout=10m
</code></pre></div><p>Alternatively, you can run <code>kubectl -n garden-local get shoot local</code> and wait for the <code>LAST OPERATION</code> to reach <code>100%</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME    CLOUDPROFILE   PROVIDER   REGION   K8S VERSION   HIBERNATION   LAST OPERATION            STATUS    AGE
local   local          local      local    1.21.0        Awake         Create Processing (43%)   healthy   94s
</code></pre></div><p>(Optional): You could also execute a simple e2e test (creating and deleting a shoot) by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make test-e2e-local-fast KUBECONFIG=<span style=color:#a31515>&#34;</span>$PWD<span style=color:#a31515>/example/gardener-local/kind/kubeconfig&#34;</span>
</code></pre></div><p>When the shoot got successfully created you can access it as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-local get secret local.kubeconfig -o jsonpath={.data.kubeconfig} | base64 -d &gt; /tmp/kubeconfig-shoot-local.yaml
kubectl --kubeconfig=/tmp/kubeconfig-shoot-local.yaml get nodes
</code></pre></div><h2 id=deleting-the-shoot-cluster>Deleting the <code>Shoot</code> cluster</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>./hack/usage/delete shoot local garden-local
</code></pre></div><h2 id=tear-down-the-gardener-environment>Tear down the Gardener environment</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make tear-down-local-env
make kind-down
</code></pre></div><h2 id=further-reading>Further reading</h2><p>This setup makes use of the local provider extension. You can read more about it in <a href=/docs/gardener/extensions/provider-local/>this document</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c95b2a377d941a326c0914b796d1f8d3>4 - Kubernetes Clients</h1><h1 id=kubernetes-clients-in-gardener>Kubernetes Clients in Gardener</h1><p>This document aims at providing a general developer guideline on different aspects of using Kubernetes clients in a large-scale distributed system and project like Gardener.
The points included here are not meant to be consulted as absolute rules, but rather as general rules of thumb, that allow developers to get a better feeling about certain gotchas and caveats.
It should be updated with lessons learned from maintaining the project and running Gardener in production.</p><p><strong>Prerequisites</strong>:</p><p>Please familiarize yourself with the following basic Kubernetes API concepts first, if you&rsquo;re new to Kubernetes. A good understanding of these basics will help you better comprehend the following document.</p><ul><li><a href=https://kubernetes.io/docs/reference/using-api/api-concepts/>Kubernetes API Concepts</a> (including terminology, watch basics, etc.)</li><li><a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>Extending the Kubernetes API</a> (including Custom Resources and aggregation layer / extension API servers)</li><li><a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Extend the Kubernetes API with CustomResourceDefinitions</a></li><li><a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/>Working with Kubernetes Objects</a></li><li><a href=https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md>Sample Controller</a> (the diagram helps to build an understanding of an controller&rsquo;s basic structure)</li></ul><h2 id=client-types-client-go-generated-controller-runtime>Client Types: Client-Go, Generated, Controller-Runtime</h2><p>For historical reasons, you will find different kinds of Kubernetes clients in Gardener:</p><h3 id=client-go-clients>Client-Go Clients</h3><p><a href=https://github.com/kubernetes/client-go>client-go</a> is the default/official client for talking to the Kubernetes API in Golang.
It features so called <a href=https://github.com/kubernetes/client-go/blob/release-1.21/kubernetes/clientset.go#L72>&ldquo;client sets&rdquo;</a> for all built-in Kubernetes API groups and versions (e.g. <code>v1</code> (aka <code>core/v1</code>), <code>apps/v1</code>, etc.).
client-go clients are generated from the built-in API types using <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/generating-clientset.md>client-gen</a> and are composed of interfaces for every known API GroupVersionKind.
A typical client-go usage looks like this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx        context.Context
  c          kubernetes.Interface <span style=color:green>// &#34;k8s.io/client-go/kubernetes&#34;
</span><span style=color:green></span>  deployment *appsv1.Deployment   <span style=color:green>// &#34;k8s.io/api/apps/v1&#34;
</span><span style=color:green></span>)

updatedDeployment, err := c.AppsV1().Deployments(<span style=color:#a31515>&#34;default&#34;</span>).Update(ctx, deployment, metav1.UpdateOptions{})
</code></pre></div><p><em>Important characteristics of client-go clients:</em></p><ul><li>clients are specific to a given API GroupVersionKind, i.e., clients are hard-coded to corresponding API-paths (don&rsquo;t need to use the discovery API to map GVK to a REST endpoint path).</li><li>client&rsquo;s don&rsquo;t modify the passed in-memory object (e.g. <code>deployment</code> in the above example). Instead, they return a new in-memory object.<br>This means, controllers have to continue working with the new in-memory object or overwrite the shared object to not lose any state updates.</li></ul><h3 id=generated-client-sets-for-gardener-apis>Generated Client Sets for Gardener APIs</h3><p>Gardener&rsquo;s APIs extend the Kubernetes API by registering an extension API server (in the garden cluster) and <code>CustomResourceDefinition</code>s (on Seed clusters), meaning that the Kubernetes API will expose additional REST endpoints to manage Gardener resources in addition to the built-in API resources.
In order to talk to these extended APIs in our controllers and components, client-gen is used to generate client-go-style clients to <a href=https://github.com/gardener/gardener/tree/master/pkg/client><code>pkg/client/{core,extensions,seedmanagement,...}</code></a>.</p><p>Usage of these clients is equivalent to <code>client-go</code> clients, and the same characteristics apply. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx   context.Context
  c     gardencoreclientset.Interface <span style=color:green>// &#34;github.com/gardener/gardener/pkg/client/core/clientset/versioned&#34;
</span><span style=color:green></span>  shoot *gardencorev1beta1.Shoot      <span style=color:green>// &#34;github.com/gardener/gardener/pkg/apis/core/v1beta1&#34;
</span><span style=color:green></span>)

updatedShoot, err := c.CoreV1beta1().Shoots(<span style=color:#a31515>&#34;garden-my-project&#34;</span>).Update(ctx, shoot, metav1.UpdateOptions{})
</code></pre></div><h3 id=controller-runtime-clients>Controller-Runtime Clients</h3><p><a href=https://github.com/kubernetes-sigs/controller-runtime>controller-runtime</a> is a Kubernetes community project (<a href=https://github.com/kubernetes-sigs/kubebuilder>kubebuilder</a> subproject) for building controllers and operators for custom resources.
Therefore, it features a generic client, that follows a different approach and does not rely on generated client sets. Instead, the client can be used for managing any Kubernetes resources (built-in or custom) homogeneously.
For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx        context.Context
  c          client.Client            <span style=color:green>// &#34;sigs.k8s.io/controller-runtime/pkg/client&#34;
</span><span style=color:green></span>  deployment *appsv1.Deployment       <span style=color:green>// &#34;k8s.io/api/apps/v1&#34;
</span><span style=color:green></span>  shoot      *gardencorev1beta1.Shoot <span style=color:green>// &#34;github.com/gardener/gardener/pkg/apis/core/v1beta1&#34;
</span><span style=color:green></span>)

err := c.Update(ctx, deployment)
<span style=color:green>// or
</span><span style=color:green></span>err = c.Update(ctx, shoot)
</code></pre></div><p>A brief introduction to controller-runtime and its basic constructs can be found <a href=https://pkg.go.dev/sigs.k8s.io/controller-runtime>here</a>.</p><p><em>Important characteristics of controller-runtime clients:</em></p><ul><li>The client functions take a generic <code>client.Object</code> or <code>client.ObjectList</code> value. These interfaces are implemented by all Golang types, that represent Kubernetes API objects or lists respectively which can be interacted with via usual API requests. [1]</li><li>The client first consults a <code>runtime.Scheme</code> (configured during client creation) for recognizing the object&rsquo;s <code>GroupVersionKind</code> (this happens on the client-side only).<br>A <code>runtime.Scheme</code> is basically a registry for Golang API types, defaulting and conversion functions. Schemes are usually provided per <code>GroupVersion</code> (see <a href=https://github.com/kubernetes/api/blob/release-1.21/apps/v1/register.go>this example</a> for <code>apps/v1</code>) and can be combined to one single scheme for further usage (<a href=https://github.com/gardener/gardener/blob/v1.29.0/pkg/client/kubernetes/types.go#L96>example</a>). In controller-runtime clients, schemes are used only for mapping a typed API object to its <code>GroupVersionKind</code>.</li><li>It then consults a <code>meta.RESTMapper</code> (also configured during client creation) for mapping the <code>GroupVersionKind</code> to a <code>RESTMapping</code>, which contains the <code>GroupVersionResource</code> and <code>Scope</code> (namespaced or cluster-scoped). From these values, the client can unambiguously determine the REST endpoint path of the corresponding API resource. For instance: <code>appsv1.DeploymentList</code> is available at <code>/apis/apps/v1/deployments</code> or <code>/apis/apps/v1/namespaces/&lt;namespace>/deployments</code> respectively.<ul><li>There are different <code>RESTMapper</code> implementations, but generally they are talking to the API server&rsquo;s discovery API for retrieving <code>RESTMappings</code> for all API resources known to the API server (either built-in, registered via API extension or <code>CustomResourceDefinition</code>s).</li><li>The default implementation of controller-runtime (which Gardener uses as well), is the <a href=https://github.com/kubernetes-sigs/controller-runtime/blob/v0.9.0/pkg/client/apiutil/dynamicrestmapper.go#L77>dynamic <code>RESTMapper</code></a>. It caches discovery results (i.e. <code>RESTMappings</code>) in-memory and only re-discovers resources from the API server, when a client tries to use an unknown <code>GroupVersionKind</code>, i.e., when it encounters a <code>No{Kind,Resource}MatchError</code>.</li></ul></li><li>The client writes back results from the API server into the passed in-memory object.<ul><li>This means, that controllers don&rsquo;t have to worry about copying back the results and should just continue to work on the given in-memory object.</li><li>This is a nice and flexible pattern and helper functions should try to follow it wherever applicable. Meaning, if possible accept an object param, pass it down to clients and keep working on the same in-memory object instead of creating a new one in your helper function.</li><li>The benefit is, that you don&rsquo;t lose updates to the API object and always have the last-known state in memory. Therefore, you don&rsquo;t have to read it again, e.g., for getting the current <code>resourceVersion</code> when working with <a href=#conflicts-concurrency-control-and-optimistic-locking>optimistic locking</a>, and thus minimize the chances for running into conflicts.</li><li>However, controllers <em>must not</em> use the same in-memory object concurrently in multiple goroutines. For example, decoding results from the API server in multiple goroutines into the same maps (e.g., labels, annotations) will cause panics because of &ldquo;concurrent map writes&rdquo;. Also, reading from an in-memory API object in one goroutine while decoding into it in another goroutine will yield non-atomic reads, meaning data might be corrupt and represent a non-valid/non-existing API object.</li><li>Therefore, if you need to use the same in-memory object in multiple goroutines concurrently (e.g., shared state), remember to leverage proper synchronization techniques like channels, mutexes, <code>atomic.Value</code> and/or copy the object prior to use. The average controller however, will not need to share in-memory API objects between goroutines, and it&rsquo;s typically an indicator that the controller&rsquo;s design should be improved.</li></ul></li><li>The client decoder erases the object&rsquo;s <code>TypeMeta</code> (<code>apiVersion</code> and <code>kind</code> fields) after retrieval from the API server, see <a href=https://github.com/kubernetes/kubernetes/issues/80609>kubernetes/kubernetes#80609</a>, <a href=https://github.com/kubernetes-sigs/controller-runtime/issues/1517>kubernetes-sigs/controller-runtime#1517</a>.
Unstructured and metadata-only requests objects are an exception to this because the contained <code>TypeMeta</code> is the only way to identify the object&rsquo;s type.
Because of this behavior, <code>obj.GetObjectKind().GroupVersionKind()</code> is likely to return an empty <code>GroupVersionKind</code>.
I.e., you must not rely on <code>TypeMeta</code> being set or <code>GetObjectKind()</code> to return something usable.<br>If you need to identify an object&rsquo;s <code>GroupVersionKind</code>, use a scheme and its <code>ObjectKinds</code> function instead (or the helper function <code>apiutil.GVKForObject</code>).
This is not specific to controller-runtime clients and applies to client-go clients as well.</li></ul><p>[1] Other lower level, config or internal API types (e.g., such as <a href=https://github.com/kubernetes/api/blob/release-1.21/admission/v1/types.go#L29><code>AdmissionReview</code></a>) don&rsquo;t implement <code>client.Object</code>. However, you also can&rsquo;t interact with such objects via the Kubernetes API and thus also not via a client, so this can be disregarded at this point.</p><h3 id=metadata-only-clients>Metadata-Only Clients</h3><p>Additionally, controller-runtime clients can be used to easily retrieve metadata-only objects or lists.
This is useful for efficiently checking if at least one object of a given kind exists, or retrieving metadata of an object, if one is not interested in the rest (e.g., spec/status).<br>The <code>Accept</code> header sent to the API server then contains <code>application/json;as=PartialObjectMetadataList;g=meta.k8s.io;v=v1</code>, which makes the API server only return metadata of the retrieved object(s).
This saves network traffic and cpu/memory load on the API server and client side.
If the client fully lists all objects of a given kind including their spec/status, the resulting list can be quite large and easily exceed the controllers available memory.
That&rsquo;s why it&rsquo;s important to carefully check, if a full list is actually needed or if metadata-only list can be used instead.</p><p>For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx       context.Context
  c         client.Client                         <span style=color:green>// &#34;sigs.k8s.io/controller-runtime/pkg/client&#34;
</span><span style=color:green></span>  shootList = &amp;metav1.PartialObjectMetadataList{} <span style=color:green>// &#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;
</span><span style=color:green></span>)
shootList.SetGroupVersionKind(gardencorev1beta1.SchemeGroupVersion.WithKind(<span style=color:#a31515>&#34;ShootList&#34;</span>))

<span style=color:#00f>if</span> err := c.List(ctx, shootList, client.InNamespace(<span style=color:#a31515>&#34;garden-my-project&#34;</span>), client.Limit(1)); err != <span style=color:#00f>nil</span> {
  <span style=color:#00f>return</span> err
}

<span style=color:#00f>if</span> len(shootList.Items) &gt; 0 {
  <span style=color:green>// project has at least one shoot
</span><span style=color:green></span>} <span style=color:#00f>else</span> {
  <span style=color:green>// project doesn&#39;t have any shoots
</span><span style=color:green></span>}
</code></pre></div><h3 id=gardeners-client-collection-clientmaps>Gardener&rsquo;s Client Collection, ClientMaps</h3><p>The Gardener codebase has a collection of clients (<a href=https://github.com/gardener/gardener/blob/v1.29.0/pkg/client/kubernetes/types.go#L149><code>kubernetes.Interface</code></a>), which can return all the above mentioned client types.
Additionally, it contains helpers for rendering and applying helm charts (<code>ChartRender</code>, <code>ChartApplier</code>) and retrieving the API server&rsquo;s version (<code>Version</code>).<br>Client sets are managed by so called <code>ClientMap</code>s, which are a form of registry for all client set for a given type of cluster, i.e., Garden, Seed, Shoot and Plant.
ClientMaps manage the whole lifecycle of clients: they take care of creating them if they don&rsquo;t exist already, running their caches, refreshing their cached server version and invalidating them when they are no longer needed.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx   context.Context
  cm    clientmap.ClientMap <span style=color:green>// &#34;github.com/gardener/gardener/pkg/client/kubernetes/clientmap&#34;
</span><span style=color:green></span>  shoot *gardencorev1beta1.Shoot
)

cs, err := cm.GetClient(ctx, keys.ForShoot(shoot)) <span style=color:green>// kubernetes.Interface
</span><span style=color:green></span><span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
  <span style=color:#00f>return</span> err
}

c := cs.Client() <span style=color:green>// client.Client
</span></code></pre></div><p>The client collection mainly exist for historical reasons (there used to be a lot of code using the client-go style clients).
However, Gardener is in the process of moving more towards controller-runtime and only using their clients, as they provide many benefits and are much easier to use.
Also, <a href=https://github.com/gardener/gardener/issues/4251>gardener/gardener#4251</a> aims at refactoring our controller and admission components to native controller-runtime components.</p><blockquote><p>⚠️ Please always prefer controller-runtime clients over other clients when writing new code or refactoring existing code.</p></blockquote><h2 id=cache-types-informers-listers-controller-runtime-caches>Cache Types: Informers, Listers, Controller-Runtime Caches</h2><p>Similar to the different types of client(set)s, there are also different kinds of Kubernetes client caches.
However, all of them are based on the same concept: <code>Informer</code>s.
An <code>Informer</code> is a watch-based cache implementation, meaning it opens <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes>watch connections</a> to the API server and continuously updates cached objects based on the received watch events (<code>ADDED</code>, <code>MODIFIED</code>, <code>DELETED</code>).
<code>Informer</code>s offer to add indices to the cache for efficient object lookup (e.g., by name or labels) and to add <code>EventHandler</code>s for the watch events.
The latter is used by controllers to fill queues with objects that should be reconciled on watch events.</p><p>Informers are used in and created via several higher-level constructs:</p><h3 id=sharedinformerfactories-listers>SharedInformerFactories, Listers</h3><p>The generated clients (built-in as well as extended) feature a <code>SharedInformerFactory</code> for every API group, which can be used to create and retrieve <code>Informers</code> for all GroupVersionKinds.
Similarly, it can be used to retrieve <code>Listers</code>, that allow getting and listing objects from the <code>Informer</code>&rsquo;s cache.
However, both of these constructs are only used for historical reasons, and we are in the process of migrating away from them in favor of cached controller-runtime clients (see <a href=https://github.com/gardener/gardener/issues/2414>gardener/gardener#2414</a>, <a href=https://github.com/gardener/gardener/issues/2822>gardener/gardener#2822</a>). Thus, they are described only briefly here.</p><p><em>Important characteristics of Listers:</em></p><ul><li>Objects read from Informers and Listers can always be slightly out-out-date (i.e., stale) because the client has to first observe changes to API objects via watch events (which can intermittently lag behind by a second or even more).</li><li>Thus, don&rsquo;t make any decisions based on data read from Listers if the consequences of deciding wrongfully based on stale state might be catastrophic (e.g. leaking infrastructure resources). In such cases, read directly from the API server via a client instead.</li><li>Objects retrieved from Informers or Listers are pointers to the cached objects, so they must not be modified without copying them first, otherwise the objects in the cache are also modified.</li></ul><h3 id=controller-runtime-caches>Controller-Runtime Caches</h3><p>controller-runtime features a cache implementation that can be used equivalently as their clients. In fact, it implements a subset of the <code>client.Client</code> interface containing the <code>Get</code> and <code>List</code> functions.
Under the hood, a <code>cache.Cache</code> dynamically creates <code>Informers</code> (i.e., opens watches) for every object GroupVersionKind that is being retrieved from it.</p><p>Note, that the underlying Informers of a controller-runtime cache (<code>cache.Cache</code>) and the ones of a <code>SharedInformerFactory</code> (client-go) are not related in any way.
Both create <code>Informers</code> and watch objects on the API server individually.
This means, that if you read the same object from different cache implementations, you may receive different versions of the object because the watch connections of the individual Informers are not synced.</p><blockquote><p>⚠️ Because of this, controllers/reconcilers should get the object from the same cache in the reconcile loop, where the <code>EventHandler</code> was also added to set up the controller. For example, if a <code>SharedInformerFactory</code> is used for setting up the controller then read the object in the reconciler from the <code>Lister</code> instead of from a cached controller-runtime client.</p></blockquote><p>By default, the <code>client.Client</code> created by a controller-runtime <code>Manager</code> is a <code>DelegatingClient</code>. It delegates <code>Get</code> and <code>List</code> calls to a <code>Cache</code> and all other calls to a client, that talks directly to the API server. Exceptions are requests with <code>*unstructured.Unstructured</code> objects and object kinds that were configured to be excluded from the cache in the <code>DelegatingClient</code>.</p><blockquote><p>ℹ️
If the <code>CachedRuntimeClients</code> feature gate is enabled (enabled by default starting from <code>v1.34</code>), <code>kubernetes.Interface.Client()</code> returns a <code>DelegatingClient</code> that uses the cache returned from <code>kubernetes.Interface.Cache()</code> under the hood. This means, all <code>Client()</code> usages need to be ready for cached clients and should be able to cater with stale cache reads.
See <a href=https://github.com/gardener/gardener/issues/2822>gardener/gardener#2822</a> for details on the graduation progress to beta.</p><p>If the feature gate is explicitly disabled, the controller-runtime client (<code>kubernetes.Interface.Client()</code>) is not cached and does not use the cache contained in the client set (<code>kubernetes.Interface.Cache()</code>). This means, the client always reads directly from the API server, but you can intentionally read from the cache if desired.</p></blockquote><p><em>Important characteristics of cached controller-runtime clients:</em></p><ul><li>Like for Listers, objects read from a controller-runtime cache can always be slightly out of date. Hence, don&rsquo;t base any important decisions on data read from the cache (see above).</li><li>In contrast to Listers, controller-runtime caches fill the passed in-memory object with the state of the object in the cache (i.e., they perform something like a &ldquo;deep copy into&rdquo;). This means that objects read from a controller-runtime cache can safely be modified without unintended side effects.</li><li>Reading from a controller-runtime cache or a cached controller-runtime client implicitly starts a watch for the given object kind under the hood. This has important consequences:<ul><li>Reading a given object kind from the cache for the first time can take up to a few seconds depending on size and amount of objects as well as API server latency. This is because the cache has to do a full list operation and wait for an initial watch sync before returning results.</li><li>⚠️ Controllers need appropriate RBAC permissions for the object kinds they retrieve via cached clients (i.e., <code>list</code> and <code>watch</code>).</li><li>⚠️ By default, watches started by a controller-runtime cache are cluster-scoped, meaning it watches and caches objects across all namespaces. Thus, be careful which objects to read from the cache as it might significantly increase the controller&rsquo;s memory footprint.</li></ul></li><li>There is no interaction with the cache on writing calls (<code>Create</code>, <code>Update</code>, <code>Patch</code> and <code>Delete</code>), see below.</li></ul><p><strong>Uncached objects, filtered caches, <code>APIReader</code>s:</strong></p><p>In order to allow more granular control over which object kinds should be cached and which calls should bypass the cache, controller-runtime offers a few mechanisms to further tweak the client/cache behavior:</p><ul><li>When creating a <code>DelegatingClient</code>, certain object kinds can be configured to always be read directly from the API instead of from the cache. Note that this does not prevent starting a new Informer when retrieving them directly from the cache.</li><li>Watches can be restricted to a given (set of) namespace(s) by using <code>cache.MultiNamespacedCacheBuilder</code> or setting <code>cache.Options.Namespace</code>.</li><li>Watches can be filtered (e.g., by label) per object kind by configuring <code>cache.Options.SelectorsByObject</code> on creation of the cache.</li><li>Retrieving metadata-only objects or lists from a cache results in a metadata-only watch/cache for that object kind.</li><li>The <code>APIReader</code> can be used to always talk directly to the API server for a given <code>Get</code> or <code>List</code> call (use with care and only as a last resort!).</li></ul><h3 id=to-cache-or-not-to-cache>To Cache or Not to Cache</h3><p>Although watch-based caches are an important factor for the immense scalability of Kubernetes, it definitely comes at a price (mainly in terms of memory consumption).
Thus, developers need to be careful when introducing new API calls and caching new object kinds.
Here are some general guidelines on choosing whether to read from a cache or not:</p><ul><li>Always try to use the cache wherever possible and make your controller able to tolerate stale reads.<ul><li>Leverage optimistic locking: use deterministic naming for objects you create (this is what the <code>Deployment</code> controller does [2]).</li><li>Leverage optimistic locking / concurrency control of the API server: send updates/patches with the last-known <code>resourceVersion</code> from the cache (see below). This will make the request fail, if there were concurrent updates to the object (conflict error), which indicates that we have operated on stale data and might have made wrong decisions. In this case, let the controller handle the error with exponential backoff. This will make the controller eventually consistent.</li><li>Track the actions you took, e.g., when creating objects with <code>generateName</code> (this is what the <code>ReplicaSet</code> controller does [3]). The actions can be tracked in memory and repeated if the expected watch events don&rsquo;t occur after a given amount of time.</li><li>Always try to write controllers with the assumption that data will only be eventually correct and can be slightly out of date (even if read directly from the API server!).</li><li>If there is already some other code that needs a cache (e.g., a controller watch), reuse it instead of doing extra direct reads.</li><li>Don&rsquo;t read an object again if you just sent a write request. Write requests (<code>Create</code>, <code>Update</code>, <code>Patch</code> and <code>Delete</code>) don&rsquo;t interact with the cache. Hence, use the current state that the API server returned (filled into the passed in-memory object), which is basically a &ldquo;free direct read&rdquo;, instead of reading the object again from a cache, because this will probably set back the object to an older <code>resourceVersion</code>.</li></ul></li><li>If you are concerned about the impact of the resulting cache, try to minimize that by using filtered or metadata-only watches.</li><li>If watching and caching an object type is not feasible, for example because there will be a lot of updates, and you are only interested in the object every ~5m, or because it will blow up the controllers memory footprint, fallback to a direct read. This can either be done by disabling caching the object type generally or doing a single request via an <code>APIReader</code>. In any case, please bear in mind that every direct API call results in a <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#the-resourceversion-parameter>quorum read from etcd</a>, which can be costly in a heavily-utilized cluster and impose significant scalability limits. Thus, always try to minimize the impact of direct calls by filtering results by namespace or labels, limiting the number of results and/or using metadata-only calls.</li></ul><p>[2] The <code>Deployment</code> controller uses the pattern <code>&lt;deployment-name>-&lt;podtemplate-hash></code> for naming <code>ReplicaSets</code>. This means, the name of a <code>ReplicaSet</code> it tries to create/update/delete at any given time is deterministically calculated based on the <code>Deployment</code> object. By this, it is insusceptible to stale reads from its <code>ReplicaSets</code> cache.</p><p>[3] In simple terms, the <code>ReplicaSet</code> controller tracks its <code>CREATE pod</code> actions as follows: when creating new <code>Pods</code>, it increases a counter of expected <code>ADDED</code> watch events for the corresponding <code>ReplicaSet</code>. As soon as such events arrive, it decreases the counter accordingly. It only creates new <code>Pods</code> for a given <code>ReplicaSet</code>, once all expected events occurred (counter is back to zero) or a timeout occurred. This way, it prevents creating more <code>Pods</code> than desired because of stale cache reads and makes the controller eventually consistent.</p><h2 id=conflicts-concurrency-control-and-optimistic-locking>Conflicts, Concurrency Control and Optimistic Locking</h2><p>Every Kubernetes API object contains the <code>metadata.resourceVersion</code> field, which identifies an object&rsquo;s version in the backing data store, i.e., etcd. Every write to an object in etcd results in a newer <code>resourceVersion</code>.
This field is mainly used for concurrency control on the API server in an optimistic locking fashion, but also for efficient resumption of interrupted watch connections.</p><p>Optimistic locking in the Kubernetes API sense means that when a client wants to update an API object then it includes the object&rsquo;s <code>resourceVersion</code> in the request to indicate the object&rsquo;s version the modifications are based on.
If the <code>resourceVersion</code> in etcd has not changed in the meantime, the update request is accepted by the API server and the updated object is written to etcd.
If the <code>resourceVersion</code> sent by the client does not match the one of the object stored in etcd, there were concurrent modifications to the object. Consequently, the request is rejected with a conflict error (status code <code>409</code>, API reason <code>Conflict</code>), for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;kind&#34;: <span style=color:#a31515>&#34;Status&#34;</span>,
  &#34;apiVersion&#34;: <span style=color:#a31515>&#34;v1&#34;</span>,
  &#34;metadata&#34;: {},
  &#34;status&#34;: <span style=color:#a31515>&#34;Failure&#34;</span>,
  &#34;message&#34;: <span style=color:#a31515>&#34;Operation cannot be fulfilled on configmaps \&#34;foo\&#34;: the object has been modified; please apply your changes to the latest version and try again&#34;</span>,
  &#34;reason&#34;: <span style=color:#a31515>&#34;Conflict&#34;</span>,
  &#34;details&#34;: {
    &#34;name&#34;: <span style=color:#a31515>&#34;foo&#34;</span>,
    &#34;kind&#34;: <span style=color:#a31515>&#34;configmaps&#34;</span>
  },
  &#34;code&#34;: 409
}
</code></pre></div><p>This concurrency control is an important mechanism in Kubernetes as there are typically multiple clients acting on API objects at the same time (humans, different controllers, etc.). If a client receives a conflict error, it should read the object&rsquo;s latest version from the API server, make the modifications based on the newest changes and retry the update.
The reasoning behind this is that a client might choose to make different decisions based on the concurrent changes made by other actors compared to the outdated version that it operated on.</p><p><em>Important points about concurrency control and conflicts:</em></p><ul><li>The <code>resourceVersion</code> field carries a string value and clients must not assume numeric values (the type and structure of versions depend on the backing data store). This means clients may compare <code>resourceVersion</code> values to detect whether objects were changed. But they must not compare <code>resourceVersion</code>s to figure out which one is newer/older, i.e., no greater/less-than comparisons are allowed.</li><li>By default, update calls (e.g. via client-go and controller-runtime clients) use optimistic locking as the passed in-memory usually object contains the latest <code>resourceVersion</code> known to the controller which is then also sent to the API server.</li><li>API servers can also choose to accept update calls without optimistic locking (i.e., without a <code>resourceVersion</code> in the object&rsquo;s metadata) for any given resource. However, sending update requests without optimistic locking is strongly discouraged as doing so overwrites the entire object discarding any concurrent changes made to it.</li><li>On the other side, patch requests can always be executed either with or without optimistic locking, by (not) including the <code>resourceVersion</code> in the patched object&rsquo;s metadata. Sending patch requests without optimistic locking might be safe and even desirable as a patch typically updates only a specific section of the object. However, there are also situations where patching without optimistic locking is not safe (see below).</li></ul><h3 id=dont-retry-on-conflict>Don’t Retry on Conflict</h3><p>Similar to how a human would typically handle a conflict error, there are helper functions implementing <code>RetryOnConflict</code>-semantics, i.e., try an update call, then re-read the object if a conflict occurs, apply the modification again and retry the update.
However, controllers should generally <em>not</em> use <code>RetryOnConflict</code>-semantics. Instead, controllers should abort their current reconciliation run and let the queue handle the conflict error with exponential backoff.
The reasoning behind this is, that a conflict error indicates that the controller has operated on stale data and might have made wrong decisions earlier on in the reconciliation.
When using a helper function that implements <code>RetryOnConflict</code>-semantics, the controller doesn&rsquo;t check which fields were changed and doesn&rsquo;t revise its previous decisions accordingly.
Instead, retrying on conflict basically just ignores any conflict error and blindly applies the modification.</p><p>To properly solve the conflict situation, controllers should immediately return with the error from the update call. This will cause retries with exponential backoff so that the cache has a chance to observe the latest changes to the object.
In a later run, the controller will then make correct decisions based on the newest version of the object, not run into conflict errors and will then be able to successfully reconcile the object. This way, the controller becomes eventually consistent.</p><p>The other way to solve the situation is to modify objects without optimistic locking in order to avoid running into a conflict in the first place (only if this is safe).
This can be a preferable solution for controllers with long-running reconciliations (which is actually an anti-pattern but quite unavoidable in some of Gardener&rsquo;s controllers).
Aborting the entire reconciliation run is rather undesirable in such cases as it will add a lot of unnecessary waiting time for end users and overhead in terms of compute and network usage.</p><p>However, in any case retrying on conflict is probably not the right option to solve the situation (there are some correct use cases for it, though, they are very rare). Hence, don&rsquo;t retry on conflict.</p><h3 id=to-lock-or-not-to-lock>To Lock or Not to Lock</h3><p>As explained before, conflicts are actually important and prevent clients from doing wrongful concurrent updates. This means, conflicts are not something we generally want to avoid or ignore.
However, in many cases controllers are exclusive owners of the fields they want to update and thus it might be safe to run without optimistic locking.</p><p>For example, the gardenlet is the exclusive owner of the <code>spec</code> section of the Extension resources it creates on behalf of a Shoot (e.g., the <code>Infrastructure</code> resource for creating VPC, etc.). Meaning, it knows the exact desired state and no other actor is supposed to update the Infrastructure&rsquo;s <code>spec</code> fields.
When the gardenlet now updates the Infrastructures <code>spec</code> section as part of the Shoot reconciliation, it can simply issue a <code>PATCH</code> request that only updates the <code>spec</code> and runs without optimistic locking.
If another controller concurrently updated the object in the meantime (e.g., the <code>status</code> section), the <code>resourceVersion</code> got changed which would cause a conflict error if running with optimistic locking.
However, concurrent <code>status</code> updates would not change the gardenlet&rsquo;s mind on the desired <code>spec</code> of the Infrastructure resource as it is determined only by looking at the Shoot&rsquo;s specification.
If the <code>spec</code> section was changed concurrently, it&rsquo;s still fine to overwrite it because the gardenlet should reconcile the <code>spec</code> back to its desired state.</p><p>Generally speaking, if a controller is the exclusive owner of a given set of fields and they are independent of concurrent changes to other fields in that object, it can patch these fields without optimistic locking.
This might ignore concurrent changes to other fields or blindly overwrite changes to the same fields, but this is fine if the mentioned conditions apply.
Obviously, this applies only to patch requests that modify only a specific set of fields but not to update requests that replace the entire object.</p><p>In such cases, it&rsquo;s even desirable to run without optimistic locking as it will be more performant and save retries.
If certain requests are made with high frequency and have a good chance of causing conflicts, retries because of optimistic locking can cause a lot of additional network traffic in a large-scale Gardener installation.</p><h2 id=updates-patches-server-side-apply>Updates, Patches, Server-side Apply</h2><p>There are different ways of modifying Kubernetes API objects.
The following snippet demonstrates how to do a given modification with the most frequently used options using a controller-runtime client:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx   context.Context
  c     client.Client
  shoot *gardencorev1beta1.Shoot
)

<span style=color:green>// update
</span><span style=color:green></span>shoot.Spec.Kubernetes.Version = <span style=color:#a31515>&#34;1.22&#34;</span>
err := c.Update(ctx, shoot)

<span style=color:green>// json merge patch
</span><span style=color:green></span>patch := client.MergeFrom(shoot.DeepCopy())
shoot.Spec.Kubernetes.Version = <span style=color:#a31515>&#34;1.22&#34;</span>
err = c.Patch(ctx, shoot, patch)

<span style=color:green>// strategic merge patch
</span><span style=color:green></span>patch = client.StrategicMergeFrom(shoot.DeepCopy())
shoot.Spec.Kubernetes.Version = <span style=color:#a31515>&#34;1.22&#34;</span>
err = c.Patch(ctx, shoot, patch)
</code></pre></div><p><em>Important characteristics of the shown request types:</em></p><ul><li>Update requests always send the entire object to the API server and update all fields accordingly. By default, optimistic locking is used (<code>resourceVersion</code> is included).</li><li>Both patch types run without optimistic locking by default. However, it can be enabled explicitly if needed:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:green>// json merge patch + optimistic locking
</span><span style=color:green></span>patch := client.MergeFromWithOptions(shoot.DeepCopy(), client.MergeFromWithOptimisticLock{})
<span style=color:green>// ...
</span><span style=color:green></span>
<span style=color:green>// strategic merge patch + optimistic locking
</span><span style=color:green></span>patch = client.StrategicMergeFrom(shoot.DeepCopy(), client.MergeFromWithOptimisticLock{})
<span style=color:green>// ...
</span></code></pre></div></li><li>Patch requests only contain the changes made to the in-memory object between the copy passed to <code>client.*MergeFrom</code> and the object passed to <code>Client.Patch()</code>. The diff is calculated on the client-side based on the in-memory objects only. This means, if in the meantime some fields were changed on the API server to a different value than the one on the client-side, the fields will not be changed back as long as they are not changed on the client-side as well (there will be no diff in memory).</li><li>Thus, if you want to ensure a given state using patch requests, always read the object first before patching it, as there will be no diff otherwise, meaning the patch will be empty. Also see <a href=https://github.com/gardener/gardener/pull/4057>gardener/gardener#4057</a> and comments in <a href=https://github.com/gardener/gardener/pull/4027>gardener/gardener#4027</a>.</li><li>Also, always send updates and patch requests even if your controller hasn&rsquo;t made any changes to the current state on the API server. I.e., don&rsquo;t make any optimization for preventing empty patches or no-op updates. There might be mutating webhooks in the system that will modify the object and that rely on update/patch requests being sent (even if they are no-op). Gardener&rsquo;s extension concept makes heavy use of mutating webhooks, so it&rsquo;s important to keep this in mind.</li><li>JSON merge patches always replace lists as a whole and don&rsquo;t merge them. Keep this in mind when operating on lists with merge patch requests. If the controller is the exclusive owner of the entire list, it&rsquo;s safe to run without optimistic locking. Though, if you want to prevent overwriting concurrent changes to the list or its items made by other actors (e.g., additions/removals to the <code>metadata.finalizers</code> list), enable optimistic locking.</li><li>Strategic merge patches are able to make more granular modifications to lists and their elements without replacing the entire list. It uses Golang struct tags of the API types to determine which and how lists should be merged. See <a href=https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>this document</a> or the <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md>strategic merge patch documentation</a> for more in-depth explanations and comparison with JSON merge patches.
With this, controllers <em>might</em> be able to issue patch requests for individual list items without optimistic locking, even if they are not exclusive owners of the entire list. Remember to check the <code>patchStrategy</code> and <code>patchMergeKey</code> struct tags of the fields you want to modify before blindly adding patch requests without optimistic locking.</li><li>Strategic merge patches are only supported by built-in Kubernetes resources and custom resources served by Extension API servers. Strategic merge patches are not supported by custom resources defined by <code>CustomResourceDefinition</code>s (see <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#advanced-features-and-flexibility>this comparison</a>). In that case, fallback to JSON merge patches.</li><li><a href=https://kubernetes.io/docs/reference/using-api/server-side-apply/>Server-side Apply</a> is yet another mechanism to modify API objects, which is supported by all API resources (in newer Kubernetes versions). However, it has a few problems and more caveats preventing us from using it in Gardener at the time of writing. See <a href=https://github.com/gardener/gardener/issues/4122>gardener/gardener#4122</a> for more details.</li></ul><blockquote><p>Generally speaking, patches are often the better option compared to update requests because they can save network traffic, encoding/decoding effort and avoid conflicts under the presented conditions.
If choosing a patch type, consider which type is supported by the resource you&rsquo;re modifying and what will happen in case of a conflict. Consider whether your modification is safe to run without optimistic locking.
However, there is no simple rule of thumb on which patch type to choose.</p></blockquote><h2 id=on-helper-functions>On Helper Functions</h2><p>Here is a note on some helper functions, that should be avoided and why:</p><p><code>controllerutil.CreateOrUpdate</code> does a basic get, mutate and create or update call chain, which is often used in controllers. We should avoid using this helper function in Gardener, because it is likely to cause conflicts for cached clients and doesn&rsquo;t send no-op requests if nothing was changed, which can cause problems because of the heavy use of webhooks in Gardener extensions (see above).
That&rsquo;s why usage of this function was completely replaced in <a href=https://github.com/gardener/gardener/pull/4227>gardener/gardener#4227</a> and similar PRs.</p><p><code>controllerutil.CreateOrPatch</code> is similar to <code>CreateOrUpdate</code> but does a patch request instead of an update request. It has the same drawback as <code>CreateOrUpdate</code> regarding no-op updates.
Also, controllers can&rsquo;t use optimistic locking or strategic merge patches when using <code>CreateOrPatch</code>.
Another reason for avoiding use of this function is, that it also implicitly patches the status section if it was changed, which is confusing for others reading the code. To accomplish this, the func does some back and forth conversion, comparison and checks, which are unnecessary in most of our cases and simply wasted CPU cycles and complexity we want to avoid.</p><p>There were some <code>Try{Update,UpdateStatus,Patch,PatchStatus}</code> helper functions in Gardener that were already removed by <a href=https://github.com/gardener/gardener/pull/4378>gardener/gardener#4378</a> but are still used in some extension code at the time of writing.
The reason for eliminating these functions is that they implement <code>RetryOnConflict</code>-semantics. Meaning, they first get the object, mutate it, then try to update and retry if a conflict error occurs.
As explained above, retrying on conflict is a controller anti-pattern and should be avoided in almost every situation.
The other problem with these functions is that they read the object first from the API server (always do a direct call), although in most cases we already have a recent version of the object at hand. So, using this function generally does unnecessary API calls and therefore causes unwanted compute and network load.</p><p>For the reasons explained above, there are similar helper functions that accomplish similar things but address the mentioned drawbacks: <code>controllerutils.{GetAndCreateOrMergePatch,GetAndCreateOrStrategicMergePatch}</code>.
These can be safely used as replacements for the aforementioned helper funcs.
If they are not fitting for your use case, for example because you need to use optimistic locking, just do the appropriate calls in the controller directly.</p><h2 id=further-resources>Further Resources</h2><ul><li><a href="https://www.youtube.com/watch?v=RPsUo925PUA&t=40s">Kubernetes Client usage in Gardener</a> (Community Meeting talk, 2020-06-26)</li></ul><p>These resources are only partially related to the topics covered in this doc, but might still be interesting for developer seeking a deeper understanding of Kubernetes API machinery, architecture and foundational concepts.</p><ul><li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md>API Conventions</a></li><li><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/resource-management.md>The Kubernetes Resource Model</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21c83bbf03336ea56a38d93f1d4fa12f>5 - Local Setup</h1><h1 id=overview>Overview</h1><p>Conceptually, all Gardener components are designed to run as a Pod inside a Kubernetes cluster.
The Gardener API server extends the Kubernetes API via the user-aggregated API server concepts.
However, if you want to develop it, you may want to work locally with the Gardener without building a Docker image and deploying it to a cluster each and every time.
That means that the Gardener runs outside a Kubernetes cluster which requires providing a <a href=https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/>Kubeconfig</a> in your local filesystem and point the Gardener to it when starting it (see below).</p><p>Further details can be found in</p><ol><li><a href=https://kubernetes.io/docs/concepts/>Principles of Kubernetes</a>, and its <a href=https://kubernetes.io/docs/concepts/overview/components/>components</a></li><li><a href=https://github.com/kubernetes/community/tree/master/contributors/devel>Kubernetes Development Guide</a></li><li><a href=https://github.com/gardener/documentation/wiki/Architecture>Architecture of Gardener</a></li></ol><p>This guide is split into three main parts:</p><ul><li><a href=#preparing-the-setup>Preparing your setup by installing all dependencies and tools</a></li><li><a href=#start-gardener-locally>Building and starting Gardener components locally</a></li><li><a href=#create-a-shoot>Using your local Gardener setup to create a Shoot</a></li></ul><h2 id=limitations-of-the-local-development-setup>Limitations of the local development setup</h2><p>You can run Gardener (API server, controller manager, scheduler, gardenlet) against any local Kubernetes cluster, however, your seed and shoot clusters must be deployed to a cloud provider.
Currently, it is not possible to run Gardener entirely isolated from any cloud provider. This means that to be able create Shoot clusters you need to register an external Seed cluster (e.g., one created in AWS).</p><h1 id=preparing-the-setup>Preparing the Setup</h1><h2 id=macos-only-installing-homebrew>[macOS only] Installing homebrew</h2><p>The copy-paste instructions in this guide are designed for macOS and use the package manager <a href=https://brew.sh/>Homebrew</a>.</p><p>On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/bin/bash -c <span style=color:#a31515>&#34;</span><span style=color:#00f>$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span style=color:#00f>)</span><span style=color:#a31515>&#34;</span>
</code></pre></div><h2 id=installing-git>Installing git</h2><p>We use <code>git</code> as VCS which you need to install. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install git
</code></pre></div><p>For other OS, please check the <a href=https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>Git installation documentation</a>.</p><h2 id=installing-go>Installing Go</h2><p>Install the latest version of Go. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install go
</code></pre></div><p>For other OS, please check <a href=https://golang.org/doc/install>Go installation documentation</a>.</p><h2 id=installing-kubectl>Installing kubectl</h2><p>Install <code>kubectl</code>. Please make sure that the version of <code>kubectl</code> is at least <code>v1.11.x</code>. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubernetes-cli
</code></pre></div><p>For other OS, please check the <a href=https://kubernetes.io/docs/tasks/tools/install-kubectl/>kubectl installation documentation</a>.</p><h2 id=installing-helm>Installing helm</h2><p>You also need the <a href=https://github.com/kubernetes/helm>Helm</a> CLI. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install helm
</code></pre></div><p>For other OS please check the <a href=https://helm.sh/docs/intro/install/>Helm installation documentation</a>.</p><h2 id=installing-openvpn>Installing openvpn</h2><p>We use <code>OpenVPN</code> to establish network connectivity from the control plane running in the Seed cluster to the Shoot&rsquo;s worker nodes running in private networks.
To harden the security we need to generate another secret to encrypt the network traffic (<a href=https://openvpn.net/index.php/open-source/documentation/howto.html#security>details</a>).
Please install the <code>openvpn</code> binary. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install openvpn
export PATH=<span style=color:#00f>$(</span>brew --prefix openvpn<span style=color:#00f>)</span>/sbin:$PATH
</code></pre></div><p>For other OS, please check the <a href=https://openvpn.net/index.php/open-source/downloads.html>OpenVPN downloads page</a>.</p><h2 id=installing-docker>Installing Docker</h2><p>You need to have docker installed and running. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install --cask docker
</code></pre></div><p>For other OS please check the <a href=https://docs.docker.com/get-docker/>docker installation documentation</a>.</p><h2 id=installing-iproute2>Installing iproute2</h2><p><code>iproute2</code> provides a collection of utilities for network administration and configuration. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install iproute2mac
</code></pre></div><h2 id=installing-jq>Installing jq</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install jq
</code></pre></div><h2 id=installing-gnu-parallel>Installing GNU Parallel</h2><p><a href=https://www.gnu.org/software/parallel/>GNU Parallel</a> is a shell tool for executing jobs in parallel, used by the code generation scripts (<code>make generate</code>). On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install parallel
</code></pre></div><h2 id=macos-only-install-gnu-core-utilities>[macOS only] Install GNU core utilities</h2><p>When running on macOS, install the GNU core utilities and friends:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install coreutils gnu-sed gnu-tar grep
</code></pre></div><p>This will create symbolic links for the GNU utilities with <code>g</code> prefix in <code>/usr/local/bin</code>, e.g., <code>gsed</code> or <code>gbase64</code>. To allow using them without the <code>g</code> prefix please put <code>/usr/local/opt/coreutils/libexec/gnubin</code> etc. at the beginning of your <code>PATH</code> environment variable, e.g., <code>export PATH=/usr/local/opt/coreutils/libexec/gnubin:$PATH</code> (<code>brew</code> will print out instructions for each installed formula).</p><h2 id=windows-only-wsl2>[Windows only] WSL2</h2><p>Apart from Linux distributions and macOS, the local gardener setup can also run on the Windows Subsystem for Linux 2.</p><p>While WSL1, plain docker for windows and various Linux distributions and local Kubernetes environments may be supported, this setup was verified with:</p><ul><li><a href=https://docs.microsoft.com/en-us/windows/wsl/wsl2-index>WSL2</a></li><li><a href=https://docs.docker.com/docker-for-windows/wsl/>Docker Desktop WSL2 Engine</a></li><li><a href=https://ubuntu.com/blog/ubuntu-on-wsl-2-is-generally-available>Ubuntu 18.04 LTS on WSL2</a></li><li>Nodeless local garden (see below)</li></ul><p>The Gardener repository and all the above-mentioned tools (git, golang, kubectl, &mldr;) should be installed in your WSL2 distro, according to the distribution-specific Linux installation instructions.</p><h1 id=start-gardener-locally>Start Gardener locally</h1><h2 id=get-the-sources>Get the sources</h2><p>Clone the repository from GitHub into your <code>$GOPATH</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir -p $GOPATH/src/github.com/gardener
cd $GOPATH/src/github.com/gardener
git clone git@github.com:gardener/gardener.git
cd gardener
</code></pre></div><blockquote><p>Note: Gardener is using Go modules and cloning the repository into <code>$GOPATH</code> is not a hard requirement. However it is still recommended to clone into <code>$GOPATH</code> because <code>k8s.io/code-generator</code> does not work yet outside of <code>$GOPATH</code> - <a href=https://github.com/kubernetes/kubernetes/issues/86753>kubernetes/kubernetes#86753</a>.</p></blockquote><h2 id=start-the-gardener>Start the Gardener</h2><p>ℹ️ In the following guide, you have to define the configuration (<code>CloudProfile</code>s, <code>SecretBinding</code>s, <code>Seed</code>s, etc.) manually for the infrastructure environment you want to develop against.
Additionally, you have to register the respective Gardener extensions manually.
If you are rather looking for a quick start guide to develop entirely locally on your machine (no real cloud provider or infrastructure involved) then you should rather follow <a href=/docs/gardener/development/getting_started_locally/>this guide</a>.</p><h3 id=start-a-local-kubernetes-cluster>Start a local kubernetes cluster</h3><p>For the development of Gardener you need a Kubernetes API server on which you can register Gardener&rsquo;s own Extension API Server as <code>APIService</code>. This cluster doesn&rsquo;t need any worker nodes to run pods, though, therefore, you can use the &ldquo;nodeless Garden cluster setup&rdquo; residing in <code>hack/local-garden</code>. This will start all minimally required components of a Kubernetes cluster (<code>etcd</code>, <code>kube-apiserver</code>, <code>kube-controller-manager</code>)
and an <code>etcd</code> Instance for the <code>gardener-apiserver</code> as Docker containers. This is the easiest way to get your
Gardener development setup up and running.</p><p><strong>Using the nodeless cluster setup</strong></p><p>Use the provided Makefile rules to start your local Garden:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make local-garden-up
[...]
Starting gardener-dev kube-etcd cluster..!
Starting gardener-dev kube-apiserver..!
Starting gardener-dev kube-controller-manager..!
Starting gardener-dev gardener-etcd cluster..!
namespace/garden created
clusterrole.rbac.authorization.k8s.io/gardener.cloud:admin created
clusterrolebinding.rbac.authorization.k8s.io/front-proxy-client created
[...]
</code></pre></div><p>ℹ️ [Optional] If you want to develop the <code>SeedAuthorization</code> feature then you have to run <code>make ACTIVATE_SEEDAUTHORIZER=true local-garden-up</code>. However, please note that this forces you to start the <code>gardener-admission-controller</code> via <code>make start-admission-controller</code>.</p><p>To tear down the local Garden cluster and remove the Docker containers, simply run:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make local-garden-down
</code></pre></div><details><summary><b>Alternative: Using a local kubernetes cluster</b></summary><p>Instead of starting a kubernetes API server and etcd as docker containers, you can also opt for running a local kubernetes cluster, provided by e.g. <a href=https://minikube.sigs.k8s.io/docs/start/>minikube</a>, <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>kind</a> or docker desktop.</p><blockquote><p>Note: Gardener requires self-contained kubeconfig files because of a <a href=https://banzaicloud.com/blog/kubeconfig-security/>security issue</a>. You can configure your minikube to create self-contained kubeconfig files via:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube config set embed-certs true
</code></pre></div><p>or when starting the local cluster</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube start --embed-certs
</code></pre></div></blockquote></details><details><summary><b>Alternative: Using a remote kubernetes cluster</b></summary><p>For some testing scenarios, you may want to use a remote cluster instead of a local one as your Garden cluster.
To do this, you can use the &ldquo;remote Garden cluster setup&rdquo; residing in <code>hack/remote-garden</code>. This will start an <code>etcd</code> instance for the <code>gardener-apiserver</code> as a Docker container, and open tunnels for accessing local gardener components from the remote cluster.</p><p>To avoid mistakes, the remote cluster must have a <code>garden</code> namespace labeled with <code>gardener.cloud/purpose=remote-garden</code>.
You must create the <code>garden</code> namespace and label it manually before running <code>make remote-garden-up</code> as described below.</p><p>Use the provided <code>Makefile</code> rules to bootstrap your remote Garden:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>export KUBECONFIG=&lt;path to kubeconfig&gt;
make remote-garden-up
[...]
<span style=color:green># Start gardener etcd used to store gardener resources (e.g., seeds, shoots)</span>
Starting gardener-dev-remote gardener-etcd cluster!
[...]
<span style=color:green># Open tunnels for accessing local gardener components from the remote cluster</span>
[...]
</code></pre></div><p>To close the tunnels and remove the locally-running Docker containers, run:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make remote-garden-down
</code></pre></div><blockquote><p>Note: The minimum K8S version of the remote cluster that can be used as Garden cluster is <code>1.19.x</code>.</p></blockquote><p>ℹ️ [Optional] If you want to use the remote Garden cluster setup with the <code>SeedAuthorization</code> feature you have to adapt the <code>kube-apiserver</code> process of your remote Garden cluster. To do this, perform the following steps after running <code>make remote-garden-up</code>:</p><ul><li><p>Create an <a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/#configuration-file-format>authorization webhook configuration file</a> using the IP of the <code>garden/quic-server</code> pod running in your remote Garden cluster and port 10444 that tunnels to your locally running <code>gardener-admission-controller</code> process.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
current-context: seedauthorizer
clusters:
- name: gardener-admission-controller
  cluster:
    insecure-skip-tls-verify: <span style=color:#00f>true</span>
    server: https://&lt;quic-server-pod-ip&gt;:10444/webhooks/auth/seed
users:
- name: kube-apiserver
  user: {}
contexts:
- name: seedauthorizer
  context:
    cluster: gardener-admission-controller
    user: kube-apiserver
</code></pre></div></li><li><p>Change or add the following command line parameters to your <code>kube-apiserver</code> process:</p><ul><li><code>--authorization-mode=&lt;...>,Webhook</code></li><li><code>--authorization-webhook-config-file=&lt;path to config file></code></li><li><code>--authorization-webhook-cache-authorized-ttl=0</code></li><li><code>--authorization-webhook-cache-unauthorized-ttl=0</code></li></ul></li><li><p>Delete the cluster role and rolebinding <code>gardener.cloud:system:seeds</code> from your remote Garden cluster.</p></li></ul><p>If your remote Garden cluster is a Gardener shoot, and you can access the seed on which this shoot is scheduled, you can automate the above steps by running the <a href=https://github.com/gardener/gardener/blob/master/hack/local-development/remote-garden/enable-seed-authorizer><code>enable-seed-authorizer</code> script</a> and passing the kubeconfig of the seed cluster and the shoot namespace as parameters:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>hack/local-development/remote-garden/enable-seed-authorizer &lt;seed kubeconfig&gt; &lt;namespace&gt;
</code></pre></div><blockquote><p>Note: The configuration changes introduced by this script result in a working <code>SeedAuthorization</code> feature only on shoots for which the <code>ReversedVPN</code> feature is not enabled. If the corresponding feature gate is enabled in <code>gardenlet</code>, add the annotation <code>alpha.featuregates.shoot.gardener.cloud/reversed-vpn: 'false'</code> to the remote Garden shoot to disable it for that particular shoot.</p></blockquote><p>To prevent Gardener from reconciling the shoot and overwriting your changes, add the annotation <code>shoot.gardener.cloud/ignore: 'true'</code> to the remote Garden shoot. Note that this annotation takes effect only if it is enabled via the <code>constollers.shoot.respectSyncPeriodOverwrite: true</code> option in the <code>gardenlet</code> configuration.</p><p>To disable the seed authorizer again, run the same script with <code>-d</code> as a third parameter:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>hack/local-development/remote-garden/enable-seed-authorizer &lt;seed kubeconfig&gt; &lt;namespace&gt; -d
</code></pre></div><p>If the seed authorizer is enabled, you also have to start the <code>gardener-admission-controller</code> via <code>make start-admission-controller</code>.</p><blockquote><p>⚠️ In the remote garden setup all Gardener components run with administrative permissions, i.e., there is no fine-grained access control via RBAC (as opposed to productive installations of Gardener).</p></blockquote></details><h3 id=prepare-the-gardener>Prepare the Gardener</h3><p>Now, that you have started your local cluster, we can go ahead and register the Gardener API Server.
Just point your <code>KUBECONFIG</code> environment variable to the cluster you created in the previous step and run:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make dev-setup
[...]
namespace/garden created
namespace/garden-dev created
deployment.apps/etcd created
service/etcd created
service/gardener-apiserver created
service/gardener-admission-controller created
endpoints/gardener-apiserver created
endpoints/gardener-admission-controller created
apiservice.apiregistration.k8s.io/v1alpha1.core.gardener.cloud created
apiservice.apiregistration.k8s.io/v1beta1.core.gardener.cloud created
apiservice.apiregistration.k8s.io/v1alpha1.seedmanagement.gardener.cloud created
apiservice.apiregistration.k8s.io/v1alpha1.settings.gardener.cloud created
</code></pre></div><p>ℹ️ [Optional] If you want to enable logging, in the Gardenlet configuration add:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
</code></pre></div><p>The Gardener exposes the API servers of Shoot clusters via Kubernetes services of type <code>LoadBalancer</code>.
In order to establish stable endpoints (robust against changes of the load balancer address), it creates DNS records pointing to these load balancer addresses. They are used internally and by all cluster components to communicate.
You need to have control over a domain (or subdomain) for which these records will be created.
Please provide an <em>internal domain secret</em> (see <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-internal-domain.yaml>this</a> for an example) which contains credentials with the proper privileges. Further information can be found <a href=/docs/gardener/usage/configuration/>here</a>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f example/10-secret-internal-domain-unmanaged.yaml
secret/internal-domain-unmanaged created
</code></pre></div><h3 id=run-the-gardener>Run the Gardener</h3><p>Next, run the Gardener API Server, the Gardener Controller Manager (optionally), the Gardener Scheduler (optionally), and the Gardenlet in different terminal windows/panes using rules in the <code>Makefile</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-apiserver
[...]
I0306 15:23:51.044421   74536 plugins.go:84] Registered admission plugin <span style=color:#a31515>&#34;ResourceReferenceManager&#34;</span>
I0306 15:23:51.044523   74536 plugins.go:84] Registered admission plugin <span style=color:#a31515>&#34;DeletionConfirmation&#34;</span>
[...]
I0306 15:23:51.626836   74536 secure_serving.go:116] Serving securely on [::]:8443
[...]
</code></pre></div><p>(Optional) Now you are ready to launch the Gardener Controller Manager.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-controller-manager
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting Gardener controller manager...&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Feature Gates: &#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting HTTP server on 0.0.0.0:2718&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Acquired leadership, starting controllers.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting HTTPS server on 0.0.0.0:2719&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Found internal domain secret internal-domain-unmanaged for domain nip.io.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Successfully bootstrapped the Garden cluster.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Gardener controller manager (version 1.0.0-dev) initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;ControllerRegistration controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;SecretBinding controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Project controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Quota controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;CloudProfile controller initialized.&#34;</span>
[...]
</code></pre></div><p>(Optional) Now you are ready to launch the Gardener Scheduler.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-scheduler
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting Gardener scheduler ...&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting HTTP server on 0.0.0.0:10251&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Acquired leadership, starting scheduler.&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Gardener scheduler initialized (with Strategy: SameRegion)&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Scheduler controller initialized.&#34;</span>
[...]
</code></pre></div><p>The Gardener should now be ready to operate on Shoot resources. You can use</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get shoots
No resources found.
</code></pre></div><p>to operate against your local running Gardener API Server.</p><blockquote><p>Note: It may take several seconds until the Gardener API server has been started and is available. <code>No resources found</code> is the expected result of our initial development setup.</p></blockquote><h1 id=create-a-shoot>Create a Shoot</h1><p>The steps below describe the general process of creating a Shoot. Have in mind that the steps do not provide full example manifests. The reader needs to check the provider documentation and adapt the manifests accordingly.</p><h4 id=1-copy-the-example-manifests>1. Copy the example manifests</h4><p>The next steps require modifications of the example manifests. These modifications are part of local setup and should not be <code>git push</code>-ed. To do not interfere with git, let&rsquo;s copy the example manifests to <code>dev/</code> which is ignored by git.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cp example/*.yaml dev/
</code></pre></div><h4 id=2-create-a-project>2. Create a Project</h4><p>Every Shoot is associated with a Project. Check the corresponding example manifests <code>dev/00-namespace-garden-dev.yaml</code> and <code>dev/05-project-dev.yaml</code>. Adapt them and create them.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/00-namespace-garden-dev.yaml
kubectl apply -f dev/05-project-dev.yaml
</code></pre></div><p>Make sure that the Project is successfully reconciled:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get project dev
NAME   NAMESPACE    STATUS   OWNER                  CREATOR            AGE
dev    garden-dev   Ready    john.doe@example.com   kubernetes-admin   6s
</code></pre></div><h4 id=3-create-a-cloudprofile>3. Create a CloudProfile</h4><p>The <code>CloudProfile</code> resource is provider specific and describes the underlying cloud provider (available machine types, regions, machine images, etc.). Check the corresponding example manifest <code>dev/30-cloudprofile.yaml</code>. Check also the documentation and example manifests of the provider extension. Adapt <code>dev/30-cloudprofile.yaml</code> and apply it.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/30-cloudprofile.yaml
</code></pre></div><h4 id=4-install-necessary-gardener-extensions>4. Install necessary Gardener Extensions</h4><p>The <a href=https://github.com/gardener/gardener/blob/master/extensions/README.md#known-extension-implementations>Known Extension Implementations</a> section contains a list of available extension implementations. You need to create a ControllerRegistration and ControllerDeployment for</p><ul><li>at least one infrastructure provider</li><li>a dns provider (if the DNS for the Seed is not disabled)</li><li>at least one operating system extension</li><li>at least one network plugin extension</li></ul><p>As a convention, the example ControllerRegistration manifest (containing also the necessary ControllerDeployment) for an extension is located under <code>example/controller-registration.yaml</code> in the corresponding repository (for example for AWS the ControllerRegistration can be found <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/controller-registration.yaml>here</a>). An example creation for provider-aws (make sure to replace <code>&lt;version></code> with the newest released version tag):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f https://raw.githubusercontent.com/gardener/gardener-extension-provider-aws/&lt;version&gt;/example/controller-registration.yaml
</code></pre></div><p>Instead of updating extensions manually you can use <a href=https://github.com/gardener/gem>Gardener Extensions Manager</a> to install and update extension controllers. This is especially useful if you want to keep and maintain your development setup for a longer time.
Also, please refer to <a href=/docs/gardener/extensions/controllerregistration/>this document</a> for further information about how extensions are registered in case you want to use other versions than the latest releases.</p><h4 id=5-register-a-seed>5. Register a Seed</h4><p>Shoot controlplanes run in seed clusters, so we need to create our first Seed now.</p><p>Check the corresponding example manifest <code>dev/40-secret-seed.yaml</code> and <code>dev/50-seed.yaml</code>. Update <code>dev/40-secret-seed.yaml</code> with base64 encoded kubeconfig of the cluster that will be used as Seed (the scope of the permissions should be identical to the kubeconfig that the Gardenlet creates during bootstrapping - for now, <code>cluster-admin</code> privileges are recommended).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/40-secret-seed.yaml
</code></pre></div><p>Adapt <code>dev/50-seed.yaml</code> - adjust <code>.spec.secretRef</code> to refer the newly created Secret, adjust <code>.spec.provider</code> with the Seed cluster provider and revise the other fields.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/50-seed.yaml
</code></pre></div><h4 id=6-start-gardenlet>6. Start Gardenlet</h4><p>Once the Seed is created, start the Gardenlet to reconcile it. The <code>make start-gardenlet</code> command will automatically configure the local Gardenlet process to use the Seed and its kubeconfig. If you have multiple Seeds, you have to specify which to use by setting the <code>SEED_NAME</code> environment variable like in <code>make start-gardenlet SEED_NAME=my-first-seed</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-gardenlet
time=<span style=color:#a31515>&#34;2019-11-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting Gardenlet...&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Feature Gates: HVPA=true, Logging=true&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Acquired leadership, starting controllers.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Found internal domain secret internal-domain-unmanaged for domain nip.io.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Gardenlet (version 1.0.0-dev) initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;ControllerInstallation controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Shoot controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Seed controller initialized.&#34;</span>
[...]
</code></pre></div><p>The Gardenlet will now reconcile the Seed. Check the progess from time to time until it&rsquo;s <code>Ready</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get seed
NAME       STATUS    PROVIDER    REGION      AGE    VERSION       K8S VERSION
seed-aws   Ready     aws         eu-west-1   4m     v1.11.0-dev   v1.18.12
</code></pre></div><h4 id=7-create-a-shoot>7. Create a Shoot</h4><p>A Shoot requires a SecretBinding. The SecretBinding refers to a Secret that contains the cloud provider credentials. The Secret data keys are provider specific and you need to check the documentation of the provider to find out which data keys are expected (for example for AWS the related documentation can be found <a href=/docs/extensions/infrastructure-extensions/gardener-extension-provider-aws/docs/usage-as-end-user/#provider-secret-data>here</a>). Adapt <code>dev/70-secret-provider.yaml</code> and <code>dev/80-secretbinding.yaml</code> and apply them.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/70-secret-provider.yaml
kubectl apply -f dev/80-secretbinding.yaml
</code></pre></div><p>After the SecretBinding creation, you are ready to proceed with the Shoot creation. You need to check the documentation of the provider to find out the expected configuration (for example for AWS the related documentation and example Shoot manifest can be found <a href=/docs/extensions/infrastructure-extensions/gardener-extension-provider-aws/docs/usage-as-end-user/>here</a>). Adapt <code>dev/90-shoot.yaml</code> and apply it.</p><p>To make sure that a specific Seed cluster will be chosen or to skip the scheduling (the sheduling requires Gardener Scheduler to be running), specify the <code>.spec.seedName</code> field (see <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L317-L318>here</a>).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/90-shoot.yaml
</code></pre></div><p>Watch the progress of the operation and make sure that the Shoot will be successfully created.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>watch kubectl get shoot --all-namespaces
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ba2932673ad3c4565462541e83ca1ede>6 - Log Parsers</h1><h1 id=how-to-create-log-parser-for-container-into-fluent-bit>How to create log parser for container into fluent-bit</h1><p>If our log message is parsed correctly, it has to be showed in Grafana like this:</p><pre><code class=language-jsonc data-lang=jsonc>  {&quot;log&quot;:&quot;OpenAPI AggregationController: Processing item v1beta1.metrics.k8s.io&quot;,&quot;pid&quot;:&quot;1&quot;,&quot;severity&quot;:&quot;INFO&quot;,&quot;source&quot;:&quot;controller.go:107&quot;}
</code></pre><p>Otherwise it will looks like this:</p><pre><code class=language-jsonc data-lang=jsonc>{
  &quot;log&quot;:&quot;{
  \&quot;level\&quot;:\&quot;info\&quot;,\&quot;ts\&quot;:\&quot;2020-06-01T11:23:26.679Z\&quot;,\&quot;logger\&quot;:\&quot;gardener-resource-manager.health-reconciler\&quot;,\&quot;msg\&quot;:\&quot;Finished ManagedResource health checks\&quot;,\&quot;object\&quot;:\&quot;garden/provider-aws-dsm9r\&quot;
  }\n&quot;
  }
}
</code></pre><h2 id=lets-make-a-custom-parser-now>Lets make a custom parser now</h2><ul><li><p>First of all we need to know how does the log for the specific container look like (for example lets take a log from the <code>alertmanager</code> :
<code>level=info ts=2019-01-28T12:33:49.362015626Z caller=main.go:175 build_context="(go=go1.11.2, user=root@4ecc17c53d26, date=20181109-15:40:48)</code>)</p></li><li><p>We can see that this log contains 4 subfields(severity=info, timestamp=2019-01-28T12:33:49.362015626Z, source=main.go:175 and the actual message).
So we have to write a regex which matches this log in 4 groups(We can use <a href=https://regex101.com/>https://regex101.com/</a> like helping tool). So for this purpose our regex
looks like this:</p></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>^level=(?&lt;severity&gt;\w+)\s+ts=(?&lt;time&gt;\d{4}-\d{2}-\d{2}[Tt].*[zZ])\s+caller=(?&lt;source&gt;[^\s]*+)\s+(?&lt;log&gt;.*)
</code></pre></div><ul><li>Now we have to create correct time format for the timestamp(We can use this site for this purpose: <a href=http://ruby-doc.org/stdlib-2.4.1/libdoc/time/rdoc/Time.html#method-c-strptime)>http://ruby-doc.org/stdlib-2.4.1/libdoc/time/rdoc/Time.html#method-c-strptime)</a>.
So our timestamp matches correctly the following format:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>%Y-%m-%dT%H:%M:%S.%L
</code></pre></div><ul><li>It&rsquo;s a time to apply our new regex into fluent-bit configuration. Go to fluent-bit-configmap.yaml and create new filter using the following template:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[FILTER]
        Name                parser
        Match               kubernetes.&lt;&lt; pod-name &gt;&gt;*&lt;&lt; container-name &gt;&gt;*
        Key_Name            log
        Parser              &lt;&lt; parser-name &gt;&gt;
        Reserve_Data        True
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>EXAMPLE
[FILTER]
        Name                parser
        Match               kubernetes.alertmanager*alertmanager*
        Key_Name            log
        Parser              alermanagerParser
        Reserve_Data        True
</code></pre></div><ul><li>Now lets check if there is already exists parser with such a regex and time format that we need. if not, let`s create one:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[PARSER]
        Name        &lt;&lt; parser-name &gt;&gt;
        Format      regex
        Regex       &lt;&lt; regex &gt;&gt;
        Time_Key    time
        Time_Format &lt;&lt; time-format &gt;&gt;
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>EXAMPLE
[PARSER]
        Name        alermanagerParser
        Format      regex
        Regex       ^level=(?&lt;severity&gt;\w+)\s+ts=(?&lt;time&gt;\d{4}-\d{2}-\d{2}[Tt].*[zZ])\s+caller=(?&lt;source&gt;[^\s]*+)\s+(?&lt;log&gt;.*)
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Follow your development setup to validate that parsers are working correctly.
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6072f273ee0aa37eba651d226b098168>7 - Logging</h1><h1 id=logging-in-gardener-components>Logging in Gardener Components</h1><p>This document aims at providing a general developer guideline on different aspects of logging practices and conventions used in the Gardener codebase.
It contains mostly Gardener-specific points and references other existing and commonly accepted logging guidelines for general advice.
Developers and reviewers should consult this guide when writing, refactoring and reviewing Gardener code.
If parts are unclear or new learnings arise, this guide should be adapted accordingly.</p><h2 id=logging-libraries--implementations>Logging Libraries / Implementations</h2><p>Historically, Gardener components have been using <a href=https://github.com/sirupsen/logrus>logrus</a>.
There is a global logrus logger (<a href=https://github.com/gardener/gardener/blob/626ba7c10e1150819b3905116d3988512c18c9ee/pkg/logger/logrus.go#L28><code>logger.Logger</code></a>) that is initialized by components on startup and used across the codebase.
In most places, it is used as a <code>printf</code>-style logger and only in some instances we make use of logrus' structured logging functionality.</p><p>In the process of migrating our components to native controller-runtime components (see <a href=https://github.com/gardener/gardener/issues/4251>gardener/gardener#4251</a>), we also want to make use of controller-runtime&rsquo;s built-in mechanisms for streamlined logging.
controller-runtime uses <a href=https://github.com/go-logr/logr>logr</a>, a simple structured logging interface, for library-internal logging and logging in controllers.</p><p>logr itself is only an interface and doesn&rsquo;t provide an implementation out of the box.
Instead, it needs to be backed by a logging implementation like <a href=https://github.com/go-logr/zapr>zapr</a>. Code that uses the logr interface is thereby not tied to a specific logging implementation and makes the implementation easily exchangeable.
controller-runtime already provides a <a href=https://github.com/kubernetes-sigs/controller-runtime/tree/v0.11.0/pkg/log/zap>set of helpers</a> for constructing zapr loggers, i.e., logr loggers backed by <a href=https://github.com/uber-go/zap>zap</a>, which is a popular logging library in the go community.
Hence, we are migrating our component logging from logrus to logr (backed by zap) as part of <a href=https://github.com/gardener/gardener/issues/4251>gardener/gardener#4251</a>.</p><blockquote><p>⚠️ <code>logger.Logger</code> (logrus logger) is deprecated in Gardener and shall not be used in new code – use logr loggers when writing new code! (also see <a href=#migration-from-logrus-to-logr>Migration from logrus to logr</a>)</p><p>ℹ️ Don&rsquo;t use zap loggers directly, always use the logr interface in order to avoid tight coupling to a specific logging implementation.</p></blockquote><p>gardener-apiserver differs from the other components as it is based on the <a href=https://github.com/kubernetes/apiserver>apiserver library</a> and therefore uses <a href=https://github.com/kubernetes/klog>klog</a> – just like kube-apiserver.
As gardener-apiserver writes (almost) no logs in our coding (outside the apiserver library), there is currently no plan for switching the logging implementation.
Hence, the following sections focus on logging in the controller and admission components only.</p><h2 id=logcheck-tool><code>logcheck</code> Tool</h2><p>To ensure a smooth migration to logr and make logging in Gardener components more consistent, the <a href=https://github.com/gardener/gardener/tree/master/hack/tools/logcheck><code>logcheck</code> tool</a> was added.
It enforces (parts of) this guideline and detects programmer-level errors early on in order to prevent bugs.
Please check out the <a href=https://github.com/gardener/gardener/tree/master/hack/tools/logcheck>tool&rsquo;s documentation</a> for a detailed description.</p><h2 id=structured-logging>Structured Logging</h2><p>Similar to <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/migration-to-structured-logging.md>efforts in the Kubernetes project</a>, we want to migrate our component logs to structured logging.
As motivated above, we will use the logr interface instead of klog though.</p><p>You can read more about the motivation behind structured logging in <a href=https://github.com/go-logr/logr#background>logr&rsquo;s background and FAQ</a> (also see <a href=http://dave.cheney.net/2015/11/05/lets-talk-about-logging>this blog post by Dave Cheney</a>).
Also, make sure to check out controller-runtime&rsquo;s <a href=https://github.com/kubernetes-sigs/controller-runtime/blob/v0.11.0/TMP-LOGGING.md>logging guideline</a> with specifics for projects using the library.
The following sections will focus on the most important takeaways from those guidelines and give general instructions on how to apply them to Gardener and its controller-runtime components.
Note: some parts in this guideline differ slightly from controller-runtime&rsquo;s document.</p><h3 id=tldr-of-structured-logging>TL;DR of Structured Logging</h3><p>❌ stop using <code>printf</code>-style logging:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> logger *logrus.Logger
logger.Infof(<span style=color:#a31515>&#34;Scaling deployment %s/%s to %d replicas&#34;</span>, deployment.Namespace, deployment.Name, replicaCount)
</code></pre></div><p>✅ instead, write static log messages and enrich them with additional structured information in form of key-value pairs:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> logger logr.Logger
logger.Info(<span style=color:#a31515>&#34;Scaling deployment&#34;</span>, <span style=color:#a31515>&#34;deployment&#34;</span>, client.ObjectKeyFromObject(deployment), <span style=color:#a31515>&#34;replicas&#34;</span>, replicaCount)
</code></pre></div><h2 id=log-configuration>Log Configuration</h2><p>Gardener components can be configured to either log in <code>json</code> (default) or <code>text</code> format:
<code>json</code> format is supposed to be used in production, while <code>text</code> format might be nicer for development.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># json
{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2021-12-16T08:32:21.059+0100&#34;,&#34;msg&#34;:&#34;Hello botanist&#34;,&#34;garden&#34;:&#34;eden&#34;}

# text
2021-12-16T08:32:21.059+0100    INFO    Hello botanist  {&#34;garden&#34;: &#34;eden&#34;}
</code></pre></div><p>Components can be set to one of the following log levels (with increasing verbosity): <code>error</code>, <code>info</code> (default), <code>debug</code>.</p><blockquote><p>ℹ️ Note: some Gardener components don&rsquo;t feature a configurable log level and format yet.
In this case, they log at <code>info</code> in <code>json</code> format.
We might add configuration options via command line flags that can be used in all components in the future though (see <a href=https://github.com/gardener/gardener/issues/5191>gardener/gardener#5191</a>).</p></blockquote><h2 id=log-levels>Log Levels</h2><p>logr uses <a href=https://github.com/go-logr/logr#why-v-levels>V-levels</a> (numbered log levels), higher V-level means higher verbosity.
V-levels are relative (in contrast to <code>klog</code>&rsquo;s absolute V-levels), i.e., <code>V(1)</code> creates a logger, that is one level more verbose than its parent logger.</p><p>In Gardener components, the mentioned log levels in the component config (<code>error</code>, <code>info</code>, <code>debug</code>) map to the zap levels with the same names (see <a href=https://github.com/gardener/gardener/blob/770fc01a34b70f6cb77b8cfe929d9daef0026d1c/pkg/logger/zap.go#L43-L55>here</a>).
Hence, our loggers follow the same mapping from numerical logr levels to named zap levels like described in <a href=https://github.com/go-logr/zapr/tree/v1.1.0#increasing-verbosity>zapr</a>, i.e.:</p><ul><li>component config specifies <code>debug</code> ➡️ both <code>V(0)</code> and <code>V(1)</code> are enabled</li><li>component config specifies <code>info</code> ➡️ <code>V(0)</code> is enabled, <code>V(1)</code> will not be shown</li><li>component config specifies <code>error</code> ➡️ neither <code>V(0)</code> nor <code>V(1)</code> will be shown</li><li><code>Error()</code> logs will always be shown</li></ul><p>This mapping applies to the components' root loggers (the ones that are not &ldquo;derived&rdquo; from any other logger; constructed on component startup).
If you derive a new logger with e.g. <code>V(1)</code>, the mapping will shift by one. For example, <code>V(0)</code> will then log at zap&rsquo;s <code>debug</code> level.</p><p>There is no <code>warning</code> level (see <a href=https://dave.cheney.net/2015/11/05/lets-talk-about-logging>Dave Cheney&rsquo;s post</a>).
If there is an error condition (e.g., unexpected error received from a called function), the error should either be handled or logged at <code>error</code> if it is neither handled nor returned.
If you have an <code>error</code> value at hand that doesn&rsquo;t represent an actual error condition, but you still want to log it as an informational message, log it at <code>info</code> level with key <code>err</code>.</p><p>We might consider to make use of a broader range of log levels in the future when introducing more logs and common command line flags for our components (comparable to <code>--v</code> of Kubernetes components).
For now, we stick to the mentioned two log levels like controller-runtime: info (<code>V(0)</code>) and debug (<code>V(1)</code>).</p><h2 id=logging-in-controllers>Logging in Controllers</h2><h3 id=named-loggers>Named Loggers</h3><p>Controllers should use named loggers that include their name, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>controllerLogger := rootLogger.WithName(<span style=color:#a31515>&#34;controller&#34;</span>).WithName(<span style=color:#a31515>&#34;shoot&#34;</span>)
controllerLogger.Info(<span style=color:#a31515>&#34;Deploying kube-apiserver&#34;</span>)
</code></pre></div><p>results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>2021-12-16T09:27:56.550+0100    INFO    controller.shoot    Deploying kube-apiserver
</code></pre></div><p>Logger names are hierarchical. You can make use of it, where controllers are composed of multiple &ldquo;subcontrollers&rdquo;, e.g., <code>controller.shoot.hibernation</code> or <code>controller.shoot.maintenance</code>.</p><p>Using the global logger <code>logf.Log</code> directly is discouraged and should be rather exceptional because it makes correlating logs with code harder.
Preferably, all parts of the code should use some named logger.</p><h3 id=reconciler-loggers>Reconciler Loggers</h3><p>In your <code>Reconcile</code> function, retrieve a logger from the given <code>context.Context</code>.
It inherits from the controller&rsquo;s logger (i.e., is already named) and is preconfigured with <code>name</code> and <code>namespace</code> values for the reconciliation request:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>func</span> (r *reconciler) Reconcile(ctx context.Context, request reconcile.Request) (reconcile.Result, <span style=color:#2b91af>error</span>) {
  log := logf.FromContext(ctx)
  log.Info(<span style=color:#a31515>&#34;Reconciling Shoot&#34;</span>)
  <span style=color:green>// ...
</span><span style=color:green></span>  <span style=color:#00f>return</span> reconcile.Result{}, <span style=color:#00f>nil</span>
}
</code></pre></div><p>results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>2021-12-16T09:35:59.099+0100    INFO    controller.shoot    Reconciling Shoot        {&#34;name&#34;: &#34;sunflower&#34;, &#34;namespace&#34;: &#34;garden-greenhouse&#34;}
</code></pre></div><p>The logger is injected by controller-runtime&rsquo;s <code>Controller</code> implementation and our <code>controllerutils.CreateWorker</code> alike (if a logger is passed using <code>controllerutils.WithLogger</code>). The logger returned by <code>logf.FromContext</code> is never <code>nil</code>. If the context doesn&rsquo;t carry a logger, it falls back to the global logger (<code>logf.Log</code>), which might discard logs if not configured, but is also never <code>nil</code>.</p><p>The controller implementation (controller-runtime / <code>CreateWorker</code>) itself takes care of logging the error returned by reconcilers.
Hence, don&rsquo;t log an error that you are returning.
Generally, functions should not return an error, if they already logged it, because that means the error is already handled and not an error anymore.
See <a href=https://dave.cheney.net/2015/11/05/lets-talk-about-logging>Dave Cheney&rsquo;s post</a> for more on this.</p><h3 id=messages>Messages</h3><ul><li>Log messages should be static. Don&rsquo;t put variable content in there, i.e., no <code>fmt.Sprintf</code> or string concatenation (<code>+</code>). Use key-value pairs instead.</li><li>Log messages should be capitalized. Note: this contrasts with error messages, that should not be capitalized. However, both should not end with a punctuation mark.</li></ul><h3 id=keys-and-values>Keys and Values</h3><ul><li><p>Use <code>WithValues</code> instead of repeatedly adding key-value pairs for multiple log statements. <code>WithValues</code> creates a new logger from the parent, that carries the given key-value pairs. E.g., use it when acting on one object in multiple steps and logging something for each step:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>log := parentLog.WithValues(<span style=color:#a31515>&#34;infrastructure&#34;</span>, client.ObjectKeyFromObject(infrastrucutre))
<span style=color:green>// ...
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Creating Infrastructure&#34;</span>)
<span style=color:green>// ...
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Waiting for Infrastructure to be reconciled&#34;</span>)
<span style=color:green>// ...
</span></code></pre></div><p>Note: <code>WithValues</code> bypasses controller-runtime&rsquo;s special zap encoder that nicely encodes <code>ObjectKey</code>/<code>NamespacedName</code> and <code>runtime.Object</code> values, see <a href=https://github.com/kubernetes-sigs/controller-runtime/issues/1290>kubernetes-sigs/controller-runtime#1290</a>.
Thus, the end result might look different depending on the value and its <code>Stringer</code> implementation.</p></li><li><p>Use <a href=https://en.wiktionary.org/wiki/lowerCamelCase>lowerCamelCase</a> for keys. Don&rsquo;t put spaces in keys, as it will make log processing with simple tools like <code>jq</code> harder.</p></li><li><p>Keys should be constant, human-readable, consistent across the codebase and naturally match parts of the log message, see <a href=https://github.com/go-logr/logr#how-do-i-choose-my-keys>logr guideline</a>.</p></li><li><p>When logging object keys (name and namespace), use the object&rsquo;s type as the log key and a <code>client.ObjectKey</code>/<code>types.NamespacedName</code> value as value, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> deployment *appsv1.Deployment
log.Info(<span style=color:#a31515>&#34;Creating Deployment&#34;</span>, <span style=color:#a31515>&#34;deployment&#34;</span>, client.ObjectKeyFromObject(deployment))
</code></pre></div><p>which results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2021-12-16T08:32:21.059+0100&#34;,&#34;msg&#34;:&#34;Creating Deployment&#34;,&#34;deployment&#34;:{&#34;name&#34;: &#34;bar&#34;, &#34;namespace&#34;: &#34;foo&#34;}}
</code></pre></div><p>Earlier, we often used <code>kutil.ObjectName()</code> for logging object keys, which encodes them into a flat string like <code>foo/bar</code>. However, this flat string cannot be processed so easily by logging stacks (or <code>jq</code>) like a structured log. Hence, the use of <code>kutil.ObjectName()</code> for logging object keys is discouraged. Existing usages should be refactored to use <code>client.ObjectKeyFromObject()</code> instead.</p></li><li><p>There are cases where you don&rsquo;t have the full object key or the object itself at hand, e.g., if an object references another object (in the same namespace) by name (think <code>secretRef</code> or similar).
In such a cases, either construct the full object key including the implied namespace or log the object name under a key ending in <code>Name</code>, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  <span style=color:green>// object to reconcile
</span><span style=color:green></span>  shoot *gardencorev1beta1.Shoot
  <span style=color:green>// retrieved via logf.FromContext, preconfigured by controller with namespace and name of reconciliation request
</span><span style=color:green></span>  log logr.Logger
)

<span style=color:green>// option a: full object key, manually constructed
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Shoot uses SecretBinding&#34;</span>, <span style=color:#a31515>&#34;secretBinding&#34;</span>, client.ObjectKey{Namespace: shoot.Namespace, Name: shoot.Spec.SecretBindingName})
<span style=color:green>// option b: only name under respective *Name log key
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Shoot uses SecretBinding&#34;</span>, <span style=color:#a31515>&#34;secretBindingName&#34;</span>, shoot.Spec.SecretBindingName)
</code></pre></div><p>Both options result in well-structured logs, that are easy to interpret and process:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2022-01-18T18:00:56.672+0100&#34;,&#34;msg&#34;:&#34;Shoot uses SecretBinding&#34;,&#34;name&#34;:&#34;my-shoot&#34;,&#34;namespace&#34;:&#34;garden-project&#34;,&#34;secretBinding&#34;:{&#34;namespace&#34;:&#34;garden-project&#34;,&#34;name&#34;:&#34;aws&#34;}}
{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2022-01-18T18:00:56.673+0100&#34;,&#34;msg&#34;:&#34;Shoot uses SecretBinding&#34;,&#34;name&#34;:&#34;my-shoot&#34;,&#34;namespace&#34;:&#34;garden-project&#34;,&#34;secretBindingName&#34;:&#34;aws&#34;}
</code></pre></div></li><li><p>When handling generic <code>client.Object</code> values (e.g. in helper funcs), use <code>object</code> as key.</p></li><li><p>When adding timestamps to key-value pairs, use <code>time.Time</code> values. By this, they will be encoded in the same format as the log entry&rsquo;s timestamp.<br>Don&rsquo;t use <code>metav1.Time</code> values, as they will be encoded in a different format by their <code>Stringer</code> implementation. Pass <code>&lt;someTimestamp>.Time</code> to loggers in case you have a <code>metav1.Time</code> value at hand.</p></li><li><p>Same applies to durations. Use <code>time.Duration</code> values instead of <code>*metav1.Duration</code>. Durations can be handled specially by zap just like timestamps.</p></li><li><p>Event recorders not only create <code>Event</code> objects but also log them.
However, both Gardener&rsquo;s manually instantiated event recorders and the ones that controller-runtime provides log to <code>debug</code> level and use generic formats, that are not very easy to interpret or process (no structured logs).
Hence, don&rsquo;t use event recorders as replacements for well-structured logs.
If a controller records an event for a completed action or important information, it should probably log it as well, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>log.Info(<span style=color:#a31515>&#34;Creating ManagedSeed&#34;</span>, <span style=color:#a31515>&#34;replica&#34;</span>, r.GetObjectKey())
a.recorder.Eventf(managedSeedSet, corev1.EventTypeNormal, EventCreatingManagedSeed, <span style=color:#a31515>&#34;Creating ManagedSeed %s&#34;</span>, r.GetFullName())
</code></pre></div></li></ul><h2 id=logging-in-test-code>Logging in Test Code</h2><ul><li>If the tested production code requires a logger, you can pass <code>logr.Discard()</code> or <code>logf.NullLogger{}</code> in your test, which simply discards all logs.</li><li>Pass <code>logzap.New(logzap.WriteTo(GinkgoWriter))</code> in tests where you want to see the logs on test failure but not on success.</li><li><code>logf.Log</code> is safe to use in tests and will not cause a nil pointer deref, even if it&rsquo;s not initialized via <code>logf.SetLogger</code>.
It is initially set to a <code>NullLogger</code> by default, which means all logs are discarded, unless <code>logf.SetLogger</code> is called in the first 30 seconds of execution.</li></ul><h2 id=migration-from-logrus-to-logr>Migration from logrus to logr</h2><p>These points might be helpful when refactoring existing code during the migration period:</p><ul><li>For migrating an existing controller to logr:<ul><li>Create a named logger (<a href=https://github.com/gardener/gardener/blob/ce9d741798eac2df8c470190ab483aa4c5818ebf/pkg/controllermanager/controller/cloudprofile/cloudprofile.go#L63>example</a>).</li><li>Pass <code>controllerutils.WithLogger</code> to <code>CreateWorker</code> (<a href=https://github.com/gardener/gardener/blob/ce9d741798eac2df8c470190ab483aa4c5818ebf/pkg/controllermanager/controller/cloudprofile/cloudprofile.go#L113>example</a>). This allows <code>logf.FromContext</code> to be used in reconcilers.</li><li>Use <code>logf.FromContext</code> in <code>Reconcile</code> to retrieve the logr logger and use it from there on (<a href=https://github.com/gardener/gardener/blob/ce9d741798eac2df8c470190ab483aa4c5818ebf/pkg/controllermanager/controller/cloudprofile/cloudprofile_control.go#L72>example</a>).</li><li>Make sure to follow the other guidelines mentioned above as well (see <a href=#logging-in-controllers>Logging in Controllers</a>).</li></ul></li><li>Libraries might expect a different logging implementation than the component which uses it. E.g., a controller that already uses logr might want to use the <code>flow</code> package which still uses logrus. In such cases:<ul><li>You can consider refactoring the library along with the component itself, if feasible.</li><li>It is acceptable for the migration period to use a logger derived from the respective global logger (<code>logger.Logger</code> or <code>logf.Log</code>) and pass it to the library.
However, please add a <code>TODO</code> for cleaning it up later on, once the migration is completed. E.g.:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:green>// TODO: switch to logr once flow package is migrated
</span><span style=color:green></span>err := shootFlow.Run(flow.Opts{
  Logger: logger.Logger.WithFields(logrus.Fields{<span style=color:#a31515>&#34;logger&#34;</span>: <span style=color:#a31515>&#34;controller.&#34;</span> + ControllerName, <span style=color:#a31515>&#34;name&#34;</span>: shoot.Name, <span style=color:#a31515>&#34;namespace&#34;</span>: shoot.Namespace})
})
</code></pre></div></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d42cb3e424a70c7c39b9f2acb996f1c8>8 - Monitoring Stack</h1><h1 id=extending-the-monitoring-stack>Extending the Monitoring Stack</h1><p>This document provides instructions to extend the Shoot cluster monitoring stack by integrating new scrape targets, alerts and dashboards.</p><p>Please ensure that you have understood the basic principles of <a href=https://prometheus.io/docs/introduction/overview/>Prometheus</a> and its ecosystem before you continue.</p><p>‼️ <strong>The purpose of the monitoring stack is to observe the behaviour of the control plane and the system components deployed by Gardener onto the worker nodes. Monitoring of custom workloads running in the cluster is out of scope.</strong></p><h2 id=overview>Overview</h2><p><img src=/__resources/monitoring-architecture_cd945d.png alt="Monitoring Architecture"></p><p>Each Shoot cluster comes with its own monitoring stack. The following components are deployed into the seed and shoot:</p><ul><li>Seed<ul><li><a href=https://github.com/prometheus/prometheus>Prometheus</a></li><li><a href=https://github.com/grafana/grafana>Grafana</a></li><li><a href=https://github.com/prometheus/blackbox_exporter>blackbox-exporter</a></li><li><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a> (Seed metrics)</li><li><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a> (Shoot metrics)</li><li><a href=https://github.com/prometheus/alertmanager>Alertmanager</a> (Optional)</li></ul></li><li>Shoot<ul><li><a href=https://github.com/prometheus/node_exporter>node-exporter(s)</a></li><li><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a></li><li><a href=https://github.com/prometheus/blackbox_exporter>blackbox-exporter</a></li></ul></li></ul><p>In each Seed cluster there is a Prometheus in the <code>garden</code> namespace responsible for collecting metrics from the Seed kubelets and cAdvisors. These metrics are provided to each Shoot Prometheus via federation.</p><p>The alerts for all Shoot clusters hosted on a Seed are routed to a central Alertmanger running in the <code>garden</code> namespace of the Seed. The purpose of this central alertmanager is to forward all important alerts to the operators of the Gardener setup.</p><p>The Alertmanager in the Shoot namespace on the Seed is only responsible for forwarding alerts from its Shoot cluster to a cluster owner/cluster alert receiver via email. The Alertmanager is optional and the conditions for a deployment are already described <a href=/docs/gardener/monitoring/alerting/>here</a>.</p><h2 id=adding-new-monitoring-targets>Adding New Monitoring Targets</h2><p>After exploring the metrics which your component provides or adding new metrics, you should be aware which metrics are required to write the needed alerts and dashboards.</p><p>Prometheus prefers a pull based metrics collection approach and therefore the targets to observe need to be defined upfront. The targets are defined in <code>charts/seed-monitoring/charts/prometheus/templates/config.yaml</code>.
New scrape jobs can be added in the section <code>scrape_configs</code>. Detailed information how to configure scrape jobs and how to use the kubernetes service discovery are available in the <a href=https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config>Prometheus documentation</a>.</p><p>The <code>job_name</code> of a scrape job should be the name of the component e.g. <code>kube-apiserver</code> or <code>vpn</code>. The collection interval should be the default of <code>30s</code>. You do not need to specify this in the configuration.</p><p>Please do not ingest all metrics which are provided by a component. Rather collect only those metrics which are needed to define the alerts and dashboards (i.e. whitelist). This can be achieved by adding the following <code>metric_relabel_configs</code> statement to your scrape jobs (replace <code>exampleComponent</code> with component name).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>    - job_name: example-component
      ...
      metric_relabel_configs:
{{ include &#34;prometheus.keep-metrics.metric-relabel-config&#34; .Values.allowedMetrics.exampleComponent | indent 6 }}
</code></pre></div><p>The whitelist for the metrics of your job can be maintained in <code>charts/seed-monitoring/charts/prometheus/values.yaml</code> in section <code>allowedMetrics.exampleComponent</code> (replace <code>exampleComponent</code> with component name). Check the following example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>allowedMetrics:
  ...
  exampleComponent:
  * metrics_name_1
  * metrics_name_2
  ...
</code></pre></div><h2 id=adding-alerts>Adding Alerts</h2><p>The alert definitons are located in <code>charts/seed-monitoring/charts/prometheus/rules</code>. There are two approaches for adding new alerts.</p><ol><li>Adding additional alerts for a component which already has a set of alerts. In this case you have to extend the existing rule file for the component.</li><li>Adding alerts for a new component. In this case a new rule file with name scheme <code>example-component.rules.yaml</code> needs to be added.</li><li>Add the new alert to <code>alertInhibitionGraph.dot</code>, add any required inhibition flows and render the new graph. To render the graph run:</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>dot -Tpng ./content/alertInhibitionGraph.dot -o ./content/alertInhibitionGraph.png
</code></pre></div><ol><li>Create a test for the new alert. See <code>Alert Tests</code>.</li></ol><p>Example alert:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>groups:
* name: example.rules
  rules:
  * alert: ExampleAlert
    expr: absent(up{job=&#34;exampleJob&#34;} == 1)
    for: 20m
    labels:
      service: example
      severity: critical <span style=color:green># How severe is the alert? (blocker|critical|info|warning)</span>
      type: shoot <span style=color:green># For which topology is the alert relevant? (seed|shoot)</span>
      visibility: all <span style=color:green># Who should receive the alerts? (all|operator|owner)</span>
    annotations:
      description: A longer description of the example alert that should also explain the impact of the alert.
      summary: Short summary of an example alert.
</code></pre></div><p>If the deployment of component is optional then the alert definitions needs to be added to <code>charts/seed-monitoring/charts/prometheus/optional-rules</code> instead. Furthermore the alerts for component need to be activatable in <code>charts/seed-monitoring/charts/prometheus/values.yaml</code> via <code>rules.optional.example-component.enabled</code>. The default should be <code>true</code>.</p><p>Basic instruction how to define alert rules can be found in the <a href=https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules>Prometheus documentation</a>.</p><h3 id=routing-tree>Routing tree</h3><p>The Alertmanager is grouping incoming alerts based on labels into buckets. Each bucket has its own configuration like alert receivers, initial delaying duration or resending frequency etc. You can find more information about Alertmanager routing in the <a href=https://prometheus.io/docs/alerting/configuration/#route>Prometheus/Alertmanager documentation</a>. The routing trees for the Alertmanagers deployed by Gardener are depicted below.</p><p>Central Seed Alertmanager</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>∟ main route (all alerts for all shoots on the seed will enter)
  ∟ group by project and shoot name
    ∟ group by visibility &#34;all&#34; and &#34;operator&#34;
      ∟ group by severity &#34;blocker&#34;, &#34;critical&#34;, and &#34;info&#34; → route to Garden operators
      ∟ group by severity &#34;warning&#34; (dropped)
    ∟ group by visibility &#34;owner&#34; (dropped)
</code></pre></div><p>Shoot Alertmanager</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>∟ main route (only alerts for one Shoot will enter)
  ∟ group by visibility &#34;all&#34; and &#34;owner&#34;
    ∟ group by severity &#34;blocker&#34;, &#34;critical&#34;, and &#34;info&#34; → route to cluster alert receiver
    ∟ group by severity &#34;warning&#34; (dropped, will change soon → route to cluster alert receiver)
  ∟ group by visibility &#34;operator&#34; (dropped)
</code></pre></div><h3 id=alert-inhibition>Alert Inhibition</h3><p>All alerts related to components running on the Shoot workers are inhibited in case of an issue with the vpn connection, because those components can&rsquo;t be scraped anymore and Prometheus will fire alerts in consequence. The components running on the workers are probably healthy and the alerts are presumably false positives. The inhibition flow is shown in the figure below. If you add a new alert make sure to add it to the diagram.</p><p><img src=/__resources/alertInhibitionGraph_ceaef0.png alt=alertDiagram></p><h3 id=alert-attributes>Alert Attributes</h3><p>Each alert rule definition has to contain the following annotations:</p><ul><li><strong>summary</strong>: A short description of the issue.</li><li><strong>description</strong>: A detailed explanation of the issue with hints to the possible root causes and the impact assessment of the issue.</li></ul><p>In addtion each alert must contain the following labels:</p><ul><li><strong>type</strong><ul><li><code>shoot</code>: Components running on the Shoot worker nodes in the <code>kube-system</code> namespace.</li><li><code>seed</code>: Components running on the Seed in the Shoot namespace as part of/next to the control plane.</li></ul></li><li><strong>service</strong><ul><li>Name of the component (in lowercase) e.g. <code>kube-apiserver</code>, <code>alertmanager</code> or <code>vpn</code>.</li></ul></li><li><strong>severity</strong><ul><li><code>blocker</code>: All issues which make the cluster entirely unusable e.g. <code>KubeAPIServerDown</code> or <code>KubeSchedulerDown</code></li><li><code>critical</code>: All issues which affect single functionalities/components but not affect the cluster in its core functionality e.g. <code>VPNDown</code> or <code>KubeletDown</code>.</li><li><code>info</code>: All issues that do not affect the cluster or its core functionality, but if this component is down we cannot determine if a blocker alert is firing. (i.e. A component with an info level severity is a dependency for a component with a blocker severity)</li><li><code>warning</code>: No current existing issue, rather a hint for situations which could lead to real issue in the close future e.g. <code>HighLatencyApiServerToWorkers</code> or <code>ApiServerResponseSlow</code>.</li></ul></li></ul><h3 id=alert-tests>Alert Tests</h3><p>To test the Prometheus alerts:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test-prometheus
</code></pre></div><p>If you want to add alert tests:</p><ol><li><p>Create a new file in <code>rules-tests</code> in the form <code>&lt;alert-group-name>.rules.test.yaml</code> or if the alerts are for an existing component with existing tests, simply add the tests to the appropriate files.</p></li><li><p>Make sure that newly added tests succeed. See above.</p></li></ol><h2 id=adding-grafana-dashboards>Adding Grafana Dashboards</h2><p>The dashboard definition files are located in <code>charts/seed-monitoring/charts/grafana/dashboards</code>. Every dashboard needs its own file.</p><p>If you are adding a new component dashboard please also update the overview dashboard by adding a chart for its current up/down status and with a drill down option to the component dashboard.</p><h3 id=dashboard-structure>Dashboard Structure</h3><p>The dashboards should be structured in the following way. The assignment of the component dashboards to the categories should be handled via dashboard tags.</p><ul><li>Kubernetes control plane components (Tag: <code>control-plane</code>)<ul><li>All components which are part of the Kubernetes control plane e. g. Kube API Server, Kube Controller Manager, Kube Scheduler and Cloud Controller Manager</li><li>ETCD + Backup/Restore</li><li>Kubernetes Addon Manager</li></ul></li><li>Node/Machine components (Tag: <code>node/machine</code>)<ul><li>All metrics which are related to the behaviour/control of the Kubernetes nodes and kubelets</li><li>Machine-Controller-Manager + Cluster Autoscaler</li></ul></li><li>Networking components (Tag: <code>network</code>)<ul><li>CoreDNS, KubeProxy, Calico, VPN, Nginx Ingress</li></ul></li><li>Addon components (Tag: <code>addon</code>)<ul><li>Cert Broker</li></ul></li><li>Monitoring components (Tag: <code>monitoring</code>)</li><li>Logging components (Tag: <code>logging</code>)</li></ul><h4 id=mandatory-charts-for-component-dashboards>Mandatory Charts for Component Dashboards</h4><p>For each new component, its corresponding dashboard should contain the following charts in the first row, before adding custom charts for the component in the subsequent rows.</p><ol><li>Pod up/down status <code>up{job="example-component"}</code></li><li>Pod/containers cpu utilization</li><li>Pod/containers memorty consumption</li><li>Pod/containers network i/o</li></ol><p>These information is provided by the cAdvisor metrics. These metrics are already integrated. Please check the other dashboards for detailed information on how to query.</p><h5 id=chart-requirements>Chart Requirements</h5><p>Each chart needs to contain:</p><ul><li>a meaningful name</li><li>a detailed description (for non trivial charts)</li><li>appropriate x/y axis descriptions</li><li>appropriate scaling levels for the x/y axis</li><li>proper units for the x/y axis</li></ul><h5 id=dashboard-parameters>Dashboard Parameters</h5><p>The following parameters should be added to all dashboards to ensure a homogeneous experience across all dashboards.</p><p>Dashboards have to &mldr;</p><ul><li>contain a title which refers to the component name(s)</li><li>contain a timezone statement which should be the browser time</li><li>contain tags which express where the component is running (<code>seed</code> or <code>shoot</code>) and to which category the component belong (see dashboard structure)</li><li>contain a version statement with a value of 1</li><li>be immutable</li></ul><p>Example dashboard configuration</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;title&#34;: <span style=color:#a31515>&#34;example-component&#34;</span>,
  &#34;timezone&#34;: <span style=color:#a31515>&#34;utc&#34;</span>,
  &#34;tags&#34;: [
    <span style=color:#a31515>&#34;seed&#34;</span>,
    <span style=color:#a31515>&#34;control-plane&#34;</span>
  ],
  &#34;version&#34;: 1,
  &#34;editable&#34;: <span style=color:#a31515>&#34;false&#34;</span>
}
</code></pre></div><p>Furthermore all dashboards should contain the following time options:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;time&#34;: {
    &#34;from&#34;: <span style=color:#a31515>&#34;now-1h&#34;</span>,
    &#34;to&#34;: <span style=color:#a31515>&#34;now&#34;</span>
  },
  &#34;timepicker&#34;: {
    &#34;refresh_intervals&#34;: [
      <span style=color:#a31515>&#34;30s&#34;</span>,
      <span style=color:#a31515>&#34;1m&#34;</span>,
      <span style=color:#a31515>&#34;5m&#34;</span>
    ],
    &#34;time_options&#34;: [
      <span style=color:#a31515>&#34;5m&#34;</span>,
      <span style=color:#a31515>&#34;15m&#34;</span>,
      <span style=color:#a31515>&#34;1h&#34;</span>,
      <span style=color:#a31515>&#34;6h&#34;</span>,
      <span style=color:#a31515>&#34;12h&#34;</span>,
      <span style=color:#a31515>&#34;24h&#34;</span>,
      <span style=color:#a31515>&#34;2d&#34;</span>,
      <span style=color:#a31515>&#34;10d&#34;</span>
    ]
  }
}
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0323918722a5b41e437d646bc4e3ca40>9 - New Cloud Provider</h1><h1 id=adding-cloud-providers>Adding Cloud Providers</h1><p>This document provides an overview of how to integrate a new cloud provider into Gardener. Each component that requires integration has a detailed description of how to integrate it and the steps required.</p><h2 id=cloud-components>Cloud Components</h2><p>Gardener is composed of 2 or more Kubernetes clusters:</p><ul><li>Shoot: These are the end-user clusters, the regular Kubernetes clusters you have seen. They provide places for your workloads to run.</li><li>Seed: This is the &ldquo;management&rdquo; cluster. It manages the control planes of shoots by running them as native Kubernetes workloads.</li></ul><p>These two clusters can run in the same cloud provider, but they do not need to. For example, you could run your Seed in AWS, while having one shoot in Azure, two in Google, two in Alicloud, and three in Equinix Metal.</p><p>The Seed cluster deploys and manages the Shoot clusters. Importantly, for this discussion, the <code>etcd</code> data store backing each Shoot runs as workloads inside the Seed. Thus, to use the above example, the clusters in Azure, Google, Alicloud and Equinix Metal will have their worker nodes and master nodes running in those clouds, but the <code>etcd</code> clusters backing them will run as separate <a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>deployments</a> in the Seed Kubernetes cluster on AWS.</p><p>This distinction becomes important when preparing the integration to a new cloud provider.</p><h2 id=gardener-cloud-integration>Gardener Cloud Integration</h2><p>Gardener and its related components integrate with cloud providers at the following key lifecycle elements:</p><ul><li>Create/destroy/get/list machines for the Shoot</li><li>Create/destroy/get/list infrastructure components for the Shoot, e.g. VPCs, subnets, routes, etc.</li><li>Backup/restore etcd for the Seed via writing files to and reading them from object storage</li></ul><p>Thus, the integrations you need for your cloud provider depend on whether you want to deploy Shoot clusters to the provider, Seed or both.</p><ul><li>Shoot Only: machine lifecycle management, infrastructure.</li><li>Seed: etcd backup/restore</li></ul><h2 id=gardener-api>Gardener API</h2><p>In addition to the requirements to integrate with the cloud provider, you also need to enable the core Gardener app to receive, validate and process requests to use that cloud provider.</p><ul><li>Expose the cloud provider to the consumers of the Gardener API, so it can be told to use that cloud provider as an option</li><li>Validate that API as requests come in</li><li>Write cloud provider specific implementation (called &ldquo;provider extension&rdquo;)</li></ul><h2 id=cloud-provider-api-requirements>Cloud Provider API Requirements</h2><p>In order for a cloud provider to integrate with Gardener, the provider must have an API to perform machine lifecycle events, specifically:</p><ul><li>Create a machine</li><li>Destroy a machine</li><li>Get information about a machine and its state</li><li>List machines</li></ul><p>In addition, if the Seed is to run on the given provider, it also must have an API to save files to block storage and retrieve them, for etcd backup/restore.</p><p>The current integration with cloud providers is to add their API calls to Gardener and the Machine Controller Manager. As both Gardener and the Machine Controller Manager are written in <a href=https://golang.org>go</a>, the cloud provider should have a go SDK. However, if it has an API that is wrappable in go, e.g. a REST API, then you can use that to integrate.</p><p>The Gardener team is working on bringing cloud provider integrations out-of-tree, making them pluggable, which should simplify the process and make it possible to use other SDKs.</p><h2 id=summary>Summary</h2><p>To add a new cloud provider, you need some or all of the following. Each repository contains instructions on how to extend it to a new cloud provider.</p><table><thead><tr><th>Type</th><th>Purpose</th><th>Location</th><th>Documentation</th></tr></thead><tbody><tr><td>Seed or Shoot</td><td>Machine Lifecycle</td><td><a href=https://github.com/gardener/machine-controller-manager>machine-controller-manager</a></td><td><a href=/docs/other-components/machine-controller-manager/docs/development/cp_support_new/>MCM new cloud provider</a></td></tr><tr><td>Seed only</td><td>etcd backup/restore</td><td><a href=https://github.com/gardener/etcd-backup-restore/>etcd-backup-restore</a></td><td>In process</td></tr><tr><td>All</td><td>Extension implementation</td><td><a href=https://github.com/gardener/gardener>gardener</a></td><td><a href=/docs/gardener/extensions/overview/>Extension controller</a></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d926243c7cdf1cf05524b388093c464b>10 - New Kubernetes Version</h1><h1 id=adding-support-for-a-new-kubernetes-version>Adding Support For A New Kubernetes Version</h1><p>This document describes the steps needed to perform in order to confidently add support for a new Kubernetes <strong>minor</strong> version.</p><blockquote><p>⚠️ Typically, once a minor Kubernetes version <code>vX.Y</code> is supported by Gardener then all patch versions <code>vX.Y.Z</code> are also automatically supported without any required action.
This is because patch versions do not introduce any new feature or API changes, so there is nothing that needs to be adapted in <code>gardener/gardener</code> code.</p></blockquote><p>The Kubernetes community release a new minor version roughly every 4 months.
Please refer to the <a href=https://kubernetes.io/releases/release/>official documentation</a> about their release cycles for any additional information.</p><p>Shortly before a new release, an &ldquo;umbrella&rdquo; issue should be opened which is used to collect the required adaptations and to track the work items.
For example, <a href=https://github.com/gardener/gardener/issues/5102>#5102</a> can be used as a template for the issue description.<br>As you can see, the task of supporting a new Kubernetes version also includes the provider extensions maintained in the <code>gardener</code> GitHub organization and is not restricted to <code>gardener/gardener</code> only.</p><p>Generally, the work items can be split into two groups:
The first group contains Kubernetes release-independent tasks, the second group contains tasks specific to the changes in the given Kubernetes release.</p><blockquote><p>ℹ️ Upgrading the <code>k8s.io/*</code> and <code>sigs.k8s.io/controller-runtime</code> Golang dependencies is typically tracked and worked on separately (see e.g. <a href=https://github.com/gardener/gardener/issues/4772>#4772</a> or <a href=https://github.com/gardener/gardener/issues/5282>#5282</a>).</p></blockquote><h2 id=deriving-release-specific-tasks>Deriving Release-Specific Tasks</h2><p>Most new minor Kubernetes releases incorporate API changes, deprecations or new features.
The community announces them via their <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/>change logs</a>.
In order to derive the release-specific tasks, the respective change log for the new version <code>vX.Y</code> has to be read and understood (for example, <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md>this document</a> for <code>v1.24</code>).</p><p>As already mentioned, typical changes to watch out for are:</p><ul><li>API version promotions or deprecations</li><li>Feature gate promotions or deprecations</li><li>CLI flag changes for Kubernetes components</li><li>New default values in resources</li><li>New available fields in resources</li><li>New features potentially relevant for the Gardener system</li><li>Changes of labels or annotations Gardener relies on</li><li>&mldr;</li></ul><p>Obviously, this requires a certain experience and understanding of the Gardener project so that all &ldquo;relevant changes&rdquo; can be identified.
While reading the change log, add the tasks (along with the respective PR in <code>kubernetes/kubernetes</code> to the umbrella issue).</p><blockquote><p>ℹ️ Some of the changes might be specific to certain cloud providers. Pay attention to those as well and add related tasks to the issue.</p></blockquote><h2 id=list-of-release-independent-tasks>List Of Release-Independent Tasks</h2><p>The following paragraphs describe recurring tasks that need to be performed for each new release.</p><h3 id=releasing-a-new-hyperkube-image>Releasing A New <code>hyperkube</code> Image</h3><p>The <a href=https://github.com/gardener/hyperkube><code>gardener/hyperkube</code></a> repository is used to release container images consisting of the <code>kubectl</code> and <code>kubelet</code> binaries.</p><p>Run the <a href=https://github.com/gardener/hyperkube/blob/master/.ci/check-and-release><code>.ci/check-and-release</code></a> script to automatically build the image (make sure Docker is running!), push the images to the GCR (make sure <code>gcloud</code> is configured properly!) and publish the release on GitHub (make sure <code>git</code> is configured properly!).</p><h3 id=adapting-gardener>Adapting Gardener</h3><ul><li>Allow instantiation of a Kubernetes client for the new minor version and update the <code>README.md</code>:<ul><li>See <a href=https://github.com/gardener/gardener/pull/5255/commits/63bdae022f1cb1c9cbd1cd49b557545dca2ec32a>this</a> example commit.</li></ul></li><li>Maintain the Kubernetes feature gates used for validation of <code>Shoot</code> resources:<ul><li>The feature gates are maintained in <a href=https://github.com/gardener/gardener/blob/master/pkg/utils/validation/features/featuregates.go>this</a> file.</li><li>To maintain this list for new Kubernetes versions, run <code>hack/compare-k8s-feature-gates.sh &lt;old-version> &lt;new-version></code> (e.g. <code>hack/compare-k8s-feature-gates.sh v1.22 v1.23</code>).</li><li>It will present 2 lists of feature gates: those added and those removed in <code>&lt;new-version></code> compared to <code>&lt;old-version></code>.</li><li>Add all added feature gates to the map with <code>&lt;new-version></code> as <code>AddedInVersion</code> and no <code>RemovedInVersion</code>.</li><li>For any removed feature gates, add <code>&lt;new-version></code> as RemovedInVersion to the already existing feature gate in the map.</li><li>See <a href=https://github.com/gardener/gardener/pull/5255/commits/97923b0604300ff805def8eae981ed388d5e4a83>this</a> example commit.</li></ul></li><li>Maintain the <code>ServiceAccount</code> names for the controllers part of <code>kube-controller-manager</code>:<ul><li>The names are maintained in <a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/shootsystem/shootsystem.go>this</a> file.</li><li>To maintain this list for new Kubernetes versions, run <code>hack/compare-k8s-controllers.sh &lt;old-version> &lt;new-version></code> (e.g. <code>hack/compare-k8s-controllers.sh 1.22 1.23</code>).</li><li>It will present 2 lists of controllers: those added and those removed in <code>&lt;new-version></code> compared to <code>&lt;old-version></code>.</li><li>Double check whether such <code>ServiceAccount</code> indeed appears in the <code>kube-system</code> namespace when creating a cluster with <code>&lt;new-version></code>. Note that it sometimes might be hidden behind a default-off feature gate. You can create a local cluster with the new version using the <a href=/docs/gardener/development/getting_started_locally/>local provider</a>.</li><li>If it appears, add all added controllers to the list based on the Kubernetes version (<a href=https://github.com/gardener/gardener/blob/5f87b18b951e104c2c25a7145548c8a2d08adefc/pkg/operation/botanist/component/shootsystem/shootsystem.go#L170-L174>example</a>).</li><li>For any removed controllers, add them only to the Kubernetes version if it is low enough.</li></ul></li><li>Bump the used Kubernetes version for local <code>Shoot</code> and local e2e test.<ul><li>See <a href=https://github.com/gardener/gardener/pull/5255/commits/5707c4c7a4fd265b176387178b755cabeea89ffe>this</a> example commit.</li></ul></li></ul><h4 id=filing-the-pull-request>Filing The Pull Request</h4><p>Work on all the tasks you have collected and validate them using the <a href=/docs/gardener/development/getting_started_locally/>local provider</a>.
Execute the e2e tests and if everything looks good, then go ahead and file the PR (<a href=https://github.com/gardener/gardener/pull/5255>example PR</a>).
Generally, it is great if you add the PRs also to the umbrella issue so that they can be tracked more easily.</p><h3 id=adapting-provider-extensions>Adapting Provider Extensions</h3><p>After the PR in <code>gardener/gardener</code> for the support of the new version has been merged, you can go ahead and work on the provider extensions.</p><blockquote><p>Actually, you can already start even if the PR is not yet merged and use the branch of your fork.</p></blockquote><ul><li>Revendor the <code>github.com/gardener/gardener</code> dependency in the extension and update the <code>README.md</code>.</li><li>Work on release-specific tasks related to this provider.</li></ul><h4 id=maintaining-the-cloud-controller-manager-images>Maintaining The <code>cloud-controller-manager</code> Images</h4><p>Some of the cloud providers are not yet using upstream <code>cloud-controller-manager</code> images.
Instead, we build and maintain them ourselves:</p><ul><li><a href=https://github.com/gardener/cloud-provider-aws>https://github.com/gardener/cloud-provider-aws</a></li><li><a href=https://github.com/gardener/cloud-provider-azure>https://github.com/gardener/cloud-provider-azure</a> (since <code>v1.23</code>, we use the upstream image)</li><li><a href=https://github.com/gardener/cloud-provider-gcp>https://github.com/gardener/cloud-provider-gcp</a></li></ul><p>Until we switch to upstream images, you need to revendor the Kubernetes dependencies and release a new image.
The required steps are as follows:</p><ul><li>Checkout the <code>legacy-cloud-provider</code> branch of the respective repository</li><li>Bump the versions in the <code>Dockerfile</code> (<a href=https://github.com/gardener/cloud-provider-gcp/commit/b7eb3f56b252aaf29adc78406672574b1bc17495>example commit</a>).</li><li>Update the <code>VERSION</code> to <code>vX.Y.Z-dev</code> where <code>Z</code> is the latest available Kubernetes patch version for the <code>vX.Y</code> minor version.</li><li>Update the <code>k8s.io/*</code> dependencies in the <code>go.mod</code> file to <code>vX.Y.Z</code> and run <code>go mod vendor</code> and <code>go mod tidy</code> (<a href=https://github.com/gardener/cloud-provider-gcp/commit/d41cc9f035bcc4893b40d90a4f617c4d436c5d62>example commit</a>).</li><li>Checkout a new <code>release-vX.Y</code> branch and release it (<a href=https://github.com/gardener/cloud-provider-gcp/commits/release-v1.23>example</a>)</li></ul><blockquote><p>As you are already on it, it is great if you also bump the <code>k8s.io/*</code> dependencies for the last three minor releases as well.
In this case, you need to checkout the <code>release-vX.{Y-{1,2,3}}</code> branches and only perform the last three steps (<a href=https://github.com/gardener/cloud-provider-gcp/commits/release-v1.20>example branch</a>, <a href=https://github.com/gardener/cloud-provider-gcp/commit/372aa43fbacdeb76b3da9f6fad6cfd924d916227>example commit</a>).</p></blockquote><p>Now you need to update the new releases in the <code>charts/images.yaml</code> of the respective provider extension so that they are used (see this <a href=https://github.com/gardener/gardener-extension-provider-aws/pull/480/commits/76256de933d5a508aba26a8f589dd1a39026142e>example commit</a> for reference).</p><h4 id=filing-the-pull-request-1>Filing The Pull Request</h4><p>Again, work on all the tasks you have collected.
This time, you cannot use the local provider for validation but should create real clusters on the various infrastructures.
Typically, the following validations should be performed:</p><ul><li>Create new clusters with versions &lt; <code>vX.Y</code></li><li>Create new clusters with version = <code>vX.Y</code></li><li>Upgrade old clusters from version <code>vX.{Y-1}</code> to version <code>vX.Y</code></li><li>Delete clusters with versions &lt; <code>vX.Y</code></li><li>Delete clusters with version = <code>vX.Y</code></li></ul><p>If everything looks good, then go ahead and file the PR (<a href=https://github.com/gardener/gardener-extension-provider-aws/pull/480>example PR</a>).
Generally, it is again great if you add the PRs also to the umbrella issue so that they can be tracked more easily.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00cd3641980cfeb33469951e8feeb244>11 - Process</h1><h1 id=releases-features-hotfixes>Releases, Features, Hotfixes</h1><p>This document describes how to contribute features or hotfixes, and how new Gardener releases are usually scheduled, validated, etc.</p><ul><li><a href=#releases>Releases</a></li><li><a href=#contributing-new-features-or-fixes>Contributing new Features or Fixes</a></li><li><a href=#cherry-picks>Cherry Picks</a></li></ul><h2 id=releases>Releases</h2><p>The <a href=https://github.com/orgs/gardener/teams/gardener-maintainers>@gardener-maintainers</a> are trying to provide a new release roughly every other week (depending on their capacity and the stability/robustness of the <code>master</code> branch).</p><p>Hotfixes are usually maintained for the latest three minor releases, though, there are no fixed release dates.</p><h3 id=release-responsible-plan>Release Responsible Plan</h3><table><thead><tr><th>Version</th><th>Week No</th><th>Begin Validation Phase</th><th>Due Date</th><th>Release Responsible</th></tr></thead><tbody><tr><td>v1.42</td><td>Week 09-10</td><td>February 28, 2022</td><td>March 13, 2022</td><td><a href=https://github.com/kris94>@kris94</a></td></tr><tr><td>v1.43</td><td>Week 11-12</td><td>March 14, 2022</td><td>March 27, 2022</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.44</td><td>Week 13-14</td><td>March 28, 2022</td><td>April 10, 2022</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.45</td><td>Week 15-16</td><td>April 11, 2022</td><td>April 24, 2022</td><td><a href=https://github.com/acumino>@acumino</a></td></tr><tr><td>v1.46</td><td>Week 17-18</td><td>April 25, 2022</td><td>May 8, 2022</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a></td></tr><tr><td>v1.47</td><td>Week 19-20</td><td>May 9, 2022</td><td>May 22, 2022</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.48</td><td>Week 21-22</td><td>May 23, 2022</td><td>June 5, 2022</td><td><a href=https://github.com/ary1992>@ary1992</a></td></tr><tr><td>v1.49</td><td>Week 23-24</td><td>June 6, 2022</td><td>June 19, 2022</td><td><a href=https://github.com/plkokanov>@plkokanov</a></td></tr><tr><td>v1.50</td><td>Week 25-26</td><td>June 20, 2022</td><td>July 3, 2022</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.51</td><td>Week 27-28</td><td>July 4, 2022</td><td>July 17, 2022</td><td><a href=https://github.com/shafeeqes>@shafeeqes</a></td></tr></tbody></table><p>Apart from the release of the next version, the release responsible is also taking care of potential hotfix releases of the last three minor versions.
The release responsible is the main contact person for coordinating new feature PRs for the next minor versions or cherry-pick PRs for the last three minor versions.</p><details><summary>Click to expand the archived release responsible associations!</summary><table><thead><tr><th>Version</th><th>Week No</th><th>Begin Validation Phase</th><th>Due Date</th><th>Release Responsible</th></tr></thead><tbody><tr><td>v1.17</td><td>Week 07-08</td><td>February 15, 2021</td><td>February 28, 2021</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.18</td><td>Week 09-10</td><td>March 1, 2021</td><td>March 14, 2021</td><td><a href=https://github.com/danielfoehrKn>@danielfoehrKn</a></td></tr><tr><td>v1.19</td><td>Week 11-12</td><td>March 15, 2021</td><td>March 28, 2021</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.20</td><td>Week 13-14</td><td>March 29, 2021</td><td>April 11, 2021</td><td><a href=https://github.com/vpnachev>@vpnachev</a></td></tr><tr><td>v1.21</td><td>Week 15-16</td><td>April 12, 2021</td><td>April 25, 2021</td><td><a href=https://github.com/timuthy>@timuthy</a></td></tr><tr><td>v1.22</td><td>Week 17-18</td><td>April 26, 2021</td><td>May 9, 2021</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.23</td><td>Week 19-20</td><td>May 10, 2021</td><td>May 23, 2021</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a></td></tr><tr><td>v1.24</td><td>Week 21-22</td><td>May 24, 2021</td><td>June 5, 2021</td><td><a href=https://github.com/stoyanr>@stoyanr</a></td></tr><tr><td>v1.25</td><td>Week 23-24</td><td>June 7, 2021</td><td>June 20, 2021</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.26</td><td>Week 25-26</td><td>June 21, 2021</td><td>July 4, 2021</td><td><a href=https://github.com/danielfoehrKn>@danielfoehrKn</a></td></tr><tr><td>v1.27</td><td>Week 27-28</td><td>July 5, 2021</td><td>July 18, 2021</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.28</td><td>Week 29-30</td><td>July 19, 2021</td><td>August 1, 2021</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a></td></tr><tr><td>v1.29</td><td>Week 31-32</td><td>August 2, 2021</td><td>August 15, 2021</td><td><a href=https://github.com/timuthy>@timuthy</a></td></tr><tr><td>v1.30</td><td>Week 33-34</td><td>August 16, 2021</td><td>August 29, 2021</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.31</td><td>Week 35-36</td><td>August 30, 2021</td><td>September 12, 2021</td><td><a href=https://github.com/stoyanr>@stoyanr</a></td></tr><tr><td>v1.32</td><td>Week 37-38</td><td>September 13, 2021</td><td>September 26, 2021</td><td><a href=https://github.com/vpnachev>@vpnachev</a></td></tr><tr><td>v1.33</td><td>Week 39-40</td><td>September 27, 2021</td><td>October 10, 2021</td><td><a href=https://github.com/voelzmo>@voelzmo</a></td></tr><tr><td>v1.34</td><td>Week 41-42</td><td>October 11, 2021</td><td>October 24, 2021</td><td><a href=https://github.com/plkokanov>@plkokanov</a></td></tr><tr><td>v1.35</td><td>Week 43-44</td><td>October 25, 2021</td><td>November 7, 2021</td><td><a href=https://github.com/kris94>@kris94</a></td></tr><tr><td>v1.36</td><td>Week 45-46</td><td>November 8, 2021</td><td>November 21, 2021</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.37</td><td>Week 47-48</td><td>November 22, 2021</td><td>December 5, 2021</td><td><a href=https://github.com/danielfoehrKn>@danielfoehrKn</a></td></tr><tr><td>v1.38</td><td>Week 49-50</td><td>December 6, 2021</td><td>December 19, 2021</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.39</td><td>Week 01-04</td><td>January 3, 2022</td><td>January 30, 2022</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a>, <a href=https://github.com/timuthy>@timuthy</a></td></tr><tr><td>v1.40</td><td>Week 05-06</td><td>January 31, 2022</td><td>February 13, 2022</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.41</td><td>Week 07-08</td><td>February 14, 2022</td><td>February 27, 2022</td><td><a href=https://github.com/plkokanov>@plkokanov</a></td></tr></tbody></table></details><h3 id=release-validation>Release Validation</h3><p>The release phase for a new minor version lasts two weeks.
Typically, the first week is used for the validation of the release.
This phase includes the following steps:</p><ol><li><code>master</code> (or latest <code>release-*</code> branch) is deployed to a development landscape that already hosts some existing seed and shoot clusters.</li><li>An extended test suite is triggered by the &ldquo;release responsible&rdquo; which<ol><li>executes the Gardener integration tests for different Kubernetes versions, infrastructures, and <code>Shoot</code> settings.</li><li>executes the Kubernetes conformance tests.</li><li>executes further tests like Kubernetes/OS patch/minor version upgrades.</li></ol></li><li>Additionally, every four hours (or on demand) more tests (e.g., including the Kubernetes e2e test suite) are executed for different infrastructures.</li><li>The &ldquo;release responsible&rdquo; is verifying new features or other notable changes (derived of the draft release notes) in this development system.</li></ol><p>Usually, the new release is triggered in the beginning of the second week if all tests are green, all checks were successful, and if all of the planned verifications were performed by the release responsible.</p><h2 id=contributing-new-features-or-fixes>Contributing new Features or Fixes</h2><p>Please refer to the <a href=https://gardener.cloud/docs/contribute/>Gardener contributor guide</a>.
Besides a lot of a general information, it also provides a checklist for newly created pull requests that may help you to prepare your changes for an efficient review process.
If you are contributing a fix or major improvement, please take care to open cherry-pick PRs to all affected and still supported versions once the change is approved and merged in the <code>master</code> branch.</p><p>⚠️ Please ensure that your modifications pass the verification checks (linting, formatting, static code checks, tests, etc.) by executing</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make verify
</code></pre></div><p>before filing your pull request.</p><p>The guide applies for both changes to the <code>master</code> and to any <code>release-*</code> branch.
All changes must be submitted via a pull request and be reviewed and approved by at least one code owner.</p><h2 id=cherry-picks>Cherry Picks</h2><p>This section explains how to initiate cherry picks on release branches within the <code>gardener/gardener</code> repository.</p><ul><li><a href=#prerequisites>Prerequisites</a></li><li><a href=#initiate-a-cherry-pick>Initiate a Cherry Pick</a></li></ul><h3 id=prerequisites>Prerequisites</h3><p>Before you initiate a cherry pick, make sure that the following prerequisites are accomplished.</p><ul><li>A pull request merged against the <code>master</code> branch.</li><li>The release branch exists (check in the <a href=https://github.com/gardener/gardener/branches>branches section</a>)</li><li>Have the <code>gardener/gardener</code> repository cloned as follows:<ul><li>the <code>origin</code> remote should point to your fork (alternatively this can be overwritten by passing <code>FORK_REMOTE=&lt;fork-remote></code>)</li><li>the <code>upstream</code> remote should point to the Gardener github org (alternatively this can be overwritten by passing <code>UPSTREAM_REMOTE=&lt;upstream-remote></code>)</li></ul></li><li>Have <code>hub</code> installed, which is most easily installed via
<code>go get github.com/github/hub</code> assuming you have a standard golang
development environment.</li><li>A github token which has permissions to create a PR in an upstream branch.</li></ul><h3 id=initiate-a-cherry-pick>Initiate a Cherry Pick</h3><ul><li><p>Run the <a href=https://github.com/gardener/gardener/blob/master/hack/cherry-pick-pull.sh>cherry pick script</a></p><p>This example applies a master branch PR #3632 to the remote branch
<code>upstream/release-v3.14</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>GITHUB_USER=&lt;your-user&gt; hack/cherry-pick-pull.sh upstream/release-v3.14 3632
</code></pre></div><ul><li><p>Be aware the cherry pick script assumes you have a git remote called
<code>upstream</code> that points at the Gardener github org.</p></li><li><p>You will need to run the cherry pick script separately for each patch
release you want to cherry pick to. Cherry picks should be applied to all
active release branches where the fix is applicable.</p></li><li><p>When asked for your github password, provide the created github token
rather than your actual github password.
Refer <a href=https://github.com/github/hub/issues/2655#issuecomment-735836048>https://github.com/github/hub/issues/2655#issuecomment-735836048</a></p></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-165b95fb0235157f8762cac8f525c5ab>12 - Secrets Management</h1><h1 id=secrets-management-for-seed-and-shoot-cluster>Secrets Management for Seed and Shoot Cluster</h1><blockquote><p>🚧️ Please note that the work in the new secrets management is ongoing and hence not yet completed.
Accordingly, expect adaptations to this document and implementation details.</p></blockquote><p>The gardenlet needs to create quite some amount of credentials (certificates, private keys, passwords, etc.) for seed and shoot clusters in order to ensure secure deployments.
Such credentials typically should be rotated regularly, and they potentially need to be persisted such that they don&rsquo;t get lost in case of a control plane migration or a lost seed cluster.</p><h2 id=secretsmanager-introduction>SecretsManager Introduction</h2><p>These requirements can be covered by using the <code>SecretsManager</code> package maintained in <a href=https://github.com/gardener/gardener/tree/master/docs/development/pkg/utils/secrets/manager><code>pkg/utils/secrets/manager</code></a>.
It is built on top of the <code>ConfigInterface</code> and <code>DataInterface</code> interfaces part of <a href=https://github.com/gardener/gardener/tree/master/docs/development/pkg/utils/secrets><code>pkg/utils/secrets</code></a> and provides the following functions:</p><ul><li><p><code>Generate(context.Context, secrets.ConfigInterface, ...GenerateOption) (*corev1.Secret, error)</code></p><p>This method either retrieves the current secret for the given configuration or it (re)generates it in case the configuration changed, the signing CA changed (for certificate secrets), or when proactive rotation was triggered.
If the configuration describes a certificate authority secret then this method automatically generates a bundle secret containing the current and potentially the old certificate.<br>Available <code>GenerateOption</code>s:</p><ul><li><code>SignedByCA(string)</code>: This is only valid for certificate secrets and automatically retrieves the correct certificate authority in order to sign the provided server or client certificate.</li><li><code>Persist()</code>: This marks the secret such that it gets persisted in the <code>ShootState</code> resource in the garden cluster. Consequently, it should only be used for secrets related to a shoot cluster.</li><li><code>Rotate(rotationStrategy)</code>: This specifies the strategy in case this secret is to be rotated or regenerated (either <code>InPlace</code> which immediately forgets about the old secret, or <code>KeepOld</code> which keeps the old secret in the system).</li><li><code>IgnoreOldSecrets()</code>: This specifies whether old secrets should be considered and loaded (which is done by default). It should be used when old secrets are no longer important and can be &ldquo;forgotten&rdquo; (e.g. in <a href=/docs/gardener/proposals/18-shoot-ca-rotation/#rotation-sequence-for-cluster-and-client-ca>&ldquo;phase 2&rdquo; (<code>t2</code>) of the CA certificate rotation</a>).</li></ul></li><li><p><code>Get(string, ...GetOption) (*corev1.Secret, bool)</code></p><p>This method retrieves the current secret for the given name.
In case the secret in question is a certificate authority secret then it retrieves the bundle secret by default.
It is important that this method only knows about secrets for which there were prior <code>Generate</code> calls.<br>Available <code>GetOption</code>s:</p><ul><li><code>Bundle</code> (default): This retrieves the bundle secret.</li><li><code>Current</code>: This retrieves the current secret.</li><li><code>Old</code>: This retrieves the old secret.</li></ul></li><li><p><code>Cleanup(context.Context) error</code></p><p>This method deletes secrets which are no longer required.
No longer required secrets are those still existing in the system which weren&rsquo;t detected by prior <code>Generate</code> calls.
Consequently, only call <code>Cleanup</code> after you have executed <code>Generate</code> calls for all desired secrets.</p></li></ul><p>Some exemplary usages would look as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>secret, err := k.secretsManager.Generate(
    ctx,
    &amp;secrets.CertificateSecretConfig{
        Name:                        <span style=color:#a31515>&#34;my-server-secret&#34;</span>,
        CommonName:                  <span style=color:#a31515>&#34;server-abc&#34;</span>,
        DNSNames:                    []<span style=color:#2b91af>string</span>{<span style=color:#a31515>&#34;first-name&#34;</span>, <span style=color:#a31515>&#34;second-name&#34;</span>},
        CertType:                    secrets.ServerCert,
        SkipPublishingCACertificate: <span style=color:#00f>true</span>,
    },
    secretsmanager.SignedByCA(<span style=color:#a31515>&#34;my-ca&#34;</span>),
    secretsmanager.Persist(),
    secretsmanager.Rotate(secretsmanager.InPlace),
)
<span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
    <span style=color:#00f>return</span> err
}
</code></pre></div><p>As explained above, the caller does not need to care about the rotation or the persistence of this secret - all of these concerns are handled by the secrets manager.</p><p>In case a CA certificate is needed by some component then it can be retrieved as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>caSecret, found := k.secretsManager.Get(<span style=color:#a31515>&#34;my-ca&#34;</span>)
<span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
    <span style=color:#00f>return</span> fmt.Errorf(<span style=color:#a31515>&#34;secret my-ca not found&#34;</span>)
}
</code></pre></div><p>As explained above, this returns the bundle secret for the CA <code>my-ca</code> which might potentially contain both the current and the old CA (in case of rotation/regeneration).</p><h2 id=reusing-the-secretsmanager-in-other-components>Reusing the SecretsManager in Other Components</h2><p>While the <code>SecretsManager</code> is primarily used by gardenlet, it can be reused by other components (e.g. extensions) as well for managing secrets that are specific to the component or extension. For example, provider extensions might use their own <code>SecretsManager</code> instance for managing the serving certificate of <code>cloud-controller-manager</code>.</p><p>External components that want to reuse the <code>SecretsManager</code> should consider the following aspects:</p><ul><li>On initialization of a <code>SecretsManager</code>, pass an <code>identity</code> specific to the component, for example the extension name (gardenlet uses <code>gardenlet</code> as the <code>SecretsManager</code>&rsquo;s identity).
The given identity is added as a value for the <code>manager-identity</code> label on managed <code>Secret</code>s.
This label is used by the <code>Cleanup</code> function to select only those <code>Secret</code>s that are actually managed by the particular <code>SecretManager</code> instance. This is done to prevent removing still needed <code>Secret</code>s that are managed by other instances.</li><li>Generate dedicated CAs for signing certificates instead of depending on CAs managed by gardenlet.</li><li>Names of <code>Secret</code>s managed by external <code>SecretsManager</code> instances must not conflict with <code>Secret</code> names from other instances (e.g. gardenlet).</li><li>For CAs that should be rotated in lock-step with the Shoot CAs managed by gardenlet, components need to pass information about the last rotation initiation time and the current rotation phase to the <code>SecretsManager</code> upon initialization.
The relevant information can be retrieved from the <code>Cluster</code> resource under <code>.spec.shoot.status.credentials.rotation.certificateAuthorities</code>.</li><li>Independent of the specific identity, secrets marked with the <code>Persist</code> option are automatically saved in the <code>ShootState</code> resource by gardenlet and are also restored by gardenlet on Control Plane Migration to the new Seed.</li></ul><h2 id=implementation-details>Implementation Details</h2><p>The source of truth for the secrets manager is the list of <code>Secret</code>s in the Kubernetes cluster it acts upon (typically, the seed cluster).
The persisted secrets in the <code>ShootState</code> are only used if and only if the shoot is in the <code>Restore</code> phase - in this case all secrets are just synced to the seed cluster so that they can be picked up by the secrets manager.</p><p>In order to prevent kubelets from unneeded watches (thus, causing some significant traffic against the <code>kube-apiserver</code>), the <code>Secret</code>s are marked as immutable.
Consequently, they have a unique, deterministic name which is computed as follows:</p><ul><li>For CA secrets, the name is just exactly the name specified in the configuration (e.g., <code>ca</code>). This is for backwards-compatibility and will be dropped in a future release once all components depending on the static name have been adapted.</li><li>For all other secrets, the name specified in the configuration is used as prefix followed by an 8-digit hash. This hash is computed out of the checksum of the secret configuration and the checksum of the certificate of the signing CA (only for certificate configurations).</li></ul><p>In all cases, the name of the secrets is suffixed with a 5-digit hash computed out of the time when the rotation for this secret was last started.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-23d6dea7b372c9f66b2ff9c33cb18db8>13 - Seed Network Policies</h1><h1 id=network-policies-in-the-seed-cluster>Network Policies in the Seed Cluster</h1><p>This document describes the <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>Kubernetes network policies</a> deployed by Gardener into the Seed cluster.
For network policies deployed into the Shoot <code>kube-system</code> namespace, please see the <a href=/docs/gardener/usage/shoot_network_policies/>usage section</a>.</p><p>Network policies deployed by Gardener have names and annotations describing their purpose, so this document does only highlight a subset of the policies in detail.</p><h2 id=network-policies-in-the-shoot-namespace-in-the-seed>Network policies in the Shoot namespace in the Seed</h2><p>The network policies in the Shoot namespace in the Seed can roughly be grouped into policies required for the control plane components and for logging & monitoring.</p><p>The network policy <code>deny-all</code> plays a special role. This policy <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic>denies all ingress and egress traffic</a> from each pod in the Shoot namespace.
So per default, a pod running in the control plane cannot talk to any other pod in the whole Seed cluster.
This means the pod needs to have labels matching to appropriate network policies allowing it to talk to exactly the components required to execute its desired functionality.
<a href=#implications-for-gardener-extensions>This has also implications for Gardener extensions</a> that need to deploy additional components into the <code>Shoot's</code> control plane.</p><h3 id=network-policies-for-control-plane-components>Network Policies for Control Plane Components</h3><p>This section highlights a selection of network policies that exist in the Shoot namespace in the Seed cluster.
In general, the control plane components serve different purposes and thus need access to different pods and network ranges.</p><p>In contrast to other network policies, the policy <code>allow-to-shoot-networks</code> is tailored to the individual Shoot cluster,
because it is based on the network configuration in the Shoot manifest.
It allows pods with the label <code>networking.gardener.cloud/to-shoot-networks=allowed</code> to access pods in the Shoot pod,
service and node CIDR range. This is used by the Shoot API Server and the prometheus pods to communicate over VPN/proxy with pods in the Shoot cluster.</p><p>The policy <code>allow-to-blocked-cidrs</code> allows pods with the label <code>networking.gardener.cloud/to-blocked-cidrs=allowed</code> to access IPs that are explicitly blocked for all control planes in a Seed cluster (configurable via <code>spec.networks.blockCIDRS</code>).
This is used for instance to block the cloud provider&rsquo;s metadata service.</p><p>Another network policy to be highlighted is <code>allow-to-seed-apiserver</code>.
Some components need access to the Seed API Server. This can be allowed by labeling the pod with <code>networking.gardener.cloud/to-seed-apiserver=allowed</code>.
This policy allows exactly the IPs of the <code>kube-apiserver</code> of the Seed.
While all other policies have a static set of permissions (do not change during the lifecycle of the Shoot), the policy <code>allow-to-seed-apiserver</code> is reconciled to reflect the endpoints in the <code>default</code> namespace.
This is required because endpoint IPs are not necessarily stable (think of scaling the Seed API Server pods or hibernating the Seed cluster (acting as a managed seed) in a local development environment).</p><p>Furthermore, the following network policies exist in the Shoot namespace.
These policies are the same for every Shoot control plane.</p><pre><code>NAME                              POD-SELECTOR      
# Pods that need to access the Shoot API server. Used by all Kubernetes control plane components.
allow-to-shoot-apiserver          networking.gardener.cloud/to-shoot-apiserver=allowed

# allows access to kube-dns/core-dns pods for DNS queries                       
allow-to-dns                      networking.gardener.cloud/to-dns=allowed

# allows access to private IP address ranges 
allow-to-private-networks         networking.gardener.cloud/to-private-networks=allowed

# allows access to all but private IP address ranges 
allow-to-public-networks          networking.gardener.cloud/to-public-networks=allowed

# allows Ingress to etcd pods from the Shoot's Kubernetes API Server
allow-etcd                        app=etcd-statefulset,garden.sapcloud.io/role=controlplane

# used by the Shoot API server to allows ingress from pods labeled
# with'networking.gardener.cloud/to-shoot-apiserver=allowed', from Prometheus, and allows Egress to etcd pods
allow-kube-apiserver              app=kubernetes,gardener.cloud/role=controlplane,role=apiserver
</code></pre><h3 id=network-policies-for-logging--monitoring>Network policies for Logging & Monitoring</h3><p>Gardener currently introduces a logging stack based on <a href=https://github.com/grafana/loki>Loki</a>. So this section is subject to change.
Please checkout <a href="https://www.youtube.com/watch?v=345b8xCcB-U&t=1166s">the Community Meeting for more information</a>.</p><p>These are the logging and monitoring related network policies:</p><pre><code>NAME                              POD-SELECTOR                                                             
allow-from-prometheus             networking.gardener.cloud/from-prometheus=allowed
allow-grafana                     component=grafana,gardener.cloud/role=monitoring
allow-prometheus                  app=prometheus,gardener.cloud/role=monitoring,role=monitoring
allow-to-aggregate-prometheus     networking.gardener.cloud/to-aggregate-prometheus=allowed
allow-to-loki                     networking.gardener.cloud/to-loki=allowed
</code></pre><p>Let&rsquo;s take for instance a look at the network policy <code>from-prometheus</code>.
As part of the shoot reconciliation flow, Gardener deploys a shoot-specific Prometheus into the shoot namespace.
Each pod that should be scraped for metrics must be labeled with <code>networking.gardener.cloud/from-prometheus=allowed</code> to allow incoming network requests by the prometheus pod.
Most components of the Shoot cluster&rsquo;s control plane expose metrics and are therefore labeled appropriately.</p><h3 id=implications-for-gardener-extensions>Implications for Gardener Extensions</h3><p>Gardener extensions sometimes need to deploy additional components into the Shoot namespace in the Seed hosting the control plane.
For example the Gardener extension <a href=https://github.com/gardener/gardener-extension-provider-aws>provider-aws</a> deploys the <code>MachineControllerManager</code> into the Shoot namespace, that is ultimately responsible to create the VMs with the cloud provider AWS.</p><p>Every Shoot namespace in the Seed contains the network policy <code>deny-all</code>.
This requires a pod deployed by a Gardener extension to have labels from network policies, that exist in the Shoot namespace, that allow the required network ranges.</p><p>Additionally, extensions could also deploy their own network policies. This is used e.g by the Gardener extension <a href=https://github.com/gardener/gardener-extension-provider-aws>provider-aws</a>
to serve <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>Admission Webhooks</a> for the Shoot API server that need to be reachable from within the Shoot namespace.</p><p>The pod can use an arbitrary combination of network policies.</p><h2 id=network-policies-in-the-garden-namespace>Network policies in the <code>garden</code> namespace</h2><p>The network policies in the <code>garden</code> namespace are, with a few exceptions (e.g Kubernetes control plane specific policies), the same as in the Shoot namespaces.
For your reference, these are all the deployed network policies.</p><pre><code>NAME                              POD-SELECTOR  
allow-fluentbit                   app=fluent-bit,gardener.cloud/role=logging,role=logging              
allow-from-aggregate-prometheus   networking.gardener.cloud/from-aggregate-prometheus=allowed              
allow-to-aggregate-prometheus     networking.gardener.cloud/to-aggregate-prometheus=allowed                
allow-to-all-shoot-apiservers     networking.gardener.cloud/to-all-shoot-apiservers=allowed                
allow-to-blocked-cidrs            networking.gardener.cloud/to-blocked-cidrs=allowed                       
allow-to-dns                      networking.gardener.cloud/to-dns=allowed                                 
allow-to-loki                     networking.gardener.cloud/to-loki=allowed                       
allow-to-private-networks         networking.gardener.cloud/to-private-networks=allowed                    
allow-to-public-networks          networking.gardener.cloud/to-public-networks=allowed                     
allow-to-seed-apiserver           networking.gardener.cloud/to-seed-apiserver=allowed                      
deny-all                          networking.gardener.cloud/to-all=disallowed                              
</code></pre><p>This section describes the network policies that are unique to the <code>garden</code> namespace.</p><p>The network policy <code>allow-to-all-shoot-apiservers</code> allows pods to access every <code>Shoot</code> API server in the <code>Seed</code>.
This is for instance used by the <a href=https://github.com/gardener/dependency-watchdog>dependency watchdog</a> to regularly check
the health of all the Shoot API servers.</p><p><a href=/docs/gardener/extensions/logging-and-monitoring/#monitoring>Gardener deploys a central Prometheus instance</a> in the <code>garden</code> namespace that fetches metrics and data from all seed cluster nodes and all seed cluster pods.
The network policies <code>allow-to-aggregate-prometheus</code> and <code>allow-from-aggregate-prometheus</code> allow traffic from and to this prometheus instance.</p><p>Worth mentioning is, that the network policy <code>allow-to-shoot-networks</code> does not exist in the <code>garden</code> namespace. This is to forbid Gardener system components to talk to workload deployed in the Shoot VPC.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b3aa3f61ef7670f29a90ef82a24cb955>14 - Testing</h1><h1 id=testing>Testing</h1><h2 id=unit-tests>Unit Tests</h2><p>We follow the BDD-style testing principles and are leveraging the <a href=https://onsi.github.io/ginkgo/>Ginkgo</a> framework along with <a href=http://onsi.github.io/gomega/>Gomega</a> as matcher library. In order to execute the existing tests, you can use</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test         <span style=color:green># runs tests</span>
make verify       <span style=color:green># runs static code checks and tests (unit and integration)</span>
</code></pre></div><p>There is an additional command for analyzing the code coverage of the tests. Ginkgo will generate standard Go cover profiles which will be translated into an HTML file by the <a href=https://blog.golang.org/cover>Go Cover Tool</a>. Another command helps you to clean up the filesystem from the temporary cover profile files and the HTML report:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test-cov
open gardener.coverage.html
make test-cov-clean
</code></pre></div><h2 id=integration-tests-envtests>Integration Tests (envtests)</h2><p>Integration tests in Gardener use the <code>sigs.k8s.io/controller-runtime/pkg/envtest</code> package.
It sets up a temporary control plane (etcd + kube-apiserver) and runs the test against it.
The <code>test-integration</code> make rule prepares the environment automatically by downloading the respective binaries (if not yet present) and sets the necessary environment variables.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test-integration
</code></pre></div><p>If you want to run a specific set of integration tests, you can also execute them using <code>./hack/test-integration.sh</code> directly instead of using the <code>test-integration</code> rule. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./hack/test-integration.sh ./test/integration/resourcemanager/tokenrequestor
</code></pre></div><p>The script takes care of preparing the environment for you.
If you want to execute the test suites directly via <code>go test</code> or <code>ginkgo</code>, you have to point the <code>KUBEBUILDER_ASSETS</code> environment variable to the path that contains the etcd and kube-apiserver binaries. Alternatively, you can install the binaries to <code>/usr/local/kubebuilder/bin</code>.</p><h3 id=debugging-integration-tests>Debugging Integration Tests</h3><p>You can configure envtest to use an existing cluster instead of starting a temporary control plane for your test.
This can be helpful for debugging integration tests, because you can easily inspect what is going on in your test cluster.
For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up
export KUBECONFIG=$PWD/example/gardener-local/kind/kubeconfig
export USE_EXISTING_CLUSTER=true

<span style=color:green># run test with verbose output</span>
./hack/test-integration.sh -v ./test/integration/resourcemanager/health -ginkgo.v
</code></pre></div><h2 id=end-to-end-tests-using-provider-local>End-to-end Tests (using provider-local)</h2><p>We run a suite of e2e tests on every pull request and periodically on the <code>master</code> branch.
It uses a <a href=https://kind.sigs.k8s.io/>KinD cluster</a> and <a href=https://skaffold.dev/>skaffold</a> to boostrap a full installation of Gardener based on the current revision, including <a href=/docs/gardener/extensions/provider-local/>provider-local</a>.
This allows us to run e2e tests in an isolated test environment and fully locally without any infrastructure interaction.
The tests perform a set of operations on Shoot clusters, e.g. creating, deleting, hibernating and waking up.</p><p>These tests are executed in our prow instance at <a href=https://prow.gardener.cloud/>prow.gardener.cloud</a>, see <a href=https://github.com/gardener/ci-infra/blob/e324cb79c39c013d7f253c33690b7fcc92c001d8/config/jobs/gardener/gardener-e2e-kind.yaml>job definition</a> and <a href="https://prow.gardener.cloud/?repo=gardener%2Fgardener&job=*gardener-e2e-kind">job history</a>.</p><p>You can also run these tests on your development machine, using the following commands:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up
export KUBECONFIG=$PWD/example/gardener-local/kind/kubeconfig
make gardener-up
make test-e2e-local  <span style=color:green># alternatively: make test-e2e-local-fast</span>
</code></pre></div><p>If you want to run a specific set of e2e test cases, you can also execute them using <code>./hack/test-e2e-local.sh</code> directly in combination with <a href=https://onsi.github.io/ginkgo/#spec-labels>ginkgo label filters</a>. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./hack/test-e2e-local.sh --label-filter <span style=color:#a31515>&#34;Shoot &amp;&amp; ca-rotation&#34;</span>
</code></pre></div><p>Also see: <a href=/docs/gardener/development/getting_started_locally/>developing Gardener locally</a> and <a href=/docs/gardener/deployment/getting_started_locally/>deploying Gardener locally</a>.</p><h2 id=test-machinery-tests>Test Machinery Tests</h2><p>Please see <a href=/docs/gardener/development/testmachinery_tests/>Test Machinery Tests</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e4015db9c3c500c41833f0a4177f9f0e>15 - Testmachinery Tests</h1><h1 id=test-machinery-tests>Test Machinery Tests</h1><p>In order to automatically qualify Gardener releases, we execute a set of end-to-end tests using <a href=https://github.com/gardener/test-infra>Test Machinery</a>.
This requires a full Gardener installation including infrastructure extensions as well as a setup of Test Machinery itself.
These tests operate on Shoot clusters across different Cloud Providers, using different supported Kubernetes versions and various configuration options (huge test matrix).</p><p>This manual gives an overview about test machinery tests in Gardener.</p><ul><li><a href=#structure>Structure</a></li><li><a href=#add-a-new-test>Add a new test</a></li><li><a href=#test-labels>Test Labels</a></li><li><a href=#framework>Framework</a></li></ul><h2 id=structure>Structure</h2><p>Gardener test machinery tests are split into two test suites that can be found under <a href=https://github.com/gardener/gardener/tree/master/test/testmachinery/suites><code>test/testmachinery/suites</code></a>:</p><ul><li>The <strong>Gardener Test Suite</strong> contains all tests that only require a running gardener instance.</li><li>The <strong>Shoot Test Suite</strong> contains all tests that require a predefined running shoot cluster.</li></ul><p>The corresponding tests of a test suite are defined in the import statement of the suite definition see <a href=https://github.com/gardener/gardener/blob/master/test/testmachinery/suites/shoot/run_suite_test.go><code>shoot/run_suite_test.go</code></a>
and their source code can be found under <a href=https://github.com/gardener/gardener/tree/master/test/testmachinery><code>test/testmachinery</code></a></p><p>The <code>test</code> directory is structured as follows:</p><pre><code class=language-console data-lang=console>test
├── e2e           # end-to-end tests (using provider-local)
│  └── shoot
├── framework     # helper code shared across integration, e2e and testmachinery tests
├── integration   # integration tests (envtests)
│  ├── controllermanager
│  ├── envtest
│  ├── resourcemanager
│  ├── scheduler
│  ├── seedadmissioncontroller
│  ├── shootmaintenance
│  └── ...
└── testmachinery # test machinery tests
   ├── gardener   # actual test cases imported by suites/gardener
   │  └── security
   ├── plants
   ├── shoots     # actual test cases imported by suites/shoot
   │  ├── applications
   │  ├── care
   │  ├── logging
   │  ├── operatingsystem
   │  ├── operations
   │  └── vpntunnel
   ├── suites     # suites that run agains a running garden or shoot cluster
   │  ├── gardener
   │  └── shoot
   └── system     # suites that are used for building a full test flow
      ├── complete_reconcile
      ├── managed_seed_creation
      ├── managed_seed_deletion
      ├── shoot_cp_migration
      ├── shoot_creation
      ├── shoot_deletion
      ├── shoot_hibernation
      ├── shoot_hibernation_wakeup
      └── shoot_update
</code></pre><p>A suite can be executed by running the suite definition with ginkgo&rsquo;s <code>focus</code> and <code>skip</code> flags
to control the execution of specific labeled test. See example below:</p><pre><code class=language-console data-lang=console>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/shoot \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      --disable-dump=false \                               # disables dumping of teh current state if a test fails
      -kubecfg=/path/to/gardener/kubeconfig \
      -shoot-name=&lt;shoot-name&gt; \                           # Name of the shoot to test
      -project-namespace=&lt;gardener project namespace&gt; \    # Name of the gardener project the test shoot resides
      -ginkgo.focus=&quot;\[RELEASE\]&quot; \                        # Run all tests that are tagged as release
      -ginkgo.skip=&quot;\[SERIAL\]|\[DISRUPTIVE\]&quot;             # Exclude all tests that are tagged SERIAL or DISRUPTIVE
</code></pre><h2 id=add-a-new-test>Add a new test</h2><p>To add a new test the framework requires the following steps (step 1. and 2. can be skipped if the test is added to an existing package):</p><ol><li>Create a new test file e.g. <code>test/testmachinery/shoot/security/my-sec-test.go</code></li><li>Import the test into the appropriate test suite (gardener or shoot): <code>import _ "github.com/gardener/gardener/test/testmachinery/shoot/security"</code></li><li>Define your test with the testframework. The framework will automatically add its initialization, cleanup and dump functions.</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#00f>var</span> _ = ginkgo.Describe(<span style=color:#a31515>&#34;my suite&#34;</span>, <span style=color:#00f>func</span>(){
  f := framework.NewShootFramework(<span style=color:#00f>nil</span>)

  f.Beta().CIt(<span style=color:#a31515>&#34;my first test&#34;</span>, <span style=color:#00f>func</span>(ctx context.Context) {
    f.ShootClient.Get(xx)
    <span style=color:green>// testing ...
</span><span style=color:green></span>  })
})
</code></pre></div><p>The newly created test can be tested by focusing the test with the default ginkgo focus <code>f.Beta().FCIt("my first test", func(ctx context.Context)</code>
and run the shoot test suite with:</p><pre><code>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/shoot \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      --disable-dump=false \                               # disables dumping of the current state if a test fails
      -kubecfg=/path/to/gardener/kubeconfig \
      -shoot-name=&lt;shoot-name&gt; \                           # Name of the shoot to test
      -project-namespace=&lt;gardener project namespace&gt; \
      -fenced=&lt;true|false&gt;                                 # Tested shoot is running in a fenced environment and cannot be reached by gardener
</code></pre><p>or for the gardener suite with:</p><pre><code>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/gardener \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      --disable-dump=false \                               # disables dumping of the current state if a test fails
      -kubecfg=/path/to/gardener/kubeconfig \
      -project-namespace=&lt;gardener project namespace&gt;
</code></pre><p>⚠️ Make sure that you do not commit any focused specs as this feature is only intended for local development! Ginkgo will fail the test suite if there are any focused specs.</p><p>Alternatively, a test can be triggered by specifying a ginkgo focus regex with the name of the test e.g.</p><pre><code>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/gardener \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      -kubecfg=/path/to/gardener/kubeconfig \
      -project-namespace=&lt;gardener project namespace&gt; \
      -ginkgo.focus=&quot;my first test&quot;                        # regex to match test cases
</code></pre><h2 id=test-labels>Test Labels</h2><p>Every test should be labeled by using the predefined labels available with every framework to have consistent labeling across
all test machinery tests.</p><p>The labels are applied to every new <code>It()/CIt()</code> definition by:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang>f := framework.NewCommonFramework()
f.Default().Serial().It(<span style=color:#a31515>&#34;my test&#34;</span>) =&gt; <span style=color:#a31515>&#34;[DEFAULT] [SERIAL] my test&#34;</span>

f := framework.NewShootFramework()
f.Default().Serial().It(<span style=color:#a31515>&#34;my test&#34;</span>) =&gt; <span style=color:#a31515>&#34;[DEFAULT] [SERIAL] [SHOOT] my test&#34;</span>

f := framework.NewGardenerFramework()
f.Default().Serial().It(<span style=color:#a31515>&#34;my test&#34;</span>) =&gt; <span style=color:#a31515>&#34;[DEFAULT] [GARDENER] [SERIAL] my test&#34;</span>
</code></pre></div><p>Labels:</p><ul><li><em>Beta</em>: Newly created tests with no experience on stableness should be first labeled as beta tests.
They should be watched (and probably improved) until stable enough to be promoted to <em>Default</em>.</li><li><em>Default</em>: Tests that were <em>Beta</em> before and proved to be stable are promoted to <em>Default</em> eventually.
<em>Default</em> tests run more often, produce alerts and are <em>considered</em> during the release decision although they don&rsquo;t necessarily block a release.</li><li><em>Release</em>: Test are release relevant. A failing <em>Release</em> test blocks the release pipeline.
Therefore these tests need to be stable. Only tests proven to be stable will eventually be promoted to <em>Release</em>.</li></ul><p>Behavior Labels:</p><ul><li><em>Serial</em>: The test should always be executed in serial with no other tests running as it may impact other tests.</li><li><em>Destructive</em>: The test is destructive. Which means that is runs with no other tests and may break gardener or the shoot.
Only create such tests if really necessary as the execution will be expensive (neither gardener nor the shoot can be reused in this case for other tests).</li></ul><h2 id=framework>Framework</h2><p>The framework directory contains all the necessary functions / utilities for running test machinery tests.
For example, there are methods for creation/deletion of shoots, waiting for shoot deletion/creation, downloading/installing/deploying helm charts, logging, etc.</p><p>The framework itself consists of 3 different framework that expect different prerequisites and offer context specific functionality.</p><ul><li><strong>CommonFramework</strong>: The common framework is the base framework that handles logging and setup of commonly needed resources like helm.
It also contains common functions for interacting with kubernetes clusters like <code>Waiting for resources to be ready</code> or <code>Exec into a running pod</code>.</li><li><strong>GardenerFramework</strong> contains all functions of the common framework and expects a running gardener instance with the provided gardener kubeconfig and a project namespace.
It also contains functions to interact with gardener like <code>Waiting for a shoot to be reconciled</code> or <code>Patch a shoot</code> or <code>Get a seed</code>.</li><li><strong>ShootFramework</strong>: contains all functions of the common and the gardener framework.
It expects a running shoot cluster defined by the shoot&rsquo;s name and namespace(project namespace).
This framework contains functions to directly interact with the specific shoot.</li></ul><p>The whole framework also includes commonly used checks, ginkgo wrapper, etc. as well as commonly used tests.
Theses common application tests (like the guestbook test) can be used within multiple tests to have a default application (with ingress, deployment, stateful backend) to test external factors.</p><p><strong>Config</strong></p><p>Every framework commandline flag can also be defined by a configuration file (the value of the configuration file is only used if flag is not specified by commandline).
The test suite searches for a configuration file (yaml is preferred) if the command line flag <code>--config=/path/to/config/file</code> is provided.
A framework can be defined in the configuration file by just using the flag name as root key e.g.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>verbose: debug
kubecfg: /kubeconfig/path
project-namespace: garden-it
</code></pre></div><p><strong>Report</strong></p><p>The framework automatically writes the default ginkgo default report to stdout and a specifically structured elastichsearch bulk report file to a specified location.
The elastichsearch bulk report will write one json document per testcase and injects metadata of the whole testsuite.
An example document for one test case would look like the following document:</p><pre><code>{
    &quot;suite&quot;: {
        &quot;name&quot;: &quot;Shoot Test Suite&quot;,
        &quot;phase&quot;: &quot;Succeeded&quot;,
        &quot;tests&quot;: 3,
        &quot;failures&quot;: 1,
        &quot;errors&quot;: 0,
        &quot;time&quot;: 87.427
    },
    &quot;name&quot;: &quot;Shoot application testing  [DEFAULT] [RELEASE] [SHOOT] should download shoot kubeconfig successfully&quot;,
    &quot;shortName&quot;: &quot;should download shoot kubeconfig successfully&quot;,
    &quot;labels&quot;: [
        &quot;DEFAULT&quot;,
        &quot;RELEASE&quot;,
        &quot;SHOOT&quot;
    ],
    &quot;phase&quot;: &quot;Succeeded&quot;,
    &quot;time&quot;: 0.724512057
}
</code></pre><p><strong>Resources</strong></p><p>The resources directory contains all the templates, helm config files (e.g., repositories.yaml, charts, and cache index which are downloaded upon the start of the test), shoot configs, etc.</p><pre><code class=language-console data-lang=console>resources
├── charts
├── repository
│   └── repositories.yaml
└── templates
    ├── guestbook-app.yaml.tpl
    └── logger-app.yaml.tpl
</code></pre><p>There are two special directories that are dynamically filled with the correct test files:</p><ul><li><strong>charts:</strong> the charts will be downloaded and saved in this directory</li><li><strong>repository</strong> contains the repository.yaml file that the target helm repos will be read from and the cache where the <code>stable-index.yaml</code> file will be created</li></ul><h3 id=system-tests>System Tests</h3><p>This directory contains the system tests that have a special meaning for the testmachinery with their own Test Definition.
Currently these system tests consists of:</p><ul><li>Shoot creation</li><li>Shoot deletion</li><li>Shoot Kubernetes update</li><li>Gardener Full reconcile check</li></ul><h4 id=shoot-creation-test>Shoot Creation test</h4><p>Create Shoot test is meant to test shoot creation.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 ./test/testmachinery/system/shoot_creation \
  --v -ginkgo.v -ginkgo.progress \
  -kubecfg=$HOME/.kube/config \
  -shoot-name=$SHOOT_NAME \
  -cloud-profile=$CLOUDPROFILE \
  -seed=$SEED \
  -secret-binding=$SECRET_BINDING \
  -provider-type=$PROVIDER_TYPE \
  -region=$REGION \
  -k8s-version=$K8S_VERSION \
  -project-namespace=$PROJECT_NAMESPACE \
  -annotations=$SHOOT_ANNOTATIONS \
  -infrastructure-provider-config-filepath=$INFRASTRUCTURE_PROVIDER_CONFIG_FILEPATH \
  -controlplane-provider-config-filepath=$CONTROLPLANE_PROVIDER_CONFIG_FILEPATH \
  -workers-config-filepath=$$WORKERS_CONFIG_FILEPATH \
  -worker-zone=$ZONE \
  -networking-pods=$NETWORKING_PODS \
  -networking-services=$NETWORKING_SERVICES \
  -networking-nodes=$NETWORKING_NODES \
  -start-hibernated=$START_HIBERNATED
</code></pre><h4 id=shoot-deletion-test>Shoot Deletion test</h4><p>Delete Shoot test is meant to test the deletion of a shoot.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 -ginkgo.v -ginkgo.progress \
  ./test/testmachinery/system/shoot_deletion \
  -kubecfg=$HOME/.kube/config \
  -shoot-name=$SHOOT_NAME \
  -project-namespace=$PROJECT_NAMESPACE
</code></pre><h4 id=shoot-update-test>Shoot Update test</h4><p>The Update Shoot test is meant to test the kubernetes version update of a existing shoot.
If no specific version is provided the next patch version is automatically selected.
If there is no available newer version this test is a noop.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 ./test/testmachinery/system/shoot_update \
  --v -ginkgo.v -ginkgo.progress \
  -kubecfg=$HOME/.kube/config \
  -shoot-name=$SHOOT_NAME \
  -project-namespace=$PROJECT_NAMESPACE \
  -version=$K8S_VERSION
</code></pre><h4 id=gardener-full-reconcile-test>Gardener Full Reconcile test</h4><p>The Gardener Full Reconcile test is meant to test if all shoots of a gardener instance are successfully reconciled.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 ./test/testmachinery/system/complete_reconcile \
  --v -ginkgo.v -ginkgo.progress \
  -kubecfg=$HOME/.kube/config \
  -project-namespace=$PROJECT_NAMESPACE \
  -gardenerVersion=$GARDENER_VERSION # needed to validate the last acted gardener version of a shoot
</code></pre></div></main></div></div><footer class="footer row d-print-none"><div class="container-fluid footer-wrapper"><ul class=nav><li><a href=https://gardener.cloud/blog/>Blogs</a></li><li><a href=https://gardener.cloud/community/>Community</a></li><li><a href=https://gardener.cloud/adopter/>Adopters</a></li><li><a href=/docs/>Documentation</a></li></ul><img src=/images/lp/gardener-logo.svg alt="Logo Gardener" class=logo><ul class=media-wr><li><a target=_blank href=https://kubernetes.slack.com/archives/CB57N0BFG><img src=/images/branding/slack-logo-white.svg class=media-icon><div class=media-text>Slack</div></a></li><li><a target=_blank href=https://github.com/gardener><img src=/images/branding/github-mark-logo.png class=media-icon><div class=media-text>GitHub</div></a></li><li><a target=_blank href=https://www.youtube.com/channel/UCwUhwKFREV8Su0gwAJQX7tw><img src=/images/branding/youtube-logo-dark.svg class=media-icon><div class=media-text>YouTube</div></a></li><li><a target=_blank href=https://twitter.com/GardenerProject><img src=/images/branding/twitter-logo-white.svg class=media-icon><div class=media-text>Twitter</div></a></li></ul><span class=copyright>Copyright 2019-2022 Gardener project authors. <a href=https://www.sap.com/corporate/en/legal/privacy.html>Privacy policy
<i class="fa fa-external-link" aria-hidden=true></i></a></span></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity=sha384-uQikAXnCAqsMb3ygtdqBYvcwvHUkzGIpjdGyy9owhURXHUxLC5LgTcSxJQH/RzjK crossorigin=anonymous></script><script src=/js/main.min.ef8e0714aff556fd5a9768ed6ecabd2964dd962cd9f89762a373947bb53bc742.js integrity="sha256-744HFK/1Vv1al2jtbsq9KWTdlizZ+Jdio3OUe7U7x0I=" crossorigin=anonymous></script></body></html>