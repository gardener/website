<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2019 on Gardener</title><link>https://gardener.cloud/blog/2019/</link><description>Recent content in 2019 on Gardener</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Tue, 11 Jun 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://gardener.cloud/blog/2019/index.xml" rel="self" type="application/rss+xml"/><item><title>Feature Flags in Kubernetes Applications</title><link>https://gardener.cloud/blog/2019/06.11-feature-flags-in-kubernetes-applications/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/06.11-feature-flags-in-kubernetes-applications/</guid><description>&lt;p>Feature flags are used to change the behavior of a program at runtime without forcing a restart.&lt;/p>
&lt;p>Although they are essential in a native cloud environment, they cannot be implemented without significant effort on some platforms. Kubernetes has made this trivial. Here we will implement them through labels and annotations, but you can also implement them by connecting directly to the Kubernetes API Server.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/blog/2019/images/teaser-2.gif" alt="teaser">&lt;/p>
&lt;h2 id="possible-use-cases">Possible Use Cases&lt;a class="td-heading-self-link" href="#possible-use-cases" aria-label="Heading self-link">&lt;/a>&lt;/h2>&lt;ul>
&lt;li>Turn on/off a specific instance&lt;/li>
&lt;li>Turn on/off the profiling of a specific instance&lt;/li>
&lt;li>Change the logging level, to capture detailed logs during a specific event&lt;/li>
&lt;li>Change caching strategy at runtime&lt;/li>
&lt;li>Change timeouts in production&lt;/li>
&lt;li>Toggle on/off some special verification&lt;/li>
&lt;/ul></description></item><item><title>Organizing Access Using kubeconfig Files</title><link>https://gardener.cloud/blog/2019/06.11-organizing-access-using-kubeconfig-files/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/06.11-organizing-access-using-kubeconfig-files/</guid><description>&lt;p>The kubectl command-line tool uses &lt;code>kubeconfig&lt;/code> files to find the information it needs in order to choose a cluster and communicate with its API server.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/blog/2019/images/teaser-1.svg" alt="teaser">&lt;/p>
&lt;h3 id="what-happens-if-the-kubeconfig-file-of-your-production-cluster-is-leaked-or-published-by-accident">What happens if the kubeconfig file of your production cluster is leaked or published by accident?&lt;a class="td-heading-self-link" href="#what-happens-if-the-kubeconfig-file-of-your-production-cluster-is-leaked-or-published-by-accident" aria-label="Heading self-link">&lt;/a>&lt;/h3>&lt;p>Since there is no possibility to rotate or revoke the initial kubeconfig, there is only one way to protect your infrastructure or application if the kubeconfig has leaked - &lt;strong>delete the cluster&lt;/strong>.&lt;/p></description></item><item><title>KubeCon Rewind: SIG Cluster API &amp; Gardener â€“ Managing Machines Automatically</title><link>https://gardener.cloud/blog/2019/05.24-cluster-api-machine-abstractions-kubecon-talk/</link><pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate><guid>https://gardener.cloud/blog/2019/05.24-cluster-api-machine-abstractions-kubecon-talk/</guid><description>&lt;p>The KubeCon + CloudNativeCon Europe buzz might be settling, but the energy from our deep dive session with the incredible folks at &lt;a href="https://github.com/kubernetes-sigs/cluster-api?tab=readme-ov-file#cluster-api">&lt;strong>SIG Cluster API&lt;/strong>&lt;/a> is still palpable! We, from the &lt;strong>Gardener&lt;/strong> team, were absolutely thrilled to share the stage and explore the powerful, declarative world of Kubernetes cluster lifecycle management.&lt;/p>
&lt;p>For those who don&amp;rsquo;t know, Gardener has been on a mission since &lt;strong>2017&lt;/strong> to provide a fully managed Kubernetes experience, uniquely running customer control planes as pods within dedicated &amp;ldquo;seed&amp;rdquo; clusters, a.k.a. &amp;ldquo;Kubeception&amp;rdquo;. This approach demanded robust automation for the underlying infrastructure. To solve this, we pioneered the &lt;a href="https://github.com/gardener/machine-controller-manager">&lt;strong>Machine Controller Manager&lt;/strong>&lt;/a>, introducing the core abstractions you might recognize: &lt;code>Machine&lt;/code>, &lt;code>MachineSet&lt;/code>, and &lt;code>MachineDeployment&lt;/code>. These concepts were born out of real-world needs to declaratively manage VMs and their lifecycles as if they were just another Kubernetes resource.&lt;/p></description></item></channel></rss>