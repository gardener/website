<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=canonical type=text/html href=https://gardener.cloud/docs/gardener/><link rel=alternate type=application/rss+xml href=https://gardener.cloud/docs/gardener/index.xml><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=icon type=image/x-icon href=https://gardener.cloud/images/favicon.ico><link rel=icon type=image/png href=https://gardener.cloud/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://gardener.cloud/images/favicon-16x16.png sizes=16x16><title>Gardener | Gardener</title><meta name=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:title" content="Gardener"><meta property="og:description" content="The core component providing the extension API server of your Kubernetes cluster"><meta property="og:type" content="website"><meta property="og:url" content="https://gardener.cloud/docs/gardener/"><meta itemprop=name content="Gardener"><meta itemprop=description content="The core component providing the extension API server of your Kubernetes cluster"><meta name=twitter:card content="summary"><meta name=twitter:title content="Gardener"><meta name=twitter:description content="The core component providing the extension API server of your Kubernetes cluster"><link rel=preload href=/scss/main.min.ca2e9ddee7809848b536632b41e4e4df665800778ffe11b75edde5bdd6c78963.css as=style><link href=/scss/main.min.ca2e9ddee7809848b536632b41e4e4df665800778ffe11b75edde5bdd6c78963.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://unpkg.com/lunr@2.3.8/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg width="90" height="90" viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>logo</title><desc>Created with Sketch.</desc><defs><path d="M41.8864954.994901575c.996545099999999-.479910833 2.6164002-.477918931 3.6088091.0L76.8159138 16.0781121C77.8124589 16.5580229 78.8208647 17.8257185 79.0659694 18.8995926l7.7355517 33.8916663C87.0476474 53.8696088 86.6852538 55.4484075 85.9984855 56.3095876L64.3239514 83.4885938C63.6343208 84.3533632 62.1740175 85.0543973 61.0725268 85.0543973H26.3092731c-1.1060816.0-2.5646564-.704623400000003-3.2514246-1.5658035L1.38331434 56.3095876C.693683723 55.4448182.335174016 53.865133.580278769 52.7912589L8.31583044 18.8995926C8.56195675 17.8212428 9.57347722 16.556031 10.5658861 16.0781121L41.8864954.994901575z" id="path-1"/><linearGradient x1="12.7542673%" y1="-18.6617048%" x2="88.2666158%" y2="84.6075483%" id="linearGradient-3"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="50%" y1="4.93673768%" x2="148.756007%" y2="175.514523%" id="linearGradient-4"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="19.1574381%" y1="-9.04800713%" x2="82.2203149%" y2="77.9084293%" id="linearGradient-5"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="57.4403751%" y1="26.3148481%" x2="137.966711%" y2="158.080556%" id="linearGradient-6"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><g id="Rectangle-2" transform="translate(1.000000, 0.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Mask" fill="#009f76" xlink:href="#path-1"/><polygon fill="#000" opacity=".289628623" mask="url(#mask-2)" points="-17.6484375 54.5224609 30.8242188 25.0791016 63.4726562 58.5 24.7324219 92.6689453"/></g><path d="M56.8508631 39.260019C56.4193519 40.443987 55.6088085 41.581593 54.6736295 42.1938694l-8.0738997 5.2861089c-1.3854671.907087099999998-3.6247515.9116711-5.0172201.0L33.50861 42.1938694C32.123143 41.2867823 31 39.206345 31 37.545932V26.4150304c0-.725313.2131118-1.5301454.569268099999999-2.2825772L56.8508631 39.260019z" id="Combined-Shape" fill="url(#linearGradient-3)" transform="translate(43.925432, 36.147233) scale(-1, 1) translate(-43.925432, -36.147233)"/><path d="M56.0774672 25.1412464C56.4306829 25.8903325 56.6425556 26.6907345 56.6425556 27.4119019V38.5428034c0 1.6598979-1.1161415 3.73626640000001-2.50861 4.6479374l-8.0738997 5.286109c-1.3854671.907087000000004-3.6247516.911671000000005-5.0172201.0L32.9689261 43.1907408C32.2918101 42.7474223 31.6773514 42.0238435 31.2260376 41.206007L56.0774672 25.1412464z" id="Combined-Shape" fill="url(#linearGradient-4)" transform="translate(43.821278, 37.246598) scale(-1, 1) translate(-43.821278, -37.246598)"/><path d="M65.0702134 57.1846889C64.5985426 58.2007851 63.8367404 59.1236871 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.1597438 58.7930183 24 56.7816693 24 55.1323495V37.1145303C24 36.3487436 24.249712 35.5060005 24.6599102 34.7400631L65.0702134 57.1846889z" id="Combined-Shape" fill="url(#linearGradient-5)"/><path d="M65.0189476 34.954538C65.3636909 35.6617313 65.5692194 36.42021 65.5692194 37.1145303V55.1323495C65.5692194 56.7842831 64.4072119 58.7943252 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.9237304 59.2341061 25.3159155 58.5918431 24.8568495 57.8487596L65.0189476 34.954538z" id="Combined-Shape" fill="url(#linearGradient-6)"/></g></g></svg></span><span class=text-capitalize>Gardener</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/adopter><span>Adopters</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/blog><span>Blogs</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community><span>Community</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs><span>Documentation</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.2035d9813dafac83fe2a48b18d50f237.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/gardener/>Return to the regular view of this page</a>.</p></div><h1 class=title>Gardener</h1><div class=lead>The core component providing the extension API server of your Kubernetes cluster</div><div class=content><h1 id=gardenerhttpsgardenercloud><a href=https://gardener.cloud>Gardener</a></h1><p><img src=/__resources/gardener-large_d39ce1.png alt="Gardener Logo"></p><p><a href=https://concourse.ci.gardener.cloud/teams/gardener/pipelines/gardener-master/jobs/master-head-update-job><img src=https://concourse.ci.gardener.cloud/api/v1/teams/gardener/pipelines/gardener-master/jobs/master-head-update-job/badge alt="CI Build status"></a>
<a href=https://kubernetes.slack.com/messages/gardener><img src="https://img.shields.io/badge/slack-gardener-brightgreen.svg?logo=slack" alt="Slack channel #gardener"></a>
<a href=https://goreportcard.com/report/github.com/gardener/gardener><img src=https://goreportcard.com/badge/github.com/gardener/gardener alt="Go Report Card"></a>
<a href=https://godoc.org/github.com/gardener/gardener><img src=https://godoc.org/github.com/gardener/gardener?status.svg alt=GoDoc></a>
<a href=https://bestpractices.coreinfrastructure.org/projects/1822><img src=https://bestpractices.coreinfrastructure.org/projects/1822/badge alt="CII Best Practices"></a></p><p>Gardener implements the automated management and operation of <a href=https://kubernetes.io/>Kubernetes</a> clusters as a service and provides a fully validated extensibility framework that can be adjusted to any programmatic cloud or infrastructure provider.</p><p>Gardener is 100% Kubernetes-native and exposes its own Cluster API to create homogeneous clusters on all supported infrastructures. This API differs from <a href=https://github.com/kubernetes/community/tree/master/sig-cluster-lifecycle>SIG Cluster Lifecycle</a>&rsquo;s <a href=https://github.com/kubernetes-sigs/cluster-api#cluster-api>Cluster API</a> that only harmonizes how to get to clusters, while <a href=/docs/gardener/api-reference/core/#shoot>Gardener&rsquo;s Cluster API</a> goes one step further and also harmonizes the make-up of the clusters themselves. That means, Gardener gives you homogeneous clusters with exactly the same bill of material, configuration and behavior on all supported infrastructures, which you can see further down below in the section on our K8s Conformance Test Coverage.</p><p>In 2020, SIG Cluster Lifecycle&rsquo;s Cluster API made a huge step forward with <a href=https://kubernetes.io/blog/2020/04/21/cluster-api-v1alpha3-delivers-new-features-and-an-improved-user-experience/><code>v1alpha3</code></a> and the newly added support for declarative control plane management. This made it possible to integrate managed services like GKE or Gardener. We would be more than happy, if the community would be interested, to contribute a Gardener control plane provider. For more information on the relation between Gardener API and SIG Cluster Lifecycle&rsquo;s Cluster API, please see <a href=/docs/gardener/concepts/cluster-api/>here</a>.</p><p>Gardener&rsquo;s main principle is to <strong>leverage Kubernetes concepts for all of its tasks</strong>.</p><p>In essence, Gardener is an <a href=https://kubernetes.io/docs/tasks/access-kubernetes-api/setup-extension-api-server/>extension API server</a> that comes along with a bundle of custom controllers. It introduces new API objects in an existing Kubernetes cluster (which is called <strong>garden</strong> cluster) in order to use them for the management of end-user Kubernetes clusters (which are called <strong>shoot</strong> clusters). These shoot clusters are described via <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml>declarative cluster specifications</a> which are observed by the controllers. They will bring up the clusters, reconcile their state, perform automated updates and make sure they are always up and running.</p><p>To accomplish these tasks reliably and to offer a high quality of service, Gardener controls the main components of a Kubernetes cluster (etcd, API server, controller manager, scheduler). These so-called <em>control plane</em> components are hosted in Kubernetes clusters themselves (which are called <strong>seed</strong> clusters). This is the main difference compared to many other OSS cluster provisioning tools: The shoot clusters do not have dedicated master VMs. Instead, the control plane is deployed as a native Kubernetes workload into the seeds (the architecture is commonly referred to as kubeception or inception design). This does not only effectively reduce the total cost of ownership but also allows easier implementations for &ldquo;day-2 operations&rdquo; (like cluster updates or robustness) by relying on all the mature Kubernetes features and capabilities.</p><p>Gardener reuses the identical Kubernetes design to span a scalable multi-cloud and multi-cluster landscape. Such familiarity with known concepts has proven to quickly ease the initial learning curve and accelerate developer productivity:</p><ul><li>Kubernetes API Server = Gardener API Server</li><li>Kubernetes Controller Manager = Gardener Controller Manager</li><li>Kubernetes Scheduler = Gardener Scheduler</li><li>Kubelet = Gardenlet</li><li>Node = Seed cluster</li><li>Pod = Shoot cluster</li></ul><p>Please find more information regarding the concepts and a detailed description of the architecture in our <a href=/docs/gardener/concepts/architecture/>Gardener Wiki</a> and our blog posts on kubernetes.io: <a href=https://kubernetes.io/blog/2018/05/17/gardener>Gardener - the Kubernetes Botanist (17.5.2018)</a> and <a href=https://kubernetes.io/blog/2019/12/02/gardener-project-update>Gardener Project Update (2.12.2019)</a>.</p><hr><h2 id=k8s-conformance-test-coverage-img-srchttpsrawgithubusercontentcomcncfartworkmasterprojectskubernetescertified-kubernetesversionlesscolorcertified-kubernetes-colorsvg-altcertified-kubernetes-logo-width50-alignright>K8s Conformance Test Coverage <img src=https://raw.githubusercontent.com/cncf/artwork/master/projects/kubernetes/certified-kubernetes/versionless/color/certified-kubernetes-color.svg alt="certified kubernetes logo" width=50 align=right></h2><p>Gardener takes part in the <a href=https://www.cncf.io/certification/software-conformance/>Certified Kubernetes Conformance Program</a> to attest its compatibility with the K8s conformance testsuite. Currently Gardener is certified for K8s versions up to v1.20, see <a href="https://docs.google.com/spreadsheets/d/1LxSqBzjOxfGx3cmtZ4EbB_BGCxT_wlxW_xgHVVa23es/edit#gid=0&range=113:114">the conformance spreadsheet</a>.</p><p>Continuous conformance test results of the latest stable Gardener release are uploaded regularly to the CNCF test grid:</p><table><thead><tr><th>Provider/K8s</th><th>v1.23</th><th>v1.22</th><th>v1.21</th><th>v1.20</th><th>v1.19</th><th>v1.18</th><th>v1.17</th></tr></thead><tbody><tr><td><strong>AWS</strong></td><td>N/A</td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.22%20AWS><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.22%20AWS/tests_status?style=svg" alt="Gardener v1.22 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.21%20AWS><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.21%20AWS/tests_status?style=svg" alt="Gardener v1.21 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.20%20AWS><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.20%20AWS/tests_status?style=svg" alt="Gardener v1.20 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.19%20AWS><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.19%20AWS/tests_status?style=svg" alt="Gardener v1.19 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.18%20AWS><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.18%20AWS/tests_status?style=svg" alt="Gardener v1.18 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.17%20AWS><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.17%20AWS/tests_status?style=svg" alt="Gardener v1.17 Conformance Tests"></a></td></tr><tr><td><strong>Azure</strong></td><td>N/A</td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.22%20Azure><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.22%20Azure/tests_status?style=svg" alt="Gardener v1.22 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.21%20Azure><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.21%20Azure/tests_status?style=svg" alt="Gardener v1.21 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.20%20Azure><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.20%20Azure/tests_status?style=svg" alt="Gardener v1.20 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.19%20Azure><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.19%20Azure/tests_status?style=svg" alt="Gardener v1.19 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.18%20Azure><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.18%20Azure/tests_status?style=svg" alt="Gardener v1.18 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.17%20Azure><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.17%20Azure/tests_status?style=svg" alt="Gardener v1.17 Conformance Tests"></a></td></tr><tr><td><strong>GCP</strong></td><td>N/A</td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.22%20GCE><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.22%20GCE/tests_status?style=svg" alt="Gardener v1.22 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.21%20GCE><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.21%20GCE/tests_status?style=svg" alt="Gardener v1.21 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.20%20GCE><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.20%20GCE/tests_status?style=svg" alt="Gardener v1.20 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.19%20GCE><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.19%20GCE/tests_status?style=svg" alt="Gardener v1.19 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.18%20GCE><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.18%20GCE/tests_status?style=svg" alt="Gardener v1.18 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.17%20GCE><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.17%20GCE/tests_status?style=svg" alt="Gardener v1.17 Conformance Tests"></a></td></tr><tr><td><strong>OpenStack</strong></td><td>N/A</td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.22%20OpenStack><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.22%20OpenStack/tests_status?style=svg" alt="Gardener v1.22 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.21%20OpenStack><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.21%20OpenStack/tests_status?style=svg" alt="Gardener v1.21 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.20%20OpenStack><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.20%20OpenStack/tests_status?style=svg" alt="Gardener v1.20 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.19%20OpenStack><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.19%20OpenStack/tests_status?style=svg" alt="Gardener v1.19 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.18%20OpenStack><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.18%20OpenStack/tests_status?style=svg" alt="Gardener v1.18 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.17%20OpenStack><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.17%20OpenStack/tests_status?style=svg" alt="Gardener v1.17 Conformance Tests"></a></td></tr><tr><td><strong>Alicloud</strong></td><td>N/A</td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.22%20Alibaba%20Cloud><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.22%20Alibaba%20Cloud/tests_status?style=svg" alt="Gardener v1.22 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.21%20Alibaba%20Cloud><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.21%20Alibaba%20Cloud/tests_status?style=svg" alt="Gardener v1.21 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.20%20Alibaba%20Cloud><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.20%20Alibaba%20Cloud/tests_status?style=svg" alt="Gardener v1.20 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.19%20Alibaba%20Cloud><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.19%20Alibaba%20Cloud/tests_status?style=svg" alt="Gardener v1.19 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.18%20Alibaba%20Cloud><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.18%20Alibaba%20Cloud/tests_status?style=svg" alt="Gardener v1.18 Conformance Tests"></a></td><td><a href=https://testgrid.k8s.io/conformance-gardener#Gardener,%20v1.17%20Alibaba%20Cloud><img src="https://testgrid.k8s.io/q/summary/conformance-gardener/Gardener,%20v1.17%20Alibaba%20Cloud/tests_status?style=svg" alt="Gardener v1.17 Conformance Tests"></a></td></tr><tr><td><strong>Equinix Metal</strong></td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><strong>vSphere</strong></td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr></tbody></table><p>[1] Conformance tests are still executed and validated, unfortunately <a href=https://github.com/kubernetes/test-infra/pull/18509#issuecomment-668204180>no longer shown in TestGrid</a>.</p><p>Get an overview of the test results at <a href=https://testgrid.k8s.io/gardener-all>testgrid</a>.</p><h2 id=start-using-or-developing-the-gardener-locally>Start using or developing the Gardener locally</h2><p>See our documentation in the <code>/docs</code> repository, please <a href=https://github.com/gardener/gardener/blob/master/docs/README.md>find the index here</a>.</p><h2 id=setting-up-your-own-gardener-landscape-in-the-cloud>Setting up your own Gardener landscape in the Cloud</h2><p>The quickest way to test drive Gardener is to install it virtually onto an existing Kubernetes cluster, just like you would install any other Kubernetes-ready application. You can do this with our <a href=https://github.com/gardener/gardener/tree/master/charts/gardener>Gardener Helm Chart</a>.</p><p>Alternatively you can use our <a href=https://github.com/gardener/garden-setup>garden setup</a> project to create a fully configured Gardener landscape which also includes our <a href=https://github.com/gardener/dashboard>Gardener Dashboard</a>.</p><h2 id=feedback-and-support>Feedback and Support</h2><p>Feedback and contributions are always welcome!</p><p>All channels for getting in touch or learning about our project are listed under the <a href=https://gardener.cloud/docs/contribute/#community>community</a> section. We are cordially inviting interested parties to join our <a href=https://gardener.cloud/docs/contribute/#bi-weekly-meetings>bi-weekly meetings</a>.</p><p>Please report bugs or suggestions about our Kubernetes clusters as such or the Gardener itself as <a href=https://github.com/gardener/gardener/issues>GitHub issues</a> or join our <a href=https://kubernetes.slack.com/messages/gardener>Slack channel #gardener</a> (please invite yourself to the Kubernetes workspace <a href=http://slack.k8s.io>here</a>).</p><h2 id=learn-more>Learn More!</h2><p>Please find further resources about our project here:</p><ul><li><a href=https://gardener.cloud/>Our landing page gardener.cloud</a></li><li><a href=https://kubernetes.io/blog/2019/12/02/gardener-project-update/>&ldquo;Gardener Project Update&rdquo; blog on kubernetes.io</a>.</li><li><a href=https://kubernetes.io/blog/2018/05/17/gardener/>&ldquo;Gardener, the Kubernetes Botanist&rdquo; blog on kubernetes.io</a></li><li><a href=https://news.sap.com/2018/11/hasso-plattner-founders-award-finalist-profile-project-gardener/>SAP news article about &ldquo;Project Gardener&rdquo;</a></li><li><a href=https://www.sap-tv.com/video/40962/gardener-planting-the-seeds-of-success-in-the-cloud>Introduction movie: &ldquo;Gardener - Planting the Seeds of Success in the Cloud&rdquo;</a></li><li><a href="https://www.youtube.com/watch?v=bfw22WPg99A">&ldquo;Thinking Cloud Native&rdquo; talk at EclipseCon 2018</a></li><li><a href=https://blogs.sap.com/2018/07/26/showcase-of-gardener-at-oscon/>Blog - &ldquo;Showcase of Gardener at OSCON 2018&rdquo;</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-a8efdcbcfad5d117ab83dc78a59d1180>1 - API Reference</h1><h1 id=gardener-api-reference>Gardener API Reference</h1><ul><li><a href=/docs/gardener/api-reference/authentication/><code>authentication.gardener.cloud</code> API Group</a></li><li><a href=/docs/gardener/api-reference/core/><code>core.gardener.cloud</code> API Group</a></li><li><a href=/docs/gardener/api-reference/extensions/><code>extensions.gardener.cloud</code> API Group</a></li><li><a href=/docs/gardener/api-reference/operations/><code>operations.gardener.cloud</code> API Group</a></li><li><a href=/docs/gardener/api-reference/resources/><code>resources.gardener.cloud</code> API Group</a></li><li><a href=/docs/gardener/api-reference/seedmanagement/><code>seedmanagement.gardener.cloud</code> API Group</a></li><li><a href=/docs/gardener/api-reference/settings/><code>settings.gardener.cloud</code> API Group</a></li></ul></div><div class=td-content><h1 id=pg-fa900f2cc6e9837e1344861d6c05eae9>1.1 - Authentication</h1><p>Packages:</p><ul><li><a href=#authentication.gardener.cloud%2fv1alpha1>authentication.gardener.cloud/v1alpha1</a></li></ul><h2 id=authentication.gardener.cloud/v1alpha1>authentication.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 is a version of the API.</p></p>Resource Types:<ul><li><a href=#authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequest>AdminKubeconfigRequest</a></li></ul><h3 id=authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequest>AdminKubeconfigRequest</h3><p><p>AdminKubeconfigRequest can be used to request a kubeconfig with admin credentials
for a Shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>authentication.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>AdminKubeconfigRequest</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequestSpec>AdminKubeconfigRequestSpec</a></em></td><td><p>Spec is the specification of the AdminKubeconfigRequest.</p><br><br><table><tr><td><code>expirationSeconds</code></br><em>int64</em></td><td><em>(Optional)</em><p>ExpirationSeconds is the requested validity duration of the credential. The
credential issuer may return a credential with a different validity duration so a
client needs to check the &lsquo;expirationTimestamp&rsquo; field in a response.
Defaults to 1 hour.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequestStatus>AdminKubeconfigRequestStatus</a></em></td><td><p>Status is the status of the AdminKubeconfigRequest.</p></td></tr></tbody></table><h3 id=authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequestSpec>AdminKubeconfigRequestSpec</h3><p>(<em>Appears on:</em>
<a href=#authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequest>AdminKubeconfigRequest</a>)</p><p><p>AdminKubeconfigRequestSpec contains the expiration time of the kubeconfig.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>expirationSeconds</code></br><em>int64</em></td><td><em>(Optional)</em><p>ExpirationSeconds is the requested validity duration of the credential. The
credential issuer may return a credential with a different validity duration so a
client needs to check the &lsquo;expirationTimestamp&rsquo; field in a response.
Defaults to 1 hour.</p></td></tr></tbody></table><h3 id=authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequestStatus>AdminKubeconfigRequestStatus</h3><p>(<em>Appears on:</em>
<a href=#authentication.gardener.cloud/v1alpha1.AdminKubeconfigRequest>AdminKubeconfigRequest</a>)</p><p><p>AdminKubeconfigRequestStatus is the status of the AdminKubeconfigRequest containing
the kubeconfig and expiration of the credential.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>kubeconfig</code></br><em>[]byte</em></td><td><p>Kubeconfig contains the kubeconfig with cluster-admin privileges for the shoot cluster.</p></td></tr><tr><td><code>expirationTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><p>ExpirationTimestamp is the expiration timestamp of the returned credential.</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-209c498ead72c3692859e3c0e9e817cb>1.2 - Core</h1><p>Packages:</p><ul><li><a href=#core.gardener.cloud%2fv1beta1>core.gardener.cloud/v1beta1</a></li></ul><h2 id=core.gardener.cloud/v1beta1>core.gardener.cloud/v1beta1</h2><p><p>Package v1beta1 is a version of the API.</p></p>Resource Types:<ul><li><a href=#core.gardener.cloud/v1beta1.BackupBucket>BackupBucket</a></li><li><a href=#core.gardener.cloud/v1beta1.BackupEntry>BackupEntry</a></li><li><a href=#core.gardener.cloud/v1beta1.CloudProfile>CloudProfile</a></li><li><a href=#core.gardener.cloud/v1beta1.ControllerDeployment>ControllerDeployment</a></li><li><a href=#core.gardener.cloud/v1beta1.ControllerInstallation>ControllerInstallation</a></li><li><a href=#core.gardener.cloud/v1beta1.ControllerRegistration>ControllerRegistration</a></li><li><a href=#core.gardener.cloud/v1beta1.Plant>Plant</a></li><li><a href=#core.gardener.cloud/v1beta1.Project>Project</a></li><li><a href=#core.gardener.cloud/v1beta1.Quota>Quota</a></li><li><a href=#core.gardener.cloud/v1beta1.SecretBinding>SecretBinding</a></li><li><a href=#core.gardener.cloud/v1beta1.Seed>Seed</a></li><li><a href=#core.gardener.cloud/v1beta1.Shoot>Shoot</a></li></ul><h3 id=core.gardener.cloud/v1beta1.BackupBucket>BackupBucket</h3><p><p>BackupBucket holds details about backup bucket</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>BackupBucket</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.BackupBucketSpec>BackupBucketSpec</a></em></td><td><p>Specification of the Backup Bucket.</p><br><br><table><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.BackupBucketProvider>BackupBucketProvider</a></em></td><td><p>Provider holds the details of cloud provider of the object store. This field is immutable.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to BackupBucket resource.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the credentials to access object store.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName holds the name of the seed allocated to BackupBucket for running controller.
This field is immutable.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.BackupBucketStatus>BackupBucketStatus</a></em></td><td><p>Most recently observed status of the Backup Bucket.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.BackupEntry>BackupEntry</h3><p><p>BackupEntry holds details about shoot backup.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>BackupEntry</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.BackupEntrySpec>BackupEntrySpec</a></em></td><td><em>(Optional)</em><p>Spec contains the specification of the Backup Entry.</p><br><br><table><tr><td><code>bucketName</code></br><em>string</em></td><td><p>BucketName is the name of backup bucket for this Backup Entry.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName holds the name of the seed to which this BackupEntry is scheduled</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.BackupEntryStatus>BackupEntryStatus</a></em></td><td><em>(Optional)</em><p>Status contains the most recently observed status of the Backup Entry.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CloudProfile>CloudProfile</h3><p><p>CloudProfile represents certain properties about a provider environment.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>CloudProfile</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a></em></td><td><em>(Optional)</em><p>Spec defines the provider environment properties.</p><br><br><table><tr><td><code>caBundle</code></br><em>string</em></td><td><em>(Optional)</em><p>CABundle is a certificate bundle which will be installed onto every host machine of shoot cluster targeting this profile.</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesSettings>KubernetesSettings</a></em></td><td><p>Kubernetes contains constraints regarding allowed values of the &lsquo;kubernetes&rsquo; block in the Shoot specification.</p></td></tr><tr><td><code>machineImages</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineImage>[]MachineImage</a></em></td><td><p>MachineImages contains constraints regarding allowed values for machine images in the Shoot specification.</p></td></tr><tr><td><code>machineTypes</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineType>[]MachineType</a></em></td><td><p>MachineTypes contains constraints regarding allowed values for machine types in the &lsquo;workers&rsquo; block in the Shoot specification.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig contains provider-specific configuration for the profile.</p></td></tr><tr><td><code>regions</code></br><em><a href=#core.gardener.cloud/v1beta1.Region>[]Region</a></em></td><td><p>Regions contains constraints regarding allowed values for regions and zones.</p></td></tr><tr><td><code>seedSelector</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSelector>SeedSelector</a></em></td><td><em>(Optional)</em><p>SeedSelector contains an optional list of labels on <code>Seed</code> resources that marks those seeds whose shoots may use this provider profile.
An empty list means that all seeds of the same provider type are supported.
This is useful for environments that are of the same type (like openstack) but may have different &ldquo;instances&rdquo;/landscapes.
Optionally a list of possible providers can be added to enable cross-provider scheduling. By default, the provider
type of the seed must match the shoot&rsquo;s provider.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the name of the provider.</p></td></tr><tr><td><code>volumeTypes</code></br><em><a href=#core.gardener.cloud/v1beta1.VolumeType>[]VolumeType</a></em></td><td><em>(Optional)</em><p>VolumeTypes contains constraints regarding allowed values for volume types in the &lsquo;workers&rsquo; block in the Shoot specification.</p></td></tr></table></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerDeployment>ControllerDeployment</h3><p><p>ControllerDeployment contains information about how this controller is deployed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ControllerDeployment</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the deployment type.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>ProviderConfig contains type-specific configuration. It contains assets that deploy the controller.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerInstallation>ControllerInstallation</h3><p><p>ControllerInstallation represents an installation request for an external controller.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ControllerInstallation</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerInstallationSpec>ControllerInstallationSpec</a></em></td><td><p>Spec contains the specification of this installation.
If the object&rsquo;s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>registrationRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>RegistrationRef is used to reference a ControllerRegistration resource.
The name field of the RegistrationRef is immutable.</p></td></tr><tr><td><code>seedRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>SeedRef is used to reference a Seed resource. The name field of the SeedRef is immutable.</p></td></tr><tr><td><code>deploymentRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><em>(Optional)</em><p>DeploymentRef is used to reference a ControllerDeployment resource.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerInstallationStatus>ControllerInstallationStatus</a></em></td><td><p>Status contains the status of this installation.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerRegistration>ControllerRegistration</h3><p><p>ControllerRegistration represents a registration of an external controller.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ControllerRegistration</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerRegistrationSpec>ControllerRegistrationSpec</a></em></td><td><p>Spec contains the specification of this registration.
If the object&rsquo;s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>resources</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerResource>[]ControllerResource</a></em></td><td><em>(Optional)</em><p>Resources is a list of combinations of kinds (DNSProvider, Infrastructure, Generic, &mldr;) and their actual types
(aws-route53, gcp, auditlog, &mldr;).</p></td></tr><tr><td><code>deployment</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerRegistrationDeployment>ControllerRegistrationDeployment</a></em></td><td><em>(Optional)</em><p>Deployment contains information for how this controller is deployed.</p></td></tr></table></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Plant>Plant</h3><p><p>Plant represents an external kubernetes cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Plant</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.PlantSpec>PlantSpec</a></em></td><td><p>Spec contains the specification of this Plant.
If the object&rsquo;s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>Kubernetes core/v1.LocalObjectReference</a></em></td><td><p>SecretRef is a reference to a Secret object containing the Kubeconfig of the external kubernetes
clusters to be added to Gardener.</p></td></tr><tr><td><code>endpoints</code></br><em><a href=#core.gardener.cloud/v1beta1.Endpoint>[]Endpoint</a></em></td><td><em>(Optional)</em><p>Endpoints is the configuration plant endpoints</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.PlantStatus>PlantStatus</a></em></td><td><p>Status contains the status of this Plant.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Project>Project</h3><p><p>Project holds certain properties about a Gardener project.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Project</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectSpec>ProjectSpec</a></em></td><td><em>(Optional)</em><p>Spec defines the project properties.</p><br><br><table><tr><td><code>createdBy</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#subject-v1-rbac>Kubernetes rbac/v1.Subject</a></em></td><td><em>(Optional)</em><p>CreatedBy is a subject representing a user name, an email address, or any other identifier of a user
who created the project. This field is immutable.</p></td></tr><tr><td><code>description</code></br><em>string</em></td><td><em>(Optional)</em><p>Description is a human-readable description of what the project is used for.</p></td></tr><tr><td><code>owner</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#subject-v1-rbac>Kubernetes rbac/v1.Subject</a></em></td><td><em>(Optional)</em><p>Owner is a subject representing a user name, an email address, or any other identifier of a user owning
the project.
IMPORTANT: Be aware that this field will be removed in the <code>v1</code> version of this API in favor of the <code>owner</code>
role. The only way to change the owner will be by moving the <code>owner</code> role. In this API version the only way
to change the owner is to use this field.
TODO: Remove this field in favor of the <code>owner</code> role in <code>v1</code>.</p></td></tr><tr><td><code>purpose</code></br><em>string</em></td><td><em>(Optional)</em><p>Purpose is a human-readable explanation of the project&rsquo;s purpose.</p></td></tr><tr><td><code>members</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectMember>[]ProjectMember</a></em></td><td><em>(Optional)</em><p>Members is a list of subjects representing a user name, an email address, or any other identifier of a user,
group, or service account that has a certain role.</p></td></tr><tr><td><code>namespace</code></br><em>string</em></td><td><em>(Optional)</em><p>Namespace is the name of the namespace that has been created for the Project object.
A nil value means that Gardener will determine the name of the namespace.
This field is immutable.</p></td></tr><tr><td><code>tolerations</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectTolerations>ProjectTolerations</a></em></td><td><em>(Optional)</em><p>Tolerations contains the tolerations for taints on seed clusters.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectStatus>ProjectStatus</a></em></td><td><em>(Optional)</em><p>Most recently observed status of the Project.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Quota>Quota</h3><p><p>Quota represents a quota on resources consumed by shoot clusters either per project or per provider secret.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Quota</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.QuotaSpec>QuotaSpec</a></em></td><td><em>(Optional)</em><p>Spec defines the Quota constraints.</p><br><br><table><tr><td><code>clusterLifetimeDays</code></br><em>int32</em></td><td><em>(Optional)</em><p>ClusterLifetimeDays is the lifetime of a Shoot cluster in days before it will be terminated automatically.</p></td></tr><tr><td><code>metrics</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#resourcelist-v1-core>Kubernetes core/v1.ResourceList</a></em></td><td><p>Metrics is a list of resources which will be put under constraints.</p></td></tr><tr><td><code>scope</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>Scope is the scope of the Quota object, either &lsquo;project&rsquo; or &lsquo;secret&rsquo;. This field is immutable.</p></td></tr></table></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SecretBinding>SecretBinding</h3><p><p>SecretBinding represents a binding to a secret in the same or another namespace.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>SecretBinding</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret object in the same or another namespace.
This field is immutable.</p></td></tr><tr><td><code>quotas</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>[]Kubernetes core/v1.ObjectReference</a></em></td><td><em>(Optional)</em><p>Quotas is a list of references to Quota objects in the same or another namespace.
This field is immutable.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.SecretBindingProvider>SecretBindingProvider</a></em></td><td><em>(Optional)</em><p>Provider defines the provider type of the SecretBinding.
This field is immutable when the SecretBindingProviderValidation feature gate is enabled.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Seed>Seed</h3><p><p>Seed represents an installation request for an external controller.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Seed</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a></em></td><td><p>Spec contains the specification of this installation.</p><br><br><table><tr><td><code>backup</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedBackup>SeedBackup</a></em></td><td><em>(Optional)</em><p>Backup holds the object store configuration for the backups of shoot (currently only etcd).
If it is not specified, then there won&rsquo;t be any backups taken for shoots associated with this seed.
If backup field is present in seed, then backups of the etcd from shoot control plane will be stored
under the configured object store.</p></td></tr><tr><td><code>dns</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedDNS>SeedDNS</a></em></td><td><p>DNS contains DNS-relevant information about this seed cluster.</p></td></tr><tr><td><code>networks</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedNetworks>SeedNetworks</a></em></td><td><p>Networks defines the pod, service and worker network of the Seed cluster.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedProvider>SeedProvider</a></em></td><td><p>Provider defines the provider type and region for this Seed cluster.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><em>(Optional)</em><p>SecretRef is a reference to a Secret object containing the Kubeconfig of the Kubernetes
cluster to be registered as Seed.</p></td></tr><tr><td><code>taints</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedTaint>[]SeedTaint</a></em></td><td><em>(Optional)</em><p>Taints describes taints on the seed.</p></td></tr><tr><td><code>volume</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedVolume>SeedVolume</a></em></td><td><em>(Optional)</em><p>Volume contains settings for persistentvolumes created in the seed cluster.</p></td></tr><tr><td><code>settings</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a></em></td><td><em>(Optional)</em><p>Settings contains certain settings for this seed cluster.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#core.gardener.cloud/v1beta1.Ingress>Ingress</a></em></td><td><em>(Optional)</em><p>Ingress configures Ingress specific settings of the Seed cluster. This field is immutable.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedStatus>SeedStatus</a></em></td><td><p>Status contains the status of this installation.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Shoot>Shoot</h3><p><p>Shoot represents a Shoot cluster created and managed by Gardener.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>core.gardener.cloud/v1beta1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Shoot</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a></em></td><td><em>(Optional)</em><p>Specification of the Shoot cluster.
If the object&rsquo;s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>addons</code></br><em><a href=#core.gardener.cloud/v1beta1.Addons>Addons</a></em></td><td><em>(Optional)</em><p>Addons contains information about enabled/disabled addons and their configuration.</p></td></tr><tr><td><code>cloudProfileName</code></br><em>string</em></td><td><p>CloudProfileName is a name of a CloudProfile object. This field is immutable.</p></td></tr><tr><td><code>dns</code></br><em><a href=#core.gardener.cloud/v1beta1.DNS>DNS</a></em></td><td><em>(Optional)</em><p>DNS contains information about the DNS settings of the Shoot.</p></td></tr><tr><td><code>extensions</code></br><em><a href=#core.gardener.cloud/v1beta1.Extension>[]Extension</a></em></td><td><em>(Optional)</em><p>Extensions contain type and provider information for Shoot extensions.</p></td></tr><tr><td><code>hibernation</code></br><em><a href=#core.gardener.cloud/v1beta1.Hibernation>Hibernation</a></em></td><td><em>(Optional)</em><p>Hibernation contains information whether the Shoot is suspended or not.</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a></em></td><td><p>Kubernetes contains the version and configuration settings of the control plane components.</p></td></tr><tr><td><code>networking</code></br><em><a href=#core.gardener.cloud/v1beta1.Networking>Networking</a></em></td><td><p>Networking contains information about cluster networking such as CNI Plugin type, CIDRs, &mldr;etc.</p></td></tr><tr><td><code>maintenance</code></br><em><a href=#core.gardener.cloud/v1beta1.Maintenance>Maintenance</a></em></td><td><em>(Optional)</em><p>Maintenance contains information about the time window for maintenance operations and which
operations should be performed.</p></td></tr><tr><td><code>monitoring</code></br><em><a href=#core.gardener.cloud/v1beta1.Monitoring>Monitoring</a></em></td><td><em>(Optional)</em><p>Monitoring contains information about custom monitoring configurations for the shoot.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.Provider>Provider</a></em></td><td><p>Provider contains all provider-specific and provider-relevant information.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootPurpose>ShootPurpose</a></em></td><td><em>(Optional)</em><p>Purpose is the purpose class for this cluster.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is a name of a region. This field is immutable.</p></td></tr><tr><td><code>secretBindingName</code></br><em>string</em></td><td><p>SecretBindingName is the name of the a SecretBinding that has a reference to the provider secret.
The credentials inside the provider secret will be used to create the shoot in the respective account.
This field is immutable.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed cluster that runs the control plane of the Shoot.
This field is immutable when the SeedChange feature gate is disabled.</p></td></tr><tr><td><code>seedSelector</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSelector>SeedSelector</a></em></td><td><em>(Optional)</em><p>SeedSelector is an optional selector which must match a seed&rsquo;s labels for the shoot to be scheduled on that seed.</p></td></tr><tr><td><code>resources</code></br><em><a href=#core.gardener.cloud/v1beta1.NamedResourceReference>[]NamedResourceReference</a></em></td><td><em>(Optional)</em><p>Resources holds a list of named resource references that can be referred to in extension configs by their names.</p></td></tr><tr><td><code>tolerations</code></br><em><a href=#core.gardener.cloud/v1beta1.Toleration>[]Toleration</a></em></td><td><em>(Optional)</em><p>Tolerations contains the tolerations for taints on seed clusters.</p></td></tr><tr><td><code>exposureClassName</code></br><em>string</em></td><td><em>(Optional)</em><p>ExposureClassName is the optional name of an exposure class to apply a control plane endpoint exposure strategy.
This field is immutable.</p></td></tr><tr><td><code>systemComponents</code></br><em><a href=#core.gardener.cloud/v1beta1.SystemComponents>SystemComponents</a></em></td><td><em>(Optional)</em><p>SystemComponents contains the settings of system components in the control or data plane of the Shoot cluster.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a></em></td><td><em>(Optional)</em><p>Most recently observed status of the Shoot cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Addon>Addon</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubernetesDashboard>KubernetesDashboard</a>,
<a href=#core.gardener.cloud/v1beta1.NginxIngress>NginxIngress</a>)</p><p><p>Addon allows enabling or disabling a specific addon and is used to derive from.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled indicates whether the addon is enabled or not.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Addons>Addons</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Addons is a collection of configuration for specific addons which are managed by the Gardener.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>kubernetesDashboard</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesDashboard>KubernetesDashboard</a></em></td><td><em>(Optional)</em><p>KubernetesDashboard holds configuration settings for the kubernetes dashboard addon.</p></td></tr><tr><td><code>nginxIngress</code></br><em><a href=#core.gardener.cloud/v1beta1.NginxIngress>NginxIngress</a></em></td><td><em>(Optional)</em><p>NginxIngress holds configuration settings for the nginx-ingress addon.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.AdmissionPlugin>AdmissionPlugin</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>)</p><p><p>AdmissionPlugin contains information about a specific admission plugin and its corresponding configuration.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the plugin.</p></td></tr><tr><td><code>config</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>Config is the configuration of the plugin.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Alerting>Alerting</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Monitoring>Monitoring</a>)</p><p><p>Alerting contains information about how alerting will be done (i.e. who will receive alerts and how).</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>emailReceivers</code></br><em>[]string</em></td><td><em>(Optional)</em><p>MonitoringEmailReceivers is a list of recipients for alerts</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.AuditConfig>AuditConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>)</p><p><p>AuditConfig contains settings for audit of the api server</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>auditPolicy</code></br><em><a href=#core.gardener.cloud/v1beta1.AuditPolicy>AuditPolicy</a></em></td><td><em>(Optional)</em><p>AuditPolicy contains configuration settings for audit policy of the kube-apiserver.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.AuditPolicy>AuditPolicy</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.AuditConfig>AuditConfig</a>)</p><p><p>AuditPolicy contains audit policy for kube-apiserver</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>configMapRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><em>(Optional)</em><p>ConfigMapRef is a reference to a ConfigMap object in the same namespace,
which contains the audit policy for the kube-apiserver.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.AvailabilityZone>AvailabilityZone</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Region>Region</a>)</p><p><p>AvailabilityZone is an availability zone.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is an an availability zone name.</p></td></tr><tr><td><code>unavailableMachineTypes</code></br><em>[]string</em></td><td><em>(Optional)</em><p>UnavailableMachineTypes is a list of machine type names that are not availability in this zone.</p></td></tr><tr><td><code>unavailableVolumeTypes</code></br><em>[]string</em></td><td><em>(Optional)</em><p>UnavailableVolumeTypes is a list of volume type names that are not availability in this zone.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.BackupBucketProvider>BackupBucketProvider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupBucketSpec>BackupBucketSpec</a>)</p><p><p>BackupBucketProvider holds the details of cloud provider of the object store.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the type of provider.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of the bucket.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.BackupBucketSpec>BackupBucketSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupBucket>BackupBucket</a>)</p><p><p>BackupBucketSpec is the specification of a Backup Bucket.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.BackupBucketProvider>BackupBucketProvider</a></em></td><td><p>Provider holds the details of cloud provider of the object store. This field is immutable.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to BackupBucket resource.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the credentials to access object store.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName holds the name of the seed allocated to BackupBucket for running controller.
This field is immutable.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.BackupBucketStatus>BackupBucketStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupBucket>BackupBucket</a>)</p><p><p>BackupBucketStatus holds the most recently observed status of the Backup Bucket.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>providerStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderStatus is the configuration passed to BackupBucket resource.</p></td></tr><tr><td><code>lastOperation</code></br><em><a href=#core.gardener.cloud/v1beta1.LastOperation>LastOperation</a></em></td><td><em>(Optional)</em><p>LastOperation holds information about the last operation on the BackupBucket.</p></td></tr><tr><td><code>lastError</code></br><em><a href=#core.gardener.cloud/v1beta1.LastError>LastError</a></em></td><td><em>(Optional)</em><p>LastError holds information about the last occurred error during an operation.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this BackupBucket. It corresponds to the
BackupBucket&rsquo;s generation, which is updated on mutation by the API Server.</p></td></tr><tr><td><code>generatedSecretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><em>(Optional)</em><p>GeneratedSecretRef is reference to the secret generated by backup bucket, which
will have object store specific credentials.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.BackupEntrySpec>BackupEntrySpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupEntry>BackupEntry</a>)</p><p><p>BackupEntrySpec is the specification of a Backup Entry.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>bucketName</code></br><em>string</em></td><td><p>BucketName is the name of backup bucket for this Backup Entry.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName holds the name of the seed to which this BackupEntry is scheduled</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.BackupEntryStatus>BackupEntryStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupEntry>BackupEntry</a>)</p><p><p>BackupEntryStatus holds the most recently observed status of the Backup Entry.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>lastOperation</code></br><em><a href=#core.gardener.cloud/v1beta1.LastOperation>LastOperation</a></em></td><td><em>(Optional)</em><p>LastOperation holds information about the last operation on the BackupEntry.</p></td></tr><tr><td><code>lastError</code></br><em><a href=#core.gardener.cloud/v1beta1.LastError>LastError</a></em></td><td><em>(Optional)</em><p>LastError holds information about the last occurred error during an operation.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this BackupEntry. It corresponds to the
BackupEntry&rsquo;s generation, which is updated on mutation by the API Server.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed to which this BackupEntry is currently scheduled. This field is populated
at the beginning of a create/reconcile operation. It is used when moving the BackupEntry between seeds.</p></td></tr><tr><td><code>migrationStartTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>MigrationStartTime is the time when a migration to a different seed was initiated.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CRI>CRI</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.MachineImageVersion>MachineImageVersion</a>,
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>CRI contains information about the Container Runtimes.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em><a href=#core.gardener.cloud/v1beta1.CRIName>CRIName</a></em></td><td><p>The name of the CRI library. Supported values are <code>docker</code> and <code>containerd</code>.</p></td></tr><tr><td><code>containerRuntimes</code></br><em><a href=#core.gardener.cloud/v1beta1.ContainerRuntime>[]ContainerRuntime</a></em></td><td><em>(Optional)</em><p>ContainerRuntimes is the list of the required container runtimes supported for a worker pool.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CRIName>CRIName
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CRI>CRI</a>)</p><p><p>CRIName is a type alias for the CRI name string.</p></p><h3 id=core.gardener.cloud/v1beta1.CloudInfo>CloudInfo</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ClusterInfo>ClusterInfo</a>)</p><p><p>CloudInfo contains information about the cloud</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the cloud type</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the cloud region</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfile>CloudProfile</a>)</p><p><p>CloudProfileSpec is the specification of a CloudProfile.
It must contain exactly one of its defined keys.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>caBundle</code></br><em>string</em></td><td><em>(Optional)</em><p>CABundle is a certificate bundle which will be installed onto every host machine of shoot cluster targeting this profile.</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesSettings>KubernetesSettings</a></em></td><td><p>Kubernetes contains constraints regarding allowed values of the &lsquo;kubernetes&rsquo; block in the Shoot specification.</p></td></tr><tr><td><code>machineImages</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineImage>[]MachineImage</a></em></td><td><p>MachineImages contains constraints regarding allowed values for machine images in the Shoot specification.</p></td></tr><tr><td><code>machineTypes</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineType>[]MachineType</a></em></td><td><p>MachineTypes contains constraints regarding allowed values for machine types in the &lsquo;workers&rsquo; block in the Shoot specification.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig contains provider-specific configuration for the profile.</p></td></tr><tr><td><code>regions</code></br><em><a href=#core.gardener.cloud/v1beta1.Region>[]Region</a></em></td><td><p>Regions contains constraints regarding allowed values for regions and zones.</p></td></tr><tr><td><code>seedSelector</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSelector>SeedSelector</a></em></td><td><em>(Optional)</em><p>SeedSelector contains an optional list of labels on <code>Seed</code> resources that marks those seeds whose shoots may use this provider profile.
An empty list means that all seeds of the same provider type are supported.
This is useful for environments that are of the same type (like openstack) but may have different &ldquo;instances&rdquo;/landscapes.
Optionally a list of possible providers can be added to enable cross-provider scheduling. By default, the provider
type of the seed must match the shoot&rsquo;s provider.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the name of the provider.</p></td></tr><tr><td><code>volumeTypes</code></br><em><a href=#core.gardener.cloud/v1beta1.VolumeType>[]VolumeType</a></em></td><td><em>(Optional)</em><p>VolumeTypes contains constraints regarding allowed values for volume types in the &lsquo;workers&rsquo; block in the Shoot specification.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ClusterAutoscaler>ClusterAutoscaler</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>)</p><p><p>ClusterAutoscaler contains the configuration flags for the Kubernetes cluster autoscaler.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>scaleDownDelayAfterAdd</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ScaleDownDelayAfterAdd defines how long after scale up that scale down evaluation resumes (default: 1 hour).</p></td></tr><tr><td><code>scaleDownDelayAfterDelete</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ScaleDownDelayAfterDelete how long after node deletion that scale down evaluation resumes, defaults to scanInterval (default: 0 secs).</p></td></tr><tr><td><code>scaleDownDelayAfterFailure</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ScaleDownDelayAfterFailure how long after scale down failure that scale down evaluation resumes (default: 3 mins).</p></td></tr><tr><td><code>scaleDownUnneededTime</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ScaleDownUnneededTime defines how long a node should be unneeded before it is eligible for scale down (default: 30 mins).</p></td></tr><tr><td><code>scaleDownUtilizationThreshold</code></br><em>float64</em></td><td><em>(Optional)</em><p>ScaleDownUtilizationThreshold defines the threshold in fraction (0.0 - 1.0) under which a node is being removed (default: 0.5).</p></td></tr><tr><td><code>scanInterval</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ScanInterval how often cluster is reevaluated for scale up or down (default: 10 secs).</p></td></tr><tr><td><code>expander</code></br><em><a href=#core.gardener.cloud/v1beta1.ExpanderMode>ExpanderMode</a></em></td><td><em>(Optional)</em><p>Expander defines the algorithm to use during scale up (default: least-waste).
See: <a href=https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md#what-are-expanders>https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md#what-are-expanders</a>.</p></td></tr><tr><td><code>maxNodeProvisionTime</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>MaxNodeProvisionTime defines how long CA waits for node to be provisioned (default: 20 mins).</p></td></tr><tr><td><code>maxGracefulTerminationSeconds</code></br><em>int32</em></td><td><em>(Optional)</em><p>MaxGracefulTerminationSeconds is the number of seconds CA waits for pod termination when trying to scale down a node (default: 600).</p></td></tr><tr><td><code>ignoreTaints</code></br><em>[]string</em></td><td><em>(Optional)</em><p>IgnoreTaints specifies a list of taint keys to ignore in node templates when considering to scale a node group.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ClusterInfo>ClusterInfo</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.PlantStatus>PlantStatus</a>)</p><p><p>ClusterInfo contains information about the Plant cluster</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>cloud</code></br><em><a href=#core.gardener.cloud/v1beta1.CloudInfo>CloudInfo</a></em></td><td><p>Cloud describes the cloud information</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesInfo>KubernetesInfo</a></em></td><td><p>Kubernetes describes kubernetes meta information (e.g., version)</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Condition>Condition</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerInstallationStatus>ControllerInstallationStatus</a>,
<a href=#core.gardener.cloud/v1beta1.PlantStatus>PlantStatus</a>,
<a href=#core.gardener.cloud/v1beta1.SeedStatus>SeedStatus</a>,
<a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a>)</p><p><p>Condition holds the information about the state of a resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em><a href=#core.gardener.cloud/v1beta1.ConditionType>ConditionType</a></em></td><td><p>Type of the condition.</p></td></tr><tr><td><code>status</code></br><em><a href=#core.gardener.cloud/v1beta1.ConditionStatus>ConditionStatus</a></em></td><td><p>Status of the condition, one of True, False, Unknown.</p></td></tr><tr><td><code>lastTransitionTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><p>Last time the condition transitioned from one status to another.</p></td></tr><tr><td><code>lastUpdateTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><p>Last time the condition was updated.</p></td></tr><tr><td><code>reason</code></br><em>string</em></td><td><p>The reason for the condition&rsquo;s last transition.</p></td></tr><tr><td><code>message</code></br><em>string</em></td><td><p>A human readable message indicating details about the transition.</p></td></tr><tr><td><code>codes</code></br><em><a href=#core.gardener.cloud/v1beta1.ErrorCode>[]ErrorCode</a></em></td><td><em>(Optional)</em><p>Well-defined error codes in case the condition reports a problem.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ConditionStatus>ConditionStatus
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Condition>Condition</a>)</p><p><p>ConditionStatus is the status of a condition.</p></p><h3 id=core.gardener.cloud/v1beta1.ConditionType>ConditionType
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Condition>Condition</a>)</p><p><p>ConditionType is a string alias.</p></p><h3 id=core.gardener.cloud/v1beta1.ContainerRuntime>ContainerRuntime</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CRI>CRI</a>)</p><p><p>ContainerRuntime contains information about worker&rsquo;s available container runtime</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the type of the Container Runtime.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to container runtime resource.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerDeploymentPolicy>ControllerDeploymentPolicy
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerRegistrationDeployment>ControllerRegistrationDeployment</a>)</p><p><p>ControllerDeploymentPolicy is a string alias.</p></p><h3 id=core.gardener.cloud/v1beta1.ControllerInstallationSpec>ControllerInstallationSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerInstallation>ControllerInstallation</a>)</p><p><p>ControllerInstallationSpec is the specification of a ControllerInstallation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>registrationRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>RegistrationRef is used to reference a ControllerRegistration resource.
The name field of the RegistrationRef is immutable.</p></td></tr><tr><td><code>seedRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>SeedRef is used to reference a Seed resource. The name field of the SeedRef is immutable.</p></td></tr><tr><td><code>deploymentRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><em>(Optional)</em><p>DeploymentRef is used to reference a ControllerDeployment resource.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerInstallationStatus>ControllerInstallationStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerInstallation>ControllerInstallation</a>)</p><p><p>ControllerInstallationStatus is the status of a ControllerInstallation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>conditions</code></br><em><a href=#core.gardener.cloud/v1beta1.Condition>[]Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a ControllerInstallations&rsquo;s current state.</p></td></tr><tr><td><code>providerStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderStatus contains type-specific status.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerRegistrationDeployment>ControllerRegistrationDeployment</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerRegistrationSpec>ControllerRegistrationSpec</a>)</p><p><p>ControllerRegistrationDeployment contains information for how this controller is deployed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>policy</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerDeploymentPolicy>ControllerDeploymentPolicy</a></em></td><td><em>(Optional)</em><p>Policy controls how the controller is deployed. It defaults to &lsquo;OnDemand&rsquo;.</p></td></tr><tr><td><code>seedSelector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><em>(Optional)</em><p>SeedSelector contains an optional label selector for seeds. Only if the labels match then this controller will be
considered for a deployment.
An empty list means that all seeds are selected.</p></td></tr><tr><td><code>deploymentRefs</code></br><em><a href=#core.gardener.cloud/v1beta1.DeploymentRef>[]DeploymentRef</a></em></td><td><em>(Optional)</em><p>DeploymentRefs holds references to <code>ControllerDeployments</code>. Only one element is support now.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerRegistrationSpec>ControllerRegistrationSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerRegistration>ControllerRegistration</a>)</p><p><p>ControllerRegistrationSpec is the specification of a ControllerRegistration.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>resources</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerResource>[]ControllerResource</a></em></td><td><em>(Optional)</em><p>Resources is a list of combinations of kinds (DNSProvider, Infrastructure, Generic, &mldr;) and their actual types
(aws-route53, gcp, auditlog, &mldr;).</p></td></tr><tr><td><code>deployment</code></br><em><a href=#core.gardener.cloud/v1beta1.ControllerRegistrationDeployment>ControllerRegistrationDeployment</a></em></td><td><em>(Optional)</em><p>Deployment contains information for how this controller is deployed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ControllerResource>ControllerResource</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerRegistrationSpec>ControllerRegistrationSpec</a>)</p><p><p>ControllerResource is a combination of a kind (DNSProvider, Infrastructure, Generic, &mldr;) and the actual type for this
kind (aws-route53, gcp, auditlog, &mldr;).</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>kind</code></br><em>string</em></td><td><p>Kind is the resource kind, for example &ldquo;OperatingSystemConfig&rdquo;.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the resource type, for example &ldquo;coreos&rdquo; or &ldquo;ubuntu&rdquo;.</p></td></tr><tr><td><code>globallyEnabled</code></br><em>bool</em></td><td><em>(Optional)</em><p>GloballyEnabled determines if this ControllerResource is required by all Shoot clusters.</p></td></tr><tr><td><code>reconcileTimeout</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ReconcileTimeout defines how long Gardener should wait for the resource reconciliation.</p></td></tr><tr><td><code>primary</code></br><em>bool</em></td><td><em>(Optional)</em><p>Primary determines if the controller backed by this ControllerRegistration is responsible for the extension
resource&rsquo;s lifecycle. This field defaults to true. There must be exactly one primary controller for this kind/type
combination. This field is immutable.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CoreDNS>CoreDNS</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SystemComponents>SystemComponents</a>)</p><p><p>CoreDNS contains the settings of the Core DNS components running in the data plane of the Shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>autoscaling</code></br><em><a href=#core.gardener.cloud/v1beta1.CoreDNSAutoscaling>CoreDNSAutoscaling</a></em></td><td><p>Autoscaling contains the settings related to autoscaling of the Core DNS components running in the data plane of the Shoot cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CoreDNSAutoscaling>CoreDNSAutoscaling</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CoreDNS>CoreDNS</a>)</p><p><p>CoreDNSAutoscaling contains the settings related to autoscaling of the Core DNS components running in the data plane of the Shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>mode</code></br><em><a href=#core.gardener.cloud/v1beta1.CoreDNSAutoscalingMode>CoreDNSAutoscalingMode</a></em></td><td><p>The mode of the autoscaling to be used for the Core DNS components running in the data plane of the Shoot cluster.
Supported values are <code>horizontal</code> and <code>cluster-proportional</code>.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.CoreDNSAutoscalingMode>CoreDNSAutoscalingMode
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CoreDNSAutoscaling>CoreDNSAutoscaling</a>)</p><p><p>CoreDNSAutoscalingMode is a type alias for the Core DNS autoscaling mode string.</p></p><h3 id=core.gardener.cloud/v1beta1.DNS>DNS</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>DNS holds information about the provider, the hosted zone id and the domain.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>domain</code></br><em>string</em></td><td><em>(Optional)</em><p>Domain is the external available domain of the Shoot cluster. This domain will be written into the
kubeconfig that is handed out to end-users. This field is immutable.</p></td></tr><tr><td><code>providers</code></br><em><a href=#core.gardener.cloud/v1beta1.DNSProvider>[]DNSProvider</a></em></td><td><em>(Optional)</em><p>Providers is a list of DNS providers that shall be enabled for this shoot cluster. Only relevant if
not a default domain is used.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.DNSIncludeExclude>DNSIncludeExclude</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.DNSProvider>DNSProvider</a>,
<a href=#core.gardener.cloud/v1beta1.SeedDNSProvider>SeedDNSProvider</a>)</p><p><p>DNSIncludeExclude contains information about which domains shall be included/excluded.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>include</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Include is a list of domains that shall be included.</p></td></tr><tr><td><code>exclude</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Exclude is a list of domains that shall be excluded.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.DNSProvider>DNSProvider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.DNS>DNS</a>)</p><p><p>DNSProvider contains information about a DNS provider.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>domains</code></br><em><a href=#core.gardener.cloud/v1beta1.DNSIncludeExclude>DNSIncludeExclude</a></em></td><td><em>(Optional)</em><p>Domains contains information about which domains shall be included/excluded for this provider.</p></td></tr><tr><td><code>primary</code></br><em>bool</em></td><td><em>(Optional)</em><p>Primary indicates that this DNSProvider is used for shoot related domains.</p></td></tr><tr><td><code>secretName</code></br><em>string</em></td><td><em>(Optional)</em><p>SecretName is a name of a secret containing credentials for the stated domain and the
provider. When not specified, the Gardener will use the cloud provider credentials referenced
by the Shoot and try to find respective credentials there (primary provider only). Specifying this field may override
this behavior, i.e. forcing the Gardener to only look into the given secret.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><em>(Optional)</em><p>Type is the DNS provider type.</p></td></tr><tr><td><code>zones</code></br><em><a href=#core.gardener.cloud/v1beta1.DNSIncludeExclude>DNSIncludeExclude</a></em></td><td><em>(Optional)</em><p>Zones contains information about which hosted zones shall be included/excluded for this provider.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.DataVolume>DataVolume</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>DataVolume contains information about a data volume.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name of the volume to make it referencable.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><em>(Optional)</em><p>Type is the type of the volume.</p></td></tr><tr><td><code>size</code></br><em>string</em></td><td><p>VolumeSize is the size of the volume.</p></td></tr><tr><td><code>encrypted</code></br><em>bool</em></td><td><em>(Optional)</em><p>Encrypted determines if the volume should be encrypted.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.DeploymentRef>DeploymentRef</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ControllerRegistrationDeployment>ControllerRegistrationDeployment</a>)</p><p><p>DeploymentRef contains information about <code>ControllerDeployment</code> references.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the <code>ControllerDeployment</code> that is being referred to.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Endpoint>Endpoint</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.PlantSpec>PlantSpec</a>)</p><p><p>Endpoint is an endpoint for monitoring, logging and other services around the plant.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the endpoint</p></td></tr><tr><td><code>url</code></br><em>string</em></td><td><p>URL is the url of the endpoint</p></td></tr><tr><td><code>purpose</code></br><em>string</em></td><td><p>Purpose is the purpose of the endpoint</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ErrorCode>ErrorCode
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Condition>Condition</a>,
<a href=#core.gardener.cloud/v1beta1.LastError>LastError</a>)</p><p><p>ErrorCode is a string alias.</p></p><h3 id=core.gardener.cloud/v1beta1.ExpanderMode>ExpanderMode
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ClusterAutoscaler>ClusterAutoscaler</a>)</p><p><p>ExpanderMode is type used for Expander values</p></p><h3 id=core.gardener.cloud/v1beta1.ExpirableVersion>ExpirableVersion</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubernetesSettings>KubernetesSettings</a>,
<a href=#core.gardener.cloud/v1beta1.MachineImageVersion>MachineImageVersion</a>)</p><p><p>ExpirableVersion contains a version and an expiration date.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the version identifier.</p></td></tr><tr><td><code>expirationDate</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>ExpirationDate defines the time at which this version expires.</p></td></tr><tr><td><code>classification</code></br><em><a href=#core.gardener.cloud/v1beta1.VersionClassification>VersionClassification</a></em></td><td><em>(Optional)</em><p>Classification defines the state of a version (preview, supported, deprecated)</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Extension>Extension</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Extension contains type and provider information for Shoot extensions.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the type of the extension resource.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to extension resource.</p></td></tr><tr><td><code>disabled</code></br><em>bool</em></td><td><em>(Optional)</em><p>Disabled allows to disable extensions that were marked as &lsquo;globally enabled&rsquo; by Gardener administrators.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Gardener>Gardener</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedStatus>SeedStatus</a>,
<a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a>)</p><p><p>Gardener holds the information about the Gardener version that operated a resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>id</code></br><em>string</em></td><td><p>ID is the Docker container id of the Gardener which last acted on a resource.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the hostname (pod name) of the Gardener which last acted on a resource.</p></td></tr><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the version of the Gardener which last acted on a resource.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Hibernation>Hibernation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Hibernation contains information whether the Shoot is suspended or not.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><em>(Optional)</em><p>Enabled specifies whether the Shoot needs to be hibernated or not. If it is true, the Shoot&rsquo;s desired state is to be hibernated.
If it is false or nil, the Shoot&rsquo;s desired state is to be awaken.</p></td></tr><tr><td><code>schedules</code></br><em><a href=#core.gardener.cloud/v1beta1.HibernationSchedule>[]HibernationSchedule</a></em></td><td><em>(Optional)</em><p>Schedules determine the hibernation schedules.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.HibernationSchedule>HibernationSchedule</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Hibernation>Hibernation</a>)</p><p><p>HibernationSchedule determines the hibernation schedule of a Shoot.
A Shoot will be regularly hibernated at each start time and will be woken up at each end time.
Start or End can be omitted, though at least one of each has to be specified.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>start</code></br><em>string</em></td><td><em>(Optional)</em><p>Start is a Cron spec at which time a Shoot will be hibernated.</p></td></tr><tr><td><code>end</code></br><em>string</em></td><td><em>(Optional)</em><p>End is a Cron spec at which time a Shoot will be woken up.</p></td></tr><tr><td><code>location</code></br><em>string</em></td><td><em>(Optional)</em><p>Location is the time location in which both start and and shall be evaluated.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.HorizontalPodAutoscalerConfig>HorizontalPodAutoscalerConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeControllerManagerConfig>KubeControllerManagerConfig</a>)</p><p><p>HorizontalPodAutoscalerConfig contains horizontal pod autoscaler configuration settings for the kube-controller-manager.
Note: Descriptions were taken from the Kubernetes documentation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>cpuInitializationPeriod</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>The period after which a ready pod transition is considered to be the first.</p></td></tr><tr><td><code>downscaleStabilization</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>The configurable window at which the controller will choose the highest recommendation for autoscaling.</p></td></tr><tr><td><code>initialReadinessDelay</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>The configurable period at which the horizontal pod autoscaler considers a Pod “not yet ready” given that it’s unready and it has transitioned to unready during that time.</p></td></tr><tr><td><code>syncPeriod</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>The period for syncing the number of pods in horizontal pod autoscaler.</p></td></tr><tr><td><code>tolerance</code></br><em>float64</em></td><td><em>(Optional)</em><p>The minimum change (from 1.0) in the desired-to-actual metrics ratio for the horizontal pod autoscaler to consider scaling.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Ingress>Ingress</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>Ingress configures the Ingress specific settings of the Seed cluster</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>domain</code></br><em>string</em></td><td><p>Domain specifies the IngressDomain of the Seed cluster pointing to the ingress controller endpoint. It will be used
to construct ingress URLs for system applications running in Shoot clusters. Once set this field is immutable.</p></td></tr><tr><td><code>controller</code></br><em><a href=#core.gardener.cloud/v1beta1.IngressController>IngressController</a></em></td><td><p>Controller configures a Gardener managed Ingress Controller listening on the ingressDomain</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.IngressController>IngressController</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Ingress>Ingress</a>)</p><p><p>IngressController enables a Gardener managed Ingress Controller listening on the ingressDomain</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>kind</code></br><em>string</em></td><td><p>Kind defines which kind of IngressController to use, for example <code>nginx</code></p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig specifies infrastructure specific configuration for the ingressController</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>)</p><p><p>KubeAPIServerConfig contains configuration settings for the kube-apiserver.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>KubernetesConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesConfig>KubernetesConfig</a></em></td><td><p>(Members of <code>KubernetesConfig</code> are embedded into this type.)</p></td></tr><tr><td><code>admissionPlugins</code></br><em><a href=#core.gardener.cloud/v1beta1.AdmissionPlugin>[]AdmissionPlugin</a></em></td><td><em>(Optional)</em><p>AdmissionPlugins contains the list of user-defined admission plugins (additional to those managed by Gardener), and, if desired, the corresponding
configuration.</p></td></tr><tr><td><code>apiAudiences</code></br><em>[]string</em></td><td><em>(Optional)</em><p>APIAudiences are the identifiers of the API. The service account token authenticator will
validate that tokens used against the API are bound to at least one of these audiences.
Defaults to [&ldquo;kubernetes&rdquo;].</p></td></tr><tr><td><code>auditConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.AuditConfig>AuditConfig</a></em></td><td><em>(Optional)</em><p>AuditConfig contains configuration settings for the audit of the kube-apiserver.</p></td></tr><tr><td><code>enableBasicAuthentication</code></br><em>bool</em></td><td><em>(Optional)</em><p>EnableBasicAuthentication defines whether basic authentication should be enabled for this cluster or not.</p></td></tr><tr><td><code>oidcConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.OIDCConfig>OIDCConfig</a></em></td><td><em>(Optional)</em><p>OIDCConfig contains configuration settings for the OIDC provider.</p></td></tr><tr><td><code>runtimeConfig</code></br><em>map[string]bool</em></td><td><em>(Optional)</em><p>RuntimeConfig contains information about enabled or disabled APIs.</p></td></tr><tr><td><code>serviceAccountConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.ServiceAccountConfig>ServiceAccountConfig</a></em></td><td><em>(Optional)</em><p>ServiceAccountConfig contains configuration settings for the service account handling
of the kube-apiserver.</p></td></tr><tr><td><code>watchCacheSizes</code></br><em><a href=#core.gardener.cloud/v1beta1.WatchCacheSizes>WatchCacheSizes</a></em></td><td><em>(Optional)</em><p>WatchCacheSizes contains configuration of the API server&rsquo;s watch cache sizes.
Configuring these flags might be useful for large-scale Shoot clusters with a lot of parallel update requests
and a lot of watching controllers (e.g. large shooted Seed clusters). When the API server&rsquo;s watch cache&rsquo;s
capacity is too small to cope with the amount of update requests and watchers for a particular resource, it
might happen that controller watches are permanently stopped with <code>too old resource version</code> errors.
Starting from kubernetes v1.19, the API server&rsquo;s watch cache size is adapted dynamically and setting the watch
cache size flags will have no effect, except when setting it to 0 (which disables the watch cache).</p></td></tr><tr><td><code>requests</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeAPIServerRequests>KubeAPIServerRequests</a></em></td><td><em>(Optional)</em><p>Requests contains configuration for request-specific settings for the kube-apiserver.</p></td></tr><tr><td><code>enableAnonymousAuthentication</code></br><em>bool</em></td><td><em>(Optional)</em><p>EnableAnonymousAuthentication defines whether anonymous requests to the secure port
of the API server should be allowed (flag <code>--anonymous-auth</code>).
See: <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/</a></p></td></tr><tr><td><code>eventTTL</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>EventTTL controls the amount of time to retain events.
Defaults to 1h.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeAPIServerRequests>KubeAPIServerRequests</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>)</p><p><p>KubeAPIServerRequests contains configuration for request-specific settings for the kube-apiserver.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>maxNonMutatingInflight</code></br><em>int32</em></td><td><em>(Optional)</em><p>MaxNonMutatingInflight is the maximum number of non-mutating requests in flight at a given time. When the server
exceeds this, it rejects requests.</p></td></tr><tr><td><code>maxMutatingInflight</code></br><em>int32</em></td><td><em>(Optional)</em><p>MaxMutatingInflight is the maximum number of mutating requests in flight at a given time. When the server
exceeds this, it rejects requests.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeControllerManagerConfig>KubeControllerManagerConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>)</p><p><p>KubeControllerManagerConfig contains configuration settings for the kube-controller-manager.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>KubernetesConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesConfig>KubernetesConfig</a></em></td><td><p>(Members of <code>KubernetesConfig</code> are embedded into this type.)</p></td></tr><tr><td><code>horizontalPodAutoscaler</code></br><em><a href=#core.gardener.cloud/v1beta1.HorizontalPodAutoscalerConfig>HorizontalPodAutoscalerConfig</a></em></td><td><em>(Optional)</em><p>HorizontalPodAutoscalerConfig contains horizontal pod autoscaler configuration settings for the kube-controller-manager.</p></td></tr><tr><td><code>nodeCIDRMaskSize</code></br><em>int32</em></td><td><em>(Optional)</em><p>NodeCIDRMaskSize defines the mask size for node cidr in cluster (default is 24). This field is immutable.</p></td></tr><tr><td><code>podEvictionTimeout</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>PodEvictionTimeout defines the grace period for deleting pods on failed nodes. Defaults to 2m.</p></td></tr><tr><td><code>nodeMonitorGracePeriod</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>NodeMonitorGracePeriod defines the grace period before an unresponsive node is marked unhealthy.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeProxyConfig>KubeProxyConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>)</p><p><p>KubeProxyConfig contains configuration settings for the kube-proxy.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>KubernetesConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesConfig>KubernetesConfig</a></em></td><td><p>(Members of <code>KubernetesConfig</code> are embedded into this type.)</p></td></tr><tr><td><code>mode</code></br><em><a href=#core.gardener.cloud/v1beta1.ProxyMode>ProxyMode</a></em></td><td><em>(Optional)</em><p>Mode specifies which proxy mode to use.
defaults to IPTables.</p></td></tr><tr><td><code>enabled</code></br><em>bool</em></td><td><em>(Optional)</em><p>Enabled indicates whether kube-proxy should be deployed or not.
Depending on the networking extensions switching kube-proxy off might be rejected. Consulting the respective documentation of the used networking extension is recommended before using this field.
defaults to true if not specified.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeSchedulerConfig>KubeSchedulerConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>)</p><p><p>KubeSchedulerConfig contains configuration settings for the kube-scheduler.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>KubernetesConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesConfig>KubernetesConfig</a></em></td><td><p>(Members of <code>KubernetesConfig</code> are embedded into this type.)</p></td></tr><tr><td><code>kubeMaxPDVols</code></br><em>string</em></td><td><em>(Optional)</em><p>KubeMaxPDVols allows to configure the <code>KUBE_MAX_PD_VOLS</code> environment variable for the kube-scheduler.
Please find more information here: <a href=https://kubernetes.io/docs/concepts/storage/storage-limits/#custom-limits>https://kubernetes.io/docs/concepts/storage/storage-limits/#custom-limits</a>
Note that using this field is considered alpha-/experimental-level and is on your own risk. You should be aware
of all the side-effects and consequences when changing it.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>,
<a href=#core.gardener.cloud/v1beta1.WorkerKubernetes>WorkerKubernetes</a>)</p><p><p>KubeletConfig contains configuration settings for the kubelet.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>KubernetesConfig</code></br><em><a href=#core.gardener.cloud/v1beta1.KubernetesConfig>KubernetesConfig</a></em></td><td><p>(Members of <code>KubernetesConfig</code> are embedded into this type.)</p></td></tr><tr><td><code>cpuCFSQuota</code></br><em>bool</em></td><td><em>(Optional)</em><p>CPUCFSQuota allows you to disable/enable CPU throttling for Pods.</p></td></tr><tr><td><code>cpuManagerPolicy</code></br><em>string</em></td><td><em>(Optional)</em><p>CPUManagerPolicy allows to set alternative CPU management policies (default: none).</p></td></tr><tr><td><code>evictionHard</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfigEviction>KubeletConfigEviction</a></em></td><td><em>(Optional)</em><p>EvictionHard describes a set of eviction thresholds (e.g. memory.available<1Gi) that if met would trigger a Pod eviction.
Default:
memory.available: &ldquo;100Mi/1Gi/5%&rdquo;
nodefs.available: &ldquo;5%&rdquo;
nodefs.inodesFree: &ldquo;5%&rdquo;
imagefs.available: &ldquo;5%&rdquo;
imagefs.inodesFree: &ldquo;5%&rdquo;</p></td></tr><tr><td><code>evictionMaxPodGracePeriod</code></br><em>int32</em></td><td><em>(Optional)</em><p>EvictionMaxPodGracePeriod describes the maximum allowed grace period (in seconds) to use when terminating pods in response to a soft eviction threshold being met.
Default: 90</p></td></tr><tr><td><code>evictionMinimumReclaim</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfigEvictionMinimumReclaim>KubeletConfigEvictionMinimumReclaim</a></em></td><td><em>(Optional)</em><p>EvictionMinimumReclaim configures the amount of resources below the configured eviction threshold that the kubelet attempts to reclaim whenever the kubelet observes resource pressure.
Default: 0 for each resource</p></td></tr><tr><td><code>evictionPressureTransitionPeriod</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>EvictionPressureTransitionPeriod is the duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.
Default: 4m0s</p></td></tr><tr><td><code>evictionSoft</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfigEviction>KubeletConfigEviction</a></em></td><td><em>(Optional)</em><p>EvictionSoft describes a set of eviction thresholds (e.g. memory.available<1.5Gi) that if met over a corresponding grace period would trigger a Pod eviction.
Default:
memory.available: &ldquo;200Mi/1.5Gi/10%&rdquo;
nodefs.available: &ldquo;10%&rdquo;
nodefs.inodesFree: &ldquo;10%&rdquo;
imagefs.available: &ldquo;10%&rdquo;
imagefs.inodesFree: &ldquo;10%&rdquo;</p></td></tr><tr><td><code>evictionSoftGracePeriod</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfigEvictionSoftGracePeriod>KubeletConfigEvictionSoftGracePeriod</a></em></td><td><em>(Optional)</em><p>EvictionSoftGracePeriod describes a set of eviction grace periods (e.g. memory.available=1m30s) that correspond to how long a soft eviction threshold must hold before triggering a Pod eviction.
Default:
memory.available: 1m30s
nodefs.available: 1m30s
nodefs.inodesFree: 1m30s
imagefs.available: 1m30s
imagefs.inodesFree: 1m30s</p></td></tr><tr><td><code>maxPods</code></br><em>int32</em></td><td><em>(Optional)</em><p>MaxPods is the maximum number of Pods that are allowed by the Kubelet.
Default: 110</p></td></tr><tr><td><code>podPidsLimit</code></br><em>int64</em></td><td><em>(Optional)</em><p>PodPIDsLimit is the maximum number of process IDs per pod allowed by the kubelet.</p></td></tr><tr><td><code>imagePullProgressDeadline</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ImagePullProgressDeadline describes the time limit under which if no pulling progress is made, the image pulling will be cancelled.
Default: 1m</p></td></tr><tr><td><code>failSwapOn</code></br><em>bool</em></td><td><em>(Optional)</em><p>FailSwapOn makes the Kubelet fail to start if swap is enabled on the node. (default true).</p></td></tr><tr><td><code>kubeReserved</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfigReserved>KubeletConfigReserved</a></em></td><td><em>(Optional)</em><p>KubeReserved is the configuration for resources reserved for kubernetes node components (mainly kubelet and container runtime).
When updating these values, be aware that cgroup resizes may not succeed on active worker nodes. Look for the NodeAllocatableEnforced event to determine if the configuration was applied.
Default: cpu=80m,memory=1Gi,pid=20k</p></td></tr><tr><td><code>systemReserved</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfigReserved>KubeletConfigReserved</a></em></td><td><em>(Optional)</em><p>SystemReserved is the configuration for resources reserved for system processes not managed by kubernetes (e.g. journald).
When updating these values, be aware that cgroup resizes may not succeed on active worker nodes. Look for the NodeAllocatableEnforced event to determine if the configuration was applied.</p></td></tr><tr><td><code>imageGCHighThresholdPercent</code></br><em>int32</em></td><td><em>(Optional)</em><p>ImageGCHighThresholdPercent describes the percent of the disk usage which triggers image garbage collection.
Default: 50</p></td></tr><tr><td><code>imageGCLowThresholdPercent</code></br><em>int32</em></td><td><em>(Optional)</em><p>ImageGCLowThresholdPercent describes the percent of the disk to which garbage collection attempts to free.
Default: 40</p></td></tr><tr><td><code>serializeImagePulls</code></br><em>bool</em></td><td><em>(Optional)</em><p>SerializeImagePulls describes whether the images are pulled one at a time.
Default: true</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeletConfigEviction>KubeletConfigEviction</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a>)</p><p><p>KubeletConfigEviction contains kubelet eviction thresholds supporting either a resource.Quantity or a percentage based value.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>memoryAvailable</code></br><em>string</em></td><td><em>(Optional)</em><p>MemoryAvailable is the threshold for the free memory on the host server.</p></td></tr><tr><td><code>imageFSAvailable</code></br><em>string</em></td><td><em>(Optional)</em><p>ImageFSAvailable is the threshold for the free disk space in the imagefs filesystem (docker images and container writable layers).</p></td></tr><tr><td><code>imageFSInodesFree</code></br><em>string</em></td><td><em>(Optional)</em><p>ImageFSInodesFree is the threshold for the available inodes in the imagefs filesystem.</p></td></tr><tr><td><code>nodeFSAvailable</code></br><em>string</em></td><td><em>(Optional)</em><p>NodeFSAvailable is the threshold for the free disk space in the nodefs filesystem (docker volumes, logs, etc).</p></td></tr><tr><td><code>nodeFSInodesFree</code></br><em>string</em></td><td><em>(Optional)</em><p>NodeFSInodesFree is the threshold for the available inodes in the nodefs filesystem.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeletConfigEvictionMinimumReclaim>KubeletConfigEvictionMinimumReclaim</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a>)</p><p><p>KubeletConfigEvictionMinimumReclaim contains configuration for the kubelet eviction minimum reclaim.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>memoryAvailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>MemoryAvailable is the threshold for the memory reclaim on the host server.</p></td></tr><tr><td><code>imageFSAvailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>ImageFSAvailable is the threshold for the disk space reclaim in the imagefs filesystem (docker images and container writable layers).</p></td></tr><tr><td><code>imageFSInodesFree</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>ImageFSInodesFree is the threshold for the inodes reclaim in the imagefs filesystem.</p></td></tr><tr><td><code>nodeFSAvailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>NodeFSAvailable is the threshold for the disk space reclaim in the nodefs filesystem (docker volumes, logs, etc).</p></td></tr><tr><td><code>nodeFSInodesFree</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>NodeFSInodesFree is the threshold for the inodes reclaim in the nodefs filesystem.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeletConfigEvictionSoftGracePeriod>KubeletConfigEvictionSoftGracePeriod</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a>)</p><p><p>KubeletConfigEvictionSoftGracePeriod contains grace periods for kubelet eviction thresholds.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>memoryAvailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>MemoryAvailable is the grace period for the MemoryAvailable eviction threshold.</p></td></tr><tr><td><code>imageFSAvailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ImageFSAvailable is the grace period for the ImageFSAvailable eviction threshold.</p></td></tr><tr><td><code>imageFSInodesFree</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>ImageFSInodesFree is the grace period for the ImageFSInodesFree eviction threshold.</p></td></tr><tr><td><code>nodeFSAvailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>NodeFSAvailable is the grace period for the NodeFSAvailable eviction threshold.</p></td></tr><tr><td><code>nodeFSInodesFree</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>NodeFSInodesFree is the grace period for the NodeFSInodesFree eviction threshold.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubeletConfigReserved>KubeletConfigReserved</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a>)</p><p><p>KubeletConfigReserved contains reserved resources for daemons</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>cpu</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>CPU is the reserved cpu.</p></td></tr><tr><td><code>memory</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>Memory is the reserved memory.</p></td></tr><tr><td><code>ephemeralStorage</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>EphemeralStorage is the reserved ephemeral-storage.</p></td></tr><tr><td><code>pid</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>PID is the reserved process-ids.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Kubernetes contains the version and configuration variables for the Shoot control plane.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>allowPrivilegedContainers</code></br><em>bool</em></td><td><em>(Optional)</em><p>AllowPrivilegedContainers indicates whether privileged containers are allowed in the Shoot (default: true).</p></td></tr><tr><td><code>clusterAutoscaler</code></br><em><a href=#core.gardener.cloud/v1beta1.ClusterAutoscaler>ClusterAutoscaler</a></em></td><td><em>(Optional)</em><p>ClusterAutoscaler contains the configuration flags for the Kubernetes cluster autoscaler.</p></td></tr><tr><td><code>kubeAPIServer</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a></em></td><td><em>(Optional)</em><p>KubeAPIServer contains configuration settings for the kube-apiserver.</p></td></tr><tr><td><code>kubeControllerManager</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeControllerManagerConfig>KubeControllerManagerConfig</a></em></td><td><em>(Optional)</em><p>KubeControllerManager contains configuration settings for the kube-controller-manager.</p></td></tr><tr><td><code>kubeScheduler</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeSchedulerConfig>KubeSchedulerConfig</a></em></td><td><em>(Optional)</em><p>KubeScheduler contains configuration settings for the kube-scheduler.</p></td></tr><tr><td><code>kubeProxy</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeProxyConfig>KubeProxyConfig</a></em></td><td><em>(Optional)</em><p>KubeProxy contains configuration settings for the kube-proxy.</p></td></tr><tr><td><code>kubelet</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a></em></td><td><em>(Optional)</em><p>Kubelet contains configuration settings for the kubelet.</p></td></tr><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the semantic Kubernetes version to use for the Shoot cluster.</p></td></tr><tr><td><code>verticalPodAutoscaler</code></br><em><a href=#core.gardener.cloud/v1beta1.VerticalPodAutoscaler>VerticalPodAutoscaler</a></em></td><td><em>(Optional)</em><p>VerticalPodAutoscaler contains the configuration flags for the Kubernetes vertical pod autoscaler.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubernetesConfig>KubernetesConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>,
<a href=#core.gardener.cloud/v1beta1.KubeControllerManagerConfig>KubeControllerManagerConfig</a>,
<a href=#core.gardener.cloud/v1beta1.KubeProxyConfig>KubeProxyConfig</a>,
<a href=#core.gardener.cloud/v1beta1.KubeSchedulerConfig>KubeSchedulerConfig</a>,
<a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a>)</p><p><p>KubernetesConfig contains common configuration fields for the control plane components.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>featureGates</code></br><em>map[string]bool</em></td><td><em>(Optional)</em><p>FeatureGates contains information about enabled feature gates.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubernetesDashboard>KubernetesDashboard</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Addons>Addons</a>)</p><p><p>KubernetesDashboard describes configuration values for the kubernetes-dashboard addon.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>Addon</code></br><em><a href=#core.gardener.cloud/v1beta1.Addon>Addon</a></em></td><td><p>(Members of <code>Addon</code> are embedded into this type.)</p></td></tr><tr><td><code>authenticationMode</code></br><em>string</em></td><td><em>(Optional)</em><p>AuthenticationMode defines the authentication mode for the kubernetes-dashboard.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubernetesInfo>KubernetesInfo</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ClusterInfo>ClusterInfo</a>)</p><p><p>KubernetesInfo contains the version and configuration variables for the Plant cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the semantic Kubernetes version to use for the Plant cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.KubernetesSettings>KubernetesSettings</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a>)</p><p><p>KubernetesSettings contains constraints regarding allowed values of the &lsquo;kubernetes&rsquo; block in the Shoot specification.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>versions</code></br><em><a href=#core.gardener.cloud/v1beta1.ExpirableVersion>[]ExpirableVersion</a></em></td><td><em>(Optional)</em><p>Versions is the list of allowed Kubernetes versions with optional expiration dates for Shoot clusters.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.LastError>LastError</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupBucketStatus>BackupBucketStatus</a>,
<a href=#core.gardener.cloud/v1beta1.BackupEntryStatus>BackupEntryStatus</a>,
<a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a>)</p><p><p>LastError indicates the last occurred error for an operation on a resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>description</code></br><em>string</em></td><td><p>A human readable message indicating details about the last error.</p></td></tr><tr><td><code>taskID</code></br><em>string</em></td><td><em>(Optional)</em><p>ID of the task which caused this last error</p></td></tr><tr><td><code>codes</code></br><em><a href=#core.gardener.cloud/v1beta1.ErrorCode>[]ErrorCode</a></em></td><td><em>(Optional)</em><p>Well-defined error codes of the last error(s).</p></td></tr><tr><td><code>lastUpdateTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>Last time the error was reported</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.LastOperation>LastOperation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.BackupBucketStatus>BackupBucketStatus</a>,
<a href=#core.gardener.cloud/v1beta1.BackupEntryStatus>BackupEntryStatus</a>,
<a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a>)</p><p><p>LastOperation indicates the type and the state of the last operation, along with a description
message and a progress indicator.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>description</code></br><em>string</em></td><td><p>A human readable message indicating details about the last operation.</p></td></tr><tr><td><code>lastUpdateTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><p>Last time the operation state transitioned from one to another.</p></td></tr><tr><td><code>progress</code></br><em>int32</em></td><td><p>The progress in percentage (0-100) of the last operation.</p></td></tr><tr><td><code>state</code></br><em><a href=#core.gardener.cloud/v1beta1.LastOperationState>LastOperationState</a></em></td><td><p>Status of the last operation, one of Aborted, Processing, Succeeded, Error, Failed.</p></td></tr><tr><td><code>type</code></br><em><a href=#core.gardener.cloud/v1beta1.LastOperationType>LastOperationType</a></em></td><td><p>Type of the last operation, one of Create, Reconcile, Delete.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.LastOperationState>LastOperationState
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.LastOperation>LastOperation</a>)</p><p><p>LastOperationState is a string alias.</p></p><h3 id=core.gardener.cloud/v1beta1.LastOperationType>LastOperationType
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.LastOperation>LastOperation</a>)</p><p><p>LastOperationType is a string alias.</p></p><h3 id=core.gardener.cloud/v1beta1.Machine>Machine</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>Machine contains information about the machine type and image.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the machine type of the worker group.</p></td></tr><tr><td><code>image</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootMachineImage>ShootMachineImage</a></em></td><td><em>(Optional)</em><p>Image holds information about the machine image to use for all nodes of this pool. It will default to the
latest version of the first image stated in the referenced CloudProfile if no value has been provided.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MachineControllerManagerSettings>MachineControllerManagerSettings</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>MachineControllerManagerSettings contains configurations for different worker-pools. Eg. MachineDrainTimeout, MachineHealthTimeout.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>machineDrainTimeout</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>MachineDrainTimeout is the period after which machine is forcefully deleted.</p></td></tr><tr><td><code>machineHealthTimeout</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>MachineHealthTimeout is the period after which machine is declared failed.</p></td></tr><tr><td><code>machineCreationTimeout</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>MachineCreationTimeout is the period after which creation of the machine is declared failed.</p></td></tr><tr><td><code>maxEvictRetries</code></br><em>int32</em></td><td><em>(Optional)</em><p>MaxEvictRetries are the number of eviction retries on a pod after which drain is declared failed, and forceful deletion is triggered.</p></td></tr><tr><td><code>nodeConditions</code></br><em>[]string</em></td><td><em>(Optional)</em><p>NodeConditions are the set of conditions if set to true for the period of MachineHealthTimeout, machine will be declared failed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MachineImage>MachineImage</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a>)</p><p><p>MachineImage defines the name and multiple versions of the machine image in any environment.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the image.</p></td></tr><tr><td><code>versions</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineImageVersion>[]MachineImageVersion</a></em></td><td><p>Versions contains versions, expiration dates and container runtimes of the machine image</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MachineImageVersion>MachineImageVersion</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.MachineImage>MachineImage</a>)</p><p><p>MachineImageVersion is an expirable version with list of supported container runtimes and interfaces</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>ExpirableVersion</code></br><em><a href=#core.gardener.cloud/v1beta1.ExpirableVersion>ExpirableVersion</a></em></td><td><p>(Members of <code>ExpirableVersion</code> are embedded into this type.)</p></td></tr><tr><td><code>cri</code></br><em><a href=#core.gardener.cloud/v1beta1.CRI>[]CRI</a></em></td><td><em>(Optional)</em><p>CRI list of supported container runtime and interfaces supported by this version</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MachineType>MachineType</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a>)</p><p><p>MachineType contains certain properties of a machine type.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>cpu</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><p>CPU is the number of CPUs for this machine type.</p></td></tr><tr><td><code>gpu</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><p>GPU is the number of GPUs for this machine type.</p></td></tr><tr><td><code>memory</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><p>Memory is the amount of memory for this machine type.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the machine type.</p></td></tr><tr><td><code>storage</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineTypeStorage>MachineTypeStorage</a></em></td><td><em>(Optional)</em><p>Storage is the amount of storage associated with the root volume of this machine type.</p></td></tr><tr><td><code>usable</code></br><em>bool</em></td><td><em>(Optional)</em><p>Usable defines if the machine type can be used for shoot clusters.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MachineTypeStorage>MachineTypeStorage</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.MachineType>MachineType</a>)</p><p><p>MachineTypeStorage is the amount of storage associated with the root volume of this machine type.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>class</code></br><em>string</em></td><td><p>Class is the class of the storage type.</p></td></tr><tr><td><code>size</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>StorageSize is the storage size.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the type of the storage.</p></td></tr><tr><td><code>minSize</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>MinSize is the minimal supported storage size.
This overrides any other common minimum size configuration from <code>spec.volumeTypes[*].minSize</code>.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Maintenance>Maintenance</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Maintenance contains information about the time window for maintenance operations and which
operations should be performed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>autoUpdate</code></br><em><a href=#core.gardener.cloud/v1beta1.MaintenanceAutoUpdate>MaintenanceAutoUpdate</a></em></td><td><em>(Optional)</em><p>AutoUpdate contains information about which constraints should be automatically updated.</p></td></tr><tr><td><code>timeWindow</code></br><em><a href=#core.gardener.cloud/v1beta1.MaintenanceTimeWindow>MaintenanceTimeWindow</a></em></td><td><em>(Optional)</em><p>TimeWindow contains information about the time window for maintenance operations.</p></td></tr><tr><td><code>confineSpecUpdateRollout</code></br><em>bool</em></td><td><em>(Optional)</em><p>ConfineSpecUpdateRollout prevents that changes/updates to the shoot specification will be rolled out immediately.
Instead, they are rolled out during the shoot&rsquo;s maintenance time window. There is one exception that will trigger
an immediate roll out which is changes to the Spec.Hibernation.Enabled field.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MaintenanceAutoUpdate>MaintenanceAutoUpdate</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Maintenance>Maintenance</a>)</p><p><p>MaintenanceAutoUpdate contains information about which constraints should be automatically updated.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>kubernetesVersion</code></br><em>bool</em></td><td><p>KubernetesVersion indicates whether the patch Kubernetes version may be automatically updated (default: true).</p></td></tr><tr><td><code>machineImageVersion</code></br><em>bool</em></td><td><p>MachineImageVersion indicates whether the machine image version may be automatically updated (default: true).</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.MaintenanceTimeWindow>MaintenanceTimeWindow</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Maintenance>Maintenance</a>)</p><p><p>MaintenanceTimeWindow contains information about the time window for maintenance operations.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>begin</code></br><em>string</em></td><td><p>Begin is the beginning of the time window in the format HHMMSS+ZONE, e.g. &ldquo;220000+0100&rdquo;.
If not present, a random value will be computed.</p></td></tr><tr><td><code>end</code></br><em>string</em></td><td><p>End is the end of the time window in the format HHMMSS+ZONE, e.g. &ldquo;220000+0100&rdquo;.
If not present, the value will be computed based on the &ldquo;Begin&rdquo; value.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Monitoring>Monitoring</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Monitoring contains information about the monitoring configuration for the shoot.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>alerting</code></br><em><a href=#core.gardener.cloud/v1beta1.Alerting>Alerting</a></em></td><td><em>(Optional)</em><p>Alerting contains information about the alerting configuration for the shoot cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.NamedResourceReference>NamedResourceReference</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>NamedResourceReference is a named reference to a resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name of the resource reference.</p></td></tr><tr><td><code>resourceRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#crossversionobjectreference-v1-autoscaling>Kubernetes autoscaling/v1.CrossVersionObjectReference</a></em></td><td><p>ResourceRef is a reference to a resource.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Networking>Networking</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Networking defines networking parameters for the shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type identifies the type of the networking plugin. This field is immutable.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to network resource.</p></td></tr><tr><td><code>pods</code></br><em>string</em></td><td><em>(Optional)</em><p>Pods is the CIDR of the pod network. This field is immutable.</p></td></tr><tr><td><code>nodes</code></br><em>string</em></td><td><em>(Optional)</em><p>Nodes is the CIDR of the entire node network. This field is immutable.</p></td></tr><tr><td><code>services</code></br><em>string</em></td><td><em>(Optional)</em><p>Services is the CIDR of the service network. This field is immutable.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.NginxIngress>NginxIngress</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Addons>Addons</a>)</p><p><p>NginxIngress describes configuration values for the nginx-ingress addon.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>Addon</code></br><em><a href=#core.gardener.cloud/v1beta1.Addon>Addon</a></em></td><td><p>(Members of <code>Addon</code> are embedded into this type.)</p></td></tr><tr><td><code>loadBalancerSourceRanges</code></br><em>[]string</em></td><td><em>(Optional)</em><p>LoadBalancerSourceRanges is list of allowed IP sources for NginxIngress</p></td></tr><tr><td><code>config</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Config contains custom configuration for the nginx-ingress-controller configuration.
See <a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/configmap.md#configuration-options>https://github.com/kubernetes/ingress-nginx/blob/master/docs/user-guide/nginx-configuration/configmap.md#configuration-options</a></p></td></tr><tr><td><code>externalTrafficPolicy</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#serviceexternaltrafficpolicytype-v1-core>Kubernetes core/v1.ServiceExternalTrafficPolicyType</a></em></td><td><em>(Optional)</em><p>ExternalTrafficPolicy controls the <code>.spec.externalTrafficPolicy</code> value of the load balancer <code>Service</code>
exposing the nginx-ingress. Defaults to <code>Cluster</code>.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.OIDCConfig>OIDCConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>)</p><p><p>OIDCConfig contains configuration settings for the OIDC provider.
Note: Descriptions were taken from the Kubernetes documentation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>caBundle</code></br><em>string</em></td><td><em>(Optional)</em><p>If set, the OpenID server&rsquo;s certificate will be verified by one of the authorities in the oidc-ca-file, otherwise the host&rsquo;s root CA set will be used.</p></td></tr><tr><td><code>clientAuthentication</code></br><em><a href=#core.gardener.cloud/v1beta1.OpenIDConnectClientAuthentication>OpenIDConnectClientAuthentication</a></em></td><td><em>(Optional)</em><p>ClientAuthentication can optionally contain client configuration used for kubeconfig generation.</p></td></tr><tr><td><code>clientID</code></br><em>string</em></td><td><em>(Optional)</em><p>The client ID for the OpenID Connect client, must be set if oidc-issuer-url is set.</p></td></tr><tr><td><code>groupsClaim</code></br><em>string</em></td><td><em>(Optional)</em><p>If provided, the name of a custom OpenID Connect claim for specifying user groups. The claim value is expected to be a string or array of strings. This flag is experimental, please see the authentication documentation for further details.</p></td></tr><tr><td><code>groupsPrefix</code></br><em>string</em></td><td><em>(Optional)</em><p>If provided, all groups will be prefixed with this value to prevent conflicts with other authentication strategies.</p></td></tr><tr><td><code>issuerURL</code></br><em>string</em></td><td><em>(Optional)</em><p>The URL of the OpenID issuer, only HTTPS scheme will be accepted. If set, it will be used to verify the OIDC JSON Web Token (JWT).</p></td></tr><tr><td><code>requiredClaims</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>key=value pairs that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value.</p></td></tr><tr><td><code>signingAlgs</code></br><em>[]string</em></td><td><em>(Optional)</em><p>List of allowed JOSE asymmetric signing algorithms. JWTs with a &lsquo;alg&rsquo; header value not in this list will be rejected. Values are defined by RFC 7518 <a href=https://tools.ietf.org/html/rfc7518#section-3.1>https://tools.ietf.org/html/rfc7518#section-3.1</a></p></td></tr><tr><td><code>usernameClaim</code></br><em>string</em></td><td><em>(Optional)</em><p>The OpenID claim to use as the user name. Note that claims other than the default (&lsquo;sub&rsquo;) is not guaranteed to be unique and immutable. This flag is experimental, please see the authentication documentation for further details. (default &ldquo;sub&rdquo;)</p></td></tr><tr><td><code>usernamePrefix</code></br><em>string</em></td><td><em>(Optional)</em><p>If provided, all usernames will be prefixed with this value. If not provided, username claims other than &lsquo;email&rsquo; are prefixed by the issuer URL to avoid clashes. To skip any prefixing, provide the value &lsquo;-&rsquo;.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.OpenIDConnectClientAuthentication>OpenIDConnectClientAuthentication</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.OIDCConfig>OIDCConfig</a>)</p><p><p>OpenIDConnectClientAuthentication contains configuration for OIDC clients.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>extraConfig</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Extra configuration added to kubeconfig&rsquo;s auth-provider.
Must not be any of idp-issuer-url, client-id, client-secret, idp-certificate-authority, idp-certificate-authority-data, id-token or refresh-token</p></td></tr><tr><td><code>secret</code></br><em>string</em></td><td><em>(Optional)</em><p>The client Secret for the OpenID Connect client.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.PlantSpec>PlantSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Plant>Plant</a>)</p><p><p>PlantSpec is the specification of a Plant.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>Kubernetes core/v1.LocalObjectReference</a></em></td><td><p>SecretRef is a reference to a Secret object containing the Kubeconfig of the external kubernetes
clusters to be added to Gardener.</p></td></tr><tr><td><code>endpoints</code></br><em><a href=#core.gardener.cloud/v1beta1.Endpoint>[]Endpoint</a></em></td><td><em>(Optional)</em><p>Endpoints is the configuration plant endpoints</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.PlantStatus>PlantStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Plant>Plant</a>)</p><p><p>PlantStatus is the status of a Plant.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>conditions</code></br><em><a href=#core.gardener.cloud/v1beta1.Condition>[]Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a Plant&rsquo;s current state.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this Plant. It corresponds to the
Plant&rsquo;s generation, which is updated on mutation by the API Server.</p></td></tr><tr><td><code>clusterInfo</code></br><em><a href=#core.gardener.cloud/v1beta1.ClusterInfo>ClusterInfo</a></em></td><td><p>ClusterInfo is additional computed information about the newly added cluster (Plant)</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ProjectMember>ProjectMember</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ProjectSpec>ProjectSpec</a>)</p><p><p>ProjectMember is a member of a project.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>Subject</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#subject-v1-rbac>Kubernetes rbac/v1.Subject</a></em></td><td><p>(Members of <code>Subject</code> are embedded into this type.)</p><p>Subject is representing a user name, an email address, or any other identifier of a user, group, or service
account that has a certain role.</p></td></tr><tr><td><code>role</code></br><em>string</em></td><td><p>Role represents the role of this member.
IMPORTANT: Be aware that this field will be removed in the <code>v1</code> version of this API in favor of the <code>roles</code>
list.
TODO: Remove this field in favor of the <code>roles</code> list in <code>v1</code>.</p></td></tr><tr><td><code>roles</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Roles represents the list of roles of this member.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ProjectPhase>ProjectPhase
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ProjectStatus>ProjectStatus</a>)</p><p><p>ProjectPhase is a label for the condition of a project at the current time.</p></p><h3 id=core.gardener.cloud/v1beta1.ProjectSpec>ProjectSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Project>Project</a>)</p><p><p>ProjectSpec is the specification of a Project.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>createdBy</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#subject-v1-rbac>Kubernetes rbac/v1.Subject</a></em></td><td><em>(Optional)</em><p>CreatedBy is a subject representing a user name, an email address, or any other identifier of a user
who created the project. This field is immutable.</p></td></tr><tr><td><code>description</code></br><em>string</em></td><td><em>(Optional)</em><p>Description is a human-readable description of what the project is used for.</p></td></tr><tr><td><code>owner</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#subject-v1-rbac>Kubernetes rbac/v1.Subject</a></em></td><td><em>(Optional)</em><p>Owner is a subject representing a user name, an email address, or any other identifier of a user owning
the project.
IMPORTANT: Be aware that this field will be removed in the <code>v1</code> version of this API in favor of the <code>owner</code>
role. The only way to change the owner will be by moving the <code>owner</code> role. In this API version the only way
to change the owner is to use this field.
TODO: Remove this field in favor of the <code>owner</code> role in <code>v1</code>.</p></td></tr><tr><td><code>purpose</code></br><em>string</em></td><td><em>(Optional)</em><p>Purpose is a human-readable explanation of the project&rsquo;s purpose.</p></td></tr><tr><td><code>members</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectMember>[]ProjectMember</a></em></td><td><em>(Optional)</em><p>Members is a list of subjects representing a user name, an email address, or any other identifier of a user,
group, or service account that has a certain role.</p></td></tr><tr><td><code>namespace</code></br><em>string</em></td><td><em>(Optional)</em><p>Namespace is the name of the namespace that has been created for the Project object.
A nil value means that Gardener will determine the name of the namespace.
This field is immutable.</p></td></tr><tr><td><code>tolerations</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectTolerations>ProjectTolerations</a></em></td><td><em>(Optional)</em><p>Tolerations contains the tolerations for taints on seed clusters.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ProjectStatus>ProjectStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Project>Project</a>)</p><p><p>ProjectStatus holds the most recently observed status of the project.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this project.</p></td></tr><tr><td><code>phase</code></br><em><a href=#core.gardener.cloud/v1beta1.ProjectPhase>ProjectPhase</a></em></td><td><p>Phase is the current phase of the project.</p></td></tr><tr><td><code>staleSinceTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>StaleSinceTimestamp contains the timestamp when the project was first discovered to be stale/unused.</p></td></tr><tr><td><code>staleAutoDeleteTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>StaleAutoDeleteTimestamp contains the timestamp when the project will be garbage-collected/automatically deleted
because it&rsquo;s stale/unused.</p></td></tr><tr><td><code>lastActivityTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastActivityTimestamp contains the timestamp from the last activity performed in this project.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ProjectTolerations>ProjectTolerations</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ProjectSpec>ProjectSpec</a>)</p><p><p>ProjectTolerations contains the tolerations for taints on seed clusters.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>defaults</code></br><em><a href=#core.gardener.cloud/v1beta1.Toleration>[]Toleration</a></em></td><td><em>(Optional)</em><p>Defaults contains a list of tolerations that are added to the shoots in this project by default.</p></td></tr><tr><td><code>whitelist</code></br><em><a href=#core.gardener.cloud/v1beta1.Toleration>[]Toleration</a></em></td><td><em>(Optional)</em><p>Whitelist contains a list of tolerations that are allowed to be added to the shoots in this project. Please note
that this list may only be added by users having the <code>spec-tolerations-whitelist</code> verb for project resources.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Provider>Provider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Provider contains provider-specific information that are handed-over to the provider-specific
extension controller.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the type of the provider. This field is immutable.</p></td></tr><tr><td><code>controlPlaneConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ControlPlaneConfig contains the provider-specific control plane config blob. Please look up the concrete
definition in the documentation of your provider extension.</p></td></tr><tr><td><code>infrastructureConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>InfrastructureConfig contains the provider-specific infrastructure config blob. Please look up the concrete
definition in the documentation of your provider extension.</p></td></tr><tr><td><code>workers</code></br><em><a href=#core.gardener.cloud/v1beta1.Worker>[]Worker</a></em></td><td><p>Workers is a list of worker groups.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ProxyMode>ProxyMode
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeProxyConfig>KubeProxyConfig</a>)</p><p><p>ProxyMode available in Linux platform: &lsquo;userspace&rsquo; (older, going to be EOL), &lsquo;iptables&rsquo;
(newer, faster), &lsquo;ipvs&rsquo; (newest, better in performance and scalability).
As of now only &lsquo;iptables&rsquo; and &lsquo;ipvs&rsquo; is supported by Gardener.
In Linux platform, if the iptables proxy is selected, regardless of how, but the system&rsquo;s kernel or iptables versions are
insufficient, this always falls back to the userspace proxy. IPVS mode will be enabled when proxy mode is set to &lsquo;ipvs&rsquo;,
and the fall back path is firstly iptables and then userspace.</p></p><h3 id=core.gardener.cloud/v1beta1.QuotaSpec>QuotaSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Quota>Quota</a>)</p><p><p>QuotaSpec is the specification of a Quota.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>clusterLifetimeDays</code></br><em>int32</em></td><td><em>(Optional)</em><p>ClusterLifetimeDays is the lifetime of a Shoot cluster in days before it will be terminated automatically.</p></td></tr><tr><td><code>metrics</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#resourcelist-v1-core>Kubernetes core/v1.ResourceList</a></em></td><td><p>Metrics is a list of resources which will be put under constraints.</p></td></tr><tr><td><code>scope</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>Scope is the scope of the Quota object, either &lsquo;project&rsquo; or &lsquo;secret&rsquo;. This field is immutable.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Region>Region</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a>)</p><p><p>Region contains certain properties of a region.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is a region name.</p></td></tr><tr><td><code>zones</code></br><em><a href=#core.gardener.cloud/v1beta1.AvailabilityZone>[]AvailabilityZone</a></em></td><td><em>(Optional)</em><p>Zones is a list of availability zones in this region.</p></td></tr><tr><td><code>labels</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Labels is an optional set of key-value pairs that contain certain administrator-controlled labels for this region.
It can be used by Gardener administrators/operators to provide additional information about a region, e.g. wrt
quality, reliability, access restrictions, etc.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ResourceWatchCacheSize>ResourceWatchCacheSize</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.WatchCacheSizes>WatchCacheSizes</a>)</p><p><p>ResourceWatchCacheSize contains configuration of the API server&rsquo;s watch cache size for one specific resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiGroup</code></br><em>string</em></td><td><em>(Optional)</em><p>APIGroup is the API group of the resource for which the watch cache size should be configured.
An unset value is used to specify the legacy core API (e.g. for <code>secrets</code>).</p></td></tr><tr><td><code>resource</code></br><em>string</em></td><td><p>Resource is the name of the resource for which the watch cache size should be configured
(in lowercase plural form, e.g. <code>secrets</code>).</p></td></tr><tr><td><code>size</code></br><em>int32</em></td><td><p>CacheSize specifies the watch cache size that should be configured for the specified resource.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SecretBindingProvider>SecretBindingProvider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SecretBinding>SecretBinding</a>)</p><p><p>SecretBindingProvider defines the provider type of the SecretBinding.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the type of the provider.</p><p>For backwards compatibility, the field can contain multiple providers separated by a comma.
However the usage of single SecretBinding (hence Secret) for different cloud providers is strongly discouraged.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedBackup>SeedBackup</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedBackup contains the object store configuration for backups for shoot (currently only etcd).</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>provider</code></br><em>string</em></td><td><p>Provider is a provider name. This field is immutable.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to BackupBucket resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><em>(Optional)</em><p>Region is a region name. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a Secret object containing the cloud provider credentials for
the object store where backups should be stored. It should have enough privileges to manipulate
the objects as well as buckets.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedDNS>SeedDNS</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedDNS contains DNS-relevant information about this seed cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>ingressDomain</code></br><em>string</em></td><td><em>(Optional)</em><p>IngressDomain is the domain of the Seed cluster pointing to the ingress controller endpoint. It will be used
to construct ingress URLs for system applications running in Shoot clusters. This field is immutable.
This will be removed in the next API version and replaced by spec.ingress.domain.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedDNSProvider>SeedDNSProvider</a></em></td><td><em>(Optional)</em><p>Provider configures a DNSProvider</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedDNSProvider>SeedDNSProvider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedDNS>SeedDNS</a>)</p><p><p>SeedDNSProvider configures a DNSProvider for Seeds</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type describes the type of the dns-provider, for example <code>aws-route53</code></p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a Secret object containing cloud provider credentials used for registering external domains.</p></td></tr><tr><td><code>domains</code></br><em><a href=#core.gardener.cloud/v1beta1.DNSIncludeExclude>DNSIncludeExclude</a></em></td><td><em>(Optional)</em><p>Domains contains information about which domains shall be included/excluded for this provider.</p></td></tr><tr><td><code>zones</code></br><em><a href=#core.gardener.cloud/v1beta1.DNSIncludeExclude>DNSIncludeExclude</a></em></td><td><em>(Optional)</em><p>Zones contains information about which hosted zones shall be included/excluded for this provider.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedNetworks>SeedNetworks</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedNetworks contains CIDRs for the pod, service and node networks of a Kubernetes cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>nodes</code></br><em>string</em></td><td><em>(Optional)</em><p>Nodes is the CIDR of the node network. This field is immutable.</p></td></tr><tr><td><code>pods</code></br><em>string</em></td><td><p>Pods is the CIDR of the pod network. This field is immutable.</p></td></tr><tr><td><code>services</code></br><em>string</em></td><td><p>Services is the CIDR of the service network. This field is immutable.</p></td></tr><tr><td><code>shootDefaults</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootNetworks>ShootNetworks</a></em></td><td><em>(Optional)</em><p>ShootDefaults contains the default networks CIDRs for shoots.</p></td></tr><tr><td><code>blockCIDRs</code></br><em>[]string</em></td><td><em>(Optional)</em><p>BlockCIDRs is a list of network addresses that should be blocked for shoot control plane components running
in the seed cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedProvider>SeedProvider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedProvider defines the provider type and region for this Seed cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type is the name of the provider.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the configuration passed to Seed resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is a name of a region.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSelector>SeedSelector</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a>,
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>SeedSelector contains constraints for selecting seed to be usable for shoots using a profile</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>LabelSelector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><p>(Members of <code>LabelSelector</code> are embedded into this type.)</p><em>(Optional)</em><p>LabelSelector is optional and can be used to select seeds by their label settings</p></td></tr><tr><td><code>providerTypes</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Providers is optional and can be used by restricting seeds by their provider type. &lsquo;*&rsquo; can be used to enable seeds regardless of their provider type.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdog>SeedSettingDependencyWatchdog</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingDependencyWatchdog controls the dependency-watchdog settings for the seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>endpoint</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdogEndpoint>SeedSettingDependencyWatchdogEndpoint</a></em></td><td><em>(Optional)</em><p>Endpoint controls the endpoint settings for the dependency-watchdog for the seed.</p></td></tr><tr><td><code>probe</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdogProbe>SeedSettingDependencyWatchdogProbe</a></em></td><td><em>(Optional)</em><p>Probe controls the probe settings for the dependency-watchdog for the seed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdogEndpoint>SeedSettingDependencyWatchdogEndpoint</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdog>SeedSettingDependencyWatchdog</a>)</p><p><p>SeedSettingDependencyWatchdogEndpoint controls the endpoint settings for the dependency-watchdog for the seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled controls whether the endpoint controller of the dependency-watchdog should be enabled. This controller
helps to alleviate the delay where control plane components remain unavailable by finding the respective pods in
CrashLoopBackoff status and restarting them once their dependants become ready and available again.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdogProbe>SeedSettingDependencyWatchdogProbe</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdog>SeedSettingDependencyWatchdog</a>)</p><p><p>SeedSettingDependencyWatchdogProbe controls the probe settings for the dependency-watchdog for the seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled controls whether the probe controller of the dependency-watchdog should be enabled. This controller
scales down the kube-controller-manager of shoot clusters in case their respective kube-apiserver is not
reachable via its external ingress in order to avoid melt-down situations.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingExcessCapacityReservation>SeedSettingExcessCapacityReservation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingExcessCapacityReservation controls the excess capacity reservation for shoot control planes in the seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled controls whether the excess capacity reservation should be enabled.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingLoadBalancerServices>SeedSettingLoadBalancerServices</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingLoadBalancerServices controls certain settings for services of type load balancer that are created in the
seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>annotations</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Annotations is a map of annotations that will be injected/merged into every load balancer service object.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingOwnerChecks>SeedSettingOwnerChecks</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingOwnerChecks controls certain owner checks settings for shoots scheduled on this seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled controls whether owner checks are enabled for shoots scheduled on this seed. It
is enabled by default because it is a prerequisite for control plane migration.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingScheduling>SeedSettingScheduling</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingScheduling controls settings for scheduling decisions for the seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>visible</code></br><em>bool</em></td><td><p>Visible controls whether the gardener-scheduler shall consider this seed when scheduling shoots. Invisible seeds
are not considered by the scheduler.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingShootDNS>SeedSettingShootDNS</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingShootDNS controls the shoot DNS settings for the seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled controls whether the DNS for shoot clusters should be enabled. When disabled then all shoots using the
seed won&rsquo;t get any DNS providers, DNS records, and no DNS extension controller is required to be installed here.
This is useful for environments where DNS is not required.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettingVerticalPodAutoscaler>SeedSettingVerticalPodAutoscaler</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a>)</p><p><p>SeedSettingVerticalPodAutoscaler controls certain settings for the vertical pod autoscaler components deployed in the
seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled controls whether the VPA components shall be deployed into the garden namespace in the seed cluster. It
is enabled by default because Gardener heavily relies on a VPA being deployed. You should only disable this if
your seed cluster already has another, manually/custom managed VPA deployment.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedSettings contains certain settings for this seed cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>excessCapacityReservation</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingExcessCapacityReservation>SeedSettingExcessCapacityReservation</a></em></td><td><em>(Optional)</em><p>ExcessCapacityReservation controls the excess capacity reservation for shoot control planes in the seed.</p></td></tr><tr><td><code>scheduling</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingScheduling>SeedSettingScheduling</a></em></td><td><em>(Optional)</em><p>Scheduling controls settings for scheduling decisions for the seed.</p></td></tr><tr><td><code>shootDNS</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingShootDNS>SeedSettingShootDNS</a></em></td><td><em>(Optional)</em><p>ShootDNS controls the shoot DNS settings for the seed.</p></td></tr><tr><td><code>loadBalancerServices</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingLoadBalancerServices>SeedSettingLoadBalancerServices</a></em></td><td><em>(Optional)</em><p>LoadBalancerServices controls certain settings for services of type load balancer that are created in the seed.</p></td></tr><tr><td><code>verticalPodAutoscaler</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingVerticalPodAutoscaler>SeedSettingVerticalPodAutoscaler</a></em></td><td><em>(Optional)</em><p>VerticalPodAutoscaler controls certain settings for the vertical pod autoscaler components deployed in the seed.</p></td></tr><tr><td><code>ownerChecks</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingOwnerChecks>SeedSettingOwnerChecks</a></em></td><td><em>(Optional)</em><p>SeedSettingOwnerChecks controls certain owner checks settings for shoots scheduled on this seed.</p></td></tr><tr><td><code>dependencyWatchdog</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettingDependencyWatchdog>SeedSettingDependencyWatchdog</a></em></td><td><em>(Optional)</em><p>DependencyWatchdog controls certain settings for the dependency-watchdog components deployed in the seed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Seed>Seed</a>,
<a href=#core.gardener.cloud/v1beta1.SeedTemplate>SeedTemplate</a>)</p><p><p>SeedSpec is the specification of a Seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>backup</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedBackup>SeedBackup</a></em></td><td><em>(Optional)</em><p>Backup holds the object store configuration for the backups of shoot (currently only etcd).
If it is not specified, then there won&rsquo;t be any backups taken for shoots associated with this seed.
If backup field is present in seed, then backups of the etcd from shoot control plane will be stored
under the configured object store.</p></td></tr><tr><td><code>dns</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedDNS>SeedDNS</a></em></td><td><p>DNS contains DNS-relevant information about this seed cluster.</p></td></tr><tr><td><code>networks</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedNetworks>SeedNetworks</a></em></td><td><p>Networks defines the pod, service and worker network of the Seed cluster.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedProvider>SeedProvider</a></em></td><td><p>Provider defines the provider type and region for this Seed cluster.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><em>(Optional)</em><p>SecretRef is a reference to a Secret object containing the Kubeconfig of the Kubernetes
cluster to be registered as Seed.</p></td></tr><tr><td><code>taints</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedTaint>[]SeedTaint</a></em></td><td><em>(Optional)</em><p>Taints describes taints on the seed.</p></td></tr><tr><td><code>volume</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedVolume>SeedVolume</a></em></td><td><em>(Optional)</em><p>Volume contains settings for persistentvolumes created in the seed cluster.</p></td></tr><tr><td><code>settings</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a></em></td><td><em>(Optional)</em><p>Settings contains certain settings for this seed cluster.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#core.gardener.cloud/v1beta1.Ingress>Ingress</a></em></td><td><em>(Optional)</em><p>Ingress configures Ingress specific settings of the Seed cluster. This field is immutable.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedStatus>SeedStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Seed>Seed</a>)</p><p><p>SeedStatus is the status of a Seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>gardener</code></br><em><a href=#core.gardener.cloud/v1beta1.Gardener>Gardener</a></em></td><td><em>(Optional)</em><p>Gardener holds information about the Gardener which last acted on the Shoot.</p></td></tr><tr><td><code>kubernetesVersion</code></br><em>string</em></td><td><em>(Optional)</em><p>KubernetesVersion is the Kubernetes version of the seed cluster.</p></td></tr><tr><td><code>conditions</code></br><em><a href=#core.gardener.cloud/v1beta1.Condition>[]Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a Seed&rsquo;s current state.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this Seed. It corresponds to the
Seed&rsquo;s generation, which is updated on mutation by the API Server.</p></td></tr><tr><td><code>clusterIdentity</code></br><em>string</em></td><td><em>(Optional)</em><p>ClusterIdentity is the identity of the Seed cluster. This field is immutable.</p></td></tr><tr><td><code>capacity</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#resourcelist-v1-core>Kubernetes core/v1.ResourceList</a></em></td><td><em>(Optional)</em><p>Capacity represents the total resources of a seed.</p></td></tr><tr><td><code>allocatable</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#resourcelist-v1-core>Kubernetes core/v1.ResourceList</a></em></td><td><em>(Optional)</em><p>Allocatable represents the resources of a seed that are available for scheduling.
Defaults to Capacity.</p></td></tr><tr><td><code>clientCertificateExpirationTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>ClientCertificateExpirationTimestamp is the timestamp at which gardenlet&rsquo;s client certificate expires.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedTaint>SeedTaint</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedTaint describes a taint on a seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>key</code></br><em>string</em></td><td><p>Key is the taint key to be applied to a seed.</p></td></tr><tr><td><code>value</code></br><em>string</em></td><td><em>(Optional)</em><p>Value is the taint value corresponding to the taint key.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedTemplate>SeedTemplate</h3><p><p>SeedTemplate is a template for creating a Seed object.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a></em></td><td><em>(Optional)</em><p>Specification of the desired behavior of the Seed.</p><br><br><table><tr><td><code>backup</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedBackup>SeedBackup</a></em></td><td><em>(Optional)</em><p>Backup holds the object store configuration for the backups of shoot (currently only etcd).
If it is not specified, then there won&rsquo;t be any backups taken for shoots associated with this seed.
If backup field is present in seed, then backups of the etcd from shoot control plane will be stored
under the configured object store.</p></td></tr><tr><td><code>dns</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedDNS>SeedDNS</a></em></td><td><p>DNS contains DNS-relevant information about this seed cluster.</p></td></tr><tr><td><code>networks</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedNetworks>SeedNetworks</a></em></td><td><p>Networks defines the pod, service and worker network of the Seed cluster.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedProvider>SeedProvider</a></em></td><td><p>Provider defines the provider type and region for this Seed cluster.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><em>(Optional)</em><p>SecretRef is a reference to a Secret object containing the Kubeconfig of the Kubernetes
cluster to be registered as Seed.</p></td></tr><tr><td><code>taints</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedTaint>[]SeedTaint</a></em></td><td><em>(Optional)</em><p>Taints describes taints on the seed.</p></td></tr><tr><td><code>volume</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedVolume>SeedVolume</a></em></td><td><em>(Optional)</em><p>Volume contains settings for persistentvolumes created in the seed cluster.</p></td></tr><tr><td><code>settings</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSettings>SeedSettings</a></em></td><td><em>(Optional)</em><p>Settings contains certain settings for this seed cluster.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#core.gardener.cloud/v1beta1.Ingress>Ingress</a></em></td><td><em>(Optional)</em><p>Ingress configures Ingress specific settings of the Seed cluster. This field is immutable.</p></td></tr></table></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedVolume>SeedVolume</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedSpec>SeedSpec</a>)</p><p><p>SeedVolume contains settings for persistentvolumes created in the seed cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>minimumSize</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>MinimumSize defines the minimum size that should be used for PVCs in the seed.</p></td></tr><tr><td><code>providers</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedVolumeProvider>[]SeedVolumeProvider</a></em></td><td><em>(Optional)</em><p>Providers is a list of storage class provisioner types for the seed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SeedVolumeProvider>SeedVolumeProvider</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedVolume>SeedVolume</a>)</p><p><p>SeedVolumeProvider is a storage class provisioner type.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>purpose</code></br><em>string</em></td><td><p>Purpose is the purpose of this provider.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the storage class provisioner type.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ServiceAccountConfig>ServiceAccountConfig</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>)</p><p><p>ServiceAccountConfig is the kube-apiserver configuration for service accounts.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>issuer</code></br><em>string</em></td><td><em>(Optional)</em><p>Issuer is the identifier of the service account token issuer. The issuer will assert this
identifier in &ldquo;iss&rdquo; claim of issued tokens. This value is used to generate new service account tokens.
This value is a string or URI. Defaults to URI of the API server.</p></td></tr><tr><td><code>signingKeySecretName</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>Kubernetes core/v1.LocalObjectReference</a></em></td><td><em>(Optional)</em><p>SigningKeySecret is a reference to a secret that contains an optional private key of the
service account token issuer. The issuer will sign issued ID tokens with this private key.
Only useful if service account tokens are also issued by another external system.</p></td></tr><tr><td><code>extendTokenExpiration</code></br><em>bool</em></td><td><em>(Optional)</em><p>ExtendTokenExpiration turns on projected service account expiration extension during token generation, which
helps safe transition from legacy token to bound service account token feature. If this flag is enabled,
admission injected tokens would be extended up to 1 year to prevent unexpected failure during transition,
ignoring value of service-account-max-token-expiration.</p></td></tr><tr><td><code>maxTokenExpiration</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>MaxTokenExpiration is the maximum validity duration of a token created by the service account token issuer. If an
otherwise valid TokenRequest with a validity duration larger than this value is requested, a token will be issued
with a validity duration of this value.
This field must be within [30d,90d] when the ShootMaxTokenExpirationValidation feature gate is enabled.
This field will be overwritten to be within [30d,90d] when the ShootMaxTokenExpirationOverwrite feature gate is enabled.</p></td></tr><tr><td><code>acceptedIssuers</code></br><em>[]string</em></td><td><em>(Optional)</em><p>AcceptedIssuers is an additional set of issuers that are used to determine which service account tokens are accepted.
These values are not used to generate new service account tokens. Only useful when service account tokens are also
issued by another external system or a change of the current issuer that is used for generating tokens is being performed.
This field is only available for Kubernetes v1.22 or later.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootAdvertisedAddress>ShootAdvertisedAddress</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a>)</p><p><p>ShootAdvertisedAddress contains information for the shoot&rsquo;s Kube API server.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name of the advertised address. e.g. external</p></td></tr><tr><td><code>url</code></br><em>string</em></td><td><p>The URL of the API Server. e.g. <a href=https://api.foo.bar>https://api.foo.bar</a> or <a href=https://1.2.3.4>https://1.2.3.4</a></p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootCARotation>ShootCARotation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootCredentialsRotation>ShootCredentialsRotation</a>)</p><p><p>ShootCARotation contains information about the certificate authority credential rotation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>phase</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootCredentialsRotationPhase>ShootCredentialsRotationPhase</a></em></td><td><p>Phase describes the phase of the certificate authority credential rotation.</p></td></tr><tr><td><code>lastInitiationTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastInitiationTime is the most recent time when the certificate authority credential rotation was initiated.</p></td></tr><tr><td><code>lastCompletionTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastCompletionTime is the most recent time when the certificate authority credential rotation was successfully
completed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootCredentials>ShootCredentials</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</a>)</p><p><p>ShootCredentials contains information about the shoot credentials.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>rotation</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootCredentialsRotation>ShootCredentialsRotation</a></em></td><td><em>(Optional)</em><p>Rotation contains information about the credential rotations.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootCredentialsRotation>ShootCredentialsRotation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootCredentials>ShootCredentials</a>)</p><p><p>ShootCredentialsRotation contains information about the rotation of credentials.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>certificateAuthorities</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootCARotation>ShootCARotation</a></em></td><td><em>(Optional)</em><p>CertificateAuthorities contains information about the certificate authority credential rotation.</p></td></tr><tr><td><code>kubeconfig</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootKubeconfigRotation>ShootKubeconfigRotation</a></em></td><td><em>(Optional)</em><p>Kubeconfig contains information about the kubeconfig credential rotation.</p></td></tr><tr><td><code>sshKeypair</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootSSHKeypairRotation>ShootSSHKeypairRotation</a></em></td><td><em>(Optional)</em><p>SSHKeypair contains information about the ssh-keypair credential rotation.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootCredentialsRotationPhase>ShootCredentialsRotationPhase
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootCARotation>ShootCARotation</a>)</p><p><p>ShootCredentialsRotationPhase is a string alias.</p></p><h3 id=core.gardener.cloud/v1beta1.ShootKubeconfigRotation>ShootKubeconfigRotation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootCredentialsRotation>ShootCredentialsRotation</a>)</p><p><p>ShootKubeconfigRotation contains information about the kubeconfig credential rotation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>lastInitiationTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastInitiationTime is the most recent time when the kubeconfig credential rotation was initiated.</p></td></tr><tr><td><code>lastCompletionTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastCompletionTime is the most recent time when the kubeconfig credential rotation was successfully completed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootMachineImage>ShootMachineImage</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Machine>Machine</a>)</p><p><p>ShootMachineImage defines the name and the version of the shoot&rsquo;s machine image in any environment. Has to be
defined in the respective CloudProfile.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the image.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the shoot&rsquo;s individual configuration passed to an extension resource.</p></td></tr><tr><td><code>version</code></br><em>string</em></td><td><em>(Optional)</em><p>Version is the version of the shoot&rsquo;s image.
If version is not provided, it will be defaulted to the latest version from the CloudProfile.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootNetworks>ShootNetworks</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.SeedNetworks>SeedNetworks</a>)</p><p><p>ShootNetworks contains the default networks CIDRs for shoots.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>pods</code></br><em>string</em></td><td><em>(Optional)</em><p>Pods is the CIDR of the pod network.</p></td></tr><tr><td><code>services</code></br><em>string</em></td><td><em>(Optional)</em><p>Services is the CIDR of the service network.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootPurpose>ShootPurpose
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>ShootPurpose is a type alias for string.</p></p><h3 id=core.gardener.cloud/v1beta1.ShootSSHKeypairRotation>ShootSSHKeypairRotation</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootCredentialsRotation>ShootCredentialsRotation</a>)</p><p><p>ShootSSHKeypairRotation contains information about the ssh-keypair credential rotation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>lastInitiationTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastInitiationTime is the most recent time when the certificate authority credential rotation was initiated.</p></td></tr><tr><td><code>lastCompletionTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastCompletionTime is the most recent time when the ssh-keypair credential rotation was successfully completed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Shoot>Shoot</a>,
<a href=#core.gardener.cloud/v1beta1.ShootTemplate>ShootTemplate</a>)</p><p><p>ShootSpec is the specification of a Shoot.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>addons</code></br><em><a href=#core.gardener.cloud/v1beta1.Addons>Addons</a></em></td><td><em>(Optional)</em><p>Addons contains information about enabled/disabled addons and their configuration.</p></td></tr><tr><td><code>cloudProfileName</code></br><em>string</em></td><td><p>CloudProfileName is a name of a CloudProfile object. This field is immutable.</p></td></tr><tr><td><code>dns</code></br><em><a href=#core.gardener.cloud/v1beta1.DNS>DNS</a></em></td><td><em>(Optional)</em><p>DNS contains information about the DNS settings of the Shoot.</p></td></tr><tr><td><code>extensions</code></br><em><a href=#core.gardener.cloud/v1beta1.Extension>[]Extension</a></em></td><td><em>(Optional)</em><p>Extensions contain type and provider information for Shoot extensions.</p></td></tr><tr><td><code>hibernation</code></br><em><a href=#core.gardener.cloud/v1beta1.Hibernation>Hibernation</a></em></td><td><em>(Optional)</em><p>Hibernation contains information whether the Shoot is suspended or not.</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a></em></td><td><p>Kubernetes contains the version and configuration settings of the control plane components.</p></td></tr><tr><td><code>networking</code></br><em><a href=#core.gardener.cloud/v1beta1.Networking>Networking</a></em></td><td><p>Networking contains information about cluster networking such as CNI Plugin type, CIDRs, &mldr;etc.</p></td></tr><tr><td><code>maintenance</code></br><em><a href=#core.gardener.cloud/v1beta1.Maintenance>Maintenance</a></em></td><td><em>(Optional)</em><p>Maintenance contains information about the time window for maintenance operations and which
operations should be performed.</p></td></tr><tr><td><code>monitoring</code></br><em><a href=#core.gardener.cloud/v1beta1.Monitoring>Monitoring</a></em></td><td><em>(Optional)</em><p>Monitoring contains information about custom monitoring configurations for the shoot.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.Provider>Provider</a></em></td><td><p>Provider contains all provider-specific and provider-relevant information.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootPurpose>ShootPurpose</a></em></td><td><em>(Optional)</em><p>Purpose is the purpose class for this cluster.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is a name of a region. This field is immutable.</p></td></tr><tr><td><code>secretBindingName</code></br><em>string</em></td><td><p>SecretBindingName is the name of the a SecretBinding that has a reference to the provider secret.
The credentials inside the provider secret will be used to create the shoot in the respective account.
This field is immutable.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed cluster that runs the control plane of the Shoot.
This field is immutable when the SeedChange feature gate is disabled.</p></td></tr><tr><td><code>seedSelector</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSelector>SeedSelector</a></em></td><td><em>(Optional)</em><p>SeedSelector is an optional selector which must match a seed&rsquo;s labels for the shoot to be scheduled on that seed.</p></td></tr><tr><td><code>resources</code></br><em><a href=#core.gardener.cloud/v1beta1.NamedResourceReference>[]NamedResourceReference</a></em></td><td><em>(Optional)</em><p>Resources holds a list of named resource references that can be referred to in extension configs by their names.</p></td></tr><tr><td><code>tolerations</code></br><em><a href=#core.gardener.cloud/v1beta1.Toleration>[]Toleration</a></em></td><td><em>(Optional)</em><p>Tolerations contains the tolerations for taints on seed clusters.</p></td></tr><tr><td><code>exposureClassName</code></br><em>string</em></td><td><em>(Optional)</em><p>ExposureClassName is the optional name of an exposure class to apply a control plane endpoint exposure strategy.
This field is immutable.</p></td></tr><tr><td><code>systemComponents</code></br><em><a href=#core.gardener.cloud/v1beta1.SystemComponents>SystemComponents</a></em></td><td><em>(Optional)</em><p>SystemComponents contains the settings of system components in the control or data plane of the Shoot cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootStatus>ShootStatus</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Shoot>Shoot</a>)</p><p><p>ShootStatus holds the most recently observed status of the Shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>conditions</code></br><em><a href=#core.gardener.cloud/v1beta1.Condition>[]Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a Shoots&rsquo;s current state.</p></td></tr><tr><td><code>constraints</code></br><em><a href=#core.gardener.cloud/v1beta1.Condition>[]Condition</a></em></td><td><em>(Optional)</em><p>Constraints represents conditions of a Shoot&rsquo;s current state that constraint some operations on it.</p></td></tr><tr><td><code>gardener</code></br><em><a href=#core.gardener.cloud/v1beta1.Gardener>Gardener</a></em></td><td><p>Gardener holds information about the Gardener which last acted on the Shoot.</p></td></tr><tr><td><code>hibernated</code></br><em>bool</em></td><td><p>IsHibernated indicates whether the Shoot is currently hibernated.</p></td></tr><tr><td><code>lastOperation</code></br><em><a href=#core.gardener.cloud/v1beta1.LastOperation>LastOperation</a></em></td><td><em>(Optional)</em><p>LastOperation holds information about the last operation on the Shoot.</p></td></tr><tr><td><code>lastErrors</code></br><em><a href=#core.gardener.cloud/v1beta1.LastError>[]LastError</a></em></td><td><em>(Optional)</em><p>LastErrors holds information about the last occurred error(s) during an operation.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this Shoot. It corresponds to the
Shoot&rsquo;s generation, which is updated on mutation by the API Server.</p></td></tr><tr><td><code>retryCycleStartTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>RetryCycleStartTime is the start time of the last retry cycle (used to determine how often an operation
must be retried until we give up).</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed cluster that runs the control plane of the Shoot. This value is only written
after a successful create/reconcile operation. It will be used when control planes are moved between Seeds.</p></td></tr><tr><td><code>technicalID</code></br><em>string</em></td><td><p>TechnicalID is the name that is used for creating the Seed namespace, the infrastructure resources, and
basically everything that is related to this particular Shoot. This field is immutable.</p></td></tr><tr><td><code>uid</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/types#UID>k8s.io/apimachinery/pkg/types.UID</a></em></td><td><p>UID is a unique identifier for the Shoot cluster to avoid portability between Kubernetes clusters.
It is used to compute unique hashes. This field is immutable.</p></td></tr><tr><td><code>clusterIdentity</code></br><em>string</em></td><td><em>(Optional)</em><p>ClusterIdentity is the identity of the Shoot cluster. This field is immutable.</p></td></tr><tr><td><code>advertisedAddresses</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootAdvertisedAddress>[]ShootAdvertisedAddress</a></em></td><td><em>(Optional)</em><p>List of addresses on which the Kube API server can be reached.</p></td></tr><tr><td><code>migrationStartTime</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>MigrationStartTime is the time when a migration to a different seed was initiated.</p></td></tr><tr><td><code>credentials</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootCredentials>ShootCredentials</a></em></td><td><em>(Optional)</em><p>Credentials contains information about the shoot credentials.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.ShootTemplate>ShootTemplate</h3><p><p>ShootTemplate is a template for creating a Shoot object.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a></em></td><td><em>(Optional)</em><p>Specification of the desired behavior of the Shoot.</p><br><br><table><tr><td><code>addons</code></br><em><a href=#core.gardener.cloud/v1beta1.Addons>Addons</a></em></td><td><em>(Optional)</em><p>Addons contains information about enabled/disabled addons and their configuration.</p></td></tr><tr><td><code>cloudProfileName</code></br><em>string</em></td><td><p>CloudProfileName is a name of a CloudProfile object. This field is immutable.</p></td></tr><tr><td><code>dns</code></br><em><a href=#core.gardener.cloud/v1beta1.DNS>DNS</a></em></td><td><em>(Optional)</em><p>DNS contains information about the DNS settings of the Shoot.</p></td></tr><tr><td><code>extensions</code></br><em><a href=#core.gardener.cloud/v1beta1.Extension>[]Extension</a></em></td><td><em>(Optional)</em><p>Extensions contain type and provider information for Shoot extensions.</p></td></tr><tr><td><code>hibernation</code></br><em><a href=#core.gardener.cloud/v1beta1.Hibernation>Hibernation</a></em></td><td><em>(Optional)</em><p>Hibernation contains information whether the Shoot is suspended or not.</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a></em></td><td><p>Kubernetes contains the version and configuration settings of the control plane components.</p></td></tr><tr><td><code>networking</code></br><em><a href=#core.gardener.cloud/v1beta1.Networking>Networking</a></em></td><td><p>Networking contains information about cluster networking such as CNI Plugin type, CIDRs, &mldr;etc.</p></td></tr><tr><td><code>maintenance</code></br><em><a href=#core.gardener.cloud/v1beta1.Maintenance>Maintenance</a></em></td><td><em>(Optional)</em><p>Maintenance contains information about the time window for maintenance operations and which
operations should be performed.</p></td></tr><tr><td><code>monitoring</code></br><em><a href=#core.gardener.cloud/v1beta1.Monitoring>Monitoring</a></em></td><td><em>(Optional)</em><p>Monitoring contains information about custom monitoring configurations for the shoot.</p></td></tr><tr><td><code>provider</code></br><em><a href=#core.gardener.cloud/v1beta1.Provider>Provider</a></em></td><td><p>Provider contains all provider-specific and provider-relevant information.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#core.gardener.cloud/v1beta1.ShootPurpose>ShootPurpose</a></em></td><td><em>(Optional)</em><p>Purpose is the purpose class for this cluster.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is a name of a region. This field is immutable.</p></td></tr><tr><td><code>secretBindingName</code></br><em>string</em></td><td><p>SecretBindingName is the name of the a SecretBinding that has a reference to the provider secret.
The credentials inside the provider secret will be used to create the shoot in the respective account.
This field is immutable.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed cluster that runs the control plane of the Shoot.
This field is immutable when the SeedChange feature gate is disabled.</p></td></tr><tr><td><code>seedSelector</code></br><em><a href=#core.gardener.cloud/v1beta1.SeedSelector>SeedSelector</a></em></td><td><em>(Optional)</em><p>SeedSelector is an optional selector which must match a seed&rsquo;s labels for the shoot to be scheduled on that seed.</p></td></tr><tr><td><code>resources</code></br><em><a href=#core.gardener.cloud/v1beta1.NamedResourceReference>[]NamedResourceReference</a></em></td><td><em>(Optional)</em><p>Resources holds a list of named resource references that can be referred to in extension configs by their names.</p></td></tr><tr><td><code>tolerations</code></br><em><a href=#core.gardener.cloud/v1beta1.Toleration>[]Toleration</a></em></td><td><em>(Optional)</em><p>Tolerations contains the tolerations for taints on seed clusters.</p></td></tr><tr><td><code>exposureClassName</code></br><em>string</em></td><td><em>(Optional)</em><p>ExposureClassName is the optional name of an exposure class to apply a control plane endpoint exposure strategy.
This field is immutable.</p></td></tr><tr><td><code>systemComponents</code></br><em><a href=#core.gardener.cloud/v1beta1.SystemComponents>SystemComponents</a></em></td><td><em>(Optional)</em><p>SystemComponents contains the settings of system components in the control or data plane of the Shoot cluster.</p></td></tr></table></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.SystemComponents>SystemComponents</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>SystemComponents contains the settings of system components in the control or data plane of the Shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>coreDNS</code></br><em><a href=#core.gardener.cloud/v1beta1.CoreDNS>CoreDNS</a></em></td><td><em>(Optional)</em><p>CoreDNS contains the settings of the Core DNS components running in the data plane of the Shoot cluster.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Toleration>Toleration</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ProjectTolerations>ProjectTolerations</a>,
<a href=#core.gardener.cloud/v1beta1.ShootSpec>ShootSpec</a>)</p><p><p>Toleration is a toleration for a seed taint.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>key</code></br><em>string</em></td><td><p>Key is the toleration key to be applied to a project or shoot.</p></td></tr><tr><td><code>value</code></br><em>string</em></td><td><em>(Optional)</em><p>Value is the toleration value corresponding to the toleration key.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.VersionClassification>VersionClassification
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.ExpirableVersion>ExpirableVersion</a>)</p><p><p>VersionClassification is the logical state of a version.</p></p><h3 id=core.gardener.cloud/v1beta1.VerticalPodAutoscaler>VerticalPodAutoscaler</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Kubernetes>Kubernetes</a>)</p><p><p>VerticalPodAutoscaler contains the configuration flags for the Kubernetes vertical pod autoscaler.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>enabled</code></br><em>bool</em></td><td><p>Enabled specifies whether the Kubernetes VPA shall be enabled for the shoot cluster.</p></td></tr><tr><td><code>evictAfterOOMThreshold</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>EvictAfterOOMThreshold defines the threshold that will lead to pod eviction in case it OOMed in less than the given
threshold since its start and if it has only one container (default: 10m0s).</p></td></tr><tr><td><code>evictionRateBurst</code></br><em>int32</em></td><td><em>(Optional)</em><p>EvictionRateBurst defines the burst of pods that can be evicted (default: 1)</p></td></tr><tr><td><code>evictionRateLimit</code></br><em>float64</em></td><td><em>(Optional)</em><p>EvictionRateLimit defines the number of pods that can be evicted per second. A rate limit set to 0 or -1 will
disable the rate limiter (default: -1).</p></td></tr><tr><td><code>evictionTolerance</code></br><em>float64</em></td><td><em>(Optional)</em><p>EvictionTolerance defines the fraction of replica count that can be evicted for update in case more than one
pod can be evicted (default: 0.5).</p></td></tr><tr><td><code>recommendationMarginFraction</code></br><em>float64</em></td><td><em>(Optional)</em><p>RecommendationMarginFraction is the fraction of usage added as the safety margin to the recommended request
(default: 0.15).</p></td></tr><tr><td><code>updaterInterval</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>UpdaterInterval is the interval how often the updater should run (default: 1m0s).</p></td></tr><tr><td><code>recommenderInterval</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration>Kubernetes meta/v1.Duration</a></em></td><td><em>(Optional)</em><p>RecommenderInterval is the interval how often metrics should be fetched (default: 1m0s).</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Volume>Volume</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>Volume contains information about the volume type, size, and encryption.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><em>(Optional)</em><p>Name of the volume to make it referencable.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><em>(Optional)</em><p>Type is the type of the volume.</p></td></tr><tr><td><code>size</code></br><em>string</em></td><td><p>VolumeSize is the size of the volume.</p></td></tr><tr><td><code>encrypted</code></br><em>bool</em></td><td><em>(Optional)</em><p>Encrypted determines if the volume should be encrypted.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.VolumeType>VolumeType</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.CloudProfileSpec>CloudProfileSpec</a>)</p><p><p>VolumeType contains certain properties of a volume type.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>class</code></br><em>string</em></td><td><p>Class is the class of the volume type.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the volume type.</p></td></tr><tr><td><code>usable</code></br><em>bool</em></td><td><em>(Optional)</em><p>Usable defines if the volume type can be used for shoot clusters.</p></td></tr><tr><td><code>minSize</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/api/resource#Quantity>k8s.io/apimachinery/pkg/api/resource.Quantity</a></em></td><td><em>(Optional)</em><p>MinSize is the minimal supported storage size.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.WatchCacheSizes>WatchCacheSizes</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.KubeAPIServerConfig>KubeAPIServerConfig</a>)</p><p><p>WatchCacheSizes contains configuration of the API server&rsquo;s watch cache sizes.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>default</code></br><em>int32</em></td><td><em>(Optional)</em><p>Default configures the default watch cache size of the kube-apiserver
(flag <code>--default-watch-cache-size</code>, defaults to 100).
See: <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/</a></p></td></tr><tr><td><code>resources</code></br><em><a href=#core.gardener.cloud/v1beta1.ResourceWatchCacheSize>[]ResourceWatchCacheSize</a></em></td><td><em>(Optional)</em><p>Resources configures the watch cache size of the kube-apiserver per resource
(flag <code>--watch-cache-sizes</code>).
See: <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/</a></p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.Worker>Worker</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Provider>Provider</a>)</p><p><p>Worker is the base definition of a worker group.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>annotations</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Annotations is a map of key/value pairs for annotations for all the <code>Node</code> objects in this worker pool.</p></td></tr><tr><td><code>caBundle</code></br><em>string</em></td><td><em>(Optional)</em><p>CABundle is a certificate bundle which will be installed onto every machine of this worker pool.</p></td></tr><tr><td><code>cri</code></br><em><a href=#core.gardener.cloud/v1beta1.CRI>CRI</a></em></td><td><em>(Optional)</em><p>CRI contains configurations of CRI support of every machine in the worker pool.
Defaults to a CRI with name <code>containerd</code> when the Kubernetes version of the <code>Shoot</code> is >= 1.22.</p></td></tr><tr><td><code>kubernetes</code></br><em><a href=#core.gardener.cloud/v1beta1.WorkerKubernetes>WorkerKubernetes</a></em></td><td><em>(Optional)</em><p>Kubernetes contains configuration for Kubernetes components related to this worker pool.</p></td></tr><tr><td><code>labels</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Labels is a map of key/value pairs for labels for all the <code>Node</code> objects in this worker pool.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the worker group.</p></td></tr><tr><td><code>machine</code></br><em><a href=#core.gardener.cloud/v1beta1.Machine>Machine</a></em></td><td><p>Machine contains information about the machine type and image.</p></td></tr><tr><td><code>maximum</code></br><em>int32</em></td><td><p>Maximum is the maximum number of VMs to create.</p></td></tr><tr><td><code>minimum</code></br><em>int32</em></td><td><p>Minimum is the minimum number of VMs to create.</p></td></tr><tr><td><code>maxSurge</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/util/intstr#IntOrString>k8s.io/apimachinery/pkg/util/intstr.IntOrString</a></em></td><td><em>(Optional)</em><p>MaxSurge is maximum number of VMs that are created during an update.</p></td></tr><tr><td><code>maxUnavailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/util/intstr#IntOrString>k8s.io/apimachinery/pkg/util/intstr.IntOrString</a></em></td><td><em>(Optional)</em><p>MaxUnavailable is the maximum number of VMs that can be unavailable during an update.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the provider-specific configuration for this worker pool.</p></td></tr><tr><td><code>taints</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#taint-v1-core>[]Kubernetes core/v1.Taint</a></em></td><td><em>(Optional)</em><p>Taints is a list of taints for all the <code>Node</code> objects in this worker pool.</p></td></tr><tr><td><code>volume</code></br><em><a href=#core.gardener.cloud/v1beta1.Volume>Volume</a></em></td><td><em>(Optional)</em><p>Volume contains information about the volume type and size.</p></td></tr><tr><td><code>dataVolumes</code></br><em><a href=#core.gardener.cloud/v1beta1.DataVolume>[]DataVolume</a></em></td><td><em>(Optional)</em><p>DataVolumes contains a list of additional worker volumes.</p></td></tr><tr><td><code>kubeletDataVolumeName</code></br><em>string</em></td><td><em>(Optional)</em><p>KubeletDataVolumeName contains the name of a dataVolume that should be used for storing kubelet state.</p></td></tr><tr><td><code>zones</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Zones is a list of availability zones that are used to evenly distribute this worker pool. Optional
as not every provider may support availability zones.</p></td></tr><tr><td><code>systemComponents</code></br><em><a href=#core.gardener.cloud/v1beta1.WorkerSystemComponents>WorkerSystemComponents</a></em></td><td><em>(Optional)</em><p>SystemComponents contains configuration for system components related to this worker pool</p></td></tr><tr><td><code>machineControllerManager</code></br><em><a href=#core.gardener.cloud/v1beta1.MachineControllerManagerSettings>MachineControllerManagerSettings</a></em></td><td><em>(Optional)</em><p>MachineControllerManagerSettings contains configurations for different worker-pools. Eg. MachineDrainTimeout, MachineHealthTimeout.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.WorkerKubernetes>WorkerKubernetes</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>WorkerKubernetes contains configuration for Kubernetes components related to this worker pool.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>kubelet</code></br><em><a href=#core.gardener.cloud/v1beta1.KubeletConfig>KubeletConfig</a></em></td><td><em>(Optional)</em><p>Kubelet contains configuration settings for all kubelets of this worker pool.
If set, all <code>spec.kubernetes.kubelet</code> settings will be overwritten for this worker pool (no merge of settings).</p></td></tr><tr><td><code>version</code></br><em>string</em></td><td><em>(Optional)</em><p>Version is the semantic Kubernetes version to use for the Kubelet in this Worker Group.
If not specified the kubelet version is derived from the global shoot cluster kubernetes version.
version must be equal or lower than the version of the shoot kubernetes version.
Only one minor version difference to other worker groups and global kubernetes version is allowed.</p></td></tr></tbody></table><h3 id=core.gardener.cloud/v1beta1.WorkerSystemComponents>WorkerSystemComponents</h3><p>(<em>Appears on:</em>
<a href=#core.gardener.cloud/v1beta1.Worker>Worker</a>)</p><p><p>WorkerSystemComponents contains configuration for system components related to this worker pool</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>allow</code></br><em>bool</em></td><td><p>Allow determines whether the pool should be allowed to host system components or not (defaults to true)</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-fca1695658a108c8072b581668195464>1.3 - Extensions</h1><p>Packages:</p><ul><li><a href=#extensions.gardener.cloud%2fv1alpha1>extensions.gardener.cloud/v1alpha1</a></li></ul><h2 id=extensions.gardener.cloud/v1alpha1>extensions.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 is the v1alpha1 version of the API.</p></p>Resource Types:<ul><li><a href=#extensions.gardener.cloud/v1alpha1.BackupBucket>BackupBucket</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.BackupEntry>BackupEntry</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.Bastion>Bastion</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.Cluster>Cluster</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntime>ContainerRuntime</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.ControlPlane>ControlPlane</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.DNSRecord>DNSRecord</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.Extension>Extension</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.Infrastructure>Infrastructure</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.Network>Network</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfig>OperatingSystemConfig</a></li><li><a href=#extensions.gardener.cloud/v1alpha1.Worker>Worker</a></li></ul><h3 id=extensions.gardener.cloud/v1alpha1.BackupBucket>BackupBucket</h3><p><p>BackupBucket is a specification for backup bucket.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>BackupBucket</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BackupBucketSpec>BackupBucketSpec</a></em></td><td><p>Specification of the BackupBucket.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this bucket. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the credentials to access object store.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BackupBucketStatus>BackupBucketStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BackupEntry>BackupEntry</h3><p><p>BackupEntry is a specification for backup Entry.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>BackupEntry</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BackupEntrySpec>BackupEntrySpec</a></em></td><td><p>Specification of the BackupEntry.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>backupBucketProviderStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>BackupBucketProviderStatus contains the provider status that has
been generated by the controller responsible for the <code>BackupBucket</code> resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this Entry. This field is immutable.</p></td></tr><tr><td><code>bucketName</code></br><em>string</em></td><td><p>BucketName is the name of backup bucket for this Backup Entry.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the credentials to access object store.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BackupEntryStatus>BackupEntryStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Bastion>Bastion</h3><p><p>Bastion is a bastion or jump host that is dynamically created
to provide SSH access to shoot nodes.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Bastion</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</a></em></td><td><p>Spec is the specification of this Bastion.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>userData</code></br><em>[]byte</em></td><td><p>UserData is the base64-encoded user data for the bastion instance. This should
contain code to provision the SSH key on the bastion instance.
This field is immutable.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BastionIngressPolicy>[]BastionIngressPolicy</a></em></td><td><p>Ingress controls from where the created bastion host should be reachable.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BastionStatus>BastionStatus</a></em></td><td><em>(Optional)</em><p>Status is the bastion’s status.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Cluster>Cluster</h3><p><p>Cluster is a specification for a Cluster resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Cluster</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ClusterSpec>ClusterSpec</a></em></td><td><br><br><table><tr><td><code>cloudProfile</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>CloudProfile is a raw extension field that contains the cloudprofile resource referenced
by the shoot that has to be reconciled.</p></td></tr><tr><td><code>seed</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>Seed is a raw extension field that contains the seed resource referenced by the shoot that
has to be reconciled.</p></td></tr><tr><td><code>shoot</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>Shoot is a raw extension field that contains the shoot resource that has to be reconciled.</p></td></tr></table></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ContainerRuntime>ContainerRuntime</h3><p><p>ContainerRuntime is a specification for a container runtime resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ContainerRuntime</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeSpec>ContainerRuntimeSpec</a></em></td><td><p>Specification of the ContainerRuntime.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>binaryPath</code></br><em>string</em></td><td><p>BinaryPath is the Worker’s machine path where container runtime extensions should copy the binaries to.</p></td></tr><tr><td><code>workerPool</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeWorkerPool>ContainerRuntimeWorkerPool</a></em></td><td><p>WorkerPool identifies the worker pool of the Shoot.
For each worker pool and type, Gardener deploys a ContainerRuntime CRD.</p></td></tr><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeStatus>ContainerRuntimeStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ControlPlane>ControlPlane</h3><p><p>ControlPlane is a specification for a ControlPlane resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ControlPlane</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ControlPlaneSpec>ControlPlaneSpec</a></em></td><td><p>Specification of the ControlPlane.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.Purpose>Purpose</a></em></td><td><em>(Optional)</em><p>Purpose contains the data if a cloud provider needs additional components in order to expose the control plane.
This field is immutable.</p></td></tr><tr><td><code>infrastructureProviderStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>InfrastructureProviderStatus contains the provider status that has
been generated by the controller responsible for the <code>Infrastructure</code> resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this control plane. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the cloud provider specific credentials.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ControlPlaneStatus>ControlPlaneStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DNSRecord>DNSRecord</h3><p><p>DNSRecord is a specification for a DNSRecord resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>DNSRecord</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DNSRecordSpec>DNSRecordSpec</a></em></td><td><p>Specification of the DNSRecord.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the cloud provider specific credentials.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><em>(Optional)</em><p>Region is the region of this DNS record. If not specified, the region specified in SecretRef will be used.
If that is also not specified, the extension controller will use its default region.</p></td></tr><tr><td><code>zone</code></br><em>string</em></td><td><em>(Optional)</em><p>Zone is the DNS hosted zone of this DNS record. If not specified, it will be determined automatically by
getting all hosted zones of the account and searching for the longest zone name that is a suffix of Name.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the fully qualified domain name, e.g. “api.<shoot domain>”. This field is immutable.</p></td></tr><tr><td><code>recordType</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DNSRecordType>DNSRecordType</a></em></td><td><p>RecordType is the DNS record type. Only A, CNAME, and TXT records are currently supported. This field is immutable.</p></td></tr><tr><td><code>values</code></br><em>[]string</em></td><td><p>Values is a list of IP addresses for A records, a single hostname for CNAME records, or a list of texts for TXT records.</p></td></tr><tr><td><code>ttl</code></br><em>int64</em></td><td><em>(Optional)</em><p>TTL is the time to live in seconds. Defaults to 120.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DNSRecordStatus>DNSRecordStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Extension>Extension</h3><p><p>Extension is a specification for a Extension resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Extension</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ExtensionSpec>ExtensionSpec</a></em></td><td><p>Specification of the Extension.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ExtensionStatus>ExtensionStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Infrastructure>Infrastructure</h3><p><p>Infrastructure is a specification for cloud provider infrastructure.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Infrastructure</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.InfrastructureSpec>InfrastructureSpec</a></em></td><td><p>Specification of the Infrastructure.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this infrastructure. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the actual result of the generated cloud config.</p></td></tr><tr><td><code>sshPublicKey</code></br><em>[]byte</em></td><td><em>(Optional)</em><p>SSHPublicKey is the public SSH key that should be used with this infrastructure.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.InfrastructureStatus>InfrastructureStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Network>Network</h3><p><p>Network is the specification for cluster networking.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Network</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.NetworkSpec>NetworkSpec</a></em></td><td><p>Specification of the Network.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>podCIDR</code></br><em>string</em></td><td><p>PodCIDR defines the CIDR that will be used for pods. This field is immutable.</p></td></tr><tr><td><code>serviceCIDR</code></br><em>string</em></td><td><p>ServiceCIDR defines the CIDR that will be used for services. This field is immutable.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.NetworkStatus>NetworkStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.OperatingSystemConfig>OperatingSystemConfig</h3><p><p>OperatingSystemConfig is a specification for a OperatingSystemConfig resource</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>OperatingSystemConfig</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</a></em></td><td><p>Specification of the OperatingSystemConfig.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>criConfig</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.CRIConfig>CRIConfig</a></em></td><td><em>(Optional)</em><p>CRI config is a structure contains configurations of the CRI library</p></td></tr><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigPurpose>OperatingSystemConfigPurpose</a></em></td><td><p>Purpose describes how the result of this OperatingSystemConfig is used by Gardener. Either it
gets sent to the <code>Worker</code> extension controller to bootstrap a VM, or it is downloaded by the
cloud-config-downloader script already running on a bootstrapped VM.
This field is immutable.</p></td></tr><tr><td><code>reloadConfigFilePath</code></br><em>string</em></td><td><em>(Optional)</em><p>ReloadConfigFilePath is the path to the generated operating system configuration. If set, controllers
are asked to use it when determining the .status.command of this resource. For example, if for CoreOS
the reload-path might be “/var/lib/config”; then the controller shall set .status.command to
“/usr/bin/coreos-cloudinit –from-file=/var/lib/config”.</p></td></tr><tr><td><code>units</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.Unit>[]Unit</a></em></td><td><em>(Optional)</em><p>Units is a list of unit for the operating system configuration (usually, a systemd unit).</p></td></tr><tr><td><code>files</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.File>[]File</a></em></td><td><em>(Optional)</em><p>Files is a list of files that should get written to the host’s file system.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigStatus>OperatingSystemConfigStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Worker>Worker</h3><p><p>Worker is a specification for a Worker resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Worker</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.WorkerSpec>WorkerSpec</a></em></td><td><p>Specification of the Worker.
If the object’s deletion timestamp is set, this field is immutable.</p><br><br><table><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>infrastructureProviderStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>InfrastructureProviderStatus is a raw extension field that contains the provider status that has
been generated by the controller responsible for the <code>Infrastructure</code> resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the name of the region where the worker pool should be deployed to. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the cloud provider specific credentials.</p></td></tr><tr><td><code>sshPublicKey</code></br><em>[]byte</em></td><td><em>(Optional)</em><p>SSHPublicKey is the public SSH key that should be used with these workers.</p></td></tr><tr><td><code>pools</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.WorkerPool>[]WorkerPool</a></em></td><td><p>Pools is a list of worker pools.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</a></em></td><td><em>(Optional)</em></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BackupBucketSpec>BackupBucketSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BackupBucket>BackupBucket</a>)</p><p><p>BackupBucketSpec is the spec for an BackupBucket resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this bucket. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the credentials to access object store.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BackupBucketStatus>BackupBucketStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BackupBucket>BackupBucket</a>)</p><p><p>BackupBucketStatus is the status for an BackupBucket resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>generatedSecretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><em>(Optional)</em><p>GeneratedSecretRef is reference to the secret generated by backup bucket, which
will have object store specific credentials.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BackupEntrySpec>BackupEntrySpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BackupEntry>BackupEntry</a>)</p><p><p>BackupEntrySpec is the spec for an BackupEntry resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>backupBucketProviderStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>BackupBucketProviderStatus contains the provider status that has
been generated by the controller responsible for the <code>BackupBucket</code> resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this Entry. This field is immutable.</p></td></tr><tr><td><code>bucketName</code></br><em>string</em></td><td><p>BucketName is the name of backup bucket for this Backup Entry.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the credentials to access object store.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BackupEntryStatus>BackupEntryStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BackupEntry>BackupEntry</a>)</p><p><p>BackupEntryStatus is the status for an BackupEntry resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BastionIngressPolicy>BastionIngressPolicy</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</a>)</p><p><p>BastionIngressPolicy represents an ingress policy for SSH bastion hosts.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>ipBlock</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#ipblock-v1-networking>Kubernetes networking/v1.IPBlock</a></em></td><td><p>IPBlock defines an IP block that is allowed to access the bastion.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Bastion>Bastion</a>)</p><p><p>BastionSpec contains the specification for an SSH bastion host.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>userData</code></br><em>[]byte</em></td><td><p>UserData is the base64-encoded user data for the bastion instance. This should
contain code to provision the SSH key on the bastion instance.
This field is immutable.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.BastionIngressPolicy>[]BastionIngressPolicy</a></em></td><td><p>Ingress controls from where the created bastion host should be reachable.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.BastionStatus>BastionStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Bastion>Bastion</a>)</p><p><p>BastionStatus holds the most recently observed status of the Bastion.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>ingress</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#loadbalanceringress-v1-core>Kubernetes core/v1.LoadBalancerIngress</a></em></td><td><em>(Optional)</em><p>Ingress is the external IP and/or hostname of the bastion host.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.CRIConfig>CRIConfig</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</a>)</p><p><p>CRIConfig contains configurations of the CRI library.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.CRIName>CRIName</a></em></td><td><p>Name is a mandatory string containing the name of the CRI library. Supported values are <code>docker</code> and <code>containerd</code>.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.CRIName>CRIName
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.CRIConfig>CRIConfig</a>)</p><p><p>CRIName is a type alias for the CRI name string.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.CloudConfig>CloudConfig</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigStatus>OperatingSystemConfigStatus</a>)</p><p><p>CloudConfig contains the generated output for the given operating system
config spec. It contains a reference to a secret as the result may contain confidential data.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the actual result of the generated cloud config.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ClusterSpec>ClusterSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Cluster>Cluster</a>)</p><p><p>ClusterSpec is the spec for a Cluster resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>cloudProfile</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>CloudProfile is a raw extension field that contains the cloudprofile resource referenced
by the shoot that has to be reconciled.</p></td></tr><tr><td><code>seed</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>Seed is a raw extension field that contains the seed resource referenced by the shoot that
has to be reconciled.</p></td></tr><tr><td><code>shoot</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><p>Shoot is a raw extension field that contains the shoot resource that has to be reconciled.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ContainerRuntimeSpec>ContainerRuntimeSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntime>ContainerRuntime</a>)</p><p><p>ContainerRuntimeSpec is the spec for a ContainerRuntime resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>binaryPath</code></br><em>string</em></td><td><p>BinaryPath is the Worker’s machine path where container runtime extensions should copy the binaries to.</p></td></tr><tr><td><code>workerPool</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeWorkerPool>ContainerRuntimeWorkerPool</a></em></td><td><p>WorkerPool identifies the worker pool of the Shoot.
For each worker pool and type, Gardener deploys a ContainerRuntime CRD.</p></td></tr><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ContainerRuntimeStatus>ContainerRuntimeStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntime>ContainerRuntime</a>)</p><p><p>ContainerRuntimeStatus is the status for a ContainerRuntime resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ContainerRuntimeWorkerPool>ContainerRuntimeWorkerPool</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeSpec>ContainerRuntimeSpec</a>)</p><p><p>ContainerRuntimeWorkerPool identifies a Shoot worker pool by its name and selector.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name specifies the name of the worker pool the container runtime should be available for.
This field is immutable.</p></td></tr><tr><td><code>selector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><p>Selector is the label selector used by the extension to match the nodes belonging to the worker pool.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ControlPlaneSpec>ControlPlaneSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.ControlPlane>ControlPlane</a>)</p><p><p>ControlPlaneSpec is the spec of a ControlPlane resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.Purpose>Purpose</a></em></td><td><em>(Optional)</em><p>Purpose contains the data if a cloud provider needs additional components in order to expose the control plane.
This field is immutable.</p></td></tr><tr><td><code>infrastructureProviderStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>InfrastructureProviderStatus contains the provider status that has
been generated by the controller responsible for the <code>Infrastructure</code> resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this control plane. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the cloud provider specific credentials.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ControlPlaneStatus>ControlPlaneStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.ControlPlane>ControlPlane</a>)</p><p><p>ControlPlaneStatus is the status of a ControlPlane resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DNSRecordSpec>DNSRecordSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.DNSRecord>DNSRecord</a>)</p><p><p>DNSRecordSpec is the spec of a DNSRecord resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the cloud provider specific credentials.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><em>(Optional)</em><p>Region is the region of this DNS record. If not specified, the region specified in SecretRef will be used.
If that is also not specified, the extension controller will use its default region.</p></td></tr><tr><td><code>zone</code></br><em>string</em></td><td><em>(Optional)</em><p>Zone is the DNS hosted zone of this DNS record. If not specified, it will be determined automatically by
getting all hosted zones of the account and searching for the longest zone name that is a suffix of Name.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the fully qualified domain name, e.g. “api.<shoot domain>”. This field is immutable.</p></td></tr><tr><td><code>recordType</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DNSRecordType>DNSRecordType</a></em></td><td><p>RecordType is the DNS record type. Only A, CNAME, and TXT records are currently supported. This field is immutable.</p></td></tr><tr><td><code>values</code></br><em>[]string</em></td><td><p>Values is a list of IP addresses for A records, a single hostname for CNAME records, or a list of texts for TXT records.</p></td></tr><tr><td><code>ttl</code></br><em>int64</em></td><td><em>(Optional)</em><p>TTL is the time to live in seconds. Defaults to 120.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DNSRecordStatus>DNSRecordStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.DNSRecord>DNSRecord</a>)</p><p><p>DNSRecordStatus is the status of a DNSRecord resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>zone</code></br><em>string</em></td><td><em>(Optional)</em><p>Zone is the DNS hosted zone of this DNS record.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DNSRecordType>DNSRecordType
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.DNSRecordSpec>DNSRecordSpec</a>)</p><p><p>DNSRecordType is a string alias.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.DataVolume>DataVolume</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.WorkerPool>WorkerPool</a>)</p><p><p>DataVolume contains information about a data volume.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name of the volume to make it referencable.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><em>(Optional)</em><p>Type is the type of the volume.</p></td></tr><tr><td><code>size</code></br><em>string</em></td><td><p>Size is the of the root volume.</p></td></tr><tr><td><code>encrypted</code></br><em>bool</em></td><td><em>(Optional)</em><p>Encrypted determines if the volume should be encrypted.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BackupBucketSpec>BackupBucketSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.BackupEntrySpec>BackupEntrySpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeSpec>ContainerRuntimeSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.ControlPlaneSpec>ControlPlaneSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.DNSRecordSpec>DNSRecordSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.ExtensionSpec>ExtensionSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.InfrastructureSpec>InfrastructureSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.NetworkSpec>NetworkSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</a>,
<a href=#extensions.gardener.cloud/v1alpha1.WorkerSpec>WorkerSpec</a>)</p><p><p>DefaultSpec contains common status fields for every extension resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em>string</em></td><td><p>Type contains the instance of the resource’s kind.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is the provider specific configuration.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.BackupBucketStatus>BackupBucketStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.BackupEntryStatus>BackupEntryStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.BastionStatus>BastionStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.ContainerRuntimeStatus>ContainerRuntimeStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.ControlPlaneStatus>ControlPlaneStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.DNSRecordStatus>DNSRecordStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.ExtensionStatus>ExtensionStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.InfrastructureStatus>InfrastructureStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.NetworkStatus>NetworkStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigStatus>OperatingSystemConfigStatus</a>,
<a href=#extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</a>)</p><p><p>DefaultStatus contains common status fields for every extension resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>providerStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderStatus contains provider-specific status.</p></td></tr><tr><td><code>conditions</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.Condition>[]github.com/gardener/gardener/pkg/apis/core/v1beta1.Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a Seed’s current state.</p></td></tr><tr><td><code>lastError</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.LastError>github.com/gardener/gardener/pkg/apis/core/v1beta1.LastError</a></em></td><td><em>(Optional)</em><p>LastError holds information about the last occurred error during an operation.</p></td></tr><tr><td><code>lastOperation</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.LastOperation>github.com/gardener/gardener/pkg/apis/core/v1beta1.LastOperation</a></em></td><td><em>(Optional)</em><p>LastOperation holds information about the last operation on the resource.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><p>ObservedGeneration is the most recent generation observed for this resource.</p></td></tr><tr><td><code>state</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>State can be filled by the operating controller with what ever data it needs.</p></td></tr><tr><td><code>resources</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.NamedResourceReference>[]github.com/gardener/gardener/pkg/apis/core/v1beta1.NamedResourceReference</a></em></td><td><em>(Optional)</em><p>Resources holds a list of named resource references that can be referred to in the state by their names.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.DropIn>DropIn</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Unit>Unit</a>)</p><p><p>DropIn is a drop-in configuration for a systemd unit.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the drop-in.</p></td></tr><tr><td><code>content</code></br><em>string</em></td><td><p>Content is the content of the drop-in.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ExtensionSpec>ExtensionSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Extension>Extension</a>)</p><p><p>ExtensionSpec is the spec for a Extension resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.ExtensionStatus>ExtensionStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Extension>Extension</a>)</p><p><p>ExtensionStatus is the status for a Extension resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.File>File</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</a>)</p><p><p>File is a file that should get written to the host’s file system. The content can either be inlined or
referenced from a secret in the same namespace.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>path</code></br><em>string</em></td><td><p>Path is the path of the file system where the file should get written to.</p></td></tr><tr><td><code>permissions</code></br><em>int32</em></td><td><em>(Optional)</em><p>Permissions describes with which permissions the file should get written to the file system.
Should be defaulted to octal 0644.</p></td></tr><tr><td><code>content</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.FileContent>FileContent</a></em></td><td><p>Content describe the file’s content.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.FileCodecID>FileCodecID
(<code>string</code> alias)</p></h3><p><p>FileCodecID is the id of a FileCodec for cloud-init scripts.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.FileContent>FileContent</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.File>File</a>)</p><p><p>FileContent can either reference a secret or contain inline configuration.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>secretRef</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.FileContentSecretRef>FileContentSecretRef</a></em></td><td><em>(Optional)</em><p>SecretRef is a struct that contains information about the referenced secret.</p></td></tr><tr><td><code>inline</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.FileContentInline>FileContentInline</a></em></td><td><em>(Optional)</em><p>Inline is a struct that contains information about the inlined data.</p></td></tr><tr><td><code>transmitUnencoded</code></br><em>bool</em></td><td><em>(Optional)</em><p>TransmitUnencoded set to true will ensure that the os-extension does not encode the file content when sent to the node.
This for example can be used to manipulate the clear-text content before it reaches the node.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.FileContentInline>FileContentInline</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.FileContent>FileContent</a>)</p><p><p>FileContentInline contains keys for inlining a file content’s data and encoding.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>encoding</code></br><em>string</em></td><td><p>Encoding is the file’s encoding (e.g. base64).</p></td></tr><tr><td><code>data</code></br><em>string</em></td><td><p>Data is the file’s data.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.FileContentSecretRef>FileContentSecretRef</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.FileContent>FileContent</a>)</p><p><p>FileContentSecretRef contains keys for referencing a file content’s data from a secret in the same namespace.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the secret.</p></td></tr><tr><td><code>dataKey</code></br><em>string</em></td><td><p>DataKey is the key in the secret’s <code>.data</code> field that should be read.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.InfrastructureSpec>InfrastructureSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Infrastructure>Infrastructure</a>)</p><p><p>InfrastructureSpec is the spec for an Infrastructure resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the region of this infrastructure. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the actual result of the generated cloud config.</p></td></tr><tr><td><code>sshPublicKey</code></br><em>[]byte</em></td><td><em>(Optional)</em><p>SSHPublicKey is the public SSH key that should be used with this infrastructure.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.InfrastructureStatus>InfrastructureStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Infrastructure>Infrastructure</a>)</p><p><p>InfrastructureStatus is the status for an Infrastructure resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>nodesCIDR</code></br><em>string</em></td><td><em>(Optional)</em><p>NodesCIDR is the CIDR of the node network that was optionally created by the acting extension controller.
This might be needed in environments in which the CIDR for the network for the shoot worker node cannot
be statically defined in the Shoot resource but must be computed dynamically.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.MachineDeployment>MachineDeployment</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</a>)</p><p><p>MachineDeployment is a created machine deployment.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the <code>MachineDeployment</code> resource.</p></td></tr><tr><td><code>minimum</code></br><em>int32</em></td><td><p>Minimum is the minimum number for this machine deployment.</p></td></tr><tr><td><code>maximum</code></br><em>int32</em></td><td><p>Maximum is the maximum number for this machine deployment.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.MachineImage>MachineImage</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.WorkerPool>WorkerPool</a>)</p><p><p>MachineImage contains logical information about the name and the version of the machie image that
should be used. The logical information must be mapped to the provider-specific information (e.g.,
AMIs, …) by the provider itself.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the logical name of the machine image.</p></td></tr><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the version of the machine image.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.NetworkSpec>NetworkSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Network>Network</a>)</p><p><p>NetworkSpec is the spec for an Network resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>podCIDR</code></br><em>string</em></td><td><p>PodCIDR defines the CIDR that will be used for pods. This field is immutable.</p></td></tr><tr><td><code>serviceCIDR</code></br><em>string</em></td><td><p>ServiceCIDR defines the CIDR that will be used for services. This field is immutable.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.NetworkStatus>NetworkStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Network>Network</a>)</p><p><p>NetworkStatus is the status for an Network resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.NodeTemplate>NodeTemplate</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.WorkerPool>WorkerPool</a>)</p><p><p>NodeTemplate contains information about the expected node properties.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>capacity</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#resourcelist-v1-core>Kubernetes core/v1.ResourceList</a></em></td><td><p>Capacity represents the expected Node capacity.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Object>Object</h3><p><p>Object is an extension object resource.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.OperatingSystemConfigPurpose>OperatingSystemConfigPurpose
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</a>)</p><p><p>OperatingSystemConfigPurpose is a string alias.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfig>OperatingSystemConfig</a>)</p><p><p>OperatingSystemConfigSpec is the spec for a OperatingSystemConfig resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>criConfig</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.CRIConfig>CRIConfig</a></em></td><td><em>(Optional)</em><p>CRI config is a structure contains configurations of the CRI library</p></td></tr><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>purpose</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigPurpose>OperatingSystemConfigPurpose</a></em></td><td><p>Purpose describes how the result of this OperatingSystemConfig is used by Gardener. Either it
gets sent to the <code>Worker</code> extension controller to bootstrap a VM, or it is downloaded by the
cloud-config-downloader script already running on a bootstrapped VM.
This field is immutable.</p></td></tr><tr><td><code>reloadConfigFilePath</code></br><em>string</em></td><td><em>(Optional)</em><p>ReloadConfigFilePath is the path to the generated operating system configuration. If set, controllers
are asked to use it when determining the .status.command of this resource. For example, if for CoreOS
the reload-path might be “/var/lib/config”; then the controller shall set .status.command to
“/usr/bin/coreos-cloudinit –from-file=/var/lib/config”.</p></td></tr><tr><td><code>units</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.Unit>[]Unit</a></em></td><td><em>(Optional)</em><p>Units is a list of unit for the operating system configuration (usually, a systemd unit).</p></td></tr><tr><td><code>files</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.File>[]File</a></em></td><td><em>(Optional)</em><p>Files is a list of files that should get written to the host’s file system.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.OperatingSystemConfigStatus>OperatingSystemConfigStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfig>OperatingSystemConfig</a>)</p><p><p>OperatingSystemConfigStatus is the status for a OperatingSystemConfig resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>cloudConfig</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.CloudConfig>CloudConfig</a></em></td><td><em>(Optional)</em><p>CloudConfig is a structure for containing the generated output for the given operating system
config spec. It contains a reference to a secret as the result may contain confidential data.</p></td></tr><tr><td><code>command</code></br><em>string</em></td><td><em>(Optional)</em><p>Command is the command whose execution renews/reloads the cloud config on an existing VM, e.g.
“/usr/bin/reload-cloud-config -from-file=<path>”. The <path>is optionally provided by Gardener
in the .spec.reloadConfigFilePath field.</p></td></tr><tr><td><code>units</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Units is a list of systemd unit names that are part of the generated Cloud Config and shall be
restarted when a new version has been downloaded.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Purpose>Purpose
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.ControlPlaneSpec>ControlPlaneSpec</a>)</p><p><p>Purpose is a string alias.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.Spec>Spec</h3><p><p>Spec is the spec section of an Object.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.Status>Status</h3><p><p>Status is the status of an Object.</p></p><h3 id=extensions.gardener.cloud/v1alpha1.Unit>Unit</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.OperatingSystemConfigSpec>OperatingSystemConfigSpec</a>)</p><p><p>Unit is a unit for the operating system configuration (usually, a systemd unit).</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of a unit.</p></td></tr><tr><td><code>command</code></br><em>string</em></td><td><em>(Optional)</em><p>Command is the unit’s command.</p></td></tr><tr><td><code>enable</code></br><em>bool</em></td><td><em>(Optional)</em><p>Enable describes whether the unit is enabled or not.</p></td></tr><tr><td><code>content</code></br><em>string</em></td><td><em>(Optional)</em><p>Content is the unit’s content.</p></td></tr><tr><td><code>dropIns</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DropIn>[]DropIn</a></em></td><td><em>(Optional)</em><p>DropIns is a list of drop-ins for this unit.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.Volume>Volume</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.WorkerPool>WorkerPool</a>)</p><p><p>Volume contains information about the root disks that should be used for worker pools.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><em>(Optional)</em><p>Name of the volume to make it referencable.</p></td></tr><tr><td><code>type</code></br><em>string</em></td><td><em>(Optional)</em><p>Type is the type of the volume.</p></td></tr><tr><td><code>size</code></br><em>string</em></td><td><p>Size is the of the root volume.</p></td></tr><tr><td><code>encrypted</code></br><em>bool</em></td><td><em>(Optional)</em><p>Encrypted determines if the volume should be encrypted.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.WorkerPool>WorkerPool</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.WorkerSpec>WorkerSpec</a>)</p><p><p>WorkerPool is the definition of a specific worker pool.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>machineType</code></br><em>string</em></td><td><p>MachineType contains information about the machine type that should be used for this worker pool.</p></td></tr><tr><td><code>maximum</code></br><em>int32</em></td><td><p>Maximum is the maximum size of the worker pool.</p></td></tr><tr><td><code>maxSurge</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/util/intstr#IntOrString>k8s.io/apimachinery/pkg/util/intstr.IntOrString</a></em></td><td><p>MaxSurge is maximum number of VMs that are created during an update.</p></td></tr><tr><td><code>maxUnavailable</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/util/intstr#IntOrString>k8s.io/apimachinery/pkg/util/intstr.IntOrString</a></em></td><td><p>MaxUnavailable is the maximum number of VMs that can be unavailable during an update.</p></td></tr><tr><td><code>annotations</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Annotations is a map of key/value pairs for annotations for all the <code>Node</code> objects in this worker pool.</p></td></tr><tr><td><code>labels</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Labels is a map of key/value pairs for labels for all the <code>Node</code> objects in this worker pool.</p></td></tr><tr><td><code>taints</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#taint-v1-core>[]Kubernetes core/v1.Taint</a></em></td><td><em>(Optional)</em><p>Taints is a list of taints for all the <code>Node</code> objects in this worker pool.</p></td></tr><tr><td><code>machineImage</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.MachineImage>MachineImage</a></em></td><td><p>MachineImage contains logical information about the name and the version of the machie image that
should be used. The logical information must be mapped to the provider-specific information (e.g.,
AMIs, …) by the provider itself.</p></td></tr><tr><td><code>minimum</code></br><em>int32</em></td><td><p>Minimum is the minimum size of the worker pool.</p></td></tr><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of this worker pool.</p></td></tr><tr><td><code>providerConfig</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>ProviderConfig is a provider specific configuration for the worker pool.</p></td></tr><tr><td><code>userData</code></br><em>[]byte</em></td><td><p>UserData is a base64-encoded string that contains the data that is sent to the provider’s APIs
when a new machine/VM that is part of this worker pool shall be spawned.</p></td></tr><tr><td><code>volume</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.Volume>Volume</a></em></td><td><em>(Optional)</em><p>Volume contains information about the root disks that should be used for this worker pool.</p></td></tr><tr><td><code>dataVolumes</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DataVolume>[]DataVolume</a></em></td><td><em>(Optional)</em><p>DataVolumes contains a list of additional worker volumes.</p></td></tr><tr><td><code>kubeletDataVolumeName</code></br><em>string</em></td><td><em>(Optional)</em><p>KubeletDataVolumeName contains the name of a dataVolume that should be used for storing kubelet state.</p></td></tr><tr><td><code>zones</code></br><em>[]string</em></td><td><em>(Optional)</em><p>Zones contains information about availability zones for this worker pool.</p></td></tr><tr><td><code>machineControllerManager</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.MachineControllerManagerSettings>github.com/gardener/gardener/pkg/apis/core/v1beta1.MachineControllerManagerSettings</a></em></td><td><em>(Optional)</em><p>MachineControllerManagerSettings contains configurations for different worker-pools. Eg. MachineDrainTimeout, MachineHealthTimeout.</p></td></tr><tr><td><code>kubernetesVersion</code></br><em>string</em></td><td><em>(Optional)</em><p>KubernetesVersion is the kubernetes version in this worker pool</p></td></tr><tr><td><code>nodeTemplate</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.NodeTemplate>NodeTemplate</a></em></td><td><em>(Optional)</em><p>NodeTemplate contains resource information of the machine which is used by Cluster Autoscaler to generate nodeTemplate during scaling a nodeGroup from zero</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.WorkerSpec>WorkerSpec</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Worker>Worker</a>)</p><p><p>WorkerSpec is the spec for a Worker resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultSpec</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultSpec>DefaultSpec</a></em></td><td><p>(Members of <code>DefaultSpec</code> are embedded into this type.)</p><p>DefaultSpec is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>infrastructureProviderStatus</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>InfrastructureProviderStatus is a raw extension field that contains the provider status that has
been generated by the controller responsible for the <code>Infrastructure</code> resource.</p></td></tr><tr><td><code>region</code></br><em>string</em></td><td><p>Region is the name of the region where the worker pool should be deployed to. This field is immutable.</p></td></tr><tr><td><code>secretRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#secretreference-v1-core>Kubernetes core/v1.SecretReference</a></em></td><td><p>SecretRef is a reference to a secret that contains the cloud provider specific credentials.</p></td></tr><tr><td><code>sshPublicKey</code></br><em>[]byte</em></td><td><em>(Optional)</em><p>SSHPublicKey is the public SSH key that should be used with these workers.</p></td></tr><tr><td><code>pools</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.WorkerPool>[]WorkerPool</a></em></td><td><p>Pools is a list of worker pools.</p></td></tr></tbody></table><h3 id=extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</h3><p>(<em>Appears on:</em>
<a href=#extensions.gardener.cloud/v1alpha1.Worker>Worker</a>)</p><p><p>WorkerStatus is the status for a Worker resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>DefaultStatus</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.DefaultStatus>DefaultStatus</a></em></td><td><p>(Members of <code>DefaultStatus</code> are embedded into this type.)</p><p>DefaultStatus is a structure containing common fields used by all extension resources.</p></td></tr><tr><td><code>machineDeployments</code></br><em><a href=#extensions.gardener.cloud/v1alpha1.MachineDeployment>[]MachineDeployment</a></em></td><td><p>MachineDeployments is a list of created machine deployments. It will be used to e.g. configure
the cluster-autoscaler properly.</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-bf08e7ef74854170c72dba9d178a3302>1.4 - Operations</h1><p>Packages:</p><ul><li><a href=#operations.gardener.cloud%2fv1alpha1>operations.gardener.cloud/v1alpha1</a></li></ul><h2 id=operations.gardener.cloud/v1alpha1>operations.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 is a version of the API.</p></p>Resource Types:<ul><li><a href=#operations.gardener.cloud/v1alpha1.Bastion>Bastion</a></li></ul><h3 id=operations.gardener.cloud/v1alpha1.Bastion>Bastion</h3><p><p>Bastion holds details about an SSH bastion for a shoot cluster.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>operations.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>Bastion</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#operations.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</a></em></td><td><p>Specification of the Bastion.</p><br><br><table><tr><td><code>shootRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>Kubernetes core/v1.LocalObjectReference</a></em></td><td><p>ShootRef defines the target shoot for a Bastion. The name field of the ShootRef is immutable.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed to which this Bastion is currently scheduled. This field is populated
at the beginning of a create/reconcile operation.</p></td></tr><tr><td><code>providerType</code></br><em>string</em></td><td><em>(Optional)</em><p>ProviderType is cloud provider used by the referenced Shoot.</p></td></tr><tr><td><code>sshPublicKey</code></br><em>string</em></td><td><p>SSHPublicKey is the user’s public key. This field is immutable.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#operations.gardener.cloud/v1alpha1.BastionIngressPolicy>[]BastionIngressPolicy</a></em></td><td><p>Ingress controls from where the created bastion host should be reachable.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#operations.gardener.cloud/v1alpha1.BastionStatus>BastionStatus</a></em></td><td><em>(Optional)</em><p>Most recently observed status of the Bastion.</p></td></tr></tbody></table><h3 id=operations.gardener.cloud/v1alpha1.BastionIngressPolicy>BastionIngressPolicy</h3><p>(<em>Appears on:</em>
<a href=#operations.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</a>)</p><p><p>BastionIngressPolicy represents an ingress policy for SSH bastion hosts.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>ipBlock</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#ipblock-v1-networking>Kubernetes networking/v1.IPBlock</a></em></td><td><p>IPBlock defines an IP block that is allowed to access the bastion.</p></td></tr></tbody></table><h3 id=operations.gardener.cloud/v1alpha1.BastionSpec>BastionSpec</h3><p>(<em>Appears on:</em>
<a href=#operations.gardener.cloud/v1alpha1.Bastion>Bastion</a>)</p><p><p>BastionSpec is the specification of a Bastion.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>shootRef</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>Kubernetes core/v1.LocalObjectReference</a></em></td><td><p>ShootRef defines the target shoot for a Bastion. The name field of the ShootRef is immutable.</p></td></tr><tr><td><code>seedName</code></br><em>string</em></td><td><em>(Optional)</em><p>SeedName is the name of the seed to which this Bastion is currently scheduled. This field is populated
at the beginning of a create/reconcile operation.</p></td></tr><tr><td><code>providerType</code></br><em>string</em></td><td><em>(Optional)</em><p>ProviderType is cloud provider used by the referenced Shoot.</p></td></tr><tr><td><code>sshPublicKey</code></br><em>string</em></td><td><p>SSHPublicKey is the user’s public key. This field is immutable.</p></td></tr><tr><td><code>ingress</code></br><em><a href=#operations.gardener.cloud/v1alpha1.BastionIngressPolicy>[]BastionIngressPolicy</a></em></td><td><p>Ingress controls from where the created bastion host should be reachable.</p></td></tr></tbody></table><h3 id=operations.gardener.cloud/v1alpha1.BastionStatus>BastionStatus</h3><p>(<em>Appears on:</em>
<a href=#operations.gardener.cloud/v1alpha1.Bastion>Bastion</a>)</p><p><p>BastionStatus holds the most recently observed status of the Bastion.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>ingress</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#loadbalanceringress-v1-core>Kubernetes core/v1.LoadBalancerIngress</a></em></td><td><em>(Optional)</em><p>Ingress holds the public IP and/or hostname of the bastion instance.</p></td></tr><tr><td><code>conditions</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1alpha1.Condition>[]github.com/gardener/gardener/pkg/apis/core/v1alpha1.Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a Bastion’s current state.</p></td></tr><tr><td><code>lastHeartbeatTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>LastHeartbeatTimestamp is the time when the bastion was last marked as
not to be deleted. When this is set, the ExpirationTimestamp is advanced
as well.</p></td></tr><tr><td><code>expirationTimestamp</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><em>(Optional)</em><p>ExpirationTimestamp is the time after which a Bastion is supposed to be
garbage collected.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><em>(Optional)</em><p>ObservedGeneration is the most recent generation observed for this Bastion. It corresponds to the
Bastion’s generation, which is updated on mutation by the API Server.</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-eb894f4ab7d87e13a51f4c08831e9f0a>1.5 - Provider Local</h1><p>Packages:</p><ul><li><a href=#local.provider.extensions.gardener.cloud%2fv1alpha1>local.provider.extensions.gardener.cloud/v1alpha1</a></li></ul><h2 id=local.provider.extensions.gardener.cloud/v1alpha1>local.provider.extensions.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 contains the local provider API resources.</p></p>Resource Types:<ul><li><a href=#local.provider.extensions.gardener.cloud/v1alpha1.CloudProfileConfig>CloudProfileConfig</a></li><li><a href=#local.provider.extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</a></li></ul><h3 id=local.provider.extensions.gardener.cloud/v1alpha1.CloudProfileConfig>CloudProfileConfig</h3><p><p>CloudProfileConfig contains provider-specific configuration that is embedded into Gardener&rsquo;s <code>CloudProfile</code>
resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>local.provider.extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>CloudProfileConfig</code></td></tr><tr><td><code>machineImages</code></br><em><a href=#local.provider.extensions.gardener.cloud/v1alpha1.MachineImages>[]MachineImages</a></em></td><td><p>MachineImages is the list of machine images that are understood by the controller. It maps
logical names and versions to provider-specific identifiers.</p></td></tr></tbody></table><h3 id=local.provider.extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</h3><p><p>WorkerStatus contains information about created worker resources.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>local.provider.extensions.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>WorkerStatus</code></td></tr><tr><td><code>machineImages</code></br><em><a href=#local.provider.extensions.gardener.cloud/v1alpha1.MachineImage>[]MachineImage</a></em></td><td><em>(Optional)</em><p>MachineImages is a list of machine images that have been used in this worker. Usually, the extension controller
gets the mapping from name/version to the provider-specific machine image data from the CloudProfile. However, if
a version that is still in use gets removed from this componentconfig it cannot reconcile anymore existing <code>Worker</code>
resources that are still using this version. Hence, it stores the used versions in the provider status to ensure
reconciliation is possible.</p></td></tr></tbody></table><h3 id=local.provider.extensions.gardener.cloud/v1alpha1.MachineImage>MachineImage</h3><p>(<em>Appears on:</em>
<a href=#local.provider.extensions.gardener.cloud/v1alpha1.WorkerStatus>WorkerStatus</a>)</p><p><p>MachineImage is a mapping from logical names and versions to provider-specific machine image data.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the logical name of the machine image.</p></td></tr><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the logical version of the machine image.</p></td></tr><tr><td><code>image</code></br><em>string</em></td><td><p>Image is the image for the machine image.</p></td></tr></tbody></table><h3 id=local.provider.extensions.gardener.cloud/v1alpha1.MachineImageVersion>MachineImageVersion</h3><p>(<em>Appears on:</em>
<a href=#local.provider.extensions.gardener.cloud/v1alpha1.MachineImages>MachineImages</a>)</p><p><p>MachineImageVersion contains a version and a provider-specific identifier.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>version</code></br><em>string</em></td><td><p>Version is the version of the image.</p></td></tr><tr><td><code>image</code></br><em>string</em></td><td><p>Image is the image for the machine image.</p></td></tr></tbody></table><h3 id=local.provider.extensions.gardener.cloud/v1alpha1.MachineImages>MachineImages</h3><p>(<em>Appears on:</em>
<a href=#local.provider.extensions.gardener.cloud/v1alpha1.CloudProfileConfig>CloudProfileConfig</a>)</p><p><p>MachineImages is a mapping from logical names and versions to provider-specific identifiers.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the logical name of the machine image.</p></td></tr><tr><td><code>versions</code></br><em><a href=#local.provider.extensions.gardener.cloud/v1alpha1.MachineImageVersion>[]MachineImageVersion</a></em></td><td><p>Versions contains versions and a provider-specific identifier.</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-b81a90a686c2492e4425c61e5875a5aa>1.6 - Resources</h1><p>Packages:</p><ul><li><a href=#resources.gardener.cloud%2fv1alpha1>resources.gardener.cloud/v1alpha1</a></li></ul><h2 id=resources.gardener.cloud/v1alpha1>resources.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 contains the configuration of the Gardener Resource Manager.</p></p>Resource Types:<ul></ul><h3 id=resources.gardener.cloud/v1alpha1.ManagedResource>ManagedResource</h3><p><p>ManagedResource describes a list of managed resources.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#resources.gardener.cloud/v1alpha1.ManagedResourceSpec>ManagedResourceSpec</a></em></td><td><p>Spec contains the specification of this managed resource.</p><br><br><table><tr><td><code>class</code></br><em>string</em></td><td><em>(Optional)</em><p>Class holds the resource class used to control the responsibility for multiple resource manager instances</p></td></tr><tr><td><code>secretRefs</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>[]Kubernetes core/v1.LocalObjectReference</a></em></td><td><p>SecretRefs is a list of secret references.</p></td></tr><tr><td><code>injectLabels</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>InjectLabels injects the provided labels into every resource that is part of the referenced secrets.</p></td></tr><tr><td><code>forceOverwriteLabels</code></br><em>bool</em></td><td><em>(Optional)</em><p>ForceOverwriteLabels specifies that all existing labels should be overwritten. Defaults to false.</p></td></tr><tr><td><code>forceOverwriteAnnotations</code></br><em>bool</em></td><td><em>(Optional)</em><p>ForceOverwriteAnnotations specifies that all existing annotations should be overwritten. Defaults to false.</p></td></tr><tr><td><code>keepObjects</code></br><em>bool</em></td><td><em>(Optional)</em><p>KeepObjects specifies whether the objects should be kept although the managed resource has already been deleted.
Defaults to false.</p></td></tr><tr><td><code>equivalences</code></br><em>[][]k8s.io/apimachinery/pkg/apis/meta/v1.GroupKind</em></td><td><em>(Optional)</em><p>Equivalences specifies possible group/kind equivalences for objects.</p></td></tr><tr><td><code>deletePersistentVolumeClaims</code></br><em>bool</em></td><td><em>(Optional)</em><p>DeletePersistentVolumeClaims specifies if PersistentVolumeClaims created by StatefulSets, which are managed by this
resource, should also be deleted when the corresponding StatefulSet is deleted (defaults to false).</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#resources.gardener.cloud/v1alpha1.ManagedResourceStatus>ManagedResourceStatus</a></em></td><td><p>Status contains the status of this managed resource.</p></td></tr></tbody></table><h3 id=resources.gardener.cloud/v1alpha1.ManagedResourceSpec>ManagedResourceSpec</h3><p>(<em>Appears on:</em>
<a href=#resources.gardener.cloud/v1alpha1.ManagedResource>ManagedResource</a>)</p><p><p>ManagedResourceSpec contains the specification of this managed resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>class</code></br><em>string</em></td><td><em>(Optional)</em><p>Class holds the resource class used to control the responsibility for multiple resource manager instances</p></td></tr><tr><td><code>secretRefs</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#localobjectreference-v1-core>[]Kubernetes core/v1.LocalObjectReference</a></em></td><td><p>SecretRefs is a list of secret references.</p></td></tr><tr><td><code>injectLabels</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>InjectLabels injects the provided labels into every resource that is part of the referenced secrets.</p></td></tr><tr><td><code>forceOverwriteLabels</code></br><em>bool</em></td><td><em>(Optional)</em><p>ForceOverwriteLabels specifies that all existing labels should be overwritten. Defaults to false.</p></td></tr><tr><td><code>forceOverwriteAnnotations</code></br><em>bool</em></td><td><em>(Optional)</em><p>ForceOverwriteAnnotations specifies that all existing annotations should be overwritten. Defaults to false.</p></td></tr><tr><td><code>keepObjects</code></br><em>bool</em></td><td><em>(Optional)</em><p>KeepObjects specifies whether the objects should be kept although the managed resource has already been deleted.
Defaults to false.</p></td></tr><tr><td><code>equivalences</code></br><em>[][]k8s.io/apimachinery/pkg/apis/meta/v1.GroupKind</em></td><td><em>(Optional)</em><p>Equivalences specifies possible group/kind equivalences for objects.</p></td></tr><tr><td><code>deletePersistentVolumeClaims</code></br><em>bool</em></td><td><em>(Optional)</em><p>DeletePersistentVolumeClaims specifies if PersistentVolumeClaims created by StatefulSets, which are managed by this
resource, should also be deleted when the corresponding StatefulSet is deleted (defaults to false).</p></td></tr></tbody></table><h3 id=resources.gardener.cloud/v1alpha1.ManagedResourceStatus>ManagedResourceStatus</h3><p>(<em>Appears on:</em>
<a href=#resources.gardener.cloud/v1alpha1.ManagedResource>ManagedResource</a>)</p><p><p>ManagedResourceStatus is the status of a managed resource.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>conditions</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.Condition>[]github.com/gardener/gardener/pkg/apis/core/v1beta1.Condition</a></em></td><td></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><p>ObservedGeneration is the most recent generation observed for this resource.</p></td></tr><tr><td><code>resources</code></br><em><a href=#resources.gardener.cloud/v1alpha1.ObjectReference>[]ObjectReference</a></em></td><td><em>(Optional)</em><p>Resources is a list of objects that have been created.</p></td></tr></tbody></table><h3 id=resources.gardener.cloud/v1alpha1.ObjectReference>ObjectReference</h3><p>(<em>Appears on:</em>
<a href=#resources.gardener.cloud/v1alpha1.ManagedResourceStatus>ManagedResourceStatus</a>)</p><p><p>ObjectReference is a reference to another object.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>ObjectReference</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectreference-v1-core>Kubernetes core/v1.ObjectReference</a></em></td><td><p>(Members of <code>ObjectReference</code> are embedded into this type.)</p></td></tr><tr><td><code>labels</code></br><em>map[string]string</em></td><td><p>Labels is a map of labels that were used during last update of the resource.</p></td></tr><tr><td><code>annotations</code></br><em>map[string]string</em></td><td><p>Annotations is a map of annotations that were used during last update of the resource.</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-ba903207997565bcd7b1f010383f1b4f>1.7 - Seedmanagement</h1><p>Packages:</p><ul><li><a href=#seedmanagement.gardener.cloud%2fv1alpha1>seedmanagement.gardener.cloud/v1alpha1</a></li></ul><h2 id=seedmanagement.gardener.cloud/v1alpha1>seedmanagement.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 is a version of the API.</p></p>Resource Types:<ul><li><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeed>ManagedSeed</a></li><li><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSet>ManagedSeedSet</a></li></ul><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeed>ManagedSeed</h3><p><p>ManagedSeed represents a Shoot that is registered as Seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>seedmanagement.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ManagedSeed</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSpec>ManagedSeedSpec</a></em></td><td><em>(Optional)</em><p>Specification of the ManagedSeed.</p><br><br><table><tr><td><code>shoot</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Shoot>Shoot</a></em></td><td><em>(Optional)</em><p>Shoot references a Shoot that should be registered as Seed.
This field is immutable.</p></td></tr><tr><td><code>seedTemplate</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.SeedTemplate>github.com/gardener/gardener/pkg/apis/core/v1beta1.SeedTemplate</a></em></td><td><em>(Optional)</em><p>SeedTemplate is a template for a Seed object, that should be used to register a given cluster as a Seed.
Either SeedTemplate or Gardenlet must be specified. When Seed is specified, the ManagedSeed controller will not deploy a gardenlet into the cluster
and an existing gardenlet reconciling the new Seed is required.</p></td></tr><tr><td><code>gardenlet</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Gardenlet>Gardenlet</a></em></td><td><em>(Optional)</em><p>Gardenlet specifies that the ManagedSeed controller should deploy a gardenlet into the cluster
with the given deployment parameters and GardenletConfiguration.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedStatus>ManagedSeedStatus</a></em></td><td><em>(Optional)</em><p>Most recently observed status of the ManagedSeed.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSet>ManagedSeedSet</h3><p><p>ManagedSeedSet represents a set of identical ManagedSeeds.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>seedmanagement.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ManagedSeedSet</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetSpec>ManagedSeedSetSpec</a></em></td><td><em>(Optional)</em><p>Spec defines the desired identities of ManagedSeeds and Shoots in this set.</p><br><br><table><tr><td><code>replicas</code></br><em>int32</em></td><td><em>(Optional)</em><p>Replicas is the desired number of replicas of the given Template. Defaults to 1.</p></td></tr><tr><td><code>selector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><p>Selector is a label query over ManagedSeeds and Shoots that should match the replica count.
It must match the ManagedSeeds and Shoots template’s labels. This field is immutable.</p></td></tr><tr><td><code>template</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedTemplate>ManagedSeedTemplate</a></em></td><td><p>Template describes the ManagedSeed that will be created if insufficient replicas are detected.
Each ManagedSeed created / updated by the ManagedSeedSet will fulfill this template.</p></td></tr><tr><td><code>shootTemplate</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.ShootTemplate>github.com/gardener/gardener/pkg/apis/core/v1beta1.ShootTemplate</a></em></td><td><p>ShootTemplate describes the Shoot that will be created if insufficient replicas are detected for hosting the corresponding ManagedSeed.
Each Shoot created / updated by the ManagedSeedSet will fulfill this template.</p></td></tr><tr><td><code>updateStrategy</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.UpdateStrategy>UpdateStrategy</a></em></td><td><em>(Optional)</em><p>UpdateStrategy specifies the UpdateStrategy that will be
employed to update ManagedSeeds / Shoots in the ManagedSeedSet when a revision is made to
Template / ShootTemplate.</p></td></tr><tr><td><code>revisionHistoryLimit</code></br><em>int32</em></td><td><em>(Optional)</em><p>RevisionHistoryLimit is the maximum number of revisions that will be maintained
in the ManagedSeedSet’s revision history. Defaults to 10. This field is immutable.</p></td></tr></table></td></tr><tr><td><code>status</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetStatus>ManagedSeedSetStatus</a></em></td><td><em>(Optional)</em><p>Status is the current status of ManagedSeeds and Shoots in this ManagedSeedSet.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.Bootstrap>Bootstrap
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.Gardenlet>Gardenlet</a>)</p><p><p>Bootstrap describes a mechanism for bootstrapping gardenlet connection to the Garden cluster.</p></p><h3 id=seedmanagement.gardener.cloud/v1alpha1.Gardenlet>Gardenlet</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSpec>ManagedSeedSpec</a>)</p><p><p>Gardenlet specifies gardenlet deployment parameters and the GardenletConfiguration used to configure gardenlet.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>deployment</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.GardenletDeployment>GardenletDeployment</a></em></td><td><em>(Optional)</em><p>Deployment specifies certain gardenlet deployment parameters, such as the number of replicas,
the image, etc.</p></td></tr><tr><td><code>config</code></br><em><a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#RawExtension>k8s.io/apimachinery/pkg/runtime.RawExtension</a></em></td><td><em>(Optional)</em><p>Config is the GardenletConfiguration used to configure gardenlet.</p></td></tr><tr><td><code>bootstrap</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Bootstrap>Bootstrap</a></em></td><td><em>(Optional)</em><p>Bootstrap is the mechanism that should be used for bootstrapping gardenlet connection to the Garden cluster. One of ServiceAccount, BootstrapToken, None.
If set to ServiceAccount or BootstrapToken, a service account or a bootstrap token will be created in the garden cluster and used to compute the bootstrap kubeconfig.
If set to None, the gardenClientConnection.kubeconfig field will be used to connect to the Garden cluster. Defaults to BootstrapToken.
This field is immutable.</p></td></tr><tr><td><code>mergeWithParent</code></br><em>bool</em></td><td><em>(Optional)</em><p>MergeWithParent specifies whether the GardenletConfiguration of the parent gardenlet
should be merged with the specified GardenletConfiguration. Defaults to true. This field is immutable.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.GardenletDeployment>GardenletDeployment</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.Gardenlet>Gardenlet</a>)</p><p><p>GardenletDeployment specifies certain gardenlet deployment parameters, such as the number of replicas,
the image, etc.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>replicaCount</code></br><em>int32</em></td><td><em>(Optional)</em><p>ReplicaCount is the number of gardenlet replicas. Defaults to 1.</p></td></tr><tr><td><code>revisionHistoryLimit</code></br><em>int32</em></td><td><em>(Optional)</em><p>RevisionHistoryLimit is the number of old gardenlet ReplicaSets to retain to allow rollback. Defaults to 10.</p></td></tr><tr><td><code>serviceAccountName</code></br><em>string</em></td><td><em>(Optional)</em><p>ServiceAccountName is the name of the ServiceAccount to use to run gardenlet pods.</p></td></tr><tr><td><code>image</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Image>Image</a></em></td><td><em>(Optional)</em><p>Image is the gardenlet container image.</p></td></tr><tr><td><code>resources</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#resourcerequirements-v1-core>Kubernetes core/v1.ResourceRequirements</a></em></td><td><em>(Optional)</em><p>Resources are the compute resources required by the gardenlet container.</p></td></tr><tr><td><code>podLabels</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>PodLabels are the labels on gardenlet pods.</p></td></tr><tr><td><code>podAnnotations</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>PodAnnotations are the annotations on gardenlet pods.</p></td></tr><tr><td><code>additionalVolumes</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#volume-v1-core>[]Kubernetes core/v1.Volume</a></em></td><td><em>(Optional)</em><p>AdditionalVolumes is the list of additional volumes that should be mounted by gardenlet containers.</p></td></tr><tr><td><code>additionalVolumeMounts</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#volumemount-v1-core>[]Kubernetes core/v1.VolumeMount</a></em></td><td><em>(Optional)</em><p>AdditionalVolumeMounts is the list of additional pod volumes to mount into the gardenlet container’s filesystem.</p></td></tr><tr><td><code>env</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#envvar-v1-core>[]Kubernetes core/v1.EnvVar</a></em></td><td><em>(Optional)</em><p>Env is the list of environment variables to set in the gardenlet container.</p></td></tr><tr><td><code>vpa</code></br><em>bool</em></td><td><em>(Optional)</em><p>VPA specifies whether to enable VPA for gardenlet. Defaults to true.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.Image>Image</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.GardenletDeployment>GardenletDeployment</a>)</p><p><p>Image specifies container image parameters.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>repository</code></br><em>string</em></td><td><em>(Optional)</em><p>Repository is the image repository.</p></td></tr><tr><td><code>tag</code></br><em>string</em></td><td><em>(Optional)</em><p>Tag is the image tag.</p></td></tr><tr><td><code>pullPolicy</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#pullpolicy-v1-core>Kubernetes core/v1.PullPolicy</a></em></td><td><em>(Optional)</em><p>PullPolicy is the image pull policy. One of Always, Never, IfNotPresent.
Defaults to Always if latest tag is specified, or IfNotPresent otherwise.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetSpec>ManagedSeedSetSpec</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSet>ManagedSeedSet</a>)</p><p><p>ManagedSeedSetSpec is the specification of a ManagedSeedSet.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>replicas</code></br><em>int32</em></td><td><em>(Optional)</em><p>Replicas is the desired number of replicas of the given Template. Defaults to 1.</p></td></tr><tr><td><code>selector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><p>Selector is a label query over ManagedSeeds and Shoots that should match the replica count.
It must match the ManagedSeeds and Shoots template’s labels. This field is immutable.</p></td></tr><tr><td><code>template</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedTemplate>ManagedSeedTemplate</a></em></td><td><p>Template describes the ManagedSeed that will be created if insufficient replicas are detected.
Each ManagedSeed created / updated by the ManagedSeedSet will fulfill this template.</p></td></tr><tr><td><code>shootTemplate</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.ShootTemplate>github.com/gardener/gardener/pkg/apis/core/v1beta1.ShootTemplate</a></em></td><td><p>ShootTemplate describes the Shoot that will be created if insufficient replicas are detected for hosting the corresponding ManagedSeed.
Each Shoot created / updated by the ManagedSeedSet will fulfill this template.</p></td></tr><tr><td><code>updateStrategy</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.UpdateStrategy>UpdateStrategy</a></em></td><td><em>(Optional)</em><p>UpdateStrategy specifies the UpdateStrategy that will be
employed to update ManagedSeeds / Shoots in the ManagedSeedSet when a revision is made to
Template / ShootTemplate.</p></td></tr><tr><td><code>revisionHistoryLimit</code></br><em>int32</em></td><td><em>(Optional)</em><p>RevisionHistoryLimit is the maximum number of revisions that will be maintained
in the ManagedSeedSet’s revision history. Defaults to 10. This field is immutable.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetStatus>ManagedSeedSetStatus</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSet>ManagedSeedSet</a>)</p><p><p>ManagedSeedSetStatus represents the current state of a ManagedSeedSet.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><p>ObservedGeneration is the most recent generation observed for this ManagedSeedSet. It corresponds to the
ManagedSeedSet’s generation, which is updated on mutation by the API Server.</p></td></tr><tr><td><code>replicas</code></br><em>int32</em></td><td><p>Replicas is the number of replicas (ManagedSeeds and their corresponding Shoots) created by the ManagedSeedSet controller.</p></td></tr><tr><td><code>readyReplicas</code></br><em>int32</em></td><td><p>ReadyReplicas is the number of ManagedSeeds created by the ManagedSeedSet controller that have a Ready Condition.</p></td></tr><tr><td><code>nextReplicaNumber</code></br><em>int32</em></td><td><p>NextReplicaNumber is the ordinal number that will be assigned to the next replica of the ManagedSeedSet.</p></td></tr><tr><td><code>currentReplicas</code></br><em>int32</em></td><td><p>CurrentReplicas is the number of ManagedSeeds created by the ManagedSeedSet controller from the ManagedSeedSet version
indicated by CurrentRevision.</p></td></tr><tr><td><code>updatedReplicas</code></br><em>int32</em></td><td><p>UpdatedReplicas is the number of ManagedSeeds created by the ManagedSeedSet controller from the ManagedSeedSet version
indicated by UpdateRevision.</p></td></tr><tr><td><code>currentRevision</code></br><em>string</em></td><td><p>CurrentRevision, if not empty, indicates the version of the ManagedSeedSet used to generate ManagedSeeds with smaller
ordinal numbers during updates.</p></td></tr><tr><td><code>updateRevision</code></br><em>string</em></td><td><p>UpdateRevision, if not empty, indicates the version of the ManagedSeedSet used to generate ManagedSeeds with larger
ordinal numbers during updates</p></td></tr><tr><td><code>collisionCount</code></br><em>int32</em></td><td><em>(Optional)</em><p>CollisionCount is the count of hash collisions for the ManagedSeedSet. The ManagedSeedSet controller
uses this field as a collision avoidance mechanism when it needs to create the name for the
newest ControllerRevision.</p></td></tr><tr><td><code>conditions</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.Condition>[]github.com/gardener/gardener/pkg/apis/core/v1beta1.Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a ManagedSeedSet’s current state.</p></td></tr><tr><td><code>pendingReplica</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.PendingReplica>PendingReplica</a></em></td><td><em>(Optional)</em><p>PendingReplica, if not empty, indicates the replica that is currently pending creation, update, or deletion.
This replica is in a state that requires the controller to wait for it to change before advancing to the next replica.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSpec>ManagedSeedSpec</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeed>ManagedSeed</a>,
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedTemplate>ManagedSeedTemplate</a>)</p><p><p>ManagedSeedSpec is the specification of a ManagedSeed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>shoot</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Shoot>Shoot</a></em></td><td><em>(Optional)</em><p>Shoot references a Shoot that should be registered as Seed.
This field is immutable.</p></td></tr><tr><td><code>seedTemplate</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.SeedTemplate>github.com/gardener/gardener/pkg/apis/core/v1beta1.SeedTemplate</a></em></td><td><em>(Optional)</em><p>SeedTemplate is a template for a Seed object, that should be used to register a given cluster as a Seed.
Either SeedTemplate or Gardenlet must be specified. When Seed is specified, the ManagedSeed controller will not deploy a gardenlet into the cluster
and an existing gardenlet reconciling the new Seed is required.</p></td></tr><tr><td><code>gardenlet</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Gardenlet>Gardenlet</a></em></td><td><em>(Optional)</em><p>Gardenlet specifies that the ManagedSeed controller should deploy a gardenlet into the cluster
with the given deployment parameters and GardenletConfiguration.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeedStatus>ManagedSeedStatus</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeed>ManagedSeed</a>)</p><p><p>ManagedSeedStatus is the status of a ManagedSeed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>conditions</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.Condition>[]github.com/gardener/gardener/pkg/apis/core/v1beta1.Condition</a></em></td><td><em>(Optional)</em><p>Conditions represents the latest available observations of a ManagedSeed’s current state.</p></td></tr><tr><td><code>observedGeneration</code></br><em>int64</em></td><td><p>ObservedGeneration is the most recent generation observed for this ManagedSeed. It corresponds to the
ManagedSeed’s generation, which is updated on mutation by the API Server.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.ManagedSeedTemplate>ManagedSeedTemplate</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetSpec>ManagedSeedSetSpec</a>)</p><p><p>ManagedSeedTemplate is a template for creating a ManagedSeed object.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><em>(Optional)</em><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSpec>ManagedSeedSpec</a></em></td><td><em>(Optional)</em><p>Specification of the desired behavior of the ManagedSeed.</p><br><br><table><tr><td><code>shoot</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Shoot>Shoot</a></em></td><td><em>(Optional)</em><p>Shoot references a Shoot that should be registered as Seed.
This field is immutable.</p></td></tr><tr><td><code>seedTemplate</code></br><em><a href=/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.SeedTemplate>github.com/gardener/gardener/pkg/apis/core/v1beta1.SeedTemplate</a></em></td><td><em>(Optional)</em><p>SeedTemplate is a template for a Seed object, that should be used to register a given cluster as a Seed.
Either SeedTemplate or Gardenlet must be specified. When Seed is specified, the ManagedSeed controller will not deploy a gardenlet into the cluster
and an existing gardenlet reconciling the new Seed is required.</p></td></tr><tr><td><code>gardenlet</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.Gardenlet>Gardenlet</a></em></td><td><em>(Optional)</em><p>Gardenlet specifies that the ManagedSeed controller should deploy a gardenlet into the cluster
with the given deployment parameters and GardenletConfiguration.</p></td></tr></table></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.PendingReplica>PendingReplica</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetStatus>ManagedSeedSetStatus</a>)</p><p><p>PendingReplica contains information about a replica that is currently pending creation, update, or deletion.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the replica name.</p></td></tr><tr><td><code>reason</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.PendingReplicaReason>PendingReplicaReason</a></em></td><td><p>Reason is the reason for the replica to be pending.</p></td></tr><tr><td><code>since</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#time-v1-meta>Kubernetes meta/v1.Time</a></em></td><td><p>Since is the moment in time since the replica is pending with the specified reason.</p></td></tr><tr><td><code>retries</code></br><em>int32</em></td><td><em>(Optional)</em><p>Retries is the number of times the shoot operation (reconcile or delete) has been retried after having failed.
Only applicable if Reason is ShootReconciling or ShootDeleting.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.PendingReplicaReason>PendingReplicaReason
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.PendingReplica>PendingReplica</a>)</p><p><p>PendingReplicaReason is a string enumeration type that enumerates all possible reasons for a replica to be pending.</p></p><h3 id=seedmanagement.gardener.cloud/v1alpha1.RollingUpdateStrategy>RollingUpdateStrategy</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.UpdateStrategy>UpdateStrategy</a>)</p><p><p>RollingUpdateStrategy is used to communicate parameters for RollingUpdateStrategyType.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>partition</code></br><em>int32</em></td><td><em>(Optional)</em><p>Partition indicates the ordinal at which the ManagedSeedSet should be partitioned. Defaults to 0.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.Shoot>Shoot</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSpec>ManagedSeedSpec</a>)</p><p><p>Shoot identifies the Shoot that should be registered as Seed.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>name</code></br><em>string</em></td><td><p>Name is the name of the Shoot that will be registered as Seed.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.UpdateStrategy>UpdateStrategy</h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.ManagedSeedSetSpec>ManagedSeedSetSpec</a>)</p><p><p>UpdateStrategy specifies the strategy that the ManagedSeedSet
controller will use to perform updates. It includes any additional parameters
necessary to perform the update for the indicated strategy.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.UpdateStrategyType>UpdateStrategyType</a></em></td><td><em>(Optional)</em><p>Type indicates the type of the UpdateStrategy. Defaults to RollingUpdate.</p></td></tr><tr><td><code>rollingUpdate</code></br><em><a href=#seedmanagement.gardener.cloud/v1alpha1.RollingUpdateStrategy>RollingUpdateStrategy</a></em></td><td><em>(Optional)</em><p>RollingUpdate is used to communicate parameters when Type is RollingUpdateStrategyType.</p></td></tr></tbody></table><h3 id=seedmanagement.gardener.cloud/v1alpha1.UpdateStrategyType>UpdateStrategyType
(<code>string</code> alias)</p></h3><p>(<em>Appears on:</em>
<a href=#seedmanagement.gardener.cloud/v1alpha1.UpdateStrategy>UpdateStrategy</a>)</p><p><p>UpdateStrategyType is a string enumeration type that enumerates
all possible update strategies for the ManagedSeedSet controller.</p></p><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-50022620f86c6e0e31acdb7087f2e64c>1.8 - Settings</h1><p>Packages:</p><ul><li><a href=#settings.gardener.cloud%2fv1alpha1>settings.gardener.cloud/v1alpha1</a></li></ul><h2 id=settings.gardener.cloud/v1alpha1>settings.gardener.cloud/v1alpha1</h2><p><p>Package v1alpha1 is a version of the API.</p></p>Resource Types:<ul><li><a href=#settings.gardener.cloud/v1alpha1.ClusterOpenIDConnectPreset>ClusterOpenIDConnectPreset</a></li><li><a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPreset>OpenIDConnectPreset</a></li></ul><h3 id=settings.gardener.cloud/v1alpha1.ClusterOpenIDConnectPreset>ClusterOpenIDConnectPreset</h3><p><p>ClusterOpenIDConnectPreset is a OpenID Connect configuration that is applied
to a Shoot objects cluster-wide.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>settings.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>ClusterOpenIDConnectPreset</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#settings.gardener.cloud/v1alpha1.ClusterOpenIDConnectPresetSpec>ClusterOpenIDConnectPresetSpec</a></em></td><td><p>Spec is the specification of this OpenIDConnect preset.</p><br><br><table><tr><td><code>OpenIDConnectPresetSpec</code></br><em><a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPresetSpec>OpenIDConnectPresetSpec</a></em></td><td><p>(Members of <code>OpenIDConnectPresetSpec</code> are embedded into this type.)</p></td></tr><tr><td><code>projectSelector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><em>(Optional)</em><p>Project decides whether to apply the configuration if the
Shoot is in a specific Project matching the label selector.
Use the selector only if the OIDC Preset is opt-in, because end
users may skip the admission by setting the labels.
Defaults to the empty LabelSelector, which matches everything.</p></td></tr></table></td></tr></tbody></table><h3 id=settings.gardener.cloud/v1alpha1.OpenIDConnectPreset>OpenIDConnectPreset</h3><p><p>OpenIDConnectPreset is a OpenID Connect configuration that is applied
to a Shoot in a namespace.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>apiVersion</code></br>string</td><td><code>settings.gardener.cloud/v1alpha1</code></td></tr><tr><td><code>kind</code></br>string</td><td><code>OpenIDConnectPreset</code></td></tr><tr><td><code>metadata</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#objectmeta-v1-meta>Kubernetes meta/v1.ObjectMeta</a></em></td><td><p>Standard object metadata.</p>Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.</td></tr><tr><td><code>spec</code></br><em><a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPresetSpec>OpenIDConnectPresetSpec</a></em></td><td><p>Spec is the specification of this OpenIDConnect preset.</p><br><br><table><tr><td><code>server</code></br><em><a href=#settings.gardener.cloud/v1alpha1.KubeAPIServerOpenIDConnect>KubeAPIServerOpenIDConnect</a></em></td><td><p>Server contains the kube-apiserver&rsquo;s OpenID Connect configuration.
This configuration is not overwritting any existing OpenID Connect
configuration already set on the Shoot object.</p></td></tr><tr><td><code>client</code></br><em><a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectClientAuthentication>OpenIDConnectClientAuthentication</a></em></td><td><em>(Optional)</em><p>Client contains the configuration used for client OIDC authentication
of Shoot clusters.
This configuration is not overwritting any existing OpenID Connect
client authentication already set on the Shoot object.</p></td></tr><tr><td><code>shootSelector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><em>(Optional)</em><p>ShootSelector decides whether to apply the configuration if the
Shoot has matching labels.
Use the selector only if the OIDC Preset is opt-in, because end
users may skip the admission by setting the labels.
Default to the empty LabelSelector, which matches everything.</p></td></tr><tr><td><code>weight</code></br><em>int32</em></td><td><p>Weight associated with matching the corresponding preset,
in the range 1-100.
Required.</p></td></tr></table></td></tr></tbody></table><h3 id=settings.gardener.cloud/v1alpha1.ClusterOpenIDConnectPresetSpec>ClusterOpenIDConnectPresetSpec</h3><p>(<em>Appears on:</em>
<a href=#settings.gardener.cloud/v1alpha1.ClusterOpenIDConnectPreset>ClusterOpenIDConnectPreset</a>)</p><p><p>ClusterOpenIDConnectPresetSpec contains the OpenIDConnect specification and
project selector matching Shoots in Projects.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>OpenIDConnectPresetSpec</code></br><em><a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPresetSpec>OpenIDConnectPresetSpec</a></em></td><td><p>(Members of <code>OpenIDConnectPresetSpec</code> are embedded into this type.)</p></td></tr><tr><td><code>projectSelector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><em>(Optional)</em><p>Project decides whether to apply the configuration if the
Shoot is in a specific Project matching the label selector.
Use the selector only if the OIDC Preset is opt-in, because end
users may skip the admission by setting the labels.
Defaults to the empty LabelSelector, which matches everything.</p></td></tr></tbody></table><h3 id=settings.gardener.cloud/v1alpha1.KubeAPIServerOpenIDConnect>KubeAPIServerOpenIDConnect</h3><p>(<em>Appears on:</em>
<a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPresetSpec>OpenIDConnectPresetSpec</a>)</p><p><p>KubeAPIServerOpenIDConnect contains configuration settings for the OIDC provider.
Note: Descriptions were taken from the Kubernetes documentation.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>caBundle</code></br><em>string</em></td><td><em>(Optional)</em><p>If set, the OpenID server&rsquo;s certificate will be verified by one of the authorities in the oidc-ca-file, otherwise the host&rsquo;s root CA set will be used.</p></td></tr><tr><td><code>clientID</code></br><em>string</em></td><td><p>The client ID for the OpenID Connect client.
Required.</p></td></tr><tr><td><code>groupsClaim</code></br><em>string</em></td><td><em>(Optional)</em><p>If provided, the name of a custom OpenID Connect claim for specifying user groups. The claim value is expected to be a string or array of strings. This field is experimental, please see the authentication documentation for further details.</p></td></tr><tr><td><code>groupsPrefix</code></br><em>string</em></td><td><em>(Optional)</em><p>If provided, all groups will be prefixed with this value to prevent conflicts with other authentication strategies.</p></td></tr><tr><td><code>issuerURL</code></br><em>string</em></td><td><p>The URL of the OpenID issuer, only HTTPS scheme will be accepted. If set, it will be used to verify the OIDC JSON Web Token (JWT).
Required.</p></td></tr><tr><td><code>requiredClaims</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>key=value pairs that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value.</p></td></tr><tr><td><code>signingAlgs</code></br><em>[]string</em></td><td><em>(Optional)</em><p>List of allowed JOSE asymmetric signing algorithms. JWTs with a &lsquo;alg&rsquo; header value not in this list will be rejected. Values are defined by RFC 7518 <a href=https://tools.ietf.org/html/rfc7518#section-3.1>https://tools.ietf.org/html/rfc7518#section-3.1</a>
Defaults to [RS256]</p></td></tr><tr><td><code>usernameClaim</code></br><em>string</em></td><td><em>(Optional)</em><p>The OpenID claim to use as the user name. Note that claims other than the default (&lsquo;sub&rsquo;) is not guaranteed to be unique and immutable. This field is experimental, please see the authentication documentation for further details.
Defaults to &ldquo;sub&rdquo;.</p></td></tr><tr><td><code>usernamePrefix</code></br><em>string</em></td><td><em>(Optional)</em><p>If provided, all usernames will be prefixed with this value. If not provided, username claims other than &lsquo;email&rsquo; are prefixed by the issuer URL to avoid clashes. To skip any prefixing, provide the value &lsquo;-&rsquo;.</p></td></tr></tbody></table><h3 id=settings.gardener.cloud/v1alpha1.OpenIDConnectClientAuthentication>OpenIDConnectClientAuthentication</h3><p>(<em>Appears on:</em>
<a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPresetSpec>OpenIDConnectPresetSpec</a>)</p><p><p>OpenIDConnectClientAuthentication contains configuration for OIDC clients.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>secret</code></br><em>string</em></td><td><em>(Optional)</em><p>The client Secret for the OpenID Connect client.</p></td></tr><tr><td><code>extraConfig</code></br><em>map[string]string</em></td><td><em>(Optional)</em><p>Extra configuration added to kubeconfig&rsquo;s auth-provider.
Must not be any of idp-issuer-url, client-id, client-secret, idp-certificate-authority, idp-certificate-authority-data, id-token or refresh-token</p></td></tr></tbody></table><h3 id=settings.gardener.cloud/v1alpha1.OpenIDConnectPresetSpec>OpenIDConnectPresetSpec</h3><p>(<em>Appears on:</em>
<a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectPreset>OpenIDConnectPreset</a>,
<a href=#settings.gardener.cloud/v1alpha1.ClusterOpenIDConnectPresetSpec>ClusterOpenIDConnectPresetSpec</a>)</p><p><p>OpenIDConnectPresetSpec contains the Shoot selector for which
a specific OpenID Connect configuration is applied.</p></p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><code>server</code></br><em><a href=#settings.gardener.cloud/v1alpha1.KubeAPIServerOpenIDConnect>KubeAPIServerOpenIDConnect</a></em></td><td><p>Server contains the kube-apiserver&rsquo;s OpenID Connect configuration.
This configuration is not overwritting any existing OpenID Connect
configuration already set on the Shoot object.</p></td></tr><tr><td><code>client</code></br><em><a href=#settings.gardener.cloud/v1alpha1.OpenIDConnectClientAuthentication>OpenIDConnectClientAuthentication</a></em></td><td><em>(Optional)</em><p>Client contains the configuration used for client OIDC authentication
of Shoot clusters.
This configuration is not overwritting any existing OpenID Connect
client authentication already set on the Shoot object.</p></td></tr><tr><td><code>shootSelector</code></br><em><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#labelselector-v1-meta>Kubernetes meta/v1.LabelSelector</a></em></td><td><em>(Optional)</em><p>ShootSelector decides whether to apply the configuration if the
Shoot has matching labels.
Use the selector only if the OIDC Preset is opt-in, because end
users may skip the admission by setting the labels.
Default to the empty LabelSelector, which matches everything.</p></td></tr><tr><td><code>weight</code></br><em>int32</em></td><td><p>Weight associated with matching the corresponding preset,
in the range 1-100.
Required.</p></td></tr></tbody></table><hr><p><em>Generated with <a href=https://github.com/ahmetb/gen-crd-api-reference-docs>gen-crd-api-reference-docs</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-8fbd5b9ae8f9df2cc2758feb9fc249f2>2 - Concepts</h1></div><div class=td-content><h1 id=pg-ccbcc1039e04b807c6daf64b9352f3d3>2.1 - Admission Controller</h1><h1 id=gardener-admission-controller>Gardener Admission Controller</h1><p>While the Gardener API server works with <a href=/docs/gardener/concepts/apiserver_admission_plugins/>admission plugins</a> to validate and mutate resources belonging to Gardener related API groups, e.g. <code>core.gardener.cloud</code>, the same is needed for resources belonging to non-Gardener API groups as well, e.g. <code>Secret</code>s in the <code>core</code> API group.
Therefore, the Gardener Admission Controller runs a http(s) server with the following handlers which serve as validating/mutating endpoints for <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>admission webhooks</a>.
It is also used to serve http(s) handlers for authorization webhooks.</p><h2 id=admission-webhook-handlers>Admission Webhook Handlers</h2><p>This section describes the admission webhook handlers that are currently served.</p><h3 id=kubeconfig-secret-validator>Kubeconfig Secret Validator</h3><p><a href=https://github.com/kubernetes/kubectl/issues/697>Malicious Kubeconfigs</a> applied by end users may cause a leakage of sensitive data.
This handler checks if the incoming request contains a Kubernetes secret with a <code>.data.kubeconfig</code> field and denies the request if the Kubeconfig structure violates Gardener&rsquo;s security standards.</p><h3 id=namespace-validator>Namespace Validator</h3><p>Namespaces are the backing entities of Gardener projects in which shoot clusters objects reside.
This validation handler protects active namespaces against premature deletion requests.
Therefore, it denies deletion requests if a namespace still contains shoot clusters or if it belongs to a non-deleting Gardener project (w/o <code>.metadata.deletionTimestamp</code>).</p><h3 id=resource-size-validator>Resource Size Validator</h3><p>Since users directly apply Kubernetes native objects to the Garden cluster, it also involves the risk of being vulnerable to DoS attacks because these resources are read continuously watched and read by controllers.
One example is the creation of <code>Shoot</code> resources with large annotation values (up to 256 kB per value) which can cause severe out-of-memory issues for the Gardenlet component.
<a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler>Vertical autoscaling</a> can help to mitigate such situations, but we cannot expect to scale infinitely, and thus need means to block the attack itself.</p><p>The Resource Size Validator checks arbitrary incoming admission requests against a configured maximum size for the resource&rsquo;s group-version-kind combination and denies the request if the contained object exceeds the quota.</p><p>Example for Gardener Admission Controller configuration:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>server:
  resourceAdmissionConfiguration:
    limits:
    - apiGroups: [<span style=color:#a31515>&#34;core.gardener.cloud&#34;</span>]
      apiVersions: [<span style=color:#a31515>&#34;*&#34;</span>]
      resources: [<span style=color:#a31515>&#34;shoots&#34;</span>, <span style=color:#a31515>&#34;plants&#34;</span>]
      size: 100k
    - apiGroups: [<span style=color:#a31515>&#34;&#34;</span>]
      apiVersions: [<span style=color:#a31515>&#34;v1&#34;</span>]
      resources: [<span style=color:#a31515>&#34;secrets&#34;</span>]
      size: 100k
    unrestrictedSubjects:
    - kind: Group
      name: gardener.cloud:system:seeds
      apiGroup: rbac.authorization.k8s.io
 <span style=color:green>#  - kind: User</span>
 <span style=color:green>#    name: admin</span>
 <span style=color:green>#    apiGroup: rbac.authorization.k8s.io</span>
 <span style=color:green>#  - kind: ServiceAccount</span>
 <span style=color:green>#    name: &#34;*&#34;</span>
 <span style=color:green>#    namespace: garden</span>
 <span style=color:green>#    apiGroup: &#34;&#34;</span>
    operationMode: block <span style=color:green>#log</span>
</code></pre></div><p>With the configuration above, the Resource Size Validator denies requests for shoots and plants with Gardener&rsquo;s core API group which exceed a size of 100 kB. The same is done for Kubernetes secrets.</p><p>As this feature is meant to protect the system from malicious requests sent by users, it is recommended to exclude trusted groups, users or service accounts from the size restriction via <code>resourceAdmissionConfiguration.unrestrictedSubjects</code>.
For example, the backing user for the Gardenlet should always be capable of changing the shoot resource instead of being blocked due to size restrictions.
This is because the Gardenlet itself occasionally changes the shoot specification, labels or annotations, and might violate the quota if the existing resource is already close to the quota boundary.
Also, operators are supposed to be trusted users and subjecting them to a size limitation can inhibit important operational tasks.
Wildcard ("*") in subject <code>name</code> is supported.</p><p>Size limitations depend on the individual Gardener setup and choosing the wrong values can affect the availability of your Gardener service.
<code>resourceAdmissionConfiguration.operationMode</code> allows to control if a violating request is actually denied (default) or only logged.
It&rsquo;s recommended to start with <code>log</code>, check the logs for exceeding requests, adjust the limits if necessary and finally switch to <code>block</code>.</p><h3 id=seedrestriction>SeedRestriction</h3><p>Please refer to <a href=/docs/gardener/deployment/gardenlet_api_access/>this document</a> for more information.</p><h2 id=authorization-webhook-handlers>Authorization Webhook Handlers</h2><p>This section describes the authorization webhook handlers that are currently served.</p><h3 id=seedauthorization>SeedAuthorization</h3><p>Please refer to <a href=/docs/gardener/deployment/gardenlet_api_access/>this document</a> for more information.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-467f70291b55149caa507ac09cae563f>2.2 - Apiserver</h1><h1 id=gardener-api-server>Gardener API server</h1><p>The Gardener API server is a Kubernetes-native extension based on its <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>aggregation layer</a>.
It is registered via an <code>APIService</code> object and designed to run inside a Kubernetes cluster whose API it wants to extend.</p><p>After registration, it exposes the following resources:</p><h2 id=cloudprofiles><code>CloudProfile</code>s</h2><p><code>CloudProfile</code>s are resources that describe a specific environment of an underlying infrastructure provider, e.g. AWS, Azure, etc.
Each shoot has to reference a <code>CloudProfile</code> to declare the environment it should be created in.
In a <code>CloudProfile</code> the gardener operator specifies certain constraints like available machine types, regions, which Kubernetes versions they want to offer, etc.
End-users can read <code>CloudProfile</code>s to see these values, but only operators can change the content or create/delete them.
When a shoot is created or updated then an admission plugin checks that only values are used that are allowed via the referenced <code>CloudProfile</code>.</p><p>Additionally, a <code>CloudProfile</code> may contain a <code>providerConfig</code> which is a special configuration dedicated for the infrastructure provider.
Gardener does not evaluate or understand this config, but extension controllers might need for declaration of provider-specific constraints, or global settings.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/30-cloudprofile.yaml>this</a> example manifest and consult the documentation of your provider extension controller to get information about its <code>providerConfig</code>.</p><h2 id=seeds><code>Seed</code>s</h2><p><code>Seed</code>s are resources that represent seed clusters.
Gardener does not care about how a seed cluster got created - the only requirement is that it is of at least Kubernetes v1.17 and passes the Kubernetes conformance tests.
The Gardener operator has to either deploy the Gardenlet into the cluster they want to use as seed (recommended, then the Gardenlet will create the <code>Seed</code> object itself after bootstrapping), or they provide the kubeconfig to the cluster inside a secret (that is referenced by the <code>Seed</code> resource) and create the <code>Seed</code> resource themselves.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/45-secret-seed-backup.yaml>this</a>, <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>this</a>(, and optionally <a href=https://github.com/gardener/gardener/blob/master/example/40-secret-seed.yaml>this</a>) example manifests.</p><h2 id=shootquotas>Shoot<code>Quota</code>s</h2><p>In order to allow end-users not having their own dedicated infrastructure account to try out Gardener the operator can register an account owned by them that they allow to be used for trial clusters.
Trial clusters can be put under quota such that they don&rsquo;t consume too many resources (resulting in costs), and so that one user cannot consume all resources on their own.
These clusters are automatically terminated after a specified time, but end-users may extend the lifetime manually if needed.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/60-quota.yaml>this</a> example manifest.</p><h2 id=projects><code>Project</code>s</h2><p>The first thing before creating a shoot cluster is to create a <code>Project</code>.
A project is used to group multiple shoot clusters together.
End-users can invite colleagues to the project to enable collaboration, and they can either make them <code>admin</code> or <code>viewer</code>.
After an end-user has created a project they will get a dedicated namespace in the garden cluster for all their shoots.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/05-project-dev.yaml>this</a> example manifest.</p><h2 id=secretbindings><code>SecretBinding</code>s</h2><p>Now that the end-user has a namespace the next step is registering their infrastructure provider account.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/70-secret-provider.yaml>this</a> example manifest and consult the documentation of the extension controller for the respective infrastructure provider to get information about which keys are required in this secret.</p><p>After the secret has been created the end-user has to create a special <code>SecretBinding</code> resource that binds this secret.
Later when creating shoot clusters they will reference such a binding.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/80-secretbinding.yaml>this</a> example manifest.</p><h2 id=shoots><code>Shoot</code>s</h2><p>Shoot cluster contain various settings that influence how end-user Kubernetes clusters will look like in the end.
As Gardener heavily relies on extension controllers for operating system configuration, networking, and infrastructure specifics, the end-user has the possibility (and responsibility) to provide these provider-specific configurations as well.
Such configurations are not evaluated by Gardener (because it doesn&rsquo;t know/understand them), but they are only transported to the respective extension controller.</p><p>⚠️ This means that any configuration issues/mistake on the end-user side that relates to a provider-specific flag or setting cannot be caught during the update request itself but only later during the reconciliation (unless a validator webhook has been registered in the garden cluster by an operator).</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml>this</a> example manifest and consult the documentation of the provider extension controller to get information about its <code>spec.provider.controlPlaneConfig</code>, <code>.spec.provider.infrastructureConfig</code>, and <code>.spec.provider.workers[].providerConfig</code>.</p><h2 id=clusteropenidconnectpresets><code>(Cluster)OpenIDConnectPreset</code>s</h2><p>Please see <a href=/docs/gardener/usage/openidconnect-presets/>this</a> separate documentation file.</p><h2 id=overview-data-model>Overview Data Model</h2><p><img src=/__resources/gardener-data-model-overview_c5b559.png alt="Gardener Overview Data Model"></p></div><div class=td-content style=page-break-before:always><h1 id=pg-330a9a0a66325841218788d3193e6fdf>2.3 - Apiserver Admission Plugins</h1><h1 id=admission-plugins>Admission Plugins</h1><p>Similar to the kube-apiserver, the gardener-apiserver comes with a few in-tree managed admission plugins.
If you want to get an overview of the what and why of admission plugins then <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/>this document</a> might be a good start.</p><p>This document lists all existing admission plugins with a short explanation of what it is responsible for.</p><h2 id=clusteropenidconnectpreset-openidconnectpreset><code>ClusterOpenIDConnectPreset</code>, <code>OpenIDConnectPreset</code></h2><p><em>(both enabled by default)</em></p><p>These admission controllers react on <code>CREATE</code> operations for <code>Shoot</code>s.
If the <code>Shoot</code> does not specify any OIDC configuration (<code>.spec.kubernetes.kubeAPIServer.oidcConfig=nil</code>) then it tries to find a matching <code>ClusterOpenIDConnectPreset</code> or <code>OpenIDConnectPreset</code>, respectively.
If there are multiples that match then the one with the highest weight &ldquo;wins&rdquo;.
In this case, the admission controller will default the OIDC configuration in the <code>Shoot</code>.</p><h2 id=controllerregistrationresources><code>ControllerRegistrationResources</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>ControllerRegistration</code>s.
It validates that there exists only one <code>ControllerRegistration</code> in the system that is primarily responsible for a given kind/type resource combination.
This prevents misconfiguration by the Gardener administrator/operator.</p><h2 id=customverbauthorizer><code>CustomVerbAuthorizer</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Project</code>s.
It validates whether the user is bound to a RBAC role with the <code>modify-spec-tolerations-whitelist</code> verb in case the user tries to change the <code>.spec.tolerations.whitelist</code> field of the respective <code>Project</code> resource.
Usually, regular project members are not bound to this custom verb, allowing the Gardener administrator to manage certain toleration whitelists on <code>Project</code> basis.</p><h2 id=deletionconfirmation><code>DeletionConfirmation</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>Project</code>s and <code>Shoot</code>s and <code>ShootState</code>s.
It validates that the respective resource is annotated with a deletion confirmation annotation, namely <code>confirmation.gardener.cloud/deletion=true</code>.
Only if this annotation is present it allows the <code>DELETE</code> operation to pass.
This prevents users from accidental/undesired deletions.</p><h2 id=exposureclass><code>ExposureClass</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>Create</code> operations for <code>Shoots</code>s.
It mutates <code>Shoot</code> resources which has an <code>ExposureClass</code> referenced by merging their both <code>shootSelectors</code> and/or <code>tolerations</code> into the <code>Shoot</code> resource.</p><h2 id=extensionvalidator><code>ExtensionValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>BackupEntry</code>s, <code>BackupBucket</code>s, <code>Seed</code>s, and <code>Shoot</code>s.
For all the various extension types in the specifications of these objects, it validates whether there exists a <code>ControllerRegistration</code> in the system that is primarily responsible for the stated extension type(s).
This prevents misconfigurations that would otherwise allow users to create such resources with extension types that don&rsquo;t exist in the cluster, effectively leading to failing reconciliation loops.</p><h2 id=extensionlabels><code>ExtensionLabels</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>BackupBucket</code>s, <code>BackupEntry</code>s, <code>CloudProfile</code>s, <code>Seed</code>s and <code>Shoot</code>s. For all the various extension types in the specifications of these objects, it adds a corresponding label in the resource. This would allow extension admission webhooks to filter out the resources they are responsible for and ignore all others. This label is of the form <code>&lt;extension-type>.extensions.gardener.cloud/&lt;extension-name> : "true"</code>. For example, an extension label for provider extension type <code>aws</code>, looks like <code>provider.extensions.gardener.cloud/aws : "true"</code>.</p><h2 id=plantvalidator><code>PlantValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Plant</code>s.
It sets the <code>gardener.cloud/created-by</code> annotation for newly created <code>Plant</code> resources.
Also, it prevents creating new <code>Plant</code> resources in <code>Project</code>s that are already have a deletion timestamp.</p><h2 id=projectvalidator><code>ProjectValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> operations for <code>Project</code>s.
It prevents creating <code>Project</code>s with a non-empty <code>.spec.namespace</code> if the value in <code>.spec.namespace</code> does not start with <code>garden-</code>.</p><p>⚠️ This admission plugin will be removed in a future release and its business logic will be incorporated into the static validation of the <code>gardener-apiserver</code>.</p><h2 id=resourcequota><code>ResourceQuota</code></h2><p><em>(enabled by default)</em></p><p>This admission controller enables <a href=https://kubernetes.io/docs/concepts/policy/resource-quotas/#object-count-quota>object count ResourceQuotas</a> for Gardener resources, e.g. <code>Shoots</code>, <code>SecretBindings</code>, <code>Projects</code>, etc..</p><blockquote><p>⚠️ In addition to this admission plugin, the <a href=https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/admission_control_resource_quota.md#resource-quota-controller>ResourceQuota controller</a> must be enabled for the Kube-Controller-Manager of your Garden cluster.</p></blockquote><h2 id=resourcereferencemanager><code>ResourceReferenceManager</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>CloudProfile</code>s, <code>Project</code>s, <code>SecretBinding</code>s, <code>Seed</code>s, and <code>Shoot</code>s.
Generally, it checks whether referred resources stated in the specifications of these objects exist in the system (e.g., if a referenced <code>Secret</code> exists).
However, it also has some special behaviours for certain resources:</p><ul><li><code>CloudProfile</code>s: It rejects removing Kubernetes or machine image versions if there is at least one <code>Shoot</code> that refers to them.</li><li><code>Project</code>s: It sets the <code>.spec.createdBy</code> field for newly created <code>Project</code> resources, and defaults the <code>.spec.owner</code> field in case it is empty (to the same value of <code>.spec.createdBy</code>).</li><li><code>Seed</code>s: It rejects changing the <code>.spec.settings.shootDNS.enabled</code> value if there is at least one <code>Shoot</code> that refers to this seed.</li><li><code>Shoot</code>s: It sets the <code>gardener.cloud/created-by=&lt;username></code> annotation for newly created <code>Shoot</code> resources.</li></ul><h2 id=seedvalidator><code>SeedValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>Seed</code>s.
Rejects the deletion if <code>Shoot</code>(s) reference the seed cluster.</p><h2 id=shootdns><code>ShootDNS</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It tries to assign a default domain to the <code>Shoot</code> if it gets scheduled to a seed that enables DNS for shoots (<code>.spec.settings.shootDNS.enabled=true</code>).
It also validates that the DNS configuration (<code>.spec.dns</code>) is not set if the seed disables DNS for shoots.</p><h2 id=shootquotavalidator><code>ShootQuotaValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It validates the resource consumption declared in the specification against applicable <code>Quota</code> resources.
Only if the applicable <code>Quota</code> resources admit the configured resources in the <code>Shoot</code> then it allows the request.
Applicable <code>Quota</code>s are referred in the <code>SecretBinding</code> that is used by the <code>Shoot</code>.</p><h2 id=shootvpaenabledbydefault><code>ShootVPAEnabledByDefault</code></h2><p><em>(disabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> operations for <code>Shoot</code>s.
If enabled, it will enable the managed <code>VerticalPodAutoscaler</code> components (see <a href=/docs/gardener/usage/shoot_autoscaling/#vertical-pod-auto-scaling>this doc</a>)
by setting <code>spec.kubernetes.verticalPodAutoscaler.enabled=true</code> for newly created Shoots.
Already existing Shoots and new Shoots that explicitly disable VPA (<code>spec.kubernetes.verticalPodAutoscaler.enabled=false</code>)
will not be affected by this admission plugin.</p><h2 id=shoottolerationrestriction><code>ShootTolerationRestriction</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It validates the <code>.spec.tolerations</code> used in <code>Shoot</code>s against the whitelist of its <code>Project</code>, or against the whitelist configured in the admission controller&rsquo;s configuration, respectively.
Additionally, it defaults the <code>.spec.tolerations</code> in <code>Shoot</code>s with those configured in its <code>Project</code>, and those configured in the admission controller&rsquo;s configuration, respectively.</p><h2 id=shootvalidator><code>ShootValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It validates certain configurations in the specification against the referred <code>CloudProfile</code> (e.g., machine images, machine types, used Kubernetes version, &mldr;).
Generally, it performs validations that cannot be handled by the static API validation due to their dynamic nature (e.g., when something needs to be checked against referred resources).
Additionally, it takes over certain defaulting tasks (e.g., default machine image for worker pools).</p><h2 id=shootmanagedseed><code>ShootManagedSeed</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>Shoot</code>s.
It rejects the deletion if the <code>Shoot</code> is referred to by a <code>ManagedSeed</code>.</p><h2 id=managedseedvalidator><code>ManagedSeedValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>ManagedSeeds</code>s.
It validates certain configuration values in the specification against the referred <code>Shoot</code>, for example Seed provider, network ranges, DNS domain, etc.
Similarly to <code>ShootValidator</code>, it performs validations that cannot be handled by the static API validation due to their dynamic nature.
Additionally, it performs certain defaulting tasks, making sure that configuration values that are not specified are defaulted to the values of the referred <code>Shoot</code>, for example Seed provider, network ranges, DNS domain, etc.</p><h2 id=managedseedshoot><code>ManagedSeedShoot</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>ManagedSeed</code>s.
It rejects the deletion if there are <code>Shoot</code>s that are scheduled onto the <code>Seed</code> that is registered by the <code>ManagedSeed</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c898670f6aa58e28fb8510640734a620>2.4 - Architecture</h1><h4 id=official-definition---what-is-kubernetes>Official Definition - What is Kubernetes?</h4><blockquote><p>&ldquo;Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.&rdquo;</p></blockquote><h4 id=introduction---basic-principle>Introduction - Basic Principle</h4><p>The foundation of the Gardener (providing <em><strong>Kubernetes Clusters as a Service</strong></em>) is Kubernetes itself, because Kubernetes is the go-to solution to manage software in the Cloud, even when it&rsquo;s Kubernetes itself (see also OpenStack which is provisioned more and more on top of Kubernetes as well).</p><p>While self-hosting, meaning to run Kubernetes components inside Kubernetes, is a popular topic in the community, we apply a special pattern catering to the needs of our cloud platform to provision hundreds or even thousands of clusters. We take a so-called &ldquo;seed&rdquo; cluster and seed the control plane (such as the API server, scheduler, controllers, etcd persistence and others) of an end-user cluster, which we call &ldquo;shoot&rdquo; cluster, as pods into the &ldquo;seed&rdquo; cluster. That means one &ldquo;seed&rdquo; cluster, of which we will have one per IaaS and region, hosts the control planes of multiple &ldquo;shoot&rdquo; clusters. That allows us to avoid dedicated hardware/virtual machines for the &ldquo;shoot&rdquo; cluster control planes. We simply put the control plane into pods/containers and since the &ldquo;seed&rdquo; cluster watches them, they can be deployed with a replica count of 1 and only need to be scaled out when the control plane gets under pressure, but no longer for HA reasons. At the same time, the deployments get simpler (standard Kubernetes deployment) and easier to update (standard Kubernetes rolling update). The actual &ldquo;shoot&rdquo; cluster consists only out of the worker nodes (no control plane) and therefore the users may get full administrative access to their clusters.</p><h4 id=setting-the-scene---components-and-procedure>Setting The Scene - Components and Procedure</h4><p>We provide a central operator UI, which we call the &ldquo;Gardener Dashboard&rdquo;. It talks to a dedicated cluster, which we call the &ldquo;Garden&rdquo; cluster and uses custom resources managed by an <a href=https://kubernetes.io/docs/concepts/api-extension/custom-resources/#api-server-aggregation>aggregated API server</a>, one of the general extension concepts of Kubernetes) to represent &ldquo;shoot&rdquo; clusters. In this &ldquo;Garden&rdquo; cluster runs the &ldquo;Gardener&rdquo;, which is basically a Kubernetes controller that watches the custom resources and acts upon them, i.e. creates, updates/modifies, or deletes &ldquo;shoot&rdquo; clusters. The creation follows basically these steps:</p><ul><li>Create a namespace in the &ldquo;seed&rdquo; cluster for the &ldquo;shoot&rdquo; cluster which will host the &ldquo;shoot&rdquo; cluster control plane</li><li>Generate secrets and credentials which the worker nodes will need to talk to the control plane</li><li>Create the infrastructure (using <a href=https://www.terraform.io/>Terraform</a>), which basically consists out of the network setup)</li><li>Deploy the &ldquo;shoot&rdquo; cluster control plane into the &ldquo;shoot&rdquo; namespace in the &ldquo;seed&rdquo; cluster, containing the &ldquo;machine-controller-manager&rdquo; pod</li><li>Create machine CRDs in the &ldquo;seed&rdquo; cluster, describing the configuration and the number of worker machines for the &ldquo;shoot&rdquo; (the machine-controller-manager watches the CRDs and creates virtual machines out of it)</li><li>Wait for the &ldquo;shoot&rdquo; cluster API server to become responsive (pods will be scheduled, persistent volumes and load balancers are created by Kubernetes via the respective cloud provider)</li><li>Finally we deploy <code>kube-system</code> daemons like <code>kube-proxy</code> and further add-ons like the <code>dashboard</code> into the &ldquo;shoot&rdquo; cluster and the cluster becomes active</li></ul><h4 id=overview-architecture-diagram>Overview Architecture Diagram</h4><p><img src=/__resources/gardener-architecture-overview_2bd462.png alt="Gardener Overview Architecture Diagram"></p><h4 id=detailed-architecture-diagram>Detailed Architecture Diagram</h4><p><img src=/__resources/gardener-architecture-detailed_945c90.png alt="Gardener Detailed Architecture Diagram"></p><p>Note: The <code>kubelet</code> as well as the pods inside the &ldquo;shoot&rdquo; cluster talk through the front-door (load balancer IP; public Internet) to its &ldquo;shoot&rdquo; cluster API server running in the &ldquo;seed&rdquo; cluster. The reverse communication from the API server to the pod, service, and node networks happens through a VPN connection that we deploy into &ldquo;seed&rdquo; and &ldquo;shoot&rdquo; clusters.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-350220592a34dc9c03bc21617e258ada>2.5 - Backup Restore</h1><h1 id=backup-and-restore>Backup and restore</h1><p>Kubernetes uses Etcd as the key-value store for its resource definitions. Gardener supports the backup and restore of etcd. It is the responsibility of the shoot owners to backup the workload data.</p><p>Gardener uses <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a> component to backup the etcd backing the Shoot cluster regularly and restore in case of disaster. It is deployed as sidecar via <a href=https://github.com/gardener/etcd-druid>etcd-druid</a>. This doc mainly focuses on the backup and restore configuration used by Gardener when deploying these components. For more details on the design and internal implementation details, please refer <a href=/docs/gardener/proposals/06-etcd-druid/>GEP-06</a> and documentation on individual repository.</p><h2 id=bucket-provisioning>Bucket provisioning</h2><p>Refer the <a href=/docs/gardener/extensions/backupbucket/>backup bucket extension document</a> to know details about configuring backup bucket.</p><h2 id=backup-policy>Backup Policy</h2><p>etcd-backup-restore supports full snapshot and delta snapshots over full snapshot. In Gardener, this configuration is currently hard-coded to following parameters:</p><ul><li>Full Snapshot Schedule:<ul><li>Daily, <code>24hr</code> interval.</li><li>For each Shoot, the schedule time in a day is randomized based on the configured Shoot maintenance window.</li></ul></li><li>Delta Snapshot schedule:<ul><li>At <code>5min</code> interval.</li><li>If aggregated events size since last snapshot goes beyond <code>100Mib</code>.</li></ul></li><li>Backup History / Garbage backup deletion policy:<ul><li>Gardener configure backup restore to have <code>Exponential</code> garbage collection policy.</li><li>As per policy, following backups are retained.</li><li>All full backups and delta backups for the previous hour.</li><li>Latest full snapshot of each previous hour for the day.</li><li>Latest full snapshot of each previous day for 7 days.</li><li>Latest full snapshot of the previous 4 weeks.</li><li>Garbage Collection is configured at <code>12hr</code> interval.</li></ul></li><li>Listing:<ul><li>Gardener don&rsquo;t have any API to list out the backups.</li><li>To find the backup list, admin can checkout the <code>BackupEntry</code> resource associated with Shoot which holds the bucket and prefix details on object store.</li></ul></li></ul><h2 id=restoration>Restoration</h2><p>Restoration process of etcd is automated through the etcd-backup-restore component from latest snapshot. Gardener dosen&rsquo;t support Point-In-Time-Recovery (PITR) of etcd. In case of etcd disaster, the etcd is recovered from latest backup automatically. For further details, please refer the <a href=https://github.com/gardener/etcd-backup-restore/blob/master/doc/proposals/restoration.md>doc</a>. Post restoration of etcd, the Shoot reconciliation loop brings back the cluster to same state.</p><p>Again, Shoot owner is responsible for maintaining the backup/restore of his workload. Gardener does only take care of the cluster&rsquo;s etcd.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-deb4b0a712a04f62d9a5892607237729>2.6 - Cluster Api</h1><h1 id=relation-between-gardener-api-and-cluster-api-sig-cluster-lifecycle>Relation between Gardener API and Cluster API (SIG Cluster Lifecycle)</h1><p>In essence, the Cluster API harmonizes how to get to clusters, while Gardener goes one step further and also harmonizes the clusters themselves. The Cluster API delegates the specifics to so-called providers for infrastructures or control planes via specific CR(D)s while Gardener only has one cluster CR(D). Different Cluster API providers, e.g. for AWS, Azure, GCP, etc. give you vastly different Kubernetes clusters. In contrast, Gardener gives you the exact same clusters with the exact same K8s version, operating system, control plane configuration like for API server or kubelet, add-ons like overlay network, HPA/VPA, DNS and certificate controllers, ingress and network policy controllers, control plane monitoring and logging stacks, down to the behavior of update procedures, auto-scaling, self-healing, etc. on all supported infrastructures. These homogeneous clusters are an essential goal for Gardener as its main purpose is to simplify operations for teams that need to develop and ship software on Kubernetes clusters on a plethora of infrastructures (a.k.a. multi-cloud).</p><p>Incidentally, Gardener influenced the Machine API in the Cluster API with its <a href=https://github.com/gardener/machine-controller-manager>Machine Controller Manager</a> and was the <a href=https://github.com/kubernetes-sigs/cluster-api/commit/00b1ead264aea6f88585559056c180771cce3815>first to adopt it</a>, see also <a href="https://www.youtube.com/watch?v=Mtg8jygK3Hs">joint SIG Cluster Lifecycle KubeCon talk</a> where @hardikdr from our Gardener team in India spoke.</p><p>That means, we follow the <a href=https://github.com/kubernetes-sigs/cluster-api#cluster-api>Cluster API</a> with great interest and are active members. It was completely overhauled from <code>v1alpha1</code> to <code>v1alpha2</code>. But because <code>v1alpha2</code> made too many assumptions about the bring-up of masters and was enforcing master machine operations (see <a href=https://cluster-api.sigs.k8s.io/user/concepts.html#control-plane>here</a>: “As of <code>v1alpha2</code>, Machine-Based is the only control plane type that Cluster API supports”), services that managed their control planes differently like GKE or Gardener couldn&rsquo;t adopt it (e.g. <a href=https://cloud.google.com/anthos/gke/docs/on-prem/concepts/cluster-api>Google only supports <code>v1alpha1</code></a>). In 2020 <a href=https://kubernetes.io/blog/2020/04/21/cluster-api-v1alpha3-delivers-new-features-and-an-improved-user-experience/><code>v1alpha3</code></a> was introduced and made it possible (again) to integrate managed services like GKE or Gardener. The mapping from the Gardener API to the Cluster API is mostly syntactic.</p><p>To wrap it up, while the Cluster API knows about clusters, it doesn&rsquo;t know about their make-up. With Gardener, we wanted to go beyond that and harmonize the make-up of the clusters themselves and make them homogeneous across all supported infrastructures. Gardener can therefore deliver homogeneous clusters with exactly the same configuration and behavior on all infrastructures (see also <a href=https://k8s-testgrid.appspot.com/conformance-all>Gardener&rsquo;s coverage in the official conformance test grid</a>).</p><p>With <a href=https://kubernetes.io/blog/2020/04/21/cluster-api-v1alpha3-delivers-new-features-and-an-improved-user-experience>Cluster API <code>v1alpha3</code></a> and the support for declarative control plane management, it became now possible (again) to enable Kubernetes managed services like GKE or Gardener. We would be more than happy, if the community would be interested, to contribute a Gardener control plane provider.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-38b8e4d34b02317602d0c383c3c76cac>2.7 - Controller Manager</h1><h1 id=gardener-controller-manager>Gardener Controller Manager</h1><p>The Gardener Controller Manager (often refered to as &ldquo;GCM&rdquo;) is a component that runs next to the Gardener API server, similar to the Kubernetes Controller Manager.
It runs several control loops that do not require talking to any seed or shoot cluster.
Also, as of today it exposes a HTTPS server that is serving several endpoints for webhooks for certain resources.</p><p>This document explains the various functionalities of the Gardener Controller Manager and their purpose.</p><h2 id=control-loops>Control Loops</h2><h3 id=project-controller><code>Project</code> Controller</h3><p>This controller consists out of three reconciliation loops:
The main loop is reconciling <code>Project</code> resources while the second loop is controlling the necessary actions for stale projects.</p><h4 id=main-reconciler>&ldquo;Main&rdquo; Reconciler</h4><p>This reconciler will create a dedicated <code>Namespace</code> prefixed with <code>garden-</code> for each <code>Project</code> resource.
The name of the namespace can either be stated in the <code>.spec.namespace</code>, or it will be auto-generated by the reconciler.
If <code>.spec.namespace</code> is set then it creates it if it does not exist yet.
Otherwise, it tries to adopt it.
This will only succeed if the <code>Namespace</code> was previously labeled with <code>gardener.cloud/role=project</code> and <code>project.gardener.cloud/name=&lt;project-name></code>.
This is to prevent that end-users can adopt arbitrary namespaces and escalate their privileges, e.g. the <code>kube-system</code> namespace.</p><p>After the namespace was created/adopted the reconciler creates several <code>ClusterRole</code>s and <code>ClusterRoleBinding</code>s that allow the project members to access related resources based on their roles.
These RBAC resources are prefixed with <code>gardener.cloud:system:project{-member,-viewer}:&lt;project-name></code>.
Gardener administrators and extension developers can define their own roles, see <a href=/docs/gardener/extensions/project-roles/>this document</a> for more information.</p><p>In addition, operators can configure the Project controller to maintain a default <a href=https://kubernetes.io/docs/concepts/policy/resource-quotas/>ResourceQuota</a> for project namespaces.
Quotas can especially limit the creation of user facing resources, e.g. <code>Shoots</code>, <code>SecretBindings</code>, <code>Secrets</code> and thus protect the Garden cluster from massive resource exhaustion but also enable operators to align quotas with respective enterprise policies.</p><blockquote><p>⚠️ <strong>Gardener itself is not exempted from configured quotas</strong>. For example, Gardener creates <code>Secrets</code> for every shoot cluster in the project namespace and at the same time increases the available quota count. Please mind this additional resource consumption.</p></blockquote><p>The GCM configuration provides a template section <code>controllers.project.quotas</code> where such a ResourceQuota (see example below) can be deposited.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>controllers:
  project:
    quotas:
    - config:
        apiVersion: v1
        kind: ResourceQuota
        spec:
          hard:
            count/shoots.core.gardener.cloud: <span style=color:#a31515>&#34;100&#34;</span>
            count/secretbindings.core.gardener.cloud: <span style=color:#a31515>&#34;10&#34;</span>
            count/secrets: <span style=color:#a31515>&#34;800&#34;</span>
      projectSelector: {}
</code></pre></div><p>The Project controller takes the shown <code>config</code> and creates a <code>ResourceQuota</code> with the name <code>gardener</code> in the project namespace.
If a <code>ResourceQuota</code> resource with the name <code>gardener</code> already exists, the controller will only update fields in <code>spec.hard</code> which are <strong>unavailable</strong> at that time.
Labels and annotations on the <code>ResourceQuota</code> <code>config</code> get merged with the respective fields on existing <code>ResourceQuota</code>s.
An optional <code>projectSelector</code> narrows down the amount of projects that are equipped with the given <code>config</code>.
If multiple configs match for a project, then only the first match in the list is applied to the project namespace.</p><p>The <code>.status.phase</code> of the <code>Project</code> resources will be set to <code>Ready</code> or <code>Failed</code> by the reconciler to indicate whether the reconciliation loop was performed successfully.
Also, it will generate <code>Event</code>s to provide further information about its operations.</p><h4 id=stale-projects-reconciler>&ldquo;Stale Projects&rdquo; Reconciler</h4><p>As Gardener is a large-scale Kubernetes as a Service it is designed for being used by a large amount of end-users.
Over time, it is likely to happen that some of the hundreds or thousands of <code>Project</code> resources are no longer actively used.</p><p>Gardener offers the &ldquo;stale projects&rdquo; reconciler which will take care of identifying such stale projects, marking them with a &ldquo;warning&rdquo;, and eventually deleting them after a certain time period.
This reconciler is enabled by default and works as following:</p><ol><li>Projects are considered as &ldquo;stale&rdquo;/not actively used when all of the following conditions apply: The namespace associated with the <code>Project</code> does not have any&mldr;<ol><li><code>Shoot</code> resources.</li><li><code>Plant</code> resources.</li><li><code>BackupEntry</code> resources.</li><li><code>Secret</code> resources that are referenced by a <code>SecretBinding</code> that is in use by a <code>Shoot</code> (not necessarily in the same namespace).</li><li><code>Quota</code> resources that are referenced by a <code>SecretBinding</code> that is in use by a <code>Shoot</code> (not necessarily in the same namespace).</li><li>The time period when the projet was used for the last time (<code>status.lastActivityTimestamp</code>) is longer than the configured <code>minimumLifetimeDays</code></li></ol></li></ol><p>If a project is considered &ldquo;stale&rdquo; then its <code>.status.staleSinceTimestamp</code> will be set to the time when it was first detected to be stale.
If it gets actively used again this timestamp will be removed.
After some time the <code>.status.staleAutoDeleteTimestamp</code> will be set to a timestamp after which Gardener will auto-delete the <code>Project</code> resource if it still is not actively used.</p><p>The component configuration of the Gardener Controller Manager offers to configure the following options:</p><ul><li><code>minimumLifetimeDays</code>: Don&rsquo;t consider newly created <code>Project</code>s as &ldquo;stale&rdquo; too early to give people/end-users some time to onboard and get familiar with the system. The &ldquo;stale project&rdquo; reconciler won&rsquo;t set any timestamp for <code>Project</code>s younger than <code>minimumLifetimeDays</code>. When you change this value then projects marked as &ldquo;stale&rdquo; may be no longer marked as &ldquo;stale&rdquo; in case they are young enough, or vice versa.</li><li><code>staleGracePeriodDays</code>: Don&rsquo;t compute auto-delete timestamps for stale <code>Project</code>s that are unused for only less than <code>staleGracePeriodDays</code>. This is to not unnecessarily make people/end-users nervous &ldquo;just because&rdquo; they haven&rsquo;t actively used their <code>Project</code> for a given amount of time. When you change this value then already assigned auto-delete timestamps may be removed again if the new grace period is not yet exceeded.</li><li><code>staleExpirationTimeDays</code>: Expiration time after which stale <code>Project</code>s are finally auto-deleted (after <code>.status.staleSinceTimestamp</code>). If this value is changed and an auto-delete timestamp got already assigned to the projects then the new value will only take effect if it&rsquo;s increased. Hence, decreasing the <code>staleExpirationTimeDays</code> will not decrease already assigned auto-delete timestamps.</li></ul><blockquote><p>Gardener administrators/operators can exclude specific <code>Project</code>s from the stale check by annotating the related <code>Namespace</code> resource with <code>project.gardener.cloud/skip-stale-check=true</code>.</p></blockquote><h4 id=activity-reconciler>&ldquo;Activity&rdquo; Reconciler</h4><p>Since the other two reconcilers are unable to actively monitor the relevant objects that are used in a <code>Project</code> (<code>Shoot</code>, <code>Plant</code>, etc.), there could be a situation where the user creates and deletes objects in a short period of time. In that case the <code>Stale Project Reconciler</code> could not see that there was any activity on that project and it will still mark it as a <code>Stale</code>, even though it is actively used.</p><p>The <code>Project Activity Reconciler</code> is implemented to take care of such cases. An event handler will notify the reconciler for any acitivity (Currently only for <code>Shoots</code>) and then it will update the <code>status.lastActivityTimestamp</code>. This update will also trigger the <code>Stale Project Reconciler</code>.</p><h3 id=event-controller>Event Controller</h3><p>With the Gardener Event Controller you can prolong the lifespan of events related to Shoot clusters.
This is an optional controller which will become active once you provide the below mentioned configuration.</p><p>All events in K8s are deleted after a configurable time-to-live (controlled via a <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver argument</a> called <code>--event-ttl</code> (defaulting to 1 hour)).
The need to prolong the time-to-live for Shoot cluster events frequently arises when debugging customer issues on live systems.
This controller leaves events involving Shoots untouched while deleting all other events after a configured time.
In order to activate it, provide the following configuration:</p><ul><li><code>concurrentSyncs</code>: The amount of goroutines scheduled for reconciling events.</li><li><code>ttlNonShootEvents</code>: When an event reaches this time-to-live it gets deleted unless it is a Shoot-related event (defaults to <code>1h</code>, equivalent to the <code>event-ttl</code> default).</li></ul><blockquote><p>⚠️ In addition, you should also configure the <code>--event-ttl</code> for the kube-apiserver to define an upper-limit of how long Shoot-related events should be stored.
The <code>--event-ttl</code> should be larger than the <code>ttlNonShootEvents</code> or this controller will have no effect.</p></blockquote><h3 id=shoot-reference-controller>Shoot Reference Controller</h3><p>Shoot objects may specify references to further objects in the Garden cluster which are required for certain features.
For example, users can configure various DNS providers via <code>.spec.dns.providers</code> and usually need to refer to a corresponding <code>secret</code> with valid DNS provider credentials inside.
Such objects need a special protection against deletion requests as long as they are still being referenced by one or multiple shoots.</p><p>Therefore, the Shoot Reference Controller scans shoot clusters for referenced objects and adds the finalizer <code>gardener.cloud/reference-protection</code> to their <code>.metadata.finalizers</code> list.
The scanned shoot also gets this finalizer to enable a proper garbage collection in case the Gardener-Controller-Manager is offline at the moment of an incoming deletion request.
When an object is not actively referenced anymore because the shoot specification has changed or all related shoots were deleted (are in deletion), the controller will remove the added finalizer again, so that the object can safely be deleted or garbage collected.</p><p>The Shoot Reference Controller inspects the following references:</p><ul><li>DNS provider secrets (<code>.spec.dns.provider</code>)</li><li>Audit policy configmaps (<code>.spec.kubernetes.kubeAPIServer.auditConfig.auditPolicy.configMapRef</code>)</li></ul><p>Further checks might be added in the future.</p><h3 id=shoot-retry-controller>Shoot Retry Controller</h3><p>The Shoot Retry Controller is responsible for retrying certain failed Shoots. Currently the controller retries only failed Shoots with error code <code>ERR_INFRA_RATE_LIMITS_EXCEEDED</code>.</p><h3 id=seed-controller>Seed Controller</h3><p>The Seed controller in the Gardener Controller Manager reconciles <code>Seed</code> objects with the help of the following reconcilers.</p><h4 id=main-reconciler-1>&ldquo;Main&rdquo; Reconciler</h4><p>This reconciliation loop takes care about seed related operations in the Garden cluster. When a new <code>Seed</code> object is created
the reconciler creates a new <code>Namespace</code> in the garden cluster <code>seed-&lt;seed-name></code>. <code>Namespaces</code> dedicated to single
seed clusters allow us to segregate access permissions i.e., a Gardenlet must not have permissions to access objects in
all <code>Namespaces</code> in the Garden cluster.
There are objects in a Garden environment which are created once by the operator e.g., default domain secret,
alerting credentials, and required for operations happening in the Gardenlet. Therefore, we not only need a seed specific
<code>Namespace</code> but also a copy of these &ldquo;shared&rdquo; objects.</p><p>The &ldquo;main&rdquo; reconciler takes care about this replication:</p><table><thead><tr><th style=text-align:center>Kind</th><th style=text-align:center>Namespace</th><th style=text-align:center>Label Selector</th></tr></thead><tbody><tr><td style=text-align:center>Secret</td><td style=text-align:center>garden</td><td style=text-align:center>gardener.cloud/role</td></tr></tbody></table><h4 id=backup-bucket-reconciler>&ldquo;Backup Bucket&rdquo; Reconciler</h4><p>Every time a <code>BackupBucket</code> object is created or updated, the referenced <code>Seed</code> object is enqueued for reconciliation.
It&rsquo;s the reconciler&rsquo;s task to check the <code>status</code> subresource of all existing <code>BackupBuckets</code> that belong to this seed.
If at least one <code>BackupBucket</code> has <code>.status.lastError</code>, the seed condition <code>BackupBucketsReady</code> will turn <code>false</code> and
consequently the seed is considered as <code>NotReady</code>. Once the <code>BackupBucket</code> is healthy again, the seed will be re-queued
and the condition will turn <code>true</code>.</p><h4 id=lifecycle-reconciler>&ldquo;Lifecycle&rdquo; Reconciler</h4><p>The &ldquo;Lifecycle&rdquo; reconciler processes <code>Seed</code> objects which are enqueued every 10 seconds in order to check if the responsible
Gardenlet is still responding and operable. Therefore, it checks renewals via <code>Lease</code> objects of the seed in the garden cluster
which are renewed regularly by the Gardenlet.</p><p>In case a <code>Lease</code> is not renewed for the configured amount in <code>config.controllers.seed.monitorPeriod.duration</code>:</p><ol><li>The reconciler assumes that the Gardenlet stopped operating and updates the <code>GardenletReady</code> condition to <code>Unknown</code>.</li><li>Additionally, conditions and constraints of all <code>Shoot</code> resources scheduled on the affected seed are set to <code>Unknown</code> as well
because a striking Gardenlet won&rsquo;t be able to maintain these conditions any more.</li><li>If the gardenlet&rsquo;s client certificate has expired (identified based on the <code>.status.clientCertificateExpirationTimestamp</code> field in the <code>Seed</code> resource) and if it is managed by a <code>ManagedSeed</code> then this will be triggered for a reconciliation. This will trigger the bootstrapping process again and allows gardenlets to obtain a fresh client certificate.</li></ol><h3 id=controllerregistration-controller>ControllerRegistration Controller</h3><p>The <code>ControllerRegistration</code> controller makes sure that the required <a href=https://github.com/gardener/gardener/blob/master/docs/README.md#extensions>Gardener extensions</a> specified by the <a href=/docs/gardener/extensions/controllerregistration/><code>ControllerRegistration</code></a> resources are present in the seed clusters. It also takes care of the creation and deletion of <code>ControllerInstallation</code> objects for a given seed cluster.
The controller has three reconciliation loops.</p><h4 id=main-reconciler-2>&ldquo;Main&rdquo; Reconciler</h4><p>This reconciliation loop watches the <code>Seed</code> objects and determines which <code>ControllerRegistrations</code> are required for them and creates/deletes the corresponding extension controller to reach the determined state. To begin with, it computes the kind/type combinations of extensions required for the seed. For this, the controller examines a live list of <code>ControllerRegistration</code>s, <code>ControllerInstallation</code>s, <code>BackupBucket</code>s, <code>BackupEntry</code>s, <code>Shoot</code>s, and <code>Secret</code>s from the garden cluster. For example, it examines the shoots running on the seed and deducts kind/type like <code>Infrastructure/gcp</code>. It also decides whether they should always be deployed based on the <code>.spec.deployment.policy</code>.
For the configuration options, please see this <a href=/docs/gardener/extensions/controllerregistration/#deployment-configuration-options>section</a>.</p><p>Based on these required combinations, each of them are mapped to <code>ControllerRegistration</code> objects and then to their corresponding <code>ControllerInstallation</code> objects (if existing). The controller then creates or updates the required <code>ControllerInstallation</code> objects for the given seed. It also deletes every existing <code>ControllerInstallation</code> whose referenced <code>ControllerRegistration</code> is not part of the required list. For example, if the shoots in the seed are no longer using the DNS provider <code>aws-route53</code>, then the controller proceeds to delete the respective <code>ControllerInstallation</code> object.</p><h4 id=controllerregistration-reconciler>&ldquo;ControllerRegistration&rdquo; Reconciler</h4><p>This reconciliation loop watches the <code>ControllerRegistration</code> resource and adds finalizers to it when they are created. In case a deletion request comes in for the resource, i.e., if a <code>.metadata.deletionTimestamp</code> is set, it actively scans for a <code>ControllerInstallation</code> resource using this <code>ControllerRegistration</code>, and decides whether the deletion can be allowed. In case no related <code>ControllerInstallation</code> is present, it removes the finalizer and marks it for deletion.</p><h4 id=seed-reconciler>&ldquo;Seed&rdquo; Reconciler</h4><p>This loop also watches the <code>Seed</code> object and adds finalizers to it at creation. If a <code>.metadata.deletionTimestamp</code> is set for the seed then the controller checks for existing <code>ControllerInstallation</code> objects which reference this seed. If no such objects exist then it removes the finalizer and allows the deletion.</p><h3 id=certificatesigningrequest-controller>&ldquo;CertificateSigningRequest&rdquo; controller</h3><p>After the <a href=/docs/gardener/concepts/gardenlet/>gardenlet</a> gets deployed on the Seed cluster it needs to establish itself as a trusted party to communicate with the Gardener API server. It runs through a bootstrap flow similar to the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet bootstrap</a> process.</p><p>On startup the gardenlet uses a <code>kubeconfig</code> with a <a href=https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/>bootstrap token</a> which authenticates it as being part of the <code>system:bootstrappers</code> group. This kubeconfig is used to create a <a href=https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/><code>CertificateSigningRequest</code></a> (CSR) against the Gardener API server.</p><p>The controller in <code>gardener-controller-manager</code> checks whether the <code>CertificateSigningRequest</code> has the expected organisation, common name and usages which the gardenlet would request.</p><p>It only auto-approves the CSR if the client making the request is allowed to &ldquo;create&rdquo; the
<code>certificatesigningrequests/seedclient</code> subresource. Clients with the <code>system:bootstrappers</code> group are bound to the <code>gardener.cloud:system:seed-bootstrapper</code> <code>ClusterRole</code>, hence, they have such privileges. As the bootstrap kubeconfig for the gardenlet contains a bootstrap token which is authenticated as being part of the <a href=https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/charts/application/templates/clusterrolebinding-seed-bootstrapper.yaml><code>systems:bootstrappers</code> group</a>, its created CSR gets auto-approved.</p><h3 id=bastion-controller>&ldquo;Bastion&rdquo; Controller</h3><p><code>Bastion</code> resources have a limited lifetime, which can be extended up to a certain amount by performing a heartbeat on
them. The <code>Bastion</code> controller is responsible for deleting expired or rotten <code>Bastion</code>s.</p><ul><li>&ldquo;expired&rdquo; means a <code>Bastion</code> has exceeded its <code>status.ExpirationTimestamp</code>.</li><li>&ldquo;rotten&rdquo; means a <code>Bastion</code> is older than the configured <code>maxLifetime</code>.</li></ul><p>The <code>maxLifetime</code> is an option on the <code>Bastion</code> controller and defaults to 24 hours.</p><p>The deletion triggers the gardenlet to perform the necessary cleanups in the Seed cluster, so some time can pass between
deletion and the <code>Bastion</code> actually disappearing. Clients like <code>gardenctl</code> are advised to not re-use <code>Bastion</code>s whose
deletion timestamp has been set already.</p><p>Refer to <a href=/docs/gardener/proposals/15-manage-bastions-and-ssh-key-pair-rotation/>GEP-15</a> for more information on the lifecycle of
<code>Bastion</code> resources.</p><h3 id=plant-controller>&ldquo;Plant&rdquo; Controller</h3><p>Using the <code>Plant</code> resource, an external Kubernetes cluster (not managed by Gardener) can be registered to Gardener. Gardener Controller Manager is the component that is responsible for the <code>Plant</code> resource reconciliation. As part of the reconciliation loop, the Gardener Controller Manager performs health checks on the external Kubernetes cluster and gathers more information about it - all of this information serves for monitoring purposes of the external Kubernetes cluster.</p><p>The component configuration of the Gardener Controller Manager offers to configure the following options for the plant controller:</p><ul><li><code>syncPeriod</code>: The duration of how often the Plant resource is reconciled, i.e., how often health checks are performed. The default value is <code>30s</code>.</li><li><code>concurrentSyncs</code>: The number of goroutines scheduled for reconciling events, i.e., the number of possible parallel reconciliations. The default value is <code>5</code>.</li></ul><p>The <code>Plant</code> resource reports the following information for the external Kubernetes cluster:</p><ul><li>Cluster information<ul><li>Cloud provider information - the cloud provider type and region are maintained in the <code>Plant</code> status (<code>.status.clusterInfo.cloud</code>).</li><li>Kubernetes version - the Kubernetes version is maintained in the <code>Plant</code> status (<code>.status.clusterInfo.kubernetes.version</code>).</li></ul></li><li>Cluster status<ul><li>API Server availability - maintained as condition with type <code>APIServerAvailable</code>.</li><li>Cluster <code>Node</code>s healthiness - maintained as condition with type <code>EveryNodeReady</code>.</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a7a632a48267b040a5183cbf28440ddf>2.8 - Etc</h1><h1 id=etcd---key-value-store-for-kubernetes>etcd - Key-Value Store for Kubernetes</h1><p><a href=https://etcd.io/>etcd</a> is a strongly consistent key-value store and the most prevalent choice for the Kubernetes
persistence layer. All API cluster objects like <code>Pod</code>s, <code>Deployment</code>s, <code>Secret</code>s, etc. are stored in <code>etcd</code> which
makes it an essential part of a <a href=https://kubernetes.io/docs/concepts/overview/components/#control-plane-components>Kubernetes control plane</a>.</p><h2 id=shoot-cluster-persistence>Shoot cluster persistence</h2><p>Each shoot cluster gets its very own persistence for the control plane. It runs in the shoot namespace on the respective
seed cluster. Concretely, there are two etcd instances per shoot cluster which the <code>Kube-Apiserver</code> is configured
to use in the following way:</p><ul><li>etcd-main</li></ul><p>A store that contains all &ldquo;cluster critical&rdquo; or &ldquo;long-term&rdquo; objects. These object kinds are typically considered
for a backup to prevent any data loss.</p><ul><li>etcd-events</li></ul><p>A store that contains all <code>Event</code> objects (<code>events.k8s.io</code>) of a cluster. <code>Events</code> have usually a short retention
period, occur frequently but are not essential for a disaster recovery.</p><p>The setup above prevents both, the critical <code>etcd-main</code> is not flooded by Kubernetes <code>Events</code> as well as backup space is
not occupied by non-critical data. This segmentation saves time and resources.</p><h2 id=etcd-operator>etcd Operator</h2><p>Configuring, maintaining and health-checking <code>etcd</code> is outsourced to a dedicated operator called <a href=https://github.com/gardener/etcd-druid/>ETCD Druid</a>.
When <a href=/docs/gardener/concepts/gardenlet/>Gardenlet</a> reconciles a <code>Shoot</code> resource, it creates or updates an <a href=https://github.com/gardener/etcd-druid/blob/1d427e9167adac1476d1847c0e265c2c09d6bc62/config/samples/druid_v1alpha1_etcd.yaml>Etcd</a>
resources in the seed cluster, containing necessary information (backup information, defragmentation schedule, resources, etc.) <code>etcd-druid</code>
needs to manage the lifecycle of the desired etcd instance (today <code>main</code> or <code>events</code>). Likewise, when the shoot is deleted,
Gardenlet deletes the <code>Etcd</code> resource and <a href=https://github.com/gardener/etcd-druid/>ETCD Druid</a> takes care about cleaning up
all related objects, e.g. the backing <code>StatefulSet</code>.</p><h2 id=autoscaling>Autoscaling</h2><p>Gardenlet maintains <a href=https://github.com/gardener/hvpa-controller/blob/master/config/samples/autoscaling_v1alpha1_hvpa.yaml>HVPA</a>
objects for etcd <code>StatefulSet</code>s if the corresponding <a href=/docs/gardener/deployment/feature_gates/>feature gate</a> is enabled. This enables
a vertical scaling for <code>etcd</code>. Downscaling is handled more pessimistic to prevent many subsequent <code>etcd</code> restarts. Thus,
for <code>production</code> clusters downscaling is deactivated and for all other clusters lower advertised requests/limits are only
applied during a shoot&rsquo;s maintenance time window.</p><h2 id=backup>Backup</h2><p>If <code>Seed</code>s specify backups for etcd (<a href=https://github.com/gardener/gardener/blob/e9bf88a7a091a8cf8c495bef298bdada17a03c7f/example/50-seed.yaml#L19>example</a>),
then Gardener and the respective <a href=/docs/gardener/extensions/overview/>provider extensions</a> are responsible for creating a bucket
on the cloud provider&rsquo;s side (modelled through <a href=/docs/gardener/extensions/backupbucket/>BackupBucket resource</a>). The bucket stores
backups of shoots scheduled on that seed. Furthermore, Gardener creates a <a href=/docs/gardener/extensions/backupentry/>BackupEntry</a>
which subdivides the bucket and thus makes it possible to store backups of multiple shoot clusters.</p><p>The <code>etcd-main</code> instance itself is configured to run with a special backup-restore <em>sidecar</em>. It takes care about regularly
backing up etcd data and restoring it in case of data loss. More information can be found on the component&rsquo;s GitHub
page <a href=https://github.com/gardener/etcd-backup-restore>https://github.com/gardener/etcd-backup-restore</a>.</p><p>How long backups are stored in the bucket after a shoot has been deleted, depends on the configured <em>retention period</em> in the
<code>Seed</code> resource. Please see this <a href=https://github.com/gardener/gardener/blob/849cd857d0d20e5dde26b9740ca2814603a56dfd/example/20-componentconfig-gardenlet.yaml#L20>example configuration</a> for more information.</p><h2 id=housekeeping>Housekeeping</h2><p><a href=https://etcd.io/docs/v3.3/op-guide/maintenance/>etcd maintenance tasks</a> must be performed from time to time in order
to re-gain database storage and to ensure the system&rsquo;s reliability. The <a href=https://github.com/gardener/etcd-backup-restore>backup-restore</a>
<em>sidecar</em> takes care about this job as well. Gardener chooses a random time <strong>within the shoot&rsquo;s maintenance time</strong> to
schedule these tasks.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-899a4a43944208c044aaee6e6023bbba>2.9 - Gardenlet</h1><h1 id=gardenlet>Gardenlet</h1><p>Gardener is implemented using the <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/operator/>operator pattern</a>:
It uses custom controllers that act on our own custom resources,
and apply Kubernetes principles to manage clusters instead of containers.
Following this analogy, you can recognize components of the Gardener architecture
as well-known Kubernetes components, for example, shoot clusters can be compared with pods,
and seed clusters can be seen as worker nodes.</p><p>The following Gardener components play a similar role as the corresponding components
in the Kubernetes architecture:</p><table><thead><tr><th style=text-align:left>Gardener Component</th><th style=text-align:left>Kubernetes Component</th></tr></thead><tbody><tr><td style=text-align:left><code>gardener-apiserver</code></td><td style=text-align:left><code>kube-apiserver</code></td></tr><tr><td style=text-align:left><code>gardener-controller-manager</code></td><td style=text-align:left><code>kube-controller-manager</code></td></tr><tr><td style=text-align:left><code>gardener-scheduler</code></td><td style=text-align:left><code>kube-scheduler</code></td></tr><tr><td style=text-align:left><code>gardenlet</code></td><td style=text-align:left><code>kubelet</code></td></tr></tbody></table><p>Similar to how the <code>kube-scheduler</code> of Kubernetes finds an appropriate node
for newly created pods, the <code>gardener-scheduler</code> of Gardener finds an appropriate seed cluster
to host the control plane for newly ordered clusters.
By providing multiple seed clusters for a region or provider, and distributing the workload,
Gardener also reduces the blast radius of potential issues.</p><p>Kubernetes runs a primary &ldquo;agent&rdquo; on every node, the kubelet,
which is responsible for managing pods and containers on its particular node.
Decentralizing the responsibility to the kubelet has the advantage that the overall system
is scalable. Gardener achieves the same for cluster management by using a <strong>gardenlet</strong>
as primary &ldquo;agent&rdquo; on every seed cluster, and is only responsible for shoot clusters
located in its particular seed cluster:</p><p><img src=/__resources/gardenlet-architecture-similarities_ba8a1c.png alt="Counterparts in the Gardener Architecture and the Kubernetes Architecture"></p><p>The <code>gardener-controller-manager</code> has control loops to manage resources of the Gardener API. However, instead of letting the <code>gardener-controller-manager</code> talk directly to seed clusters or shoot clusters, the responsibility isn’t only delegated to the gardenlet, but also managed using a reversed control flow: It&rsquo;s up to the gardenlet to contact the Gardener API server, for example, to share a status for its managed seed clusters.</p><p>Reversing the control flow allows placing seed clusters or shoot clusters behind firewalls without the necessity of direct access via VPN tunnels anymore.</p><p><img src=/__resources/gardenlet-architecture-detailed_6f3172.png alt="Reversed Control Flow Using a Gardenlet"></p><h2 id=tls-bootstrapping>TLS Bootstrapping</h2><p>Kubernetes doesn’t manage worker nodes itself, and it’s also not
responsible for the lifecycle of the kubelet running on the workers.
Similarly, Gardener doesn’t manage seed clusters itself,
so Gardener is also not responsible for the lifecycle of the gardenlet running on the seeds.
As a consequence, both the gardenlet and the kubelet need to prepare
a trusted connection to the Gardener API server
and the Kubernetes API server correspondingly.</p><p>To prepare a trusted connection between the gardenlet
and the Gardener API server, the gardenlet initializes
a bootstrapping process after you deployed it into your seed clusters:</p><ol><li><p>The gardenlet starts up with a bootstrap <code>kubeconfig</code>
having a bootstrap token that allows to create <code>CertificateSigningRequest</code> (CSR) resources.</p></li><li><p>After the CSR is signed, the gardenlet downloads
the created client certificate, creates a new <code>kubeconfig</code> with it,
and stores it inside a <code>Secret</code> in the seed cluster.</p></li><li><p>The gardenlet deletes the bootstrap <code>kubeconfig</code> secret,
and starts up with its new <code>kubeconfig</code>.</p></li><li><p>The gardenlet starts normal operation.</p></li></ol><p>The <code>gardener-controller-manager</code> runs a control loop
that automatically signs CSRs created by gardenlets.</p><blockquote><p>The gardenlet bootstrapping process is based on the
kubelet bootstrapping process. More information:
<a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Kubelet&rsquo;s TLS bootstrapping</a>.</p></blockquote><p>If you don&rsquo;t want to run this bootstrap process you can create
a <code>kubeconfig</code> pointing to the garden cluster for the gardenlet yourself,
and use field <code>gardenClientConnection.kubeconfig</code> in the
gardenlet configuration to share it with the gardenlet.</p><h2 id=gardenlet-certificate-rotation>Gardenlet Certificate Rotation</h2><p>The certificate used to authenticate the gardenlet against the API server
has a certain validity based on the configuration of the garden cluster
(<code>--cluster-signing-duration</code> flag of the <code>kube-controller-manager</code> (default <code>1y</code>)).
After about 80% of the validity expired, the gardenlet tries to automatically replace
the current certificate with a new one (certificate rotation).</p><p>To use certificate rotation, you need to specify the secret to store
the <code>kubeconfig</code> with the rotated certificate in field
<code>.gardenClientConnection.kubeconfigSecret</code> of the
gardenlet <a href=#component-configuration>component configuration</a>.</p><h3 id=rotate-certificates-using-bootstrap-kubeconfig>Rotate certificates using bootstrap <code>kubeconfig</code></h3><p>If the gardenlet created the certificate during the initial TLS Bootstrapping
using the Bootstrap <code>kubeconfig</code>, certificates can be rotated automatically.
The same control loop in the <code>gardener-controller-manager</code> that signs
the CSRs during the initial TLS Bootstrapping also automatically signs
the CSR during a certificate rotation.</p><p>ℹ️ You can trigger an immediate renewal by annotating the <code>Secret</code> in the seed
cluster stated in the <code>.gardenClientConnection.kubeconfigSecret</code> field with
<code>gardener.cloud/operation=renew</code> and restarting the gardenlet. After it booted
up again, gardenlet will issue a new certificate independent of the remaining
validity of the existing one.</p><h3 id=rotate-certificate-using-custom-kubeconfig>Rotate Certificate Using Custom <code>kubeconfig</code></h3><p>When trying to rotate a custom certificate that wasn’t created by gardenlet
as part of the TLS Bootstrap, the x509 certificate&rsquo;s <code>Subject</code> field
needs to conform to the following:</p><ul><li>the Common Name (CN) is prefixed with <code>gardener.cloud:system:seed:</code></li><li>the Organization (O) equals <code>gardener.cloud:system:seeds</code></li></ul><p>Otherwise, the <code>gardener-controller-manager</code> doesn’t automatically
sign the CSR.
In this case, an external component or user needs to approve the CSR manually,
for example, using command <code>kubectl certificate approve seed-csr-&lt;...></code>).
If that doesn’t happen within 15 minutes,
the gardenlet repeats the process and creates another CSR.</p><h2 id=configuring-the-seed-to-work-with>Configuring the Seed to work with</h2><p>The Gardenlet works with a single seed, which must be configured in the
<code>GardenletConfiguration</code> under <code>.seedConfig</code>. This must be a copy of the
<code>Seed</code> resource, for example (see <code>example/20-componentconfig-gardenlet.yaml</code>
for a more complete example):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardenlet.config.gardener.cloud/v1alpha1
kind: GardenletConfiguration
seedConfig:
  metadata:
    name: my-seed
  spec:
    provider:
      type: aws
    <span style=color:green># ...</span>
    secretRef:
      name: my-seed-secret
      namespace: garden
</code></pre></div><p>When using <code>make start-gardenlet</code>, the corresponding script will automatically
fetch the seed cluster&rsquo;s <code>kubeconfig</code> based on the <code>seedConfig.spec.secretRef</code>
and set the environment accordingly.</p><p>On startup, gardenlet registers a <code>Seed</code> resource using the given template
in <code>seedConfig</code> if it&rsquo;s not present already.</p><h2 id=component-configuration>Component Configuration</h2><p>In the component configuration for the gardenlet, it’s possible to define:</p><ul><li>settings for the Kubernetes clients interacting with the various clusters</li><li>settings for the control loops inside the gardenlet</li><li>settings for leader election and log levels, feature gates, and seed selection or seed configuration.</li></ul><p>More information: <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>Example Gardenlet Component Configuration</a>.</p><h2 id=heartbeats>Heartbeats</h2><p>Similar to how Kubernetes uses <code>Lease</code> objects for node heart beats
(see <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/589-efficient-node-heartbeats/README.md>KEP</a>),
the gardenlet is using <code>Lease</code> objects for heart beats of the seed cluster.
Every two seconds, the gardenlet checks that the seed cluster&rsquo;s <code>/healthz</code>
endpoint returns HTTP status code 200.
If that is the case, the gardenlet renews the lease in the Garden cluster in the <code>gardener-system-seed-lease</code> namespace and updates
the <code>GardenletReady</code> condition in the <code>status.conditions</code> field of the <code>Seed</code> resource(s).</p><p>Similarly to the <code>node-lifecycle-controller</code> inside the <code>kube-controller-manager</code>,
the <code>gardener-controller-manager</code> features a <code>seed-lifecycle-controller</code> that sets
the <code>GardenletReady</code> condition to <code>Unknown</code> in case the gardenlet fails to renew the lease.
As a consequence, the <code>gardener-scheduler</code> doesn’t consider this seed cluster for newly created shoot clusters anymore.</p><h3 id=healthz-endpoint><code>/healthz</code> Endpoint</h3><p>The gardenlet includes an HTTPS server that serves a <code>/healthz</code> endpoint.
It’s used as a liveness probe in the <code>Deployment</code> of the gardenlet.
If the gardenlet fails to renew its lease
then the endpoint returns <code>500 Internal Server Error</code>, otherwise it returns <code>200 OK</code>.</p><p>Please note that the <code>/healthz</code> only indicates whether the gardenlet
could successfully probe the Seed&rsquo;s API server and renew the lease with
the Garden cluster.
It does <em>not</em> show that the Gardener extension API server (with the Gardener resource groups)
is available.
However, the Gardenlet is designed to withstand such connection outages and
retries until the connection is reestablished.</p><h2 id=control-loops>Control Loops</h2><p>The gardenlet consists out of several controllers which are now described in more detail.</p><p>⚠️ This section is not necessarily complete and might be under construction.</p><h3 id=backupentry-controller><code>BackupEntry</code> Controller</h3><p>The <code>BackupEntry</code> controller reconciles those <code>core.gardener.cloud/v1beta1.BackupEntry</code> resources whose <code>.spec.seedName</code> value is equal to the name of a <code>Seed</code> the respective gardenlet is responsible for.
Those resources are created by the <code>Shoot</code> controller (only if backup is enabled for the respective <code>Seed</code>) and there is exactly one <code>BackupEntry</code> per <code>Shoot</code>.</p><p>The controller creates an <code>extensions.gardener.cloud/v1alpha1.BackupEntry</code> resource (non-namespaced) in the seed cluster and waits until the responsible extension controller reconciled it (see <a href=/docs/gardener/extensions/backupentry/>this</a> for more details).
The status is populated in the <code>.status.lastOperation</code> field.</p><p>The <code>core.gardener.cloud/v1beta1.BackupEntry</code> resource has an owner reference pointing to the corresponding <code>Shoot</code>.
Hence, if the <code>Shoot</code> is deleted, also the <code>BackupEntry</code> resource gets deleted.
In this case, the controller deletes the <code>extensions.gardener.cloud/v1alpha1.BackupEntry</code> resource in the seed cluster and waits until the responsible extension controller has deleted it.
Afterwards, the finalizer of the <code>core.gardener.cloud/v1beta1.BackupEntry</code> resource is released so that it finally disappears from the system.</p><h4 id=keep-backup-for-deleted-shoots>Keep Backup for Deleted Shoots</h4><p>In some scenarios it might be beneficial to not immediately delete the <code>BackupEntry</code>s (and with them, the etcd backup) for deleted <code>Shoot</code>s.</p><p>In this case you can configure the <code>.controllers.backupEntry.deletionGracePeriodHours</code> field in the component configuration of the gardenlet.
For example, if you set it to <code>48</code>, then the <code>BackupEntry</code>s for deleted <code>Shoot</code>s will only be deleted <code>48</code> hours after the <code>Shoot</code> was deleted.</p><p>Additionally, you can limit the <a href=/docs/gardener/usage/shoot_purposes/>shoot purposes</a> for which this applies by setting <code>.controllers.backupEntry.deletionGracePeriodShootPurposes[]</code>.
For example, if you set it to <code>[production]</code> then only the <code>BackupEntry</code>s for <code>Shoot</code>s with <code>.spec.purpose=production</code> will be deleted after the configured grace period. All others will be deleted immediately after the <code>Shoot</code> deletion.</p><h2 id=managed-seeds>Managed Seeds</h2><p>Gardener users can use shoot clusters as seed clusters, so-called &ldquo;managed seeds&rdquo; (aka &ldquo;shooted seeds&rdquo;),
by creating <code>ManagedSeed</code> resources.
By default, the gardenlet that manages this shoot cluster then automatically
creates a clone of itself with the same version and the same configuration
that it currently has.
Then it deploys the gardenlet clone into the managed seed cluster.</p><p>If you want to prevent the automatic gardenlet deployment,
specify the <code>seedTemplate</code> section in the <code>ManagedSeed</code> resource, and don&rsquo;t specify
the <code>gardenlet</code> section.
In this case, you have to deploy the gardenlet on your own into the seed cluster.</p><p>More information: <a href=/docs/gardener/usage/managed_seed/>Register Shoot as Seed</a></p><h2 id=migrating-from-previous-gardener-versions>Migrating from Previous Gardener Versions</h2><p>If your Gardener version doesn’t support gardenlets yet,
no special migration is required, but the following prerequisites must be met:</p><ul><li>Your Gardener version is at least 0.31 before upgrading to v1.</li><li>You have to make sure that your garden cluster is exposed in a way
that it’s reachable from all your seed clusters.</li></ul><p>With previous Gardener versions, you had deployed the Gardener Helm chart
(incorporating the API server, <code>controller-manager</code>, and scheduler).
With v1, this stays the same, but you now have to deploy the gardenlet Helm chart as well
into all of your seeds (if they aren’t managed, as mentioned earlier).</p><p>More information: <a href=/docs/gardener/deployment/deploy_gardenlet/>Deploy a Gardenlet</a> for all instructions.</p><h2 id=related-links>Related Links</h2><p><a href=https://github.com/gardener/documentation/wiki/Architecture>Gardener Architecture</a></p><p><a href=https://github.com/gardener/gardener/issues/356>Issue #356: Implement Gardener Scheduler</a></p><p><a href=https://github.com/gardener/gardener/pull/2309>PR #2309: Add /healthz endpoint for Gardenlet</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-cb07d159d53f4035bc26172627a54c7b>2.10 - Network Policies</h1><h1 id=network-policies-in-gardener>Network Policies in Gardener</h1><p>As <code>Seed</code> clusters can host the <a href=https://kubernetes.io/docs/concepts/#kubernetes-control-plane>Kubernetes control planes</a> of many <code>Shoot</code> clusters, it is necessary to isolate the control planes from each other for security reasons.
Besides deploying each control plane in its own namespace, Gardener creates <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>network policies</a> to also isolate the networks.
Essentially, network policies make sure that pods can only talk to other pods over the network they are supposed to.
As such, network policies are an important part of Gardener&rsquo;s tenant isolation.</p><p>Gardener deploys network policies into</p><ul><li>each namespace hosting the Kubernetes control plane of the Shoot cluster.</li><li>the namespace dedicated to Gardener seed-wide global controllers. This namespace is often called <code>garden</code> and contains e.g. the <a href=https://github.com/gardener/gardener/blob/15cae57db802cbe460ff4cb3f80c26b2fc15e26f/docs/concepts/gardenlet.md>Gardenlet</a>.</li><li>the <code>kube-system</code> namespace in the Shoot.</li></ul><p>The aforementioned namespaces in the Seed contain a <code>deny-all</code> network policy that <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic>denies all ingress and egress traffic</a>.
This <a href=https://en.wikipedia.org/wiki/Secure_by_default>secure by default</a> setting requires pods to allow network traffic.
This is done by pods having <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource>labels matching to the selectors of the network policies</a> deployed by Gardener.</p><p>More details on the deployed network policies can be found in the <a href=https://github.com/gardener/gardener/tree/master/docs/development/seed_network_policies.md>development</a> and <a href=https://github.com/gardener/gardener/tree/master/docs/usage/shoot_network_policies.md>usage</a> sections.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-41370c41a8d3d04ad03bad8e1b4c465e>2.11 - Resource Manager</h1><h1 id=gardener-resource-manager>Gardener Resource Manager</h1><p>Initially, the gardener-resource-manager was a project similar to the <a href=https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/addon-manager>kube-addon-manager</a>.
It manages Kubernetes resources in a target cluster which means that it creates, updates, and deletes them.
Also, it makes sure that manual modifications to these resources are reconciled back to the desired state.</p><p>In the Gardener project we were using the kube-addon-manager since more than two years.
While we have progressed with our <a href=/docs/gardener/proposals/01-extensibility/>extensibility story</a> (moving cloud providers out-of-tree) we had decided that the kube-addon-manager is no longer suitable for this use-case.
The problem with it is that it needs to have its managed resources on its file system.
This requires storing the resources in <code>ConfigMap</code>s or <code>Secret</code>s and mounting them to the kube-addon-manager pod during deployment time.
The gardener-resource-manager uses <code>CustomResourceDefinition</code>s which allows to dynamically add, change, and remove resources with immediate action and without the need to reconfigure the volume mounts/restarting the pod.</p><p>Meanwhile, the <code>gardener-resource-manager</code> has evolved to a more generic component comprising several controllers and webhook handlers.
It is deployed by gardenlet once per seed (in the <code>garden</code> namespace) and once per shoot (in the respective shoot namespaces in the seed).</p><h2 id=controllers>Controllers</h2><h3 id=managedresource-controller><code>ManagedResource</code> controller</h3><p>This controller watches custom objects called <code>ManagedResource</code>s in the <code>resources.gardener.cloud/v1alpha1</code> API group.
These objects contain references to secrets which itself contain the resources to be managed.
The reason why a <code>Secret</code> is used to store the resources is that they could contain confidential information like credentials.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: Secret
metadata:
  name: managedresource-example1
  namespace: default
type: Opaque
data:
  objects.yaml: YXBpVmVyc2lvbjogdjEKa2luZDogQ29uZmlnTWFwCm1ldGFkYXRhOgogIG5hbWU6IHRlc3QtMTIzNAogIG5hbWVzcGFjZTogZGVmYXVsdAotLS0KYXBpVmVyc2lvbjogdjEKa2luZDogQ29uZmlnTWFwCm1ldGFkYXRhOgogIG5hbWU6IHRlc3QtNTY3OAogIG5hbWVzcGFjZTogZGVmYXVsdAo=
    <span style=color:green># apiVersion: v1</span>
    <span style=color:green># kind: ConfigMap</span>
    <span style=color:green># metadata:</span>
    <span style=color:green>#   name: test-1234</span>
    <span style=color:green>#   namespace: default</span>
    <span style=color:green># ---</span>
    <span style=color:green># apiVersion: v1</span>
    <span style=color:green># kind: ConfigMap</span>
    <span style=color:green># metadata:</span>
    <span style=color:green>#   name: test-5678</span>
    <span style=color:green>#   namespace: default</span>
---
apiVersion: resources.gardener.cloud/v1alpha1
kind: ManagedResource
metadata:
  name: example
  namespace: default
spec:
  secretRefs:
  - name: managedresource-example1
</code></pre></div><p>In the above example, the controller creates two <code>ConfigMap</code>s in the <code>default</code> namespace.
When a user is manually modifying them they will be reconciled back to the desired state stored in the <code>managedresource-example</code> secret.</p><p>It is also possible to inject labels into all the resources:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: Secret
metadata:
  name: managedresource-example2
  namespace: default
type: Opaque
data:
  other-objects.yaml: YXBpVmVyc2lvbjogYXBwcy92MSAjIGZvciB2ZXJzaW9ucyBiZWZvcmUgMS45LjAgdXNlIGFwcHMvdjFiZXRhMgpraW5kOiBEZXBsb3ltZW50Cm1ldGFkYXRhOgogIG5hbWU6IG5naW54LWRlcGxveW1lbnQKc3BlYzoKICBzZWxlY3RvcjoKICAgIG1hdGNoTGFiZWxzOgogICAgICBhcHA6IG5naW54CiAgcmVwbGljYXM6IDIgIyB0ZWxscyBkZXBsb3ltZW50IHRvIHJ1biAyIHBvZHMgbWF0Y2hpbmcgdGhlIHRlbXBsYXRlCiAgdGVtcGxhdGU6CiAgICBtZXRhZGF0YToKICAgICAgbGFiZWxzOgogICAgICAgIGFwcDogbmdpbngKICAgIHNwZWM6CiAgICAgIGNvbnRhaW5lcnM6CiAgICAgIC0gbmFtZTogbmdpbngKICAgICAgICBpbWFnZTogbmdpbng6MS43LjkKICAgICAgICBwb3J0czoKICAgICAgICAtIGNvbnRhaW5lclBvcnQ6IDgwCg==
    <span style=color:green># apiVersion: apps/v1</span>
    <span style=color:green># kind: Deployment</span>
    <span style=color:green># metadata:</span>
    <span style=color:green>#   name: nginx-deployment</span>
    <span style=color:green># spec:</span>
    <span style=color:green>#   selector:</span>
    <span style=color:green>#     matchLabels:</span>
    <span style=color:green>#       app: nginx</span>
    <span style=color:green>#   replicas: 2 # tells deployment to run 2 pods matching the template</span>
    <span style=color:green>#   template:</span>
    <span style=color:green>#     metadata:</span>
    <span style=color:green>#       labels:</span>
    <span style=color:green>#         app: nginx</span>
    <span style=color:green>#     spec:</span>
    <span style=color:green>#       containers:</span>
    <span style=color:green>#       - name: nginx</span>
    <span style=color:green>#         image: nginx:1.7.9</span>
    <span style=color:green>#         ports:</span>
    <span style=color:green>#         - containerPort: 80</span>

---
apiVersion: resources.gardener.cloud/v1alpha1
kind: ManagedResource
metadata:
  name: example
  namespace: default
spec:
  secretRefs:
  - name: managedresource-example2
  injectLabels:
    foo: bar
</code></pre></div><p>In this example the label <code>foo=bar</code> will be injected into the <code>Deployment</code> as well as into all created <code>ReplicaSet</code>s and <code>Pod</code>s.</p><h4 id=preventing-reconciliations>Preventing Reconciliations</h4><p>If a ManagedResource is annotated with <code>resources.gardener.cloud/ignore=true</code> then it will be skipped entirely by the controller (no reconciliations or deletions of managed resources at all).
However, when the ManagedResource itself is deleted (for example when a shoot is deleted) then the annotation is not respected and all resources will be deleted as usual.
This feature can be helpful to temporarily patch/change resources managed as part of such ManagedResource.</p><h4 id=modes>Modes</h4><p>The gardener-resource-manager can manage a resource in different modes. The supported modes are:</p><ul><li><code>Ignore</code><ul><li>The corresponding resource is removed from the ManagedResource status (<code>.status.resources</code>). No action is performed on the cluster - the resource is no longer &ldquo;managed&rdquo; (updated or deleted).</li><li>The primary use case is a migration of a resource from one ManagedResource to another one.</li></ul></li></ul><p>The mode for a resource can be specified with the <code>resources.gardener.cloud/mode</code> annotation. The annotation should be specified in the encoded resource manifest in the Secret that is referenced by the ManagedResource.</p><h4 id=resource-class>Resource Class</h4><p>By default, gardener-resource-manager controller watches for ManagedResources in all namespaces. <code>--namespace</code> flag can be specified to gardener-resource-manager binary to restrict the watch to ManagedResources in a single namespace.
A ManagedResource has an optional <code>.spec.class</code> field that allows to indicate that it belongs to given class of resources. <code>--resource-class</code> flag can be specified to gardener-resource-manager binary to restrict the watch to ManagedResources with the given <code>.spec.class</code>. A default class is assumed if no class is specified.</p><h4 id=conditions>Conditions</h4><p>A ManagedResource has a ManagedResourceStatus, which has an array of Conditions. Conditions currently include:</p><table><thead><tr><th>Condition</th><th>Description</th></tr></thead><tbody><tr><td><code>ResourcesApplied</code></td><td><code>True</code> if all resources are applied to the target cluster</td></tr><tr><td><code>ResourcesHealthy</code></td><td><code>True</code> if all resources are present and healthy</td></tr></tbody></table><p><code>ResourcesApplied</code> may be <code>False</code> when:</p><ul><li>the resource <code>apiVersion</code> is not known to the target cluster</li><li>the resource spec is invalid (for example the label value does not match the required regex for it)</li><li>&mldr;</li></ul><p><code>ResourcesHealthy</code> may be <code>False</code> when:</p><ul><li>the resource is not found</li><li>the resource is a Deployment and the Deployment does not have the minimum availability.</li><li>&mldr;</li></ul><p>Each Kubernetes resources has different notion for being healthy. For example, a Deployment is considered healthy if the controller observed its current revision and if the number of updated replicas is equal to the number of replicas.</p><p>The following section describes a healthy ManagedResource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#a31515>&#34;conditions&#34;</span><span>:</span> [
  {
    &#34;type&#34;: <span style=color:#a31515>&#34;ResourcesApplied&#34;</span>,
    &#34;status&#34;: <span style=color:#a31515>&#34;True&#34;</span>,
    &#34;reason&#34;: <span style=color:#a31515>&#34;ApplySucceeded&#34;</span>,
    &#34;message&#34;: <span style=color:#a31515>&#34;All resources are applied.&#34;</span>,
    &#34;lastUpdateTime&#34;: <span style=color:#a31515>&#34;2019-09-09T11:31:21Z&#34;</span>,
    &#34;lastTransitionTime&#34;: <span style=color:#a31515>&#34;2019-09-08T19:53:23Z&#34;</span>
  },
  {
    &#34;type&#34;: <span style=color:#a31515>&#34;ResourcesHealthy&#34;</span>,
    &#34;status&#34;: <span style=color:#a31515>&#34;True&#34;</span>,
    &#34;reason&#34;: <span style=color:#a31515>&#34;ResourcesHealthy&#34;</span>,
    &#34;message&#34;: <span style=color:#a31515>&#34;All resources are healthy.&#34;</span>,
    &#34;lastUpdateTime&#34;: <span style=color:#a31515>&#34;2019-09-09T11:31:21Z&#34;</span>,
    &#34;lastTransitionTime&#34;: <span style=color:#a31515>&#34;2019-09-09T11:31:21Z&#34;</span>
  }
]  
</code></pre></div><h4 id=ignoring-updates>Ignoring Updates</h4><p>In some cases it is not desirable to update or re-apply some of the cluster components (for example, if customization is required or needs to be applied by the end-user).
For these resources, the annotation &ldquo;resources.gardener.cloud/ignore&rdquo; needs to be set to &ldquo;true&rdquo; or a truthy value (Truthy values are &ldquo;1&rdquo;, &ldquo;t&rdquo;, &ldquo;T&rdquo;, &ldquo;true&rdquo;, &ldquo;TRUE&rdquo;, &ldquo;True&rdquo;) in the corresponding managed resource secrets,
this can be done from the components that create the managed resource secrets, for example Gardener extensions or Gardener. Once this is done, the resource will be initially created and later ignored during reconciliation.</p><h4 id=preserving-replicas-or-resources-in-workload-resources>Preserving <code>replicas</code> or <code>resources</code> in Workload Resources</h4><p>The objects which are part of the <code>ManagedResource</code> can be annotated with</p><ul><li><code>resources.gardener.cloud/preserve-replicas=true</code> in case the <code>.spec.replicas</code> field of workload resources like <code>Deployment</code>s, <code>StatefulSet</code>s, etc. shall be preserved during updates.</li><li><code>resources.gardener.cloud/preserve-resources=true</code> in case the <code>.spec.containers[*].resources</code> fields of all containers of workload resources like <code>Deployment</code>s, <code>StatefulSet</code>s, etc. shall be preserved during updates.</li></ul><blockquote><p>This can be useful if there are non-standard horizontal/vertical auto-scaling mechanisms in place.
Standard mechanisms like <code>HorizontalPodAutoscaler</code> or <code>VerticalPodAutoscaler</code> will be auto-recognized by <code>gardener-resource-manager</code>, i.e., in such cases the annotations are not needed.</p></blockquote><h4 id=origin>Origin</h4><p>All the objects managed by the resource manager get a dedicated annotation
<code>resources.gardener.cloud/origin</code> describing the <code>ManagedResource</code> object that describes
this object.</p><p>By default this is in this format &lt;namespace>/&lt;objectname>.
In multi-cluster scenarios (the <code>ManagedResource</code> objects are maintained in a
cluster different from the one the described objects are managed), it might
be useful to include the cluster identity, as well.</p><p>This can be enforced by setting the <code>--cluster-id</code> option. Here, several
possibilities are supported:</p><ul><li>given a direct value: use this as id for the source cluster</li><li><code>&lt;cluster></code>: read the cluster identity from a <code>cluster-identity</code> config map
in the <code>kube-system</code> namespace (attribute <code>cluster-identity</code>). This is
automatically maintained in all clusters managed or involved in a gardener landscape.</li><li><code>&lt;default></code>: try to read the cluster identity from the config map. If not found,
no identity is used</li><li>empty string: no cluster identity is used (completely cluster local scenarios)</li></ul><p>The format of the origin annotation with a cluster id is &lt;cluster id>:&lt;namespace>/&lt;objectname>.</p><p>The default for the cluster id is the empty value (do not use cluster id).</p><h3 id=garbage-collector-for-immutable-configmapssecrets>Garbage Collector For Immutable <code>ConfigMap</code>s/<code>Secret</code>s</h3><p>In Kubernetes, workload resources (e.g., <code>Pod</code>s) can mount <code>ConfigMap</code>s or <code>Secret</code>s or reference them via environment variables in containers.
Typically, when the content of such <code>ConfigMap</code>/<code>Secret</code> gets changed then the respective workload is usually not dynamically reloading the configuration, i.e., a restart is required.
The most commonly used approach is probably having so-called <a href=https://helm.sh/docs/howto/charts_tips_and_tricks/#automatically-roll-deployments>checksum annotations in the pod template</a> which makes Kubernetes to recreate the pod if the checksum changes.
However, it has the downside that old, still running versions of the workload might not be able to properly work with the already updated content in the <code>ConfigMap</code>/<code>Secret</code>, potentially causing application outages.</p><p>In order to protect users from such outages (and to also improve the performance of the cluster), the Kubernetes community provides the <a href=https://kubernetes.io/docs/concepts/configuration/configmap/#configmap-immutable>&ldquo;immutable <code>ConfigMap</code>s/<code>Secret</code>s feature&rdquo;</a>.
Enabling immutability requires <code>ConfigMap</code>s/<code>Secret</code>s to have unique names.
Having unique names requires the client to delete <code>ConfigMap</code>s<code>/</code>Secret`s no longer in use.</p><p>In order to provide a similarly lightweight experience for clients (compared to the well-established checksum annotation approach), the Gardener Resource Manager features an optional garbage collector controller (disabled by default).
The purpose of this controller is cleaning up such immutable <code>ConfigMap</code>s/<code>Secret</code>s if they are no longer in use.</p><h4 id=how-does-the-garbage-collector-work>How does the garbage collector work?</h4><p>The following algorithm is implemented in the GC controller:</p><ol><li>List all <code>ConfigMap</code>s and <code>Secret</code>s labeled with <code>resources.gardener.cloud/garbage-collectable-reference=true</code>.</li><li>List all <code>Deployment</code>s, <code>StatefulSet</code>s, <code>DaemonSet</code>s, <code>Job</code>s, <code>CronJob</code>s, <code>Pod</code>s and for each of them<ol><li>iterate over the <code>.metadata.annotations</code> and for each of them<ol><li>If the annotation key follows the <code>reference.resources.gardener.cloud/{configmap,secret}-&lt;hash></code> scheme and the value equals <code>&lt;name></code> then consider it as &ldquo;in-use&rdquo;.</li></ol></li></ol></li><li>Delete all <code>ConfigMap</code>s and <code>Secret</code>s not considered as &ldquo;in-use&rdquo;.</li></ol><p>Consequently, clients need to</p><ol><li><p>Create immutable <code>ConfigMap</code>s/<code>Secret</code>s with unique names (e.g., a checksum suffix based on the <code>.data</code>).</p></li><li><p>Label such <code>ConfigMap</code>s/<code>Secret</code>s with <code>resources.gardener.cloud/garbage-collectable-reference=true</code>.</p></li><li><p>Annotate their workload resources with <code>reference.resources.gardener.cloud/{configmap,secret}-&lt;hash>=&lt;name></code> for all <code>ConfigMap</code>s/<code>Secret</code>s used by the containers of the respective <code>Pod</code>s.</p><p>⚠️ Add such annotations to <code>.metadata.annotations</code> as well as to all templates of other resources (e.g., <code>.spec.template.metadata.annotations</code> in <code>Deployment</code>s or <code>.spec.jobTemplate.metadata.annotations</code> and <code>.spec.jobTemplate.spec.template.metadata.annotations</code> for <code>CronJob</code>s.
This ensures that the GC controller does not unintentionally consider <code>ConfigMap</code>s/<code>Secret</code>s as &ldquo;not in use&rdquo; just because there isn&rsquo;t a <code>Pod</code> referencing them anymore (e.g., they could still be used by a <code>Deployment</code> scaled down to <code>0</code>).</p></li></ol><p>ℹ️ For the last step, there is a helper function <code>InjectAnnotations</code> in the <code>pkg/controller/garbagecollector/references</code> which you can use for your convenience.</p><p><strong>Example:</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-1234
  namespace: default
  labels:
    resources.gardener.cloud/garbage-collectable-reference: <span style=color:#a31515>&#34;true&#34;</span>
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-5678
  namespace: default
  labels:
    resources.gardener.cloud/garbage-collectable-reference: <span style=color:#a31515>&#34;true&#34;</span>
---
apiVersion: v1
kind: Pod
metadata:
  name: example
  namespace: default
  annotations:
    reference.resources.gardener.cloud/configmap-82a3537f: test-5678
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    terminationGracePeriodSeconds: 2
</code></pre></div><p>The GC controller would delete the <code>ConfigMap/test-1234</code> because it is considered as not &ldquo;in-use&rdquo;.</p><p>ℹ️ If the GC controller is activated then the <code>ManagedResource</code> controller will no longer delete <code>ConfigMap</code>s/<code>Secret</code>s having the above label.</p><h4 id=how-to-activate-the-garbage-collector>How to activate the garbage collector?</h4><p>The GC controller can be activated by providing the <code>--garbage-collector-sync-period</code> flag with a value larger than <code>0</code> (e.g., <code>1h</code>) to the Gardener Resource Manager.</p><h3 id=tokeninvalidator>TokenInvalidator</h3><p>The Kubernetes community is slowly transitioning from static <code>ServiceAccount</code> token <code>Secret</code>s to <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection><code>ServiceAccount</code> Token Volume Projection</a>.
Typically, when you create a <code>ServiceAccount</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ServiceAccount
metadata:
  name: default
</code></pre></div><p>then the <a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/serviceaccount/tokens_controller.go><code>serviceaccount-token</code></a> controller (part of <code>kube-controller-manager</code>) auto-generates a <code>Secret</code> with a static token:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
   annotations:
      kubernetes.io/service-account.name: default
      kubernetes.io/service-account.uid: 86e98645-2e05-11e9-863a-b2d4d086dd5a)
   name: default-token-ntxs9
type: kubernetes.io/service-account-token
data:
   ca.crt: base64(cluster-ca-cert)
   namespace: base64(namespace)
   token: base64(static-jwt-token)
</code></pre></div><p>Unfortunately, when using <code>ServiceAccount</code> Token Volume Projection in a <code>Pod</code>, this static token is actually not used at all:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  serviceAccountName: default
  containers:
  - image: nginx
    name: nginx
    volumeMounts:
    - mountPath: /var/run/secrets/tokens
      name: token
  volumes:
  - name: token
    projected:
      sources:
      - serviceAccountToken:
          path: token
          expirationSeconds: 7200
</code></pre></div><p>While the <code>Pod</code> is now using an expiring and auto-rotated token, the static token is still generated and valid.</p><p>As of Kubernetes v1.22, there is neither a way of preventing <code>kube-controller-manager</code> to generate such static tokens, nor a way to proactively remove or invalidate them:</p><ul><li><a href=https://github.com/kubernetes/kubernetes/issues/77599>https://github.com/kubernetes/kubernetes/issues/77599</a></li><li><a href=https://github.com/kubernetes/kubernetes/issues/77600>https://github.com/kubernetes/kubernetes/issues/77600</a></li></ul><p>Disabling the <code>serviceaccount-token</code> controller is an option, however, especially in the Gardener context it may either break end-users or it may not even be possible to control such settings.
Also, even if a future Kubernetes version supports native configuration of above behaviour, Gardener still supports older versions which won&rsquo;t get such features but need a solution as well.</p><p>This is where the <em>TokenInvalidator</em> comes into play:
Since it is not possible to prevent <code>kube-controller-manager</code> from generating static <code>ServiceAccount</code> <code>Secret</code>s, the <em>TokenInvalidator</em> is - as its name suggests - just invalidating these tokens.
It considers all such <code>Secret</code>s belonging to <code>ServiceAccount</code>s with <code>.automountServiceAccountToken=false</code>.
By default, all namespaces in the target cluster are watched, however, this can be configured by specifying the <code>--target-namespace</code> flag.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-serviceaccount
automountServiceAccountToken: <span style=color:#00f>false</span>
</code></pre></div><p>This will result in a static <code>ServiceAccount</code> token secret whose <code>token</code> value is invalid:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: my-serviceaccount
    kubernetes.io/service-account.uid: 86e98645-2e05-11e9-863a-b2d4d086dd5a
  name: my-serviceaccount-token-ntxs9
type: kubernetes.io/service-account-token
data:
  ca.crt: base64(cluster-ca-cert)
  namespace: base64(namespace)
  token: AAAA
</code></pre></div><p>Any attempt to regenerate the token or creating a new such secret will again make the component invalidating it.</p><blockquote><p>You can opt-out of this behaviour for <code>ServiceAccount</code>s setting <code>.automountServiceAccountToken=false</code> by labeling them with <code>token-invalidator.resources.gardener.cloud/skip=true</code>.</p></blockquote><p>In order to enable the <em>TokenInvalidator</em> you have to set <code>--token-invalidator-max-concurrent-workers</code> to a value larger than <code>0</code>.</p><p>Below graphic shows an overview of the Token Invalidator for Service account secrets in the Shoot cluster.
<img src=/__resources/resource-manager-token-invalidator_b43fa2.jpg alt=image></p><h3 id=tokenrequestor>TokenRequestor</h3><p>This controller provides the service to create and auto-renew tokens via the <a href=https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/><code>TokenRequest</code> API</a>.</p><p>It provides a functionality similar to the kubelet&rsquo;s <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>Service Account Token Volume Projection</a>.
It was created to handle the special case of issuing tokens to pods that run in a different cluster than the API server they communicate with (hence, using the native token volume projection feature is not possible).</p><p>The controller differentiates between <code>source cluster</code> and <code>target cluster</code>.
The <code>source cluster</code> hosts the gardener-resource-manager pod. Secrets in this cluster are watched and modified by the controller.
The <code>target cluster</code> <em>can</em> be configured to point to another cluster. The existence of ServiceAccounts are ensured and token requests are issued against the target.
When the gardener-resource-manager is deployed next to the Shoot&rsquo;s controlplane in the Seed the <code>source cluster</code> is the Seed while the <code>target cluster</code> points to the Shoot.</p><h4 id=reconciliation-loop>Reconciliation Loop</h4><p>This controller reconciles secrets in all namespaces in the source cluster with the label: <code>resources.gardener.cloud/purpose: token-requestor</code>.
See <a href=https://github.com/gardener/gardener/blob/master/example/resource-manager/30-secret-tokenrequestor.yaml>here</a> for an example of the secret.</p><p>The controller ensures a <code>ServiceAccount</code> exists in the target cluster as specified in the annotations of the <code>Secret</code> in the source cluster:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>serviceaccount.resources.gardener.cloud/name: &lt;sa-name&gt;
serviceaccount.resources.gardener.cloud/namespace: &lt;sa-namespace&gt;
</code></pre></div><p>The requested tokens will act with the privileges which are assigned to this <code>ServiceAccount</code>.</p><p>The controller will then request a token via the <a href=https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/><code>TokenRequest</code> API</a> and populate it into the <code>.data.token</code> field to the <code>Secret</code> in the source cluster.</p><p>Alternatively, the client can provide a raw kubeconfig (in YAML or JSON format) via the <code>Secret</code>&rsquo;s <code>.data.kubeconfig</code> field.
The controller will then populate the requested token in the kubeconfig for the user used in the <code>.current-context</code>.
For example, if <code>.data.kubeconfig</code> is</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: AAAA
    server: some-server-url
  name: shoot--foo--bar
contexts:
- context:
    cluster: shoot--foo--bar
    user: shoot--foo--bar-token
  name: shoot--foo--bar
current-context: shoot--foo--bar
kind: Config
preferences: {}
users:
- name: shoot--foo--bar-token
  user:
    token: <span style=color:#a31515>&#34;&#34;</span>
</code></pre></div><p>then the <code>.users[0].user.token</code> field of the kubeconfig will be updated accordingly.</p><p>The controller also adds an annotation to the <code>Secret</code> to keep track when to renew the token before it expires.
By default, the tokens are issued to expire after 12 hours. The expiration time can be set with the following annotation:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>serviceaccount.resources.gardener.cloud/token-expiration-duration: 6h
</code></pre></div><p>It automatically renews once 80% of the lifetime is reached or after <code>24h</code>.</p><p>Optionally, the controller can also populate the token into a <code>Secret</code> in the target cluster. This can be requested by annotating the <code>Secret</code> in the source cluster with</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>token-requestor.resources.gardener.cloud/target-secret-name: <span style=color:#a31515>&#34;foo&#34;</span>
token-requestor.resources.gardener.cloud/target-secret-namespace: <span style=color:#a31515>&#34;bar&#34;</span>
</code></pre></div><p>Overall, the TokenRequestor controller provides credentials with limited lifetime (JWT tokens) used by Shoot control plane components running in the Seed
to talk to the Shoot API Server.
Please see the graphic below:</p><p><img src=/__resources/resource-manager-projected-token-controlplane-to-shoot-apiserver_da4cda.jpg alt=image></p><h2 id=webhooks>Webhooks</h2><h3 id=auto-mounting-projected-serviceaccount-tokens>Auto-Mounting Projected <code>ServiceAccount</code> Tokens</h3><p>When this webhook is activated then it automatically injects projected <code>ServiceAccount</code> token volumes into <code>Pod</code>s and all its containers if all of the following preconditions are fulfilled:</p><ol><li>The <code>Pod</code> is NOT labeled with <code>projected-token-mount.resources.gardener.cloud/skip=true</code>.</li><li>The <code>Pod</code>&rsquo;s <code>.spec.serviceAccountName</code> field is NOT empty and NOT set to <code>default</code>.</li><li>The <code>ServiceAccount</code> specified in the <code>Pod</code>&rsquo;s <code>.spec.serviceAccountName</code> sets <code>.automountServiceAccountToken=false</code>.</li><li>The <code>Pod</code>&rsquo;s <code>.spec.volumes[]</code> DO NOT already contain a volume with a name prefixed with <code>kube-api-access-</code>.</li></ol><p>The projected volume will look as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  volumes:
  - name: kube-api-access-gardener
    projected:
      defaultMode: 420
      sources:
      - serviceAccountToken:
          expirationSeconds: 43200
          path: token
      - configMap:
          items:
          - key: ca.crt
            path: ca.crt
          name: kube-root-ca.crt
      - downwardAPI:
          items:
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
            path: namespace
</code></pre></div><blockquote><p>The <code>expirationSeconds</code> are defaulted to <code>12h</code> and can be overwritten with the <code>--projected-token-mount-expiration-seconds</code> flag, or with the <code>projected-token-mount.resources.gardener.cloud/expiration-seconds</code> annotation on a <code>Pod</code> resource.</p></blockquote><p>The volume will be mounted into all containers specified in the <code>Pod</code> to the path <code>/var/run/secrets/kubernetes.io/serviceaccount</code>.
This is the default location where client libraries expect to find the tokens and mimics the <a href=https://github.com/kubernetes/kubernetes/tree/v1.22.2/plugin/pkg/admission/serviceaccount>upstream <code>ServiceAccount</code> admission plugin</a>, see <a href=https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#serviceaccount-admission-controller>this document</a> for more information.</p><p>Overall, this webhook is used to inject projected service account tokens into pods running in the Shoot and the Seed cluster.
Hence, it is served from the Seed GRM and each Shoot GRM.
Please find an overview below for pods deployed in the Shoot cluster:</p><p><img src=/__resources/resource-manager-projected-token-shoot-to-shoot-apiserver_4fdaf3.jpg alt=image></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d13c2ec04fc608d6d65a3a24ab54fbf9>2.12 - Scheduler</h1><h1 id=gardener-scheduler>Gardener Scheduler</h1><p>The Gardener Scheduler is in essence a controller that watches newly created shoots and assigns a seed cluster to them.
Conceptually, the task of the Gardener Scheduler is very similar to the task of the Kubernetes Scheduler: finding a seed for a shoot instead of a node for a pod.</p><p>Either the scheduling strategy or the shoot cluster purpose hereby determines how the scheduler is operating.
The following sections explain the configuration and flow in greater detail.</p><h2 id=why-is-the-gardener-scheduler-needed>Why is the Gardener Scheduler needed?</h2><h3 id=1-decoupling>1. Decoupling</h3><p>Previously, an admission plugin in the Gardener API server conducted the scheduling decisions.
This implies changes to the API server whenever adjustments of the scheduling are needed.
Decoupling the API server and the scheduler comes with greater flexibility to develop these components independently from each other.</p><h3 id=2-extensibility>2. Extensibility</h3><p>It should be possible to easily extend and tweak the scheduler in the future.
Possibly, similar to the Kubernetes scheduler, hooks could be provided which influence the scheduling decisions.
It should be also possible to completely replace the standard Gardener Scheduler with a custom implementation.</p><h2 id=algorithm-overview>Algorithm overview</h2><p>The following <strong>sequence</strong> describes the steps involved to determine a seed candidate:</p><ol><li>Determine usable seeds with &ldquo;usable&rdquo; defined as follows:<ul><li>no <code>.metadata.deletionTimestamp</code></li><li><code>.spec.settings.scheduling.visible</code> is <code>true</code></li><li>conditions <code>Bootstrapped</code>, <code>GardenletReady</code>, <code>BackupBucketsReady</code> (if available) are <code>true</code></li></ul></li><li>Filter seeds:<ul><li>matching <code>.spec.seedSelector</code> in <code>CloudProfile</code> used by the <code>Shoot</code></li><li>matching <code>.spec.seedSelector</code> in <code>Shoot</code></li><li>having no network intersection with the <code>Shoot</code>&rsquo;s networks (due to the VPN connectivity between seeds and shoots their networks must be disjoint)</li><li>having <code>.spec.settings.shootDNS.enabled=false</code> (only if the shoot specifies a DNS domain or does not use the <code>unmanaged</code> DNS provider)</li><li>whose taints (<code>.spec.taints</code>) are tolerated by the <code>Shoot</code> (<code>.spec.tolerations</code>)</li><li>whose capacity for shoots would not be exceeded if the shoot is scheduled onto the seed, see <a href=#ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring seeds capacity for shoots is not exceeded</a></li></ul></li><li>Apply active <a href=#strategies>strategy</a> e.g., <em>Minimal Distance strategy</em></li><li>Choose least utilized seed, i.e., the one with the least number of shoot control planes, will be the winner and written to the <code>.spec.seedName</code> field of the <code>Shoot</code>.</li></ol><h2 id=configuration>Configuration</h2><p>The Gardener Scheduler configuration has to be supplied on startup. It is a mandatory and also the only available flag.
<a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardener-scheduler.yaml>Here</a> is an example scheduler configuration.</p><p>Most of the configuration options are the same as in the Gardener Controller Manager (leader election, client connection, &mldr;).
However, the Gardener Scheduler on the other hand does not need a TLS configuration, because there are currently no webhooks configurable.</p><h2 id=strategies>Strategies</h2><p>The scheduling strategy is defined in the <em><strong>candidateDeterminationStrategy</strong></em> of the scheduler&rsquo;s configuration and can have the possible values <code>SameRegion</code> and <code>MinimalDistance</code>.
The <code>SameRegion</code> strategy is the default strategy.</p><ol><li><p><em>Same Region strategy</em></p><p>The Gardener Scheduler reads the <code>spec.provider.type</code> and <code>.spec.region</code> fields from the <code>Shoot</code> resource.
It tries to find a seed that has the identical <code>.spec.provider.type</code> and <code>.spec.provider.region</code> fields set.
If it cannot find a suitable seed, it adds an event to the shoot stating, that it is unschedulable.</p></li><li><p><em>Minimal Distance strategy</em></p><p>The Gardener Scheduler tries to find a valid seed with minimal distance to the shoot&rsquo;s intended region.
The distance is calculated based on the Levenshtein distance of the region. Therefore the region name
is split into a base name and an orientation. Possible orientations are <code>north</code>, <code>south</code>, <code>east</code>, <code>west</code> and <code>central</code>.
The distance then is twice the Levenshtein distance of the region&rsquo;s base name plus a correction value based on the
orientation and the provider.</p><p>If the orientations of shoot and seed candidate match, the correction value is 0, if they differ it is 2 and if
either the seed&rsquo;s or the shoot&rsquo;s region does not have an orientation it is 1.
If the provider differs the correction value is additionally incremented by 2.</p><p>Because of this a matching region with a matching provider is always prefered.</p></li></ol><p>In order to put the scheduling decision into effect, the scheduler sends an update request for the <code>Shoot</code> resource to
the API server. After validation, the Gardener Aggregated API server updates the shoot to have the <code>spec.seedName</code> field set.
Subsequently, the Gardenlet picks up and starts to create the cluster on the specified seed.</p><ol start=3><li><em>Special handling based on shoot cluster purpose</em></li></ol><p>Every shoot cluster can have a purpose that describes what the cluster is used for, and also influences how the cluster is setup (see <a href=/docs/gardener/usage/shoot_purposes/>this document</a> for more information).</p><p>In case the shoot has the <code>testing</code> purpose then the scheduler only reads the <code>.spec.provider.type</code> from the <code>Shoot</code> resource and tries to find a <code>Seed</code> that has the identical <code>.spec.provider.type</code>.
The region does not matter, i.e., <code>testing</code> shoots may also be scheduled on a seed in a complete different region if it is better for balancing the whole Gardener system.</p><h2 id=seedselector-field-in-the-shoot-specification><code>seedSelector</code> field in the <code>Shoot</code> specification</h2><p>Similar to the <code>.spec.nodeSelector</code> field in <code>Pod</code>s, the <code>Shoot</code> specification has an optional <code>.spec.seedSelector</code> field.
It allows the user to provide a label selector that must match the labels of <code>Seed</code>s in order to be scheduled to one of them.
The labels on <code>Seed</code>s are usually controlled by Gardener administrators/operators - end users cannot add arbitrary labels themselves.
If provided, the Gardener Scheduler will only consider those seeds as &ldquo;suitable&rdquo; whose labels match those provided in the <code>.spec.seedSelector</code> of the <code>Shoot</code>.</p><p>By default only seeds with the same provider than the shoot are selected. By adding a <code>providerTypes</code> field to the <code>seedSelector</code>
a dedicated set of possible providers (<code>*</code> means all provider types) can be selected.</p><h2 id=ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring seeds capacity for shoots is not exceeded</h2><p>Seeds have a practical limit of how many shoots they can accommodate. Exceeding this limit is undesirable as the system performance will be noticeably impacted. Therefore, the scheduler ensures that a seed&rsquo;s capacity for shoots is not exceeded by taking into account a maximum number of shoots that can be scheduled onto a seed.</p><p>This mechanism works as follows:</p><ul><li>The <code>gardenlet</code> is configured with certain <em>resources</em> and their total <em>capacity</em> (and, for certain resources, the amount <em>reserved</em> for Gardener), see <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>/example/20-componentconfig-gardenlet.yaml</a>. Currently, the only such resource is the maximum number of shoots that can be scheduled onto a seed.</li><li>The <code>gardenlet</code> seed controller updates the <code>capacity</code> and <code>allocatable</code> fields in Seed status with the capacity of each resource and how much of it is actually available to be consumed by shoots. The <code>allocatable</code> value of a resource is equal to <code>capacity</code> minus <code>reserved</code>.</li><li>When scheduling shoots, the scheduler filters out all candidate seeds whose allocatable capacity for shoots would be exceeded if the shoot is scheduled onto the seed.</li></ul><h2 id=failure-to-determine-a-suitable-seed>Failure to determine a suitable seed</h2><p>In case the scheduler fails to find a suitable seed, the operation is being retried with exponential backoff.</p><h2 id=current-limitation--future-plans>Current Limitation / Future Plans</h2><ul><li>Azure has unfortunately a geographically non-hierarchical naming pattern and does not start with the continent. This is the reason why we will exchange the implementation of the <code>MinimalDistance</code> strategy with a more suitable one in the future.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-948cfa9fe34970ab31d7b3bb36556f67>2.13 - Seed Admission Controller</h1><h1 id=gardener-seed-admission-controller>Gardener Seed Admission Controller</h1><p>The Gardener Seed admission controller is deployed by the Gardenlet as part of its seed bootstrapping phase and, consequently, running in every seed cluster.
It&rsquo;s main purpose is to serve webhooks (validating or mutating) in order to admit or deny certain requests to the seed&rsquo;s API server.</p><h2 id=what-is-it-doing-concretely>What is it doing concretely?</h2><h3 id=validating-webhooks>Validating Webhooks</h3><h4 id=unconfirmed-deletion-prevention>Unconfirmed Deletion Prevention</h4><p>As part of Gardener&rsquo;s <a href=/docs/gardener/extensions/overview/>extensibility concepts</a> a lot of <code>CustomResourceDefinition</code>s are deployed to the seed clusters that serve as extension points for provider-specific controllers.
For example, the <a href=/docs/gardener/extensions/infrastructure/><code>Infrastructure</code> CRD</a> triggers the provider extension to prepare the IaaS infrastructure of the underlying cloud provider for a to-be-created shoot cluster.
Consequently, these extension CRDs have a lot of power and control large portions of the end-user&rsquo;s shoot cluster.
Accidental or undesired deletions of those resource can cause tremendous and hard-to-recover-from outages and should be prevented.</p><p>Together with the deployment of the Gardener seed admission controller a <code>ValidatingWebhookConfiguration</code> for <code>CustomResourceDefinitions</code> and most (custom) resources in the <code>extensions.gardener.cloud/v1alpha1</code> API group is registered.
It prevents <code>DELETE</code> requests for those <code>CustomResourceDefinitions</code> labeled with <code>gardener.cloud/deletion-protected=true</code>, and for all mentioned custom resources if they were not previously annotated with the <code>confirmation.gardener.cloud/deletion=true</code>.
This prevents that undesired <code>kubectl delete &lt;...></code> requests are accepted.</p><h3 id=mutating-webhooks>Mutating Webhooks</h3><p>The admission controller endpoint <code>/webhooks/default-pod-scheduler-name/gardener-kube-scheduler</code> mutates <code>pods</code> and adds <code>gardener-kube-scheduler</code> to <code>.spec.scheduleName</code>.</p><p>When <code>SeedKubeScheduler</code> feature gate is enabled, all control plane components are mutated. The scheduler scores <code>Nodes</code> with most resource usage higher than the rest, resulting in greater resource utilization.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-72b9682105f8bd3513ac668369408e8f>3 - Deployment</h1></div><div class=td-content><h1 id=pg-b1cfab34422422de1f43457e8491a94f>3.1 - Authentication Gardener Control Plane</h1><h1 id=authentication-of-gardener-control-plane-components-against-the-garden-cluster>Authentication of Gardener control plane components against the Garden cluster</h1><p><strong>Note:</strong> This document refers to Gardener&rsquo;s API server, admission controller, controller manager and scheduler components. Any reference to the term <strong>Gardener control plane component</strong> can be replaced with any of the mentioned above.</p><p>There are several authentication possibilities depending on whether or not <a href=https://github.com/gardener/garden-setup#concept-the-virtual-cluster>the concept of Virtual Garden</a> is used.</p><h2 id=virtual-garden-is-not-used-ie-the-runtime-garden-cluster-is-also-the-target-garden-cluster>Virtual Garden is not used, i.e., the <code>runtime</code> Garden cluster is also the <code>target</code> Garden cluster.</h2><h4 id=automounted-service-account-token>Automounted Service Account Token</h4><p>The easiest way to deploy a <strong>Gardener control plane component</strong> will be to not provide <code>kubeconfig</code> at all. This way in-cluster configuration and an automounted service account token will be used. The drawback of this approach is that the automounted token will not be automatically rotated.</p><h4 id=service-account-token-volume-projection>Service Account Token Volume Projection</h4><p>Another solution will be to use <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>Service Account Token Volume Projection</a> combined with a <code>kubeconfig</code> referencing a token file (see example below).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: &lt;CA-DATA&gt;
    server: https://default.kubernetes.svc.cluster.local
  name: garden
contexts:
- context:
    cluster: garden
    user: garden
  name: garden
current-context: garden
users:
- name: garden
  user:
    tokenFile: /var/run/secrets/projected/serviceaccount/token
</code></pre></div><p>This will allow for automatic rotation of the service account token by the <code>kubelet</code>. The configuration can be achieved by setting both <code>.Values.global.&lt;GardenerControlPlaneComponent>.serviceAccountTokenVolumeProjection.enabled: true</code> and <code>.Values.global.&lt;GardenerControlPlaneComponent>.kubeconfig</code> in the respective chart&rsquo;s <code>values.yaml</code> file.</p><h2 id=virtual-garden-is-used-ie-the-runtime-garden-cluster-is-different-from-the-target-garden-cluster>Virtual Garden is used, i.e., the <code>runtime</code> Garden cluster is different from the <code>target</code> Garden cluster.</h2><h4 id=service-account>Service Account</h4><p>The easiest way to setup the authentication will be to create a service account and the respective roles will be bound to this service account in the <code>target</code> cluster. Then use the generated service account token and craft a <code>kubeconfig</code> which will be used by the workload in the <code>runtime</code> cluster. This approach does not provide a solution for the rotation of the service account token. However, this setup can be achieved by setting <code>.Values.global.deployment.virtualGarden.enabled: true</code> and following these steps:</p><ol><li>Deploy the <code>application</code> part of the charts in the <code>target</code> cluster.</li><li>Get the service account token and craft the <code>kubeconfig</code>.</li><li>Set the crafted <code>kubeconfig</code> and deploy the <code>runtime</code> part of the charts in the <code>runtime</code> cluster.</li></ol><h4 id=client-certificate>Client Certificate</h4><p>Another solution will be to bind the roles in the <code>target</code> cluster to a <code>User</code> subject instead of a service account and use a client certificate for authentication. This approach does not provide a solution for the client certificate rotation. However, this setup can be achieved by setting both <code>.Values.global.deployment.virtualGarden.enabled: true</code> and <code>.Values.global.deployment.virtualGarden.&lt;GardenerControlPlaneComponent>.user.name</code>, then following these steps:</p><ol><li>Generate a client certificate for the <code>target</code> cluster for the respective user.</li><li>Deploy the <code>application</code> part of the charts in the <code>target</code> cluster.</li><li>Craft a <code>kubeconfig</code> using the already generated client certificate.</li><li>Set the crafted <code>kubeconfig</code> and deploy the <code>runtime</code> part of the charts in the <code>runtime</code> cluster.</li></ol><h4 id=projected-service-account-token>Projected Service Account Token</h4><p>This approach requires an already deployed and configured <a href=https://github.com/gardener/oidc-webhook-authenticator>oidc-webhook-authenticator</a> for the <code>target</code> cluster. Also the <code>runtime</code> cluster should be registered as a trusted identity provider in the <code>target</code> cluster. Then projected service accounts tokens from the <code>runtime</code> cluster can be used to authenticate against the <code>target</code> cluster. The needed steps are as follows:</p><ol><li>Deploy <a href=https://github.com/gardener/oidc-webhook-authenticator>OWA</a> and establish the needed trust.</li><li>Set <code>.Values.global.deployment.virtualGarden.enabled: true</code> and <code>.Values.global.deployment.virtualGarden.&lt;GardenerControlPlaneComponent>.user.name</code>. <strong>Note:</strong> username value will depend on the trust configuration, e.g., <code>&lt;prefix>:system:serviceaccount:&lt;namespace>:&lt;serviceaccount></code></li><li>Set <code>.Values.global.&lt;GardenerControlPlaneComponent>.serviceAccountTokenVolumeProjection.enabled: true</code> and <code>.Values.global.&lt;GardenerControlPlaneComponent>.serviceAccountTokenVolumeProjection.audience</code>. <strong>Note:</strong> audience value will depend on the trust configuration, e.g., <code>&lt;cliend-id-from-trust-config></code>.</li><li>Craft a kubeconfig (see example below).</li><li>Deploy the <code>application</code> part of the charts in the <code>target</code> cluster.</li><li>Deploy the <code>runtime</code> part of the charts in the <code>runtime</code> cluster.</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: &lt;CA-DATA&gt;
    server: https://virtual-garden.api
  name: virtual-garden
contexts:
- context:
    cluster: virtual-garden
    user: virtual-garden
  name: virtual-garden
current-context: virtual-garden
users:
- name: virtual-garden
  user:
    tokenFile: /var/run/secrets/projected/serviceaccount/token
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ac0acc1100465755b2c4985cf68f7409>3.2 - Configuring Logging</h1><h1 id=configuring-the-logging-stack-via-gardenlet-configurations>Configuring the Logging stack via Gardenlet configurations</h1><h1 id=enable-the-logging>Enable the Logging</h1><p>In order to install the Gardener logging stack the <code>logging.enabled</code> configuration option has to be enabled in the Gardenlet configuration:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
</code></pre></div><p>From now on each Seed is going to have a logging stack which will collect logs from all pods and some systemd services. Logs related to Shoots with <code>testing</code> purpose are dropped in the <code>fluent-bit</code> output plugin. Shoots with a purpose different than <code>testing</code> have the same type of log aggregator (but different instance) as the Seed. The logs can be viewed in the Grafana in the <code>garden</code> namespace for the Seed components and in the respective shoot control plane namespaces.</p><h1 id=enable-logs-from-the-shoots-node-systemd-services>Enable logs from the Shoot&rsquo;s node systemd services.</h1><p>The logs from the systemd services on each node can be retrieved by enabling the <code>logging.shootNodeLogging</code> option in the Gardenlet configuration:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
  shootNodeLogging:
    shootPurposes:
    - <span style=color:#a31515>&#34;evaluation&#34;</span>
    - <span style=color:#a31515>&#34;deployment&#34;</span>
</code></pre></div><p>Under the <code>shootPurpose</code> section just list all the shoot purposes for which the Shoot node logging feature will be enabled. Specifying the <code>testing</code> purpose has no effect because this purpose prevents the logging stack installation.
Logs can be viewed in the operator Grafana!
The dedicated labels are <code>unit</code>, <code>syslog_identifier</code> and <code>nodename</code> in the <code>Explore</code> menu.</p><h1 id=configuring-the-log-processor>Configuring the log processor</h1><p>Under <code>logging.fluentBit</code> there is three optional sections.</p><ul><li><code>input</code>: This overwrite the input configuration of the fluent-bit log processor.</li><li><code>output</code>: This overwrite the output configuration of the fluent-bit log processor.</li><li><code>service</code>: This overwrite the service configuration of the fluent-bit log processor.</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
  fluentBit:
    output: |-<span style=color:#a31515>
</span><span style=color:#a31515>      [Output]
</span><span style=color:#a31515>          ...</span>      
    input: |-<span style=color:#a31515>
</span><span style=color:#a31515>      [Input]
</span><span style=color:#a31515>          ...</span>      
    service: |-<span style=color:#a31515>
</span><span style=color:#a31515>      [Service]
</span><span style=color:#a31515>          ...</span>      
</code></pre></div><h1 id=configuring-the-loki-priorityclass>Configuring the Loki PriorityClass</h1><p>The central Loki, which is in the <code>garden</code> namespace, contains all the logs from the most important seed components. When the central Loki <code>PriorityClass</code> is with low value then its pods can be preempted and often moved from one node to another while Kubernetes tries to free space for more important pods. The persistent volume will be detached/attached again as well. Based on the performance of the underlying infrastructure, this leads to great central Loki downtime. To give greater priority of the seed Loki you can use the <code>logging.loki.garden.priority</code> option.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
  loki:
    garden:
      priority: 100
</code></pre></div><h1 id=configure-central-logging>Configure central logging</h1><p>For central logging, the output configuration of the fluent-bit log processor can be overwritten (<code>logging.fluentBit.output</code>) and the Loki instances deployments in Garden and Shoot namespace can be enabled/disabled (<code>logging.loki.enabled</code>), by default Loki is enabled.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
  fluentBit:
    output: |-<span style=color:#a31515>
</span><span style=color:#a31515>      [Output]
</span><span style=color:#a31515>          ...</span>      
  loki:
    enabled: <span style=color:#00f>false</span>
</code></pre></div><h1 id=configuring-central-loki-storage-capacity>Configuring central Loki storage capacity</h1><p>By default, the central Loki has <code>100Gi</code> of storage capacity.
To overwrite the current central Loki storage capacity, the <code>logging.loki.garden.storage</code> setting in the gardenlet&rsquo;s component configuration should be altered.
If you need to increase it you can do so without losing the current data by specifying higher capacity. Doing so, the Loki&rsquo;s <code>PersistentVolume</code> capacity will be increased instead of deleting the current PV.
However, if you specify less capacity then the <code>PersistentVolume</code> will be deleted and with it the logs, too.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
  fluentBit:
    output: |-<span style=color:#a31515>
</span><span style=color:#a31515>      [Output]
</span><span style=color:#a31515>          ...</span>      
  loki:
    garden:
      storage: <span style=color:#a31515>&#34;200Gi&#34;</span>
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-e2f3032b3740e0030af0d52262ec390e>3.3 - Deploy Gardenlet</h1><h1 id=deploying-gardenlets>Deploying Gardenlets</h1><p>Gardenlets act as decentral &ldquo;agents&rdquo; to manage shoot clusters of a seed cluster.</p><p>To support scaleability in an automated way, gardenlets are deployed automatically. However, you can still deploy gardenlets manually to be more flexible, for example, when shoot clusters that need to be managed by Gardener are behind a firewall. The gardenlet only requires network connectivity from the gardenlet to the Garden cluster (not the other way round), so it can be used to register Kubernetes clusters with no public endpoint.</p><h2 id=procedure>Procedure</h2><ol><li><p>First, an initial gardenlet needs to be deployed:</p><ul><li>Deploy it manually if you have special requirements. More information: <a href=/docs/gardener/deployment/deploy_gardenlet_manually/>Deploy a Gardenlet Manually</a></li><li>Let the Gardener installer deploy it automatically otherwise. More information: <a href=/docs/gardener/deployment/deploy_gardenlet_automatically/>Automatic Deployment of Gardenlets</a></li></ul></li><li><p>To add additional seed clusters, it is recommended to use regular shoot clusters. You can do this by creating a <code>ManagedSeed</code> resource with a <code>gardenlet</code> section as described in <a href=/docs/gardener/usage/managed_seed/>Register Shoot as Seed</a>.</p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-0af204f84f4a80fc61988beb16c39e12>3.4 - Deploy Gardenlet Automatically</h1><h1 id=automatic-deployment-of-gardenlets>Automatic Deployment of Gardenlets</h1><p>The gardenlet can automatically deploy itself into shoot clusters, and register this cluster as a seed cluster.
These clusters are called &ldquo;managed seeds&rdquo; (aka &ldquo;shooted seeds&rdquo;).
This procedure is the preferred way to add additional seed clusters, because shoot clusters already come with production-grade qualities that are also demanded for seed clusters.</p><h2 id=prerequisites>Prerequisites</h2><p>The only prerequisite is to register an initial cluster as a seed cluster that has already a gardenlet deployed:</p><ul><li>This gardenlet was either deployed as part of a Gardener installation using a setup tool (for example, <code>gardener/garden-setup</code>) or</li><li>the gardenlet was deployed manually<ul><li>for a step-by-step manual installation Guide see: <a href=/docs/gardener/deployment/deploy_gardenlet_manually/>Deploy a Gardenlet Manually</a>)</li></ul></li></ul><blockquote><p>The initial cluster can be the garden cluster itself.</p></blockquote><h2 id=self-deployment-of-gardenlets-in-additional-managed-seed-clusters>Self-Deployment of Gardenlets in Additional Managed Seed Clusters</h2><p>For a better scalability, you usually need more seed clusters that you can create as follows:</p><ol><li>Use the initial cluster as the seed cluster for other managed seed clusters. It hosts the control planes of the other seed clusters.</li><li>The gardenlet deployed in the initial cluster deploys itself automatically into the managed seed clusters.</li></ol><p>The advantage of this approach is that there’s only one initial gardenlet installation required. Every other managed seed cluster has a gardenlet deployed automatically.</p><h2 id=related-links>Related Links</h2><p><a href=/docs/gardener/usage/managed_seed/>Register Shoot as Seed</a></p><p><a href=http://github.com/gardener/garden-setup>garden-setup</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-ed3b289c8b619ea2a52bab3ae97c199c>3.5 - Deploy Gardenlet Manually</h1><h1 id=deploy-a-gardenlet-manually>Deploy a Gardenlet Manually</h1><p>Manually deploying a gardenlet is required in the following cases:</p><ul><li><p>The Kubernetes cluster to be registered as a seed cluster has no public endpoint,
because it is behind a firewall.
The gardenlet must then be deployed into the cluster itself.</p></li><li><p>The Kubernetes cluster to be registered as a seed cluster is managed externally
(the Kubernetes cluster is not a shoot cluster, so <a href=/docs/gardener/deployment/deploy_gardenlet_automatically/>Automatic Deployment of Gardenlets</a> cannot be used).</p></li><li><p>The gardenlet runs outside of the Kubernetes cluster
that should be registered as a seed cluster.
(The gardenlet is not restricted to run in the seed cluster or
to be deployed into a Kubernetes cluster at all).</p></li></ul><blockquote><p>Once you’ve deployed a gardenlet manually, for example, behind a firewall, you can deploy new gardenlets automatically. The manually deployed gardenlet is then used as a template for the new gardenlets. More information: <a href=/docs/gardener/deployment/deploy_gardenlet_automatically/>Automatic Deployment of Gardenlets</a>.</p></blockquote><h2 id=prerequisites>Prerequisites</h2><h3 id=kubernetes-cluster-that-should-be-registered-as-a-seed-cluster>Kubernetes cluster that should be registered as a seed cluster</h3><ul><li><p>Verify that the cluster has a <a href=/docs/gardener/usage/supported_k8s_versions/>supported Kubernetes version</a>.</p></li><li><p>Determine the nodes, pods, and services CIDR of the cluster.
You need to configure this information in the <code>Seed</code> configuration.
Gardener uses this information to check that the shoot cluster isn’t created with overlapping CIDR ranges.</p></li><li><p>Every Seed cluster needs an Ingress controller which distributes external requests to internal components like grafana and prometheus. Gardener supports two approaches to achieve this:</p></li></ul><p>a. Gardener managed Ingress controller and DNS records. For this configure the following lines in your <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>Seed resource</a>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  dns:
    provider:
      type: aws-route53
      secretRef:
        name: ingress-secret
        namespace: garden
  ingress:
    domain: ingress.my-seed.example.com
    controller:
      kind: nginx
      providerConfig:
        &lt;some-optional-provider-specific-config-for-the-ingressController&gt;
</code></pre></div><p>⚠ Please note that if you set <code>.spec.ingress</code> then <code>.spec.dns.ingressDomain</code> must be <code>nil</code>.</p><p>b. Self-managed DNS record and Ingress controller:</p><p>⚠️
There should exist a DNS record <code>*.ingress.&lt;SEED-CLUSTER-DOMAIN></code> where <code>&lt;SEED-CLUSTER-DOMAIN></code> is the value of the <code>.dns.ingressDomain</code> field of <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>a Seed cluster resource</a> (or the <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml#L84-L85>respective Gardenlet configuration</a>).</p><p><em>This is how it could be done for the Nginx ingress controller</em></p><p>Deploy nginx into the <code>kube-system</code> namespace in the Kubernetes cluster that should be registered as a <code>Seed</code>.</p><p>Nginx will on most cloud providers create the service with type <code>LoadBalancer</code> with an external ip.</p><pre><code>NAME                        TYPE           CLUSTER-IP    EXTERNAL-IP
nginx-ingress-controller    LoadBalancer   10.0.15.46    34.200.30.30
</code></pre><p>Create a wildcard <code>A</code> record (e.g *.ingress.sweet-seed.<my-domain>. IN A 34.200.30.30) with your DNS provider and point it to the external ip of the ingress service. This ingress domain is later required to register the <code>Seed</code> cluster.</p><p>Please configure the ingress domain in the <code>Seed</code> specification as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  dns:
    ingressDomain: ingress.sweet-seed.&lt;my-domain&gt;
</code></pre></div><p>⚠ Please note that if you set <code>.spec.dns.ingressDomain</code> then <code>.spec.ingress</code> must be <code>nil</code>.</p><h3 id=kubeconfig-for-the-seed-cluster><code>kubeconfig</code> for the Seed Cluster</h3><p>The <code>kubeconfig</code> is required to deploy the gardenlet Helm chart to the seed cluster.
The gardenlet requires certain privileges to be able to operate.
These privileges are described in RBAC resources in the gardenlet Helm chart (see <a href=https://github.com/gardener/gardener/tree/master/charts/gardener/gardenlet/charts/runtime/templates>charts/gardener/gardenlet/charts/runtime/templates</a>).
The Helm chart contains a service account <code>gardenlet</code>
that the gardenlet deployment uses by default to talk to the Seed API server.</p><blockquote><p>If the gardenlet isn’t deployed in the seed cluster,
the gardenlet can be configured to use a <code>kubeconfig</code>,
which also requires the above-mentioned privileges, from a mounted directory.
The <code>kubeconfig</code> is specified in section <code>seedClientConnection.kubeconfig</code>
of the <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>Gardenlet configuration</a>.
This configuration option isn’t used in the following,
as this procedure only describes the recommended setup option
where the gardenlet is running in the seed cluster itself.</p></blockquote><h2 id=procedure-overview>Procedure Overview</h2><ol><li><p>Prepare the garden cluster:</p><ol><li><a href=#create-a-bootstrap-token-secret-in-the-kube-system-namespace-of-the-garden-cluster>Create a bootstrap token secret in the <code>kube-system</code> namespace of the garden cluster</a></li><li><a href=#create-rbac-roles-for-the-gardenlet-to-allow-bootstrapping-in-the-garden-cluster>Create RBAC roles for the gardenlet to allow bootstrapping in the garden cluster</a></li></ol></li><li><p><a href=#prepare-the-gardenlet-helm-chart>Prepare the gardenlet Helm chart</a>.</p></li><li><p><a href=#automatically-register-shoot-cluster-as-a-seed-cluster>Automatically register shoot cluster as a seed cluster</a>.</p></li><li><p><a href=#deploy-the-gardenlet>Deploy the gardenlet</a></p></li><li><p><a href=#check-that-the-gardenlet-is-successfully-deployed>Check that the gardenlet is successfully deployed</a></p></li></ol><h2 id=create-a-bootstrap-token-secret-in-the-kube-system-namespace-of-the-garden-cluster>Create a bootstrap token secret in the <code>kube-system</code> namespace of the garden cluster</h2><p>The gardenlet needs to talk to the <a href=/docs/gardener/concepts/apiserver/>Gardener API server</a> residing in the garden cluster.</p><p>The gardenlet can be configured with an already existing garden cluster <code>kubeconfig</code> in one of the following ways:</p><ul><li><p>Either by specifying <code>gardenClientConnection.kubeconfig</code>
in the <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>Gardenlet configuration</a> or</p></li><li><p>by supplying the environment variable <code>GARDEN_KUBECONFIG</code> pointing to
a mounted <code>kubeconfig</code> file).</p></li></ul><p>The preferred way however, is to use the gardenlets ability to request
a signed certificate for the garden cluster by leveraging
<a href=https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/>Kubernetes Certificate Signing Requests</a>.
The gardenlet performs a TLS bootstrapping process that is similar to the
<a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Kubelet TLS Bootstrapping</a>.
Make sure that the API server of the garden cluster has
<a href=https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/#enabling-bootstrap-token-authentication>bootstrap token authentication</a>
enabled.</p><p>The client credentials required for the gardenlets TLS bootstrapping process,
need to be either <code>token</code> or <code>certificate</code> (OIDC isn’t supported) and have permissions
to create a Certificate Signing Request (<a href=https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/>CSR</a>).
It’s recommended to use <a href=https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/>bootstrap tokens</a>
due to their desirable security properties (such as a limited token lifetime).</p><p>Therefore, first create a bootstrap token secret for the garden cluster:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  <span style=color:green># Name MUST be of form &#34;bootstrap-token-&lt;token id&gt;&#34;</span>
  name: bootstrap-token-07401b
  namespace: kube-system

<span style=color:green># Type MUST be &#39;bootstrap.kubernetes.io/token&#39;</span>
type: bootstrap.kubernetes.io/token
stringData:
  <span style=color:green># Human readable description. Optional.</span>
  description: <span style=color:#a31515>&#34;Token to be used by the gardenlet for Seed `sweet-seed`.&#34;</span>

  <span style=color:green># Token ID and secret. Required.</span>
  token-id: 07401b <span style=color:green># 6 characters</span>
  token-secret: f395accd246ae52d <span style=color:green># 16 characters</span>

  <span style=color:green># Expiration. Optional.</span>
  <span style=color:green># expiration: 2017-03-10T03:22:11Z</span>

  <span style=color:green># Allowed usages.</span>
  usage-bootstrap-authentication: <span style=color:#a31515>&#34;true&#34;</span>
  usage-bootstrap-signing: <span style=color:#a31515>&#34;true&#34;</span>
</code></pre></div><p>When you later prepare the gardenlet Helm chart,
a <code>kubeconfig</code> based on this token is shared with the gardenlet upon deployment.</p><h2 id=create-rbac-roles-for-the-gardenlet-to-allow-bootstrapping-in-the-garden-cluster>Create RBAC roles for the gardenlet to allow bootstrapping in the garden cluster</h2><p>This step is only required if the gardenlet you deploy is the first gardenlet
in the Gardener installation.
Additionally, when using the <a href=https://github.com/gardener/gardener/tree/master/charts/gardener/controlplane>control plane chart</a>,
the following resources are already contained in the Helm chart,
that is, if you use it you can skip these steps as the needed RBAC roles already exist.</p><p>The gardenlet uses the configured bootstrap <code>kubeconfig</code> in <code>gardenClientConnection.bootstrapKubeconfig</code> to request a signed certificate for the user <code>gardener.cloud:system:seed:&lt;seed-name></code> in the group <code>gardener.cloud:system:seeds</code>.</p><p>Create a <code>ClusterRole</code> and <code>ClusterRoleBinding</code> that grant full admin permissions to authenticated gardenlets.</p><p>Create the following resources in the garden cluster:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: gardener.cloud:system:seeds
rules:
  - apiGroups:
      - <span style=color:#a31515>&#39;*&#39;</span>
    resources:
      - <span style=color:#a31515>&#39;*&#39;</span>
    verbs:
      - <span style=color:#a31515>&#39;*&#39;</span>
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: gardener.cloud:system:seeds
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gardener.cloud:system:seeds
subjects:
  - kind: Group
    name: gardener.cloud:system:seeds
    apiGroup: rbac.authorization.k8s.io
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: gardener.cloud:system:seed-bootstrapper
rules:
  - apiGroups:
      - certificates.k8s.io
    resources:
      - certificatesigningrequests
    verbs:
      - create
      - get
  - apiGroups:
      - certificates.k8s.io
    resources:
      - certificatesigningrequests/seedclient
    verbs:
      - create
---
<span style=color:green># A kubelet/gardenlet authenticating using bootstrap tokens is authenticated as a user in the group system:bootstrappers</span>
<span style=color:green># Allows the Gardenlet to create a CSR</span>
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: gardener.cloud:system:seed-bootstrapper
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gardener.cloud:system:seed-bootstrapper
subjects:
  - kind: Group
    name: system:bootstrappers
    apiGroup: rbac.authorization.k8s.io
</code></pre></div><p>ℹ️ After bootstrapping, the gardenlet has full administrative access to the garden cluster.
You might be interested to harden this and limit its permissions to only resources related to the seed cluster it is responsible for.
Please take a look into <a href=/docs/gardener/deployment/gardenlet_api_access/>this document</a>.</p><h2 id=prepare-the-gardenlet-helm-chart>Prepare the gardenlet Helm chart</h2><p>This section only describes the minimal configuration,
using the global configuration values of the gardenlet Helm chart.
For an overview over all values, see the <a href=https://github.com/gardener/gardener/blob/master/charts/gardener/gardenlet/values.yaml>configuration values</a>.
We refer to the global configuration values as <em>gardenlet configuration</em> in the remaining procedure.</p><ol><li><p>Create a gardenlet configuration <code>gardenlet-values.yaml</code> based on <a href=https://github.com/gardener/gardener/blob/master/charts/gardener/gardenlet/values.yaml>this template</a>.</p></li><li><p>Create a bootstrap <code>kubeconfig</code> based on the bootstrap token created in the garden cluster.</p><p>Replace the <code>&lt;bootstrap-token></code> with <code>token-id.token-secret</code> (from our previous example: <code>07401b.f395accd246ae52d</code>) from the bootstrap token secret.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
current-context: gardenlet-bootstrap@default
clusters:
- cluster:
    certificate-authority-data: &lt;ca-of-garden-cluster&gt;
    server: https://&lt;endpoint-of-garden-cluster&gt;
  name: default
contexts:
- context:
    cluster: default
    user: gardenlet-bootstrap
  name: gardenlet-bootstrap@default
users:
- name: gardenlet-bootstrap
  user:
    token: &lt;bootstrap-token&gt;
</code></pre></div></li><li><p>In section <code>gardenClientConnection.bootstrapKubeconfig</code> of your gardenlet configuration, provide the bootstrap <code>kubeconfig</code> together with a name and namespace to the gardenlet Helm chart.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>gardenClientConnection:
  bootstrapKubeconfig:
    name: gardenlet-kubeconfig-bootstrap
    namespace: garden
    kubeconfig: |<span style=color:#a31515>
</span><span style=color:#a31515>      </span>      &lt;bootstrap-kubeconfig&gt;  <span style=color:green># will be base64 encoded by helm</span>
</code></pre></div><p>The bootstrap <code>kubeconfig</code> is stored in the specified secret.</p></li><li><p>In section <code>gardenClientConnection.kubeconfigSecret</code> of your gardenlet configuration,
define a name and a namespace where the gardenlet stores
the real <code>kubeconfig</code> that it creates during the bootstrap process. If the secret doesn&rsquo;t exist,
the gardenlet creates it for you.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>gardenClientConnection:
  kubeconfigSecret:
    name: gardenlet-kubeconfig
    namespace: garden
</code></pre></div></li></ol><h2 id=automatically-register-shoot-cluster-as-a-seed-cluster>Automatically register shoot cluster as a seed cluster</h2><p>A seed cluster can either be registered by manually creating
the <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml><code>Seed</code> resource</a>
or automatically by the gardenlet.
This functionality is useful for managed seed clusters,
as the gardenlet in the garden cluster deploys a copy of itself
into the cluster with automatic registration of the <code>Seed</code> configured.
However, it can also be used to have a streamlined seed cluster registration process when manually deploying the gardenlet.</p><blockquote><p>This procedure doesn’t describe all the possible configurations
for the <code>Seed</code> resource. For more information, see:</p><ul><li><a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>Example Seed resource</a></li><li><a href=/docs/gardener/usage/seed_settings/>Configurable Seed settings</a>.</li></ul></blockquote><h3 id=adjust-the-gardenlet-component-configuration>Adjust the gardenlet component configuration</h3><ol><li><p>Supply the <code>Seed</code> resource in section <code>seedConfig</code> of your gardenlet configuration <code>gardenlet-values.yaml</code>.</p></li><li><p>Add the <code>seedConfig</code> to your gardenlet configuration <code>gardenlet-values.yaml</code>.
The field <code>seedConfig.spec.provider.type</code> specifies the infrastructure provider type (for example, <code>aws</code>) of the seed cluster.
For all supported infrastructure providers, see <a href=https://github.com/gardener/gardener/blob/master/extensions/README.md#known-extension-implementations>Known Extension Implementations</a>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>....
seedConfig:
  metadata:
    name: sweet-seed
  spec:
    dns:
      ingressDomain: ingress.sweet-seed.&lt;my-domain&gt; <span style=color:green># see prerequisites</span>
    networks: <span style=color:green># see prerequisites</span>
      nodes: 10.240.0.0/16
      pods: 100.244.0.0/16
      services: 100.32.0.0/13
      shootDefaults: # optional: non-overlapping default CIDRs for shoot clusters of that Seed
        pods: 100.96.0.0/11
        services: 100.64.0.0/13
    provider:
      region: eu-west-1
      type: &lt;provider&gt;
</code></pre></div></li></ol><h3 id=optional-enable-backup-and-restore>Optional: Enable backup and restore</h3><p>The seed cluster can be set up with backup and restore
for the main <code>etcds</code> of shoot clusters.</p><p>Gardener uses <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a>
that <a href=https://github.com/gardener/etcd-backup-restore/blob/master/doc/usage/getting_started.md#usage>integrates with different storage providers</a>
to store the shoot cluster&rsquo;s main <code>etcd</code> backups.
Make sure to obtain client credentials that have sufficient permissions with the chosen storage provider.</p><p>Create a secret in the garden cluster with client credentials for the storage provider.
The format of the secret is cloud provider specific and can be found
in the repository of the respective Gardener extension.
For example, the secret for AWS S3 can be found in the AWS provider extension
(<a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-etcd-backup-secret.yaml>30-etcd-backup-secret.yaml</a>).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: sweet-seed-backup
  namespace: garden
type: Opaque
data:
  <span style=color:green># client credentials format is provider specific</span>
</code></pre></div><p>Configure the <code>Seed</code> resource in section <code>seedConfig</code> of your gardenlet configuration to use backup and restore:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>...
seedConfig:
  metadata:
    name: sweet-seed
  spec:
    backup:
      provider: &lt;provider&gt;
      secretRef:
        name: sweet-seed-backup
        namespace: garden
</code></pre></div><h2 id=deploy-the-gardenlet>Deploy the gardenlet</h2><blockquote><p>The gardenlet doesn’t have to run in the same Kubernetes cluster as the seed cluster
it’s registering and reconciling, but it is in most cases advantageous
to use in-cluster communication to talk to the Seed API server.
Running a gardenlet outside of the cluster is mostly used for local development.</p></blockquote><p>The <code>gardenlet-values.yaml</code> looks something like this
(with automatic Seed registration and backup for shoot clusters enabled):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>global:
  <span style=color:green># Gardenlet configuration values</span>
  gardenlet:
    enabled: <span style=color:#00f>true</span>
    ...
    &lt;default config&gt;
    ...
    config:
      gardenClientConnection:
        ...
        bootstrapKubeconfig:
          name: gardenlet-bootstrap-kubeconfig
          namespace: garden
          kubeconfig: |<span style=color:#a31515>
</span><span style=color:#a31515>            apiVersion: v1
</span><span style=color:#a31515>            clusters:
</span><span style=color:#a31515>            - cluster:
</span><span style=color:#a31515>                certificate-authority-data: &lt;dummy&gt;
</span><span style=color:#a31515>                server: &lt;my-garden-cluster-endpoint&gt;
</span><span style=color:#a31515>              name: my-kubernetes-cluster
</span><span style=color:#a31515>            ....</span>            

        kubeconfigSecret:
          name: gardenlet-kubeconfig
          namespace: garden
      ...
      &lt;default config&gt;
      ...
      seedConfig:
        metadata:
          name: sweet-seed
        spec:
          dns:
            ingressDomain: ingress.sweet-seed.&lt;my-domain&gt;
          networks:
            nodes: 10.240.0.0/16
            pods: 100.244.0.0/16
            services: 100.32.0.0/13
            shootDefaults:
              pods: 100.96.0.0/11
              services: 100.64.0.0/13
          provider:
            region: eu-west-1
            type: &lt;provider&gt;
          backup:
            provider: &lt;provider&gt;
            secretRef:
              name: sweet-seed-backup
              namespace: garden
</code></pre></div><p>Deploy the gardenlet Helm chart to the Kubernetes cluster.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>helm install gardenlet charts/gardener/gardenlet <span style=color:#a31515>\
</span><span style=color:#a31515></span>  --namespace garden <span style=color:#a31515>\
</span><span style=color:#a31515></span>  -f gardenlet-values.yaml <span style=color:#a31515>\
</span><span style=color:#a31515></span>  --wait
</code></pre></div><p>This helm chart creates:</p><ul><li>A service account <code>gardenlet</code> that the gardenlet can use to talk to the Seed API server.</li><li>RBAC roles for the service account (full admin rights at the moment).</li><li>The secret (<code>garden</code>/<code>gardenlet-bootstrap-kubeconfig</code>) containing the bootstrap <code>kubeconfig</code>.</li><li>The gardenlet deployment in the <code>garden</code> namespace.</li></ul><h2 id=check-that-the-gardenlet-is-successfully-deployed>Check that the gardenlet is successfully deployed</h2><ol><li><p>Check that the gardenlets certificate bootstrap was successful.</p><p>Check if the secret <code>gardenlet-kubeconfig</code> in the namespace <code>garden</code> in the seed cluster
is created and contains a <code>kubeconfig</code> with a valid certificate.</p><ol><li><p>Get the <code>kubeconfig</code> from the created secret.</p><pre><code>$ kubectl -n garden get secret gardenlet-kubeconfig -o json | jq -r .data.kubeconfig | base64 -d
</code></pre></li><li><p>Test against the garden cluster and verify it’s working.</p></li><li><p>Extract the <code>client-certificate-data</code> from the user <code>gardenlet</code>.</p></li><li><p>View the certificate:</p><pre><code>$ openssl x509 -in ./gardenlet-cert -noout -text
</code></pre><p>Check that the certificate is valid for a year (that is the lifetime of new certificates).</p></li></ol></li><li><p>Check that the bootstrap secret <code>gardenlet-bootstrap-kubeconfig</code> has been deleted from the seed cluster in namespace <code>garden</code>.</p></li><li><p>Check that the seed cluster is registered and <code>READY</code> in the garden cluster.</p><p>Check that the seed cluster <code>sweet-seed</code> exists and all conditions indicate that it’s available.
If so, the <a href=/docs/gardener/concepts/gardenlet/#heartbeats>Gardenlet is sending regular heartbeats</a> and the <a href=/docs/gardener/usage/seed_bootstrapping/>seed bootstrapping</a> was successful.</p><p>Check that the conditions on the <code>Seed</code> resource look similar to the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get seed sweet-seed -o json | jq .status.conditions
[
  {
    <span style=color:#a31515>&#34;lastTransitionTime&#34;</span>: <span style=color:#a31515>&#34;2020-07-17T09:17:29Z&#34;</span>,
    <span style=color:#a31515>&#34;lastUpdateTime&#34;</span>: <span style=color:#a31515>&#34;2020-07-17T09:17:29Z&#34;</span>,
    <span style=color:#a31515>&#34;message&#34;</span>: <span style=color:#a31515>&#34;Gardenlet is posting ready status.&#34;</span>,
    <span style=color:#a31515>&#34;reason&#34;</span>: <span style=color:#a31515>&#34;GardenletReady&#34;</span>,
    <span style=color:#a31515>&#34;status&#34;</span>: <span style=color:#a31515>&#34;True&#34;</span>,
    <span style=color:#a31515>&#34;type&#34;</span>: <span style=color:#a31515>&#34;GardenletReady&#34;</span>
  },
  {
    <span style=color:#a31515>&#34;lastTransitionTime&#34;</span>: <span style=color:#a31515>&#34;2020-07-17T09:17:49Z&#34;</span>,
    <span style=color:#a31515>&#34;lastUpdateTime&#34;</span>: <span style=color:#a31515>&#34;2020-07-17T09:53:17Z&#34;</span>,
    <span style=color:#a31515>&#34;message&#34;</span>: <span style=color:#a31515>&#34;Seed cluster has been bootstrapped successfully.&#34;</span>,
    <span style=color:#a31515>&#34;reason&#34;</span>: <span style=color:#a31515>&#34;BootstrappingSucceeded&#34;</span>,
    <span style=color:#a31515>&#34;status&#34;</span>: <span style=color:#a31515>&#34;True&#34;</span>,
    <span style=color:#a31515>&#34;type&#34;</span>: <span style=color:#a31515>&#34;Bootstrapped&#34;</span>
  },
  {
    <span style=color:#a31515>&#34;lastTransitionTime&#34;</span>: <span style=color:#a31515>&#34;2020-07-17T09:17:49Z&#34;</span>,
    <span style=color:#a31515>&#34;lastUpdateTime&#34;</span>: <span style=color:#a31515>&#34;2020-07-17T09:53:17Z&#34;</span>,
    <span style=color:#a31515>&#34;message&#34;</span>: <span style=color:#a31515>&#34;Backup Buckets are available.&#34;</span>,
    <span style=color:#a31515>&#34;reason&#34;</span>: <span style=color:#a31515>&#34;BackupBucketsAvailable&#34;</span>,
    <span style=color:#a31515>&#34;status&#34;</span>: <span style=color:#a31515>&#34;True&#34;</span>,
    <span style=color:#a31515>&#34;type&#34;</span>: <span style=color:#a31515>&#34;BackupBucketsReady&#34;</span>
  }
]
</code></pre></div></li></ol><h2 id=related-links>Related Links</h2><p><a href=https://github.com/gardener/gardener/issues/1724>Issue #1724: Harden Gardenlet RBAC privileges</a>.</p><p><a href=/docs/gardener/concepts/backup-restore/>Backup and Restore</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c3272d62c1687598614ee78517d7640c>3.6 - Feature Gates</h1><h1 id=feature-gates-in-gardener>Feature Gates in Gardener</h1><p>This page contains an overview of the various feature gates an administrator can specify on different Gardener components.</p><h2 id=overview>Overview</h2><p>Feature gates are a set of key=value pairs that describe Gardener features. You can turn these features on or off using the a component configuration file for a specific component.</p><p>Each Gardener component lets you enable or disable a set of feature gates that are relevant to that component. For example this is the configuration of the <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>gardenlet</a> component.</p><p>The following tables are a summary of the feature gates that you can set on different Gardener components.</p><ul><li>The “Since” column contains the Gardener release when a feature is introduced or its release stage is changed.</li><li>The “Until” column, if not empty, contains the last Gardener release in which you can still use a feature gate.</li><li>If a feature is in the Alpha or Beta state, you can find the feature listed in the Alpha/Beta feature gate table.</li><li>If a feature is stable you can find all stages for that feature listed in the Graduated/Deprecated feature gate table.</li><li>The Graduated/Deprecated feature gate table also lists deprecated and withdrawn features.</li></ul><h2 id=feature-gates-for-alpha-or-beta-features>Feature gates for Alpha or Beta features</h2><table><thead><tr><th>Feature</th><th>Default</th><th>Stage</th><th>Since</th><th>Until</th></tr></thead><tbody><tr><td>HVPA</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>0.31</code></td><td></td></tr><tr><td>HVPAForShootedSeed</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>0.32</code></td><td></td></tr><tr><td>ManagedIstio</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.5</code></td><td><code>1.18</code></td></tr><tr><td>ManagedIstio</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.19</code></td><td></td></tr><tr><td>APIServerSNI</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.7</code></td><td><code>1.18</code></td></tr><tr><td>APIServerSNI</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.19</code></td><td></td></tr><tr><td>CachedRuntimeClients</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.7</code></td><td><code>1.33</code></td></tr><tr><td>CachedRuntimeClients</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.34</code></td><td></td></tr><tr><td>SeedChange</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.12</code></td><td></td></tr><tr><td>SeedKubeScheduler</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.15</code></td><td></td></tr><tr><td>ReversedVPN</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.22</code></td><td><code>1.41</code></td></tr><tr><td>ReversedVPN</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.42</code></td><td></td></tr><tr><td>UseDNSRecords</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.27</code></td><td><code>1.38</code></td></tr><tr><td>UseDNSRecords</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.39</code></td><td></td></tr><tr><td>RotateSSHKeypairOnMaintenance</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.28</code></td><td></td></tr><tr><td>DenyInvalidExtensionResources</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.31</code></td><td><code>1.41</code></td></tr><tr><td>DenyInvalidExtensionResources</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.42</code></td><td></td></tr><tr><td>WorkerPoolKubernetesVersion</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.35</code></td><td></td></tr><tr><td>CopyEtcdBackupsDuringControlPlaneMigration</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.37</code></td><td></td></tr><tr><td>SecretBindingProviderValidation</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.38</code></td><td></td></tr><tr><td>ForceRestore</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.39</code></td><td></td></tr><tr><td>DisableDNSProviderManagement</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.41</code></td><td></td></tr><tr><td>ShootCARotation</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.42</code></td><td></td></tr><tr><td>ShootMaxTokenExpirationOverwrite</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.43</code></td><td></td></tr><tr><td>ShootMaxTokenExpirationValidation</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.43</code></td><td></td></tr></tbody></table><h2 id=feature-gates-for-graduated-or-deprecated-features>Feature gates for graduated or deprecated features</h2><table><thead><tr><th>Feature</th><th>Default</th><th>Stage</th><th>Since</th><th>Until</th></tr></thead><tbody><tr><td>NodeLocalDNS</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.7</code></td><td></td></tr><tr><td>NodeLocalDNS</td><td></td><td><code>Removed</code></td><td><code>1.26</code></td><td></td></tr><tr><td>KonnectivityTunnel</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.6</code></td><td></td></tr><tr><td>KonnectivityTunnel</td><td></td><td><code>Removed</code></td><td><code>1.27</code></td><td></td></tr><tr><td>MountHostCADirectories</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.11</code></td><td><code>1.25</code></td></tr><tr><td>MountHostCADirectories</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.26</code></td><td><code>1.27</code></td></tr><tr><td>MountHostCADirectories</td><td><code>true</code></td><td><code>GA</code></td><td><code>1.27</code></td><td></td></tr><tr><td>MountHostCADirectories</td><td></td><td><code>Removed</code></td><td><code>1.30</code></td><td></td></tr><tr><td>DisallowKubeconfigRotationForShootInDeletion</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.28</code></td><td><code>1.31</code></td></tr><tr><td>DisallowKubeconfigRotationForShootInDeletion</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.32</code></td><td><code>1.35</code></td></tr><tr><td>DisallowKubeconfigRotationForShootInDeletion</td><td><code>true</code></td><td><code>GA</code></td><td><code>1.36</code></td><td></td></tr><tr><td>DisallowKubeconfigRotationForShootInDeletion</td><td></td><td><code>Removed</code></td><td><code>1.38</code></td><td></td></tr><tr><td>Logging</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>0.13</code></td><td><code>1.40</code></td></tr><tr><td>Logging</td><td><code>false</code></td><td><code>Removed</code></td><td><code>1.41</code></td><td></td></tr><tr><td>AdminKubeconfigRequest</td><td><code>false</code></td><td><code>Alpha</code></td><td><code>1.24</code></td><td><code>1.38</code></td></tr><tr><td>AdminKubeconfigRequest</td><td><code>true</code></td><td><code>Beta</code></td><td><code>1.39</code></td><td><code>1.41</code></td></tr><tr><td>AdminKubeconfigRequest</td><td><code>true</code></td><td><code>GA</code></td><td><code>1.42</code></td><td></td></tr></tbody></table><h2 id=using-a-feature>Using a feature</h2><p>A feature can be in <em>Alpha</em>, <em>Beta</em> or <em>GA</em> stage.
An <em>Alpha</em> feature means:</p><ul><li>Disabled by default.</li><li>Might be buggy. Enabling the feature may expose bugs.</li><li>Support for feature may be dropped at any time without notice.</li><li>The API may change in incompatible ways in a later software release without notice.</li><li>Recommended for use only in short-lived testing clusters, due to increased
risk of bugs and lack of long-term support.</li></ul><p>A <em>Beta</em> feature means:</p><ul><li>Enabled by default.</li><li>The feature is well tested. Enabling the feature is considered safe.</li><li>Support for the overall feature will not be dropped, though details may change.</li><li>The schema and/or semantics of objects may change in incompatible ways in a
subsequent beta or stable release. When this happens, we will provide instructions
for migrating to the next version. This may require deleting, editing, and
re-creating API objects. The editing process may require some thought.
This may require downtime for applications that rely on the feature.</li><li>Recommended for only non-critical uses because of potential for
incompatible changes in subsequent releases.</li></ul><blockquote><p>Please do try <em>Beta</em> features and give feedback on them!
After they exit beta, it may not be practical for us to make more changes.</p></blockquote><p>A <em>General Availability</em> (GA) feature is also referred to as a <em>stable</em> feature. It means:</p><ul><li>The feature is always enabled; you cannot disable it.</li><li>The corresponding feature gate is no longer needed.</li><li>Stable versions of features will appear in released software for many subsequent versions.</li></ul><h2 id=list-of-feature-gates>List of Feature Gates</h2><table><thead><tr><th>Feature</th><th>Relevant Components</th><th>Description</th></tr></thead><tbody><tr><td>HVPA</td><td><code>gardenlet</code></td><td>Enables simultaneous horizontal and vertical scaling in Seed Clusters.</td></tr><tr><td>HVPAForShootedSeed</td><td><code>gardenlet</code></td><td>Enables simultaneous horizontal and vertical scaling in managed seed (aka &ldquo;shooted seed&rdquo;) clusters.</td></tr><tr><td>ManagedIstio</td><td><code>gardenlet</code></td><td>Enables a Gardener-tailored <a href=https://istio.io>Istio</a> in each Seed cluster. Disable this feature if Istio is already installed in the cluster. Istio is not automatically removed if this feature is disabled. See the <a href=/docs/gardener/usage/istio/>detailed documentation</a> for more information.</td></tr><tr><td>APIServerSNI</td><td><code>gardenlet</code></td><td>Enables only one LoadBalancer to be used for every Shoot cluster API server in a Seed. Enable this feature when <code>ManagedIstio</code> is enabled or Istio is manually deployed in Seed cluster. See <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>GEP-8</a> for more details.</td></tr><tr><td>CachedRuntimeClients</td><td><code>gardener-controller-manager</code>, <code>gardenlet</code></td><td>Enables a cache in the controller-runtime clients, that Gardener components use. If disabled all controller-runtime clients will directly talk to the API server instead of relying on a cache. The feature gate can be specified for gardenlet and gardener-controller-manager (and gardener-scheduler for the versions <code>&lt; 1.29</code>).</td></tr><tr><td>SeedChange</td><td><code>gardener-apiserver</code></td><td>Enables updating the <code>spec.seedName</code> field during shoot validation from a non-empty value in order to trigger shoot control plane migration.</td></tr><tr><td>SeedKubeScheduler</td><td><code>gardenlet</code></td><td>Adds custom <code>kube-scheduler</code> in <code>gardener-kube-scheduler</code> namespace. It schedules <a href=/docs/gardener/concepts/seed-admission-controller/#mutating-webhooks>pods with scheduler name</a> <code>gardener-kube-scheduler</code> on Nodes with higher resource utilization. It requires Seed cluster with kubernetes version <code>1.18</code> or higher.</td></tr><tr><td>ReversedVPN</td><td><code>gardenlet</code></td><td>Reverses the connection setup of the vpn tunnel between the Seed and the Shoot cluster(s). It allows Seed and Shoot clusters to be in different networks with only direct access in one direction (Shoot -> Seed). In addition to that, it reduces the amount of load balancers required, i.e. no load balancers are required for the vpn tunnel anymore. It requires <code>APIServerSNI</code> and kubernetes version <code>1.18</code> or higher to work. Details can be found in <a href=/docs/gardener/proposals/14-reversed-cluster-vpn/>GEP-14</a>.</td></tr><tr><td>AdminKubeconfigRequest</td><td><code>gardener-apiserver</code></td><td>Enables the <code>AdminKubeconfigRequest</code> endpoint on Shoot resources. See <a href=/docs/gardener/proposals/16-adminkubeconfig-subresource/>GEP-16</a> for more details.</td></tr><tr><td>UseDNSRecords</td><td><code>gardener-apiserver</code>, <code>gardener-controller-manager</code>, <code>gardenlet</code></td><td>Enables using <code>DNSRecord</code> resources for Gardener DNS records instead of <code>DNSProvider</code>, <code>DNSEntry</code>, and <code>DNSOwner</code> resources. See <a href=/docs/gardener/extensions/dnsrecord/>Contract: <code>DNSRecord</code> resources</a> for more details.</td></tr><tr><td>RotateSSHKeypairOnMaintenance</td><td><code>gardener-controller-manager</code></td><td>Enables SSH keypair rotation in the maintenance controller of the gardener-controller-manager. Details can be found in <a href=/docs/gardener/proposals/15-manage-bastions-and-ssh-key-pair-rotation/>GEP-15</a>.</td></tr><tr><td>DenyInvalidExtensionResources</td><td><code>gardenlet</code></td><td>Causes the <code>seed-admission-controller</code> to deny invalid extension resources, instead of just logging validation errors.</td></tr><tr><td>WorkerPoolKubernetesVersion</td><td><code>gardener-apiserver</code></td><td>Allows to overwrite the Kubernetes version used for shoot clusters per worker pool (see <a href=/docs/gardener/usage/worker_pool_k8s_versions/>this document</a>)</td></tr><tr><td>CopyEtcdBackupsDuringControlPlaneMigration</td><td><code>gardenlet</code></td><td>Enables the copy of etcd backups from the object store of the source seed to the object store of the destination seed during control plane migration.</td></tr><tr><td>SecretBindingProviderValidation</td><td><code>gardener-apiserver</code></td><td>Enables validations on Gardener API server that:<br>- requires the provider type of a SecretBinding to be set (on SecretBinding creation)<br>- requires the SecretBinding provider type to match the Shoot provider type (on Shoot creation)<br>- enforces immutability on the provider type of a SecretBinding</td></tr><tr><td>ForceRestore</td><td><code>gardenlet</code></td><td>Enables forcing the shoot&rsquo;s restoration to the destination seed during control plane migration if the preparation for migration in the source seed is not finished after a certain grace period and is considered unlikely to succeed (falling back to the <a href=/docs/gardener/proposals/17-shoot-control-plane-migration-bad-case/>control plane migration &ldquo;bad case&rdquo; scenario</a>). If you enable this feature gate, make sure to also enable <code>UseDNSRecords</code> and <code>CopyEtcdBackupsDuringControlPlaneMigration</code>.</td></tr><tr><td>DisableDNSProviderManagement</td><td><code>gardenlet</code></td><td>Disables management of <code>dns.gardener.cloud/v1alpha1.DNSProvider</code> resources. In this case, the <code>shoot-dns-service</code> extension will take this over if it is installed. This feature is only effective if the feature <code>UseDNSRecords</code> is <code>true</code>.</td></tr><tr><td>ShootCARotation</td><td><code>gardener-apiserver</code>, <code>gardenlet</code></td><td>Enables the feature to trigger automated CA rotation for shoot clusters.</td></tr><tr><td>ShootMaxTokenExpirationOverwrite</td><td><code>gardener-apiserver</code></td><td>Makes the Gardener API server overwriting values in the <code>.spec.kubernetes.kubeAPIServer.serviceAccountConfig.maxTokenExpiration</code> field of Shoot specifications to<br>- be at least 720h (30d) when the current value is lower<br>- be at most 2160h (90d) when the current value is higher<br>before persisting the object to etcd.</td></tr><tr><td>ShootMaxTokenExpirationValidation</td><td><code>gardener-apiserver</code></td><td>Enables validations on Gardener API server that enforce that the value of the <code>.spec.kubernetes.kubeAPIServer.serviceAccountConfig.maxTokenExpiration</code> field<br>- is at least 720h (30d).<br>- is at most 2160h (90d).<br>Only enable this after <code>ShootMaxTokenExpirationOverwrite</code> is enabled and all shoots got updated accordingly.</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-9cfd104830b4bc8eafa2e90c3d9ff542>3.7 - Gardenlet Api Access</h1><h1 id=scoped-api-access-for-gardenlets>Scoped API Access for Gardenlets</h1><p>By default, <code>gardenlet</code>s have administrative access in the garden cluster.
They are able to execute any API request on any object independent of whether the object is related to the seed cluster the <code>gardenlet</code> is responsible fto.
As RBAC is not powerful enough for fine-grained checks and for the sake of security, Gardener provides two optional but recommended configurations for your environments that scope the API access for <code>gardenlet</code>s.</p><p>Similar to the <a href=https://kubernetes.io/docs/reference/access-authn-authz/node/><code>Node</code> authorization mode in Kubernetes</a>, Gardener features a <code>SeedAuthorizer</code> plugin.
It is a special-purpose authorization plugin that specifically authorizes API requests made by the <code>gardenlet</code>s.</p><p>Likewise, similar to the <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction><code>NodeRestriction</code> admission plugin in Kubernetes</a>, Gardener features a <code>SeedRestriction</code> plugin.
It is a special-purpose admission plugin that specifically limits the Kubernetes objects <code>gardenlet</code>s can modify.</p><p>📚 You might be interested to look into the <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/kubelet-authorizer.md>design proposal for scoped Kubelet API access</a> from the Kubernetes community.
It can be translated to Gardener and Gardenlets with their <code>Seed</code> and <code>Shoot</code> resources.</p><h2 id=flow-diagram>Flow Diagram</h2><p>The following diagram shows how the two plugins are included in the request flow of a <code>gardenlet</code>.
When they are not enabled then the <code>kube-apiserver</code> is internally authorizing the request via RBAC before forwarding the request directly to the <code>gardener-apiserver</code>, i.e., the <code>gardener-admission-controller</code> would not be consulted (this is not entirely correct because it also serves other admission webhook handlers, but for simplicity reasons this document focuses on the API access scope only).</p><p>When enabling the plugins, there is one additional step for each before the <code>gardener-apiserver</code> responds to the request.</p><p><img src=/__resources/gardenlet_api_access_flow_6dfa06.png alt="Flow Diagram"></p><p>Please note that the example shows a request to an object (<code>Shoot</code>) residing in one of the API groups served by <code>gardener-apiserver</code>.
However, the <code>gardenlet</code> is also interacting with objects in API groups served by the <code>kube-apiserver</code> (e.g., <code>Secret</code>,<code>ConfigMap</code>, etc.).
In this case, the consultation of the <code>SeedRestriction</code> admission plugin is performed by the <code>kube-apiserver</code> itself before it forwards the request to the <code>gardener-apiserver</code>.</p><p>Today, the following rules are implemented:</p><table><thead><tr><th>Resource</th><th>Verbs</th><th>Path(s)</th><th>Description</th></tr></thead><tbody><tr><td><code>BackupBucket</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>delete</code></td><td><code>BackupBucket</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>BackupBucket</code>s. Allow only <code>create</code>, <code>update</code>, <code>patch</code>, <code>delete</code> requests for <code>BackupBucket</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>BackupEntry</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>create</code>, <code>update</code>, <code>patch</code></td><td><code>BackupEntry</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>BackupEntry</code>s. Allow only <code>create</code>, <code>update</code>, <code>patch</code> requests for <code>BackupEntry</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code> and referencing <code>BackupBucket</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>Bastion</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>create</code>, <code>update</code>, <code>patch</code></td><td><code>Bastion</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>Bastion</code>s. Allow only <code>create</code>, <code>update</code>, <code>patch</code> requests for <code>Bastion</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>CertificateSigningRequest</code></td><td><code>get</code>, <code>create</code></td><td><code>CertificateSigningRequest</code> -> <code>Seed</code></td><td>Allow only <code>get</code>, <code>create</code> requests for <code>CertificateSigningRequest</code>s related to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>CloudProfile</code></td><td><code>get</code></td><td><code>CloudProfile</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow only <code>get</code> requests for <code>CloudProfile</code>s referenced by <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>ClusterRoleBinding</code></td><td><code>create</code>, <code>get</code>, <code>update</code>, <code>patch</code>, <code>delete</code></td><td><code>ClusterRoleBinding</code> -> <code>ManagedSeed</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>create</code>, <code>get</code>, <code>update</code>, <code>patch</code> requests for <code>ManagedSeed</code>s in the bootstrapping phase assigned to the gardenlet&rsquo;s <code>Seed</code>s. Allow <code>delete</code> requests from gardenlets bootstrapped via <code>ManagedSeed</code>s.</td></tr><tr><td><code>ConfigMap</code></td><td><code>get</code></td><td><code>ConfigMap</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow only <code>get</code> requests for <code>ConfigMap</code>s referenced by <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>. Allows reading the <code>kube-system/cluster-identity</code> <code>ConfigMap</code>.</td></tr><tr><td><code>ControllerRegistration</code></td><td><code>get</code>, <code>list</code>, <code>watch</code></td><td><code>ControllerRegistration</code> -> <code>ControllerInstallation</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>ControllerRegistration</code>s.</td></tr><tr><td><code>ControllerDeployment</code></td><td><code>get</code></td><td><code>ControllerDeployment</code> -> <code>ControllerInstallation</code> -> <code>Seed</code></td><td>Allow <code>get</code> requests for <code>ControllerDeployments</code>s referenced by <code>ControllerInstallation</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>ControllerInstallation</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>update</code>, <code>patch</code></td><td><code>ControllerInstallation</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>ControllerInstallation</code>s. Allow only <code>update</code>, <code>patch</code> requests for <code>ControllerInstallation</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>Event</code></td><td><code>create</code>, <code>patch</code></td><td>none</td><td>Allow to <code>create</code> or <code>patch</code> all kinds of <code>Event</code>s.</td></tr><tr><td><code>ExposureClass</code></td><td><code>get</code></td><td><code>ExposureClass</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>get</code> requests for <code>ExposureClass</code>es referenced by <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>. Deny <code>get</code> requests to other <code>ExposureClass</code>es.</td></tr><tr><td><code>Lease</code></td><td><code>create</code>, <code>get</code>, <code>watch</code>, <code>update</code></td><td><code>Lease</code> -> <code>Seed</code></td><td>Allow <code>create</code>, <code>get</code>, <code>update</code>, and <code>delete</code> requests for <code>Lease</code>s of the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>ManagedSeed</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>update</code>, <code>patch</code></td><td><code>ManagedSeed</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>ManagedSeed</code>s. Allow only <code>update</code>, <code>patch</code> requests for <code>ManagedSeed</code>s referencing a <code>Shoot</code> assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>Namespace</code></td><td><code>get</code></td><td><code>Namespace</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>get</code> requests for <code>Namespace</code>s of <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>. Always allow <code>get</code> requests for the <code>garden</code> <code>Namespace</code>.</td></tr><tr><td><code>Project</code></td><td><code>get</code></td><td><code>Project</code> -> <code>Namespace</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>get</code> requests for <code>Project</code>s referenced by the <code>Namespace</code> of <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>SecretBinding</code></td><td><code>get</code></td><td><code>SecretBinding</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow only <code>get</code> requests for <code>SecretBinding</code>s referenced by <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>Secret</code></td><td><code>create</code>, <code>get</code>, <code>update</code>, <code>patch</code>, <code>delete</code>(, <code>list</code>, <code>watch</code>)</td><td><code>Secret</code> -> <code>Seed</code>, <code>Secret</code> -> <code>Shoot</code> -> <code>Seed</code>, <code>Secret</code> -> <code>SecretBinding</code> -> <code>Shoot</code> -> <code>Seed</code>, <code>BackupBucket</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>Secret</code>s in the <code>seed-&lt;name></code> namespace. Allow only <code>create</code>, <code>get</code>, <code>update</code>, <code>patch</code>, <code>delete</code> requests for the <code>Secret</code>s related to resources assigned to the gardenlet<code>'s </code>Seed`s.</td></tr><tr><td><code>Seed</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>delete</code></td><td><code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>Seed</code>s. Allow only <code>create</code>, <code>update</code>, <code>patch</code>, <code>delete</code> requests for the <code>gardenlet</code>&rsquo;s <code>Seed</code>s. [1]</td></tr><tr><td><code>ServiceAccount</code></td><td><code>create</code>, <code>get</code>, <code>update</code>, <code>patch</code>, <code>delete</code></td><td><code>ServiceAccount</code> -> <code>ManagedSeed</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>create</code>, <code>get</code>, <code>update</code>, <code>patch</code> requests for <code>ManagedSeed</code>s in the bootstrapping phase assigned to the gardenlet&rsquo;s <code>Seed</code>s. Allow <code>delete</code> requests from gardenlets bootstrapped via <code>ManagedSeed</code>s.</td></tr><tr><td><code>Shoot</code></td><td><code>get</code>, <code>list</code>, <code>watch</code>, <code>update</code>, <code>patch</code></td><td><code>Shoot</code> -> <code>Seed</code></td><td>Allow <code>get</code>, <code>list</code>, <code>watch</code> requests for all <code>Shoot</code>s. Allow only <code>update</code>, <code>patch</code> requests for <code>Shoot</code>s assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr><tr><td><code>ShootState</code></td><td><code>get</code>, <code>create</code>, <code>update</code>, <code>patch</code></td><td><code>ShootState</code> -> <code>Shoot</code> -> <code>Seed</code></td><td>Allow only <code>get</code>, <code>create</code>, <code>update</code>, <code>patch</code> requests for <code>ShootState</code>s belonging by <code>Shoot</code>s that are assigned to the <code>gardenlet</code>&rsquo;s <code>Seed</code>.</td></tr></tbody></table><p>[1] If you use <code>ManagedSeed</code> resources then the gardenlet reconciling them (&ldquo;parent gardenlet&rdquo;) may be allowed to submit certain requests for the <code>Seed</code> resources resulting out of such <code>ManagedSeed</code> reconciliations (even if the &ldquo;parent gardenlet&rdquo; is not responsible for them):</p><ul><li>ℹ️ It is allowed to delete the <code>Seed</code> resources if the corresponding <code>ManagedSeed</code> objects already have a <code>deletionTimestamp</code> (this is secure as gardenlets themselves don&rsquo;t have permissions for deleting <code>ManagedSeed</code>s).</li><li>⚠ It is allowed to create or update <code>Seed</code> resources if the corresponding <code>ManagedSeed</code> objects use a seed template, i.e., <code>.spec.seedTemplate != nil</code>. In this case, there is at least one gardenlet in your system which is responsible for two or more <code>Seed</code>s. Please keep in mind that this use case is not recommended for production scenarios (you should only have one dedicated gardenlet per seed cluster), hence, the security improvements discussed in this document might be limited.</li></ul><h2 id=seedauthorizer-authorization-webhook-enablement><code>SeedAuthorizer</code> Authorization Webhook Enablement</h2><p>The <code>SeedAuthorizer</code> is implemented as <a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/>Kubernetes authorization webhook</a> and part of the <a href=/docs/gardener/concepts/admission-controller/><code>gardener-admission-controller</code></a> component running in the garden cluster.</p><p>🎛 In order to activate it, you have to follow these steps:</p><ol><li><p>Set the following flags for the <code>kube-apiserver</code> of the garden cluster (i.e., the <code>kube-apiserver</code> whose API is extended by Gardener):</p><ul><li><code>--authorization-mode=RBAC,Node,Webhook</code> (please note that <code>Webhook</code> should appear after <code>RBAC</code> in the list [1]; <code>Node</code> might not be needed if you use a virtual garden cluster)</li><li><code>--authorization-webhook-config-file=&lt;path-to-the-webhook-config-file></code></li><li><code>--authorization-webhook-cache-authorized-ttl=0</code></li><li><code>--authorization-webhook-cache-unauthorized-ttl=0</code></li></ul></li><li><p>The webhook config file (stored at <code>&lt;path-to-the-webhook-config-file></code>) should look as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
clusters:
- name: garden
  cluster:
    certificate-authority-data: base64(CA-CERT-OF-GARDENER-ADMISSION-CONTROLLER)
    server: https://gardener-admission-controller.garden/webhooks/auth/seed
users:
- name: kube-apiserver
  user: {}
contexts:
- name: auth-webhook
  context:
    cluster: garden
    user: kube-apiserver
current-context: auth-webhook
</code></pre></div></li><li><p>When deploying the <a href=https://github.com/gardener/gardener/tree/master/charts/gardener/controlplane>Gardener <code>controlplane</code> Helm chart</a>, set <code>.global.rbac.seedAuthorizer.enabled=true</code>. This will prevent that the RBAC resources granting global access for all gardenlets will be deployed.</p></li><li><p>Delete the existing RBAC resources granting global access for all gardenlets by running:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete <span style=color:#a31515>\
</span><span style=color:#a31515></span>  clusterrole.rbac.authorization.k8s.io/gardener.cloud:system:seeds <span style=color:#a31515>\
</span><span style=color:#a31515></span>  clusterrolebinding.rbac.authorization.k8s.io/gardener.cloud:system:seeds <span style=color:#a31515>\
</span><span style=color:#a31515></span>  --ignore-not-found
</code></pre></div></li></ol><p>Please note that you should activate the <a href=#seedrestriction-admission-webhook-enablement><code>SeedRestriction</code></a> admission handler as well.</p><blockquote><p>[1] The reason for the fact that <code>Webhook</code> authorization plugin should appear after <code>RBAC</code> is that the <code>kube-apiserver</code> will be depending on the <code>gardener-admission-controller</code> (serving the webhook). However, the <code>gardener-admission-controller</code> can only start when <code>gardener-apiserver</code> runs, but <code>gardener-apiserver</code> itself can only start when <code>kube-apiserver</code> runs. If <code>Webhook</code> is before <code>RBAC</code> then <code>gardener-apiserver</code> might not be able to start, leading to a deadlock.</p></blockquote><h3 id=authorizer-decisions>Authorizer Decisions</h3><p>As mentioned earlier, it&rsquo;s the authorizer&rsquo;s job to evaluate API requests and return one of the following decisions:</p><ul><li><code>DecisionAllow</code>: The request is allowed, further configured authorizers won&rsquo;t be consulted.</li><li><code>DecisionDeny</code>: The request is denied, further configured authorizers won&rsquo;t be consulted.</li><li><code>DecisionNoOpinion</code>: A decision cannot be made, further configured authorizers will be consulted.</li></ul><p>For backwards compatibility, no requests are denied at the moment, so that they are still deferred to a subsequent authorizer like RBAC.
Though, this might change in the future.</p><p>First, the <code>SeedAuthorizer</code> extracts the <code>Seed</code> name from the API request. This requires a proper TLS certificate the <code>gardenlet</code> uses to contact the API server and is automatically given if <a href=/docs/gardener/concepts/gardenlet/#TLS-Bootstrapping>TLS bootstrapping</a> is used.
Concretely, the authorizer checks the certificate for name <code>gardener.cloud:system:seed:&lt;seed-name></code> and group <code>gardener.cloud:system:seeds</code>.
In cases where this information is missing e.g., when a custom Kubeconfig is used, the authorizer cannot make any decision. Thus, RBAC is still a considerable option to restrict the <code>gardenlet</code>&rsquo;s access permission if the above explained preconditions are not given.</p><p>With the <code>Seed</code> name at hand, the authorizer checks for an <strong>existing path</strong> from the resource that a request is being made for to the <code>Seed</code> belonging to the <code>gardenlet</code>. Take a look at the <a href=#implementation-details>Implementation Details</a> section for more information.</p><h3 id=implementation-details>Implementation Details</h3><p>Internally, the <code>SeedAuthorizer</code> uses a directed, acyclic graph data structure in order to efficiently respond to authorization requests for gardenlets:</p><ul><li>A vertex in this graph represents a Kubernetes resource with its kind, namespace, and name (e.g., <code>Shoot:garden-my-project/my-shoot</code>).</li><li>An edge from vertex <code>u</code> to vertex <code>v</code> in this graph exists when<ul><li>(1) <code>v</code> is referred by <code>u</code> and <code>v</code> is a <code>Seed</code>, or when</li><li>(2) <code>u</code> is referred by <code>v</code>, or when</li><li>(3) <code>u</code> is strictly associated with <code>v</code>.</li></ul></li></ul><p>For example, a <code>Shoot</code> refers to a <code>Seed</code>, a <code>CloudProfile</code>, a <code>SecretBinding</code>, etc., so it has an outgoing edge to the <code>Seed</code> (1) and incoming edges from the <code>CloudProfile</code> and <code>SecretBinding</code> vertices (2).
However, there might also be a <code>ShootState</code> or a <code>BackupEntry</code> resource strictly associated with this <code>Shoot</code>, hence, it has incoming edges from these vertices (3).</p><p><img src=/__resources/gardenlet_api_access_graph_5486ba.png alt="Resource Dependency Graph"></p><p>In above picture the resources that are actively watched have are shaded.
Gardener resources are green while Kubernetes resources are blue.
It shows the dependencies between the resources and how the graph is built based on above rules.</p><p>ℹ️ Above picture shows all resources that may be accessed by <code>gardenlet</code>s, except for the <code>Quota</code> resource which is only included for completeness.</p><p>Now, when a <code>gardenlet</code> wants to access certain resources then the <code>SeedAuthorizer</code> uses a Depth-First traversal starting from the vertex representing the resource in question, e.g., from a <code>Project</code> vertex.
If there is a path from the <code>Project</code> vertex to the vertex representing the <code>Seed</code> the gardenlet is responsible for then it allows the request.</p><h4 id=metrics>Metrics</h4><p>The <code>SeedAuthorizer</code> registers the following metrics related to the mentioned graph implementation:</p><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody><tr><td><code>gardener_admission_controller_seed_authorizer_graph_update_duration_seconds</code></td><td>Histogram of duration of resource dependency graph updates in seed authorizer, i.e., how long does it take to update the graph&rsquo;s vertices/edges when a resource is created, changed, or deleted.</td></tr><tr><td><code>gardener_admission_controller_seed_authorizer_graph_path_check_duration_seconds</code></td><td>Histogram of duration of checks whether a path exists in the resource dependency graph in seed authorizer.</td></tr></tbody></table><h4 id=debug-handler>Debug Handler</h4><p>When the <code>.server.enableDebugHandlers</code> field in the <code>gardener-admission-controller</code>&rsquo;s component configuration is set to <code>true</code> then it serves a handler that can be used for debugging the resource dependency graph under <code>/debug/resource-dependency-graph</code>.</p><p>🚨 Only use this setting for development purposes as it enables unauthenticated users to view all data if they have access to the <code>gardener-admission-controller</code> component.</p><p>The handler renders an HTML page displaying the current graph with a list of vertices and its associated incoming and outgoing edges to other vertices.
Depending on the size of the Gardener landscape (and consequently, the size of the graph), it might not be possible to render it in its entirety.
If there are more than 2000 vertices then the default filtering will selected for <code>kind=Seed</code> to prevent overloading the output.</p><p><em>Example output</em>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>-------------------------------------------------------------------------------
|
| # Seed:my-seed
|   &lt;- (11)
|     BackupBucket:73972fe2-3d7e-4f61-a406-b8f9e670e6b7
|     BackupEntry:garden-my-project/shoot--dev--my-shoot--4656a460-1a69-4f00-9372-7452cbd38ee3
|     ControllerInstallation:dns-external-mxt8m
|     ControllerInstallation:extension-shoot-cert-service-4qw5j
|     ControllerInstallation:networking-calico-bgrb2
|     ControllerInstallation:os-gardenlinux-qvb5z
|     ControllerInstallation:provider-gcp-w4mvf
|     Secret:garden/backup
|     Shoot:garden-my-project/my-shoot
|
-------------------------------------------------------------------------------
|
| # Shoot:garden-my-project/my-shoot
|   &lt;- (5)
|     CloudProfile:gcp
|     Namespace:garden-my-project
|     Secret:garden-my-project/my-dns-secret
|     SecretBinding:garden-my-project/my-credentials
|     ShootState:garden-my-project/my-shoot
|   -&gt; (1)
|     Seed:my-seed
|
-------------------------------------------------------------------------------
|
| # ShootState:garden-my-project/my-shoot
|   -&gt; (1)
|     Shoot:garden-my-project/my-shoot
|
-------------------------------------------------------------------------------

... (etc., similarly for the other resources)
</code></pre></div><p>There are anchor links to easily jump from one resource to another, and the page provides means for filtering the results based on the <code>kind</code>, <code>namespace</code>, and/or <code>name</code>.</p><h4 id=pitfalls>Pitfalls</h4><p>When there is a relevant update to an existing resource, i.e., when a reference to another resource is changed, then the corresponding vertex (along with all associated edges) is first deleted from the graph before it gets added again with the up-to-date edges.
However, this does only work for vertices belonging to resources that are only created in exactly one &ldquo;watch handler&rdquo;.
For example, the vertex for a <code>SecretBinding</code> can either be created in the <code>SecretBinding</code> handler itself or in the <code>Shoot</code> handler.
In such cases, deleting the vertex before (re-)computing the edges might lead to race conditions and potentially renders the graph invalid.
Consequently, instead of deleting the vertex, only the edges the respective handler is responsible for are deleted.
If the vertex ends up with no remaining edges then it also gets deleted automatically.
Afterwards, the vertex can either be added again or the updated edges can be created.</p><h2 id=seedrestriction-admission-webhook-enablement><code>SeedRestriction</code> Admission Webhook Enablement</h2><p>The <code>SeedRestriction</code> is implemented as <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>Kubernetes admission webhook</a> and part of the <a href=/docs/gardener/concepts/admission-controller/><code>gardener-admission-controller</code></a> component running in the garden cluster.</p><p>🎛 In order to activate it, you have to set <code>.global.admission.seedRestriction.enabled=true</code> when using the <a href=https://github.com/gardener/gardener/tree/master/charts/gardener/controlplane>Gardener <code>controlplane</code> Helm chart</a>.
This will add an additional webhook in the existing <code>ValidatingWebhookConfiguration</code> of the <code>gardener-admission-controller</code> which contains the configuration for the <code>SeedRestriction</code> handler.
Please note that it should only be activated when the <code>SeedAuthorizer</code> is active as well.</p><h3 id=admission-decisions>Admission Decisions</h3><p>The admission&rsquo;s purpose is to perform extended validation on requests which require the body of the object in question.
Additionally, it handles <code>CREATE</code> requests of gardenlets (above discussed resource dependency graph cannot be used in such cases because there won&rsquo;t be any vertex/edge for non-existing resources).</p><p>Gardenlets are restricted to only create new resources which are somehow related to the seed clusters they are responsible for.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b20736e3fcbc4d202271af720d0806cf>3.8 - Getting Started Locally</h1><h1 id=deploying-gardener-locally>Deploying Gardener locally</h1><p>This document will walk you through deploying Gardener on your local machine.
If you encounter difficulties, please open an issue so that we can make this process easier.</p><p>Gardener runs in any Kubernetes cluster.
In this guide, we will start a <a href=https://kind.sigs.k8s.io/>KinD</a> cluster which is used as both garden and seed cluster (please refer to the <a href=/docs/gardener/concepts/architecture/>architecture overview</a>) for simplicity.</p><p>Based on <a href=https://skaffold.dev/>Skaffold</a>, the container images for all required components will be built and deployed into the cluster (via their <a href=https://helm.sh/>Helm charts</a>).</p><p><img src=/__resources/getting_started_locally_f66391.png alt="Architecture Diagram"></p><h2 id=prerequisites>Prerequisites</h2><ul><li><p>Make sure your Docker daemon is up-to-date, up and running and has enough resources (at least <code>8</code> CPUs and <code>8Gi</code> memory; see <a href=https://docs.docker.com/desktop/mac/#resources>here</a> how to configure the resources for Docker for Mac).</p><blockquote><p>Please note that 8 CPU / 8Gi memory might not be enough for more than two <code>Shoot</code> clusters, i.e., you might need to increase these values if you want to run additional <code>Shoot</code>s.</p></blockquote><p>Additionally, please configure at least <code>120Gi</code> of disk size for the Docker daemon.</p><blockquote><p>Tip: With <code>docker system df</code> and <code>docker system prune -a</code> you can cleanup unused data.</p></blockquote></li></ul><h2 id=setting-up-the-kind-cluster-garden-and-seed>Setting up the KinD cluster (garden and seed)</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up
</code></pre></div><p>This command sets up a new KinD cluster named <code>gardener-local</code> and stores the kubeconfig in the <code>./example/gardener-local/kind/kubeconfig</code> file.</p><blockquote><p>It might be helpful to copy this file to <code>$HOME/.kube/config</code> since you will need to target this KinD cluster multiple times.
Alternatively, make sure to set your <code>KUBECONFIG</code> environment variable to <code>./example/gardener-local/kind/kubeconfig</code> for all future steps via <code>export KUBECONFIG=example/gardener-local/kind/kubeconfig</code>.</p></blockquote><p>All following steps assume that your are using this kubeconfig.</p><h2 id=setting-up-gardener>Setting up Gardener</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make gardener-up
</code></pre></div><p>This will first build the images based (which might take a bit if you do it for the first time).
Afterwards, the Gardener resources will be deployed into the cluster.</p><h2 id=creating-a-shoot-cluster>Creating a <code>Shoot</code> cluster</h2><p>You can wait for the <code>Seed</code> to be ready by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=gardenletready --for=condition=extensionsready --for=condition=bootstrapped seed local --timeout=5m
</code></pre></div><p>Alternatively, you can run <code>kubectl get seed local</code> and wait for the <code>STATUS</code> to indicate readiness:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME    STATUS   PROVIDER   REGION   AGE     VERSION       K8S VERSION
local   Ready    local      local    4m42s   vX.Y.Z-dev    v1.21.1
</code></pre></div><p>In order to create a first shoot cluster, just run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f example/provider-local/shoot.yaml
</code></pre></div><p>You can wait for the <code>Shoot</code> to be ready by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=apiserveravailable --for=condition=controlplanehealthy --for=condition=everynodeready --for=condition=systemcomponentshealthy shoot local -n garden-local --timeout=10m
</code></pre></div><p>Alternatively, you can run <code>kubectl -n garden-local get shoot local</code> and wait for the <code>LAST OPERATION</code> to reach <code>100%</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME    CLOUDPROFILE   PROVIDER   REGION   K8S VERSION   HIBERNATION   LAST OPERATION            STATUS    AGE
local   local          local      local    1.21.0        Awake         Create Processing (43%)   healthy   94s
</code></pre></div><p>(Optional): You could also execute a simple e2e test (creating and deleting a shoot) by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make test-e2e-local-fast KUBECONFIG=<span style=color:#a31515>&#34;</span>$PWD<span style=color:#a31515>/example/gardener-local/kind/kubeconfig&#34;</span>
</code></pre></div><p>⚠️ Please note that in this setup shoot clusters are not accessible by default when you download the kubeconfig and try to communicate with them.
The reason is that your host most probably cannot resolve the DNS names of the clusters since <code>provider-local</code> extension runs inside the KinD cluster (see <a href=/docs/gardener/extensions/provider-local/#dnsrecord>this</a> for more details).
Hence, if you want to access the shoot cluster, you have to run the following command which will extend your <code>/etc/hosts</code> file with the required information to make the DNS names resolvable:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#a31515>&lt;&lt;EOF | sudo tee -a /etc/hosts
</span><span style=color:#a31515>
</span><span style=color:#a31515># Manually created to access local Gardener shoot clusters with names &#39;local&#39; or &#39;e2e-local&#39; in the &#39;garden-local&#39; namespace.
</span><span style=color:#a31515># TODO: Remove this again when the shoot cluster access is no longer required.
</span><span style=color:#a31515>127.0.0.1 api.local.local.external.local.gardener.cloud
</span><span style=color:#a31515>127.0.0.1 api.local.local.internal.local.gardener.cloud
</span><span style=color:#a31515>127.0.0.1 api.e2e-local.local.external.local.gardener.cloud
</span><span style=color:#a31515>127.0.0.1 api.e2e-local.local.internal.local.gardener.cloud
</span><span style=color:#a31515>EOF</span>
</code></pre></div><p>Now you can access it by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-local get secret local.kubeconfig -o jsonpath={.data.kubeconfig} | base64 -d &gt; /tmp/kubeconfig-shoot-local.yaml
kubectl --kubeconfig=/tmp/kubeconfig-shoot-local.yaml get nodes
</code></pre></div><h2 id=deleting-the-shoot-cluster>Deleting the <code>Shoot</code> cluster</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>./hack/usage/delete shoot local garden-local
</code></pre></div><h2 id=tear-down-the-gardener-environment>Tear down the Gardener environment</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make kind-down
</code></pre></div><h2 id=further-reading>Further reading</h2><p>This setup makes use of the local provider extension. You can read more about it in <a href=/docs/gardener/extensions/provider-local/>this document</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a53ffb401b7a9ba7d6243e70af0be09>3.9 - Image Vector</h1><h1 id=image-vector>Image Vector</h1><p>The Gardenlet is deploying several different container images into the seed and the shoot clusters.
The image repositories and tags are defined in a <a href=https://github.com/gardener/gardener/blob/master/charts/images.yaml>central image vector file</a>.
Obviously, the image versions defined there must fit together with the deployment manifests (e.g., some command-line flags do only exist in certain versions).</p><h2 id=example>Example</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>images:
- name: pause-container
  sourceRepository: github.com/kubernetes/kubernetes/blob/master/build/pause/Dockerfile
  repository: gcr.io/google_containers/pause-amd64
  tag: <span style=color:#a31515>&#34;3.0&#34;</span>
  version: 1.17.x
- name: pause-container
  sourceRepository: github.com/kubernetes/kubernetes/blob/master/build/pause/Dockerfile
  repository: gcr.io/google_containers/pause-amd64
  tag: <span style=color:#a31515>&#34;3.1&#34;</span>
  version: <span style=color:#a31515>&#34;&gt;= 1.18&#34;</span>
...
</code></pre></div><p>That means that the Gardenlet will use the <code>pause-container</code> in with tag <code>3.0</code> for all seed/shoot clusters with Kubernetes version <code>1.17.x</code>, and tag <code>3.1</code> for all clusters with Kubernetes <code>>= 1.18</code>.</p><h2 id=overwrite-image-vector>Overwrite image vector</h2><p>In some environment it is not possible to use these &ldquo;pre-defined&rdquo; images that come with a Gardener release.
A prominent example for that is Alicloud in China which does not allow access to Google&rsquo;s GCR.
In these cases you might want to overwrite certain images, e.g., point the <code>pause-container</code> to a different registry.</p><p>⚠️ If you specify an image that does not fit to the resource manifest then the seed/shoot reconciliation might fail.</p><p>In order to overwrite the images you must provide a similar file to Gardenlet:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>images:
- name: pause-container
  sourceRepository: github.com/kubernetes/kubernetes/blob/master/build/pause/Dockerfile
  repository: my-custom-image-registry/pause-amd64
  tag: <span style=color:#a31515>&#34;3.0&#34;</span>
  version: 1.17.x
- name: pause-container
  sourceRepository: github.com/kubernetes/kubernetes/blob/master/build/pause/Dockerfile
  repository: my-custom-image-registry/pause-amd64
  tag: <span style=color:#a31515>&#34;3.1&#34;</span>
  version: <span style=color:#a31515>&#34;&gt;= 1.18&#34;</span>
...
</code></pre></div><p>During deployment of the gardenlet create a <code>ConfigMap</code> containing the above content and mount it as a volume into the gardenlet pod.
Next, specify the environment variable <code>IMAGEVECTOR_OVERWRITE</code> whose value must be the path to the file you just mounted:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ConfigMap
metadata:
  name: gardenlet-images-overwrite
  namespace: garden
data:
  images_overwrite.yaml: |<span style=color:#a31515>
</span><span style=color:#a31515>    images:
</span><span style=color:#a31515>    - ...</span>    
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: gardenlet
  namespace: garden
spec:
  template:
    ...
    spec:
      containers:
      - name: gardenlet
        env:
        - name: IMAGEVECTOR_OVERWRITE
          value: /charts-overwrite/images_overwrite.yaml
        volumeMounts:
        - name: gardenlet-images-overwrite
          mountPath: /charts-overwrite
        ...
      volumes:
      - name: gardenlet-images-overwrite
        configMap:
          name: gardenlet-images-overwrite
  ...
</code></pre></div><h2 id=image-vectors-for-dependent-components>Image vectors for dependent components</h2><p>The gardenlet is deploying a lot of different components that might deploy other images themselves.
These components might use an image vector as well.
Operators might want to customize the image locations for these transitive images as well, hence, they might need to specify an image vector overwrite for the components directly deployed by Gardener.</p><p>It is possible to specify the <code>IMAGEVECTOR_OVERWRITE_COMPONENTS</code> environment variable to the gardenlet that points to a file with the following content:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>components:
- name: etcd-druid
  imageVectorOverwrite: |<span style=color:#a31515>
</span><span style=color:#a31515>    images:
</span><span style=color:#a31515>    - name: etcd
</span><span style=color:#a31515>      tag: v1.2.3
</span><span style=color:#a31515>      repository: etcd/etcd</span>    
...
</code></pre></div><p>The gardenlet will, if supported by the directly deployed component (<code>etcd-druid</code> in this example), inject the given <code>imageVectorOverwrite</code> into the <code>Deployment</code> manifest.
The respective component is responsible for using the overwritten images instead of its defaults.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d48433bb7b23a8ada3fb3a2f6c8674f1>3.10 - Migration V0 To V1</h1><h1 id=migration-from-gardener-v0-to-v1>Migration from Gardener <code>v0</code> to <code>v1</code></h1><p>Please refer to the <a href=https://github.com/gardener/gardener/blob/v1.10.1/docs/deployment/migration_v0_to_v1.md>document for older Gardener versions</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ba94e9b56f741be3998ac8487425f6b3>3.11 - Secret Binding Provider Controller</h1><h1 id=secretbinding-provider-controller>SecretBinding Provider Controller</h1><p>This page describes the process on how to enable the SecretBinding provider controller.</p><h2 id=overview>Overview</h2><p>With Gardener v1.38.0 the SecretBinding resource does now contain a new optional field <code>.provider.type</code> (details about the motivation can be found in <a href=https://github.com/gardener/gardener/issues/4888)>https://github.com/gardener/gardener/issues/4888)</a>. To make the process of setting the new field automated and afterwards to enforce validation on the new field in backwards compatible manner, Gardener features the SecretBinding provider controller and a feature gate - <code>SecretBindingProviderValidation</code>.</p><h2 id=process>Process</h2><p>A Gardener landscape operator can follow the following steps:</p><ol><li><p>Enable the SecretBinding provider controller of Gardener Controller Manager.</p><p>The SecretBinding provider controller is responsible to populate the <code>.provider.type</code> field of a SecretBinding based on its current usage by Shoot resources. For example if a Shoot <code>crazy-botany</code> with <code>.provider.type=aws</code> is using a SecretBinding <code>my-secret-binding</code>, then the SecretBinding provider controller will take care to set the <code>.provider.type</code> field of the SecretBinding to the same provider type (<code>aws</code>).
To enable the SecretBinding provider controller, in the ControllerManagerConfiguration set the <code>controller.secretBindingProvider.concurentSyncs</code> field (e.g set it to <code>5</code>).
Although that it is not recommended, the API allows Shoots from different provider types to reference the same SecretBinding (assuming that backing Secret contains data for both of the provider types). To preserve the backwards compatibility for such SecretBindings, the provider controller will maintain the multiple provider types in the field (it will join them with separator <code>,</code> - for example <code>aws,gcp</code>).</p></li><li><p>Disable the SecretBinding provider controller and enable <code>SecretBindingProviderValidation</code> feature gate of Gardener API server.</p><p>The <code>SecretBindingProviderValidation</code> feature gate of Gardener API server enables set of validations for the SecretBinding provider field. It forbids creating a Shoot that has a different provider type from the referenced SecretBinding&rsquo;s one. It also enforces immutability on the field.
After making sure that SecretBinding provider controller is enabled and it populated the <code>.provider.type</code> field of a majority of the SecretBindings on a Gardener landscape (the SecretBindings that are unused will have their provider type unset), a Gardener landscape operator has to disable the SecretBinding provider controller and to enable the <code>SecretBindingProviderValidation</code> feature gate of Gardener API server. To disable the SecretBinding provider controller, in the ControllerManagerConfiguration set the <code>controller.secretBindingProvider.concurentSyncs</code> field to <code>0</code>.</p></li></ol><h2 id=implementation-history>Implementation History</h2><ul><li>Gardener v1.38: SecretBinding resource has a new optional field <code>.provider.type</code>. SecretBinding provider controller is disabled by default. <code>SecretBindingProviderValidation</code> feature gate of Gardener API server is disabled by default.</li><li>Gardener v1.42: SecretBinding provider controller is enabled by default.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-83f23df3bdd8e7e5f8233751ed6600f6>3.12 - Setup Gardener</h1><h1 id=deploying-the-gardener-into-a-kubernetes-cluster>Deploying the Gardener into a Kubernetes cluster</h1><p>Similar to Kubernetes, Gardener consists out of control plane components (Gardener API server, Gardener controller manager, Gardener scheduler), and an agent component (Gardenlet).
The control plane is deployed in the so-called garden cluster while the agent is installed into every seed cluster.
Please note that it is possible to use the garden cluster as seed cluster by simply deploying the Gardenlet into it.</p><p>We are providing <a href=https://github.com/gardener/gardener/tree/master/charts/gardener>Helm charts</a> in order to manage the various resources of the components.
Please always make sure that you use the Helm chart version that matches the Gardener version you want to deploy.</p><h2 id=deploying-the-gardener-control-plane-api-server-admission-controller-controller-manager-scheduler>Deploying the Gardener control plane (API server, admission controller, controller manager, scheduler)</h2><p>The <a href=https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/values.yaml>configuration values</a> depict the various options to configure the different components.
Please consult <a href=/docs/gardener/usage/configuration/>this document</a> for component specific configurations and <a href=/docs/gardener/deployment/authentication_gardener_control_plane/>this document</a> for authentication related specifics.</p><p>Also note that all resources and deployments need to be created in the <code>garden</code> namespace (not overrideable).
If you enable the Gardener admission controller as part of you setup, please make sure the <code>garden</code> namespace is labelled with <code>app: gardener</code>.
Otherwise, the backing service account for the admission controller Pod might not be created successfully.
No action is necessary, if you deploy the <code>garden</code> namespace with the Gardener control plane Helm chart.</p><p>After preparing your values in a separate <code>controlplane-values.yaml</code> file (<a href=https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/values.yaml>values.yaml</a> can be used as starting point), you can run the following command against your garden cluster:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>helm install charts/gardener/controlplane <span style=color:#a31515>\
</span><span style=color:#a31515></span>  --namespace garden <span style=color:#a31515>\
</span><span style=color:#a31515></span>  --name gardener-controlplane <span style=color:#a31515>\
</span><span style=color:#a31515></span>  -f controlplane-values.yaml <span style=color:#a31515>\
</span><span style=color:#a31515></span>  --wait
</code></pre></div><h2 id=deploying-gardener-extensions>Deploying Gardener extensions</h2><p>Gardener is an extensible system that does not contain the logic for provider-specific things like DNS management, cloud infrastructures, network plugins, operating system configs, and many more.</p><p>You have to install extension controllers for these parts.
Please consult <a href=/docs/gardener/extensions/overview/>the documentation regarding extensions</a> to get more information.</p><h2 id=deploying-the-gardener-agent-gardenlet>Deploying the Gardener agent (Gardenlet)</h2><p>Please refer to <a href=/docs/gardener/deployment/deploy_gardenlet/>this document</a> on how to deploy a Gardenlet.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9dd0ffa442dec2cdede353f4d427f770>3.13 - Version Skew Policy</h1><h1 id=version-skew-policy>Version Skew Policy</h1><p>This document describes the maximum version skew supported between various Gardener components.</p><h2 id=supported-gardener-versions>Supported Gardener Versions</h2><p>Gardener versions are expressed as <code>x.y.z</code>, where <code>x</code> is the major version, <code>y</code> is the minor version, and <code>z</code> is the patch version, following Semantic Versioning terminology.</p><p>The Gardener project maintains release branches for the most recent three minor releases.</p><p>Applicable fixes, including security fixes, may be backported to those three release branches, depending on severity and feasibility.
Patch releases are cut from those branches at a regular cadence, plus additional urgent releases when required.</p><p>For more information, see <a href=/docs/gardener/development/process/#releases>this document</a>.</p><h3 id=supported-version-skew>Supported Version Skew</h3><p>Technically, we follow the same <a href=https://kubernetes.io/releases/version-skew-policy/>policy</a> as the Kubernetes project.
However, given that our release cadence is much more frequent compared to Kubernetes (every <code>14d</code> vs. every <code>120d</code>), in many cases it is possible to skip a version.
Still, to be on the safe side, it is highly recommended to follow the described policy.</p><h4 id=gardener-apiserver>gardener-apiserver</h4><p>In multi-instance setups of Gardener, the newest and oldest <code>gardener-apiserver</code> instances must be within one minor version.</p><p>Example:</p><ul><li>newest <code>gardener-apiserver</code> is at <strong>1.37</strong></li><li>other <code>gardener-apiserver</code> instances are supported at <strong>1.37</strong> and <strong>v1.36</strong></li></ul><h4 id=gardener-controller-manager-gardener-scheduler-gardener-admission-controller-gardenlet>gardener-controller-manager, gardener-scheduler, gardener-admission-controller, gardenlet</h4><p><code>gardener-controller-manager</code>, <code>gardener-scheduler</code>, <code>gardener-admission-controller</code>, and <code>gardenlet</code> must not be newer than the <code>gardener-apiserver</code> instances they communicate with.
They are expected to match the <code>gardener-apiserver</code> minor version, but may be up to one minor version older (to allow live upgrades).</p><p>Example:</p><ul><li><code>gardener-apiserver</code> is at <strong>v1.37</strong></li><li><code>gardener-controller-manager</code>, <code>gardener-scheduler</code>, <code>gardener-admission-controller</code>, and <code>gardenlet</code> are supported at <strong>1.37</strong> and <strong>v1.36</strong></li></ul><h3 id=supported-component-upgrade-order>Supported Component Upgrade Order</h3><p>The supported version skew between components has implications on the order in which components must be upgraded.
This section describes the order in which components must be upgraded to transition an existing Gardener installation from version <strong>1.37</strong> to version <strong>1.38</strong>.</p><h4 id=gardener-apiserver-1>gardener-apiserver</h4><p>Pre-requisites:</p><ul><li>In a single-instance setup, the existing <code>gardener-apiserver</code> instance is <strong>1.37</strong></li><li>In a multi-instance setup, all <code>gardener-apiserver</code> instances are at <strong>1.37</strong> or <strong>1.38</strong> (this ensures maximum skew of 1 minor version between the oldest and newest <code>gardener-apiserver</code> instance)</li><li>The <code>gardener-controller-manager</code>, <code>gardener-scheduler</code>, <code>gardener-admission-controller</code>, and <code>gardenlet</code> instances that communicate with this <code>gardener-apiserver</code> are at version <strong>1.37</strong> (this ensures they are not newer than the existing API server version and are within 1 minor version of the new API server version)</li></ul><p>Action:</p><ul><li>Upgrade <code>gardener-apiserver</code> to <strong>1.38</strong></li></ul><h4 id=gardener-controller-manager-gardener-scheduler-gardener-admission-controller-gardenlet-1>gardener-controller-manager, gardener-scheduler, gardener-admission-controller, gardenlet</h4><p>Pre-requisites:</p><ul><li>The <code>gardener-apiserver</code> instances these components communicate with are at <strong>1.38</strong> (in multi-instance setups in which these components can communicate with any <code>gardener-apiserver</code> instance in the cluster, all <code>gardener-apiserver</code> instances must be upgraded before upgrading these components)</li></ul><p>Action:</p><ul><li>Upgrade <code>gardener-controller-manager</code>, <code>gardener-scheduler</code>, <code>gardener-admission-controller</code>, and <code>gardenlet</code> to <strong>1.38</strong></li></ul><h2 id=supported-kubernetes-versions>Supported Kubernetes Versions</h2><p>Please refer to <a href=/docs/gardener/usage/supported_k8s_versions/>this document</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d4e003b162dfe49dc28bfcebcbeae620>4 - Development</h1></div><div class=td-content><h1 id=pg-d3de31ca8fda3468ee64b931363985a9>4.1 - Changing The Api</h1><h1 id=extending-the-api>Extending the API</h1><p>This document describes the steps that need to be performed when changing the API.
It provides guidance for API changes to both (Gardener system in general or component configurations).</p><p>Generally, as Gardener is a Kubernetes-native extension, it follows the same API conventions and guidelines like Kubernetes itself.
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md>This document</a> as well as <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md>this document</a> already provide a good overview and general explanation of the basic concepts behind it.
We are following the same approaches.</p><h2 id=gardener-api>Gardener API</h2><p>The Gardener API is defined in <code>pkg/apis/{core,extensions,settings}</code> directories and is the main point of interaction with the system.
It must be ensured that the API is always backwards-compatible.
If fields shall be removed permanently from the API then a proper deprecation period must be adhered to so that end-users have enough time adapt their clients.</p><p><strong>Checklist</strong> when changing the API:</p><ol><li>Modify the field(s) in the respective Golang files of all external and the internal version.<ol><li>Make sure new fields are being added as &ldquo;optional&rdquo; fields, i.e., they are of pointer types, they have the <code>// +optional</code> comment, and they have the <code>omitempty</code> JSON tag.</li><li>Make sure that the existing field numbers in the protobuf tags are not changed.</li></ol></li><li>If necessary then implement/adapt the conversion logic defined in the versioned APIs (e.g., <code>pkg/apis/core/v1beta1/conversions*.go</code>).</li><li>If necessary then implement/adapt defaulting logic defined in the versioned APIs (e.g., <code>pkg/apis/core/v1beta1/defaults*.go</code>).</li><li>Run the code generation: <code>make generate</code></li><li>If necessary then implement/adapt validation logic defined in the internal API (e.g., <code>pkg/apis/core/validation/validation*.go</code>).</li><li>If necessary then adapt the exemplary YAML manifests of the Gardener resources defined in <code>example/*.yaml</code>.</li><li>In most cases it makes sense to add/adapt the documentation for administrators/operators and/or end-users in the <code>docs</code> folder to provide information on purpose and usage of the added/changed fields.</li><li>When opening the pull request then always add a release note so that end-users are becoming aware of the changes.</li></ol><h2 id=component-configuration-apis>Component configuration APIs</h2><p>Most Gardener components have a component configuration that follows similar principles to the Gardener API.
Those component configurations are defined in <code>pkg/{controllermanager,gardenlet,scheduler},pkg/apis/config</code>.
Hence, the above checklist also applies for changes to those APIs.
However, since these APIs are only used internally and only during the deployment of Gardener the guidelines with respect to changes and backwards-compatibility are slightly relaxed.
If necessary then it is allowed to remove fields without a proper deprecation period if the release note uses the <code>breaking operator</code> keywords.</p><p>In addition to the above checklist:</p><ol><li>If necessary then adapt the Helm chart of Gardener defined in <code>charts/gardener</code>. Adapt the <code>values.yaml</code> file as well as the manifest templates.</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-58950a0fdac8b00f91fdd5b644642c8f>4.2 - Dependencies</h1><h1 id=dependency-management>Dependency Management</h1><p>We are using <a href=https://github.com/golang/go/wiki/Modules>go modules</a> for depedency management.
In order to add a new package dependency to the project, you can perform <code>go get &lt;PACKAGE>@&lt;VERSION></code> or edit the <code>go.mod</code> file and append the package along with the version you want to use.</p><h2 id=updating-dependencies>Updating Dependencies</h2><p>The <code>Makefile</code> contains a rule called <code>revendor</code> which performs <code>go mod tidy</code> and <code>go mod vendor</code>.
<code>go mod tidy</code> makes sure go.mod matches the source code in the module. It adds any missing modules necessary to build the current module&rsquo;s packages and dependencies, and it removes unused modules that don&rsquo;t provide any relevant packages.
<code>go mod vendor</code> resets the main module&rsquo;s vendor directory to include all packages needed to build and test all the main module&rsquo;s packages. It does not include test code for vendored packages.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make revendor
</code></pre></div><p>The dependencies are installed into the <code>vendor</code> folder which <strong>should be added</strong> to the VCS.</p><p>⚠️ Make sure that you test the code after you have updated the dependencies!</p><h2 id=exported-packages>Exported Packages</h2><p>This repository contains several packages that could be considered &ldquo;exported packages&rdquo;, in a sense that they are supposed to be reused in other Go projects.
For example:</p><ul><li>Gardener&rsquo;s API packages: <code>pkg/apis</code></li><li>Library for building Gardener extensions: <code>extensions</code></li><li>Gardener&rsquo;s Test Framework: <code>test/framework</code></li></ul><p>There are a few more folders in this repository (non-Go sources) that are reused across projects in the gardener organization:</p><ul><li>GitHub templates: <code>.github</code></li><li>Concourse / cc-utils related helpers: <code>hack/.ci</code></li><li>Development, build and testing helpers: <code>hack</code></li></ul><p>These packages feature a dummy <code>doc.go</code> file to allow other Go projects to pull them in as go mod dependencies.</p><p>These packages are explicitly <em>not</em> supposed to be used in other projects (consider them as &ldquo;non-exported&rdquo;):</p><ul><li>API validation packages: <code>pkg/apis/*/*/validation</code></li><li>Operation package (main Gardener business logic regarding <code>Seed</code> and <code>Shoot</code> clusters): <code>pkg/operation</code></li><li>Third party code: <code>third_party</code></li></ul><p>Currently, we don&rsquo;t have a mechanism yet for selectively syncing out these exported packages into dedicated repositories like kube&rsquo;s <a href=https://github.com/kubernetes/kubernetes/tree/master/staging>staging mechanism</a> (<a href=https://github.com/kubernetes/publishing-bot>publishing-bot</a>).</p><h2 id=import-restrictions>Import Restrictions</h2><p>We want to make sure, that other projects can depend on this repository&rsquo;s &ldquo;exported&rdquo; packages without pulling in the entire repository (including &ldquo;non-exported&rdquo; packages) or a high number of other unwanted dependencies.
Hence, we have to be careful when adding new imports or references between our packages.</p><blockquote><p>ℹ️ General rule of thumb: the mentioned &ldquo;exported&rdquo; packages should be as self-contained as possible and depend on as few other packages in the repository and other projects as possible.</p></blockquote><p>In order to support that rule and automatically check compliance with that goal, we leverage <a href=https://github.com/kubernetes/code-generator/tree/master/cmd/import-boss>import-boss</a>.
The tool checks all imports of the given packages (including transitive imports) against rules defined in <code>.import-restrictions</code> files in each directory.
An import is allowed if it matches at least one allowed prefix and does not match any forbidden prefixes.
Note: <code>''</code> (the empty string) is a prefix of everything.
For more details, see: <a href=https://github.com/kubernetes/code-generator/tree/master/cmd/import-boss>https://github.com/kubernetes/code-generator/tree/master/cmd/import-boss</a></p><p><code>import-boss</code> is executed on every pull request and blocks the PR if it doesn&rsquo;t comply with the defined import restrictions.
You can also run it locally using <code>make check</code>.</p><p>Import restrictions should be changed in the following situations:</p><ul><li>We spot a new pattern of imports across our packages that was not restricted before but makes it more difficult for other projects to depend on our &ldquo;exported&rdquo; packages.
In that case, the imports should be further restricted to disallow such problematic imports, and the code/package structure should be reworked to comply with the newly given restrictions.</li><li>We want to share code between packages, but existing import restrictions prevent us from doing so.
In that case, please consider what additional dependencies it will pull in, when loosening existing restrictions.
Also consider possible alternatives, like code restructurings or extracting shared code into dedicated packages for minimal impact on dependent projects.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-94e3f754736ad20216bc6c1d11abac6f>4.3 - Getting Started Locally</h1><h1 id=running-gardener-locally>Running Gardener locally</h1><p>This document will walk you through running Gardener on your local machine for development purposes.
If you encounter difficulties, please open an issue so that we can make this process easier.</p><p>Gardener runs in any Kubernetes cluster.
In this guide, we will start a <a href=https://kind.sigs.k8s.io/>KinD</a> cluster which is used as both garden and seed cluster (please refer to the <a href=/docs/gardener/concepts/architecture/>architecture overview</a>) for simplicity.</p><p>The Gardener components, however, will be run as regular processes on your machine (hence, no container images are being built).</p><p><img src=/__resources/getting_started_locally_39a5b3.png alt="Architecture Diagram"></p><h2 id=prerequisites>Prerequisites</h2><ul><li><p>Make sure your Docker daemon is up-to-date, up and running and has enough resources (at least <code>4</code> CPUs and <code>4Gi</code> memory; see <a href=https://docs.docker.com/desktop/mac/#resources>here</a> how to configure the resources for Docker for Mac).</p><blockquote><p>Please note that 4 CPU / 4Gi memory might not be enough for more than one <code>Shoot</code> cluster, i.e., you might need to increase these values if you want to run additional <code>Shoot</code>s.</p></blockquote><p>Additionally, please configure at least <code>120Gi</code> of disk size for the Docker daemon.</p><blockquote><p>Tip: With <code>docker system df</code> and <code>docker system prune -a</code> you can cleanup unused data.</p></blockquote></li><li><p>Make sure that you increase the maximum number of open files on your host:</p><ul><li><p>On Mac, run <code>sudo launchctl limit maxfiles 65536 200000</code></p></li><li><p>On Linux, extend the <code>/etc/security/limits.conf</code> file with</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>* hard nofile 97816
* soft nofile 97816
</code></pre></div><p>and reload the terminal.</p></li></ul></li></ul><h2 id=setting-up-the-kind-cluster-garden-and-seed>Setting up the KinD cluster (garden and seed)</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up KIND_ENV=local
</code></pre></div><p>This command sets up a new KinD cluster named <code>gardener-local</code> and stores the kubeconfig in the <code>./example/gardener-local/kind/kubeconfig</code> file.</p><blockquote><p>It might be helpful to copy this file to <code>$HOME/.kube/config</code> since you will need to target this KinD cluster multiple times.
Alternatively, make sure to set your <code>KUBECONFIG</code> environment variable to <code>./example/gardener-local/kind/kubeconfig</code> for all future steps via <code>export KUBECONFIG=example/gardener-local/kind/kubeconfig</code>.</p></blockquote><p>All following steps assume that your are using this kubeconfig.</p><h2 id=setting-up-gardener>Setting up Gardener</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make dev-setup                                                                <span style=color:green># preparing the environment (without webhooks for now)</span>
kubectl wait --for=condition=ready pod -l run=etcd -n garden --timeout 2m     <span style=color:green># wait for etcd to be ready</span>
make start-apiserver                                                          <span style=color:green># starting gardener-apiserver</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=available apiservice v1beta1.core.gardener.cloud <span style=color:green># wait for gardener-apiserver to be ready</span>
make start-admission-controller                                               <span style=color:green># starting gardener-admission-controller</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make dev-setup DEV_SETUP_WITH_WEBHOOKS=true                                   <span style=color:green># preparing the environment with webhooks</span>
make start-controller-manager                                                 <span style=color:green># starting gardener-controller-manager</span>
</code></pre></div><p>(Optional): In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-scheduler                                                          <span style=color:green># starting gardener-scheduler</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make register-local-env                                                       <span style=color:green># registering the local environment (CloudProfile, Seed, etc.)</span>
make start-gardenlet SEED_NAME=local                                          <span style=color:green># starting gardenlet</span>
</code></pre></div><p>In a new terminal pane, run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-extension-provider-local                                           <span style=color:green># starting gardener-extension-provider-local</span>
</code></pre></div><p>ℹ️ The <a href=/docs/gardener/extensions/provider-local/><code>provider-local</code></a> is started with elevated privileges since it needs to manipulate your <code>/etc/hosts</code> file to enable you accessing the created shoot clusters from your local machine, see <a href=/docs/gardener/extensions/provider-local/#dnsrecord>this</a> for more details.</p><h2 id=creating-a-shoot-cluster>Creating a <code>Shoot</code> cluster</h2><p>You can wait for the <code>Seed</code> to be ready by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=gardenletready --for=condition=extensionsready --for=condition=bootstrapped seed local --timeout=5m
</code></pre></div><p>Alternatively, you can run <code>kubectl get seed local</code> and wait for the <code>STATUS</code> to indicate readiness:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME    STATUS   PROVIDER   REGION   AGE     VERSION       K8S VERSION
local   Ready    local      local    4m42s   vX.Y.Z-dev    v1.21.1
</code></pre></div><p>In order to create a first shoot cluster, just run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f example/provider-local/shoot.yaml
</code></pre></div><p>You can wait for the <code>Shoot</code> to be ready by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl wait --for=condition=apiserveravailable --for=condition=controlplanehealthy --for=condition=everynodeready --for=condition=systemcomponentshealthy shoot local -n garden-local --timeout=10m
</code></pre></div><p>Alternatively, you can run <code>kubectl -n garden-local get shoot local</code> and wait for the <code>LAST OPERATION</code> to reach <code>100%</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>NAME    CLOUDPROFILE   PROVIDER   REGION   K8S VERSION   HIBERNATION   LAST OPERATION            STATUS    AGE
local   local          local      local    1.21.0        Awake         Create Processing (43%)   healthy   94s
</code></pre></div><p>(Optional): You could also execute a simple e2e test (creating and deleting a shoot) by running</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make test-e2e-local-fast KUBECONFIG=<span style=color:#a31515>&#34;</span>$PWD<span style=color:#a31515>/example/gardener-local/kind/kubeconfig&#34;</span>
</code></pre></div><p>When the shoot got successfully created you can access it as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-local get secret local.kubeconfig -o jsonpath={.data.kubeconfig} | base64 -d &gt; /tmp/kubeconfig-shoot-local.yaml
kubectl --kubeconfig=/tmp/kubeconfig-shoot-local.yaml get nodes
</code></pre></div><h2 id=deleting-the-shoot-cluster>Deleting the <code>Shoot</code> cluster</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>./hack/usage/delete shoot local garden-local
</code></pre></div><h2 id=tear-down-the-gardener-environment>Tear down the Gardener environment</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make tear-down-local-env
make kind-down
</code></pre></div><h2 id=further-reading>Further reading</h2><p>This setup makes use of the local provider extension. You can read more about it in <a href=/docs/gardener/extensions/provider-local/>this document</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c95b2a377d941a326c0914b796d1f8d3>4.4 - Kubernetes Clients</h1><h1 id=kubernetes-clients-in-gardener>Kubernetes Clients in Gardener</h1><p>This document aims at providing a general developer guideline on different aspects of using Kubernetes clients in a large-scale distributed system and project like Gardener.
The points included here are not meant to be consulted as absolute rules, but rather as general rules of thumb, that allow developers to get a better feeling about certain gotchas and caveats.
It should be updated with lessons learned from maintaining the project and running Gardener in production.</p><p><strong>Prerequisites</strong>:</p><p>Please familiarize yourself with the following basic Kubernetes API concepts first, if you&rsquo;re new to Kubernetes. A good understanding of these basics will help you better comprehend the following document.</p><ul><li><a href=https://kubernetes.io/docs/reference/using-api/api-concepts/>Kubernetes API Concepts</a> (including terminology, watch basics, etc.)</li><li><a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/>Extending the Kubernetes API</a> (including Custom Resources and aggregation layer / extension API servers)</li><li><a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Extend the Kubernetes API with CustomResourceDefinitions</a></li><li><a href=https://kubernetes.io/docs/concepts/overview/working-with-objects/>Working with Kubernetes Objects</a></li><li><a href=https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md>Sample Controller</a> (the diagram helps to build an understanding of an controller&rsquo;s basic structure)</li></ul><h2 id=client-types-client-go-generated-controller-runtime>Client Types: Client-Go, Generated, Controller-Runtime</h2><p>For historical reasons, you will find different kinds of Kubernetes clients in Gardener:</p><h3 id=client-go-clients>Client-Go Clients</h3><p><a href=https://github.com/kubernetes/client-go>client-go</a> is the default/official client for talking to the Kubernetes API in Golang.
It features so called <a href=https://github.com/kubernetes/client-go/blob/release-1.21/kubernetes/clientset.go#L72>&ldquo;client sets&rdquo;</a> for all built-in Kubernetes API groups and versions (e.g. <code>v1</code> (aka <code>core/v1</code>), <code>apps/v1</code>, etc.).
client-go clients are generated from the built-in API types using <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/generating-clientset.md>client-gen</a> and are composed of interfaces for every known API GroupVersionKind.
A typical client-go usage looks like this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx        context.Context
  c          kubernetes.Interface <span style=color:green>// &#34;k8s.io/client-go/kubernetes&#34;
</span><span style=color:green></span>  deployment *appsv1.Deployment   <span style=color:green>// &#34;k8s.io/api/apps/v1&#34;
</span><span style=color:green></span>)

updatedDeployment, err := c.AppsV1().Deployments(<span style=color:#a31515>&#34;default&#34;</span>).Update(ctx, deployment, metav1.UpdateOptions{})
</code></pre></div><p><em>Important characteristics of client-go clients:</em></p><ul><li>clients are specific to a given API GroupVersionKind, i.e., clients are hard-coded to corresponding API-paths (don&rsquo;t need to use the discovery API to map GVK to a REST endpoint path).</li><li>client&rsquo;s don&rsquo;t modify the passed in-memory object (e.g. <code>deployment</code> in the above example). Instead, they return a new in-memory object.<br>This means, controllers have to continue working with the new in-memory object or overwrite the shared object to not lose any state updates.</li></ul><h3 id=generated-client-sets-for-gardener-apis>Generated Client Sets for Gardener APIs</h3><p>Gardener&rsquo;s APIs extend the Kubernetes API by registering an extension API server (in the garden cluster) and <code>CustomResourceDefinition</code>s (on Seed clusters), meaning that the Kubernetes API will expose additional REST endpoints to manage Gardener resources in addition to the built-in API resources.
In order to talk to these extended APIs in our controllers and components, client-gen is used to generate client-go-style clients to <a href=https://github.com/gardener/gardener/tree/master/pkg/client><code>pkg/client/{core,extensions,seedmanagement,...}</code></a>.</p><p>Usage of these clients is equivalent to <code>client-go</code> clients, and the same characteristics apply. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx   context.Context
  c     gardencoreclientset.Interface <span style=color:green>// &#34;github.com/gardener/gardener/pkg/client/core/clientset/versioned&#34;
</span><span style=color:green></span>  shoot *gardencorev1beta1.Shoot      <span style=color:green>// &#34;github.com/gardener/gardener/pkg/apis/core/v1beta1&#34;
</span><span style=color:green></span>)

updatedShoot, err := c.CoreV1beta1().Shoots(<span style=color:#a31515>&#34;garden-my-project&#34;</span>).Update(ctx, shoot, metav1.UpdateOptions{})
</code></pre></div><h3 id=controller-runtime-clients>Controller-Runtime Clients</h3><p><a href=https://github.com/kubernetes-sigs/controller-runtime>controller-runtime</a> is a Kubernetes community project (<a href=https://github.com/kubernetes-sigs/kubebuilder>kubebuilder</a> subproject) for building controllers and operators for custom resources.
Therefore, it features a generic client, that follows a different approach and does not rely on generated client sets. Instead, the client can be used for managing any Kubernetes resources (built-in or custom) homogeneously.
For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx        context.Context
  c          client.Client            <span style=color:green>// &#34;sigs.k8s.io/controller-runtime/pkg/client&#34;
</span><span style=color:green></span>  deployment *appsv1.Deployment       <span style=color:green>// &#34;k8s.io/api/apps/v1&#34;
</span><span style=color:green></span>  shoot      *gardencorev1beta1.Shoot <span style=color:green>// &#34;github.com/gardener/gardener/pkg/apis/core/v1beta1&#34;
</span><span style=color:green></span>)

err := c.Update(ctx, deployment)
<span style=color:green>// or
</span><span style=color:green></span>err = c.Update(ctx, shoot)
</code></pre></div><p>A brief introduction to controller-runtime and its basic constructs can be found <a href=https://pkg.go.dev/sigs.k8s.io/controller-runtime>here</a>.</p><p><em>Important characteristics of controller-runtime clients:</em></p><ul><li>The client functions take a generic <code>client.Object</code> or <code>client.ObjectList</code> value. These interfaces are implemented by all Golang types, that represent Kubernetes API objects or lists respectively which can be interacted with via usual API requests. [1]</li><li>The client first consults a <code>runtime.Scheme</code> (configured during client creation) for recognizing the object&rsquo;s <code>GroupVersionKind</code> (this happens on the client-side only).<br>A <code>runtime.Scheme</code> is basically a registry for Golang API types, defaulting and conversion functions. Schemes are usually provided per <code>GroupVersion</code> (see <a href=https://github.com/kubernetes/api/blob/release-1.21/apps/v1/register.go>this example</a> for <code>apps/v1</code>) and can be combined to one single scheme for further usage (<a href=https://github.com/gardener/gardener/blob/v1.29.0/pkg/client/kubernetes/types.go#L96>example</a>). In controller-runtime clients, schemes are used only for mapping a typed API object to its <code>GroupVersionKind</code>.</li><li>It then consults a <code>meta.RESTMapper</code> (also configured during client creation) for mapping the <code>GroupVersionKind</code> to a <code>RESTMapping</code>, which contains the <code>GroupVersionResource</code> and <code>Scope</code> (namespaced or cluster-scoped). From these values, the client can unambiguously determine the REST endpoint path of the corresponding API resource. For instance: <code>appsv1.DeploymentList</code> is available at <code>/apis/apps/v1/deployments</code> or <code>/apis/apps/v1/namespaces/&lt;namespace>/deployments</code> respectively.<ul><li>There are different <code>RESTMapper</code> implementations, but generally they are talking to the API server&rsquo;s discovery API for retrieving <code>RESTMappings</code> for all API resources known to the API server (either built-in, registered via API extension or <code>CustomResourceDefinition</code>s).</li><li>The default implementation of controller-runtime (which Gardener uses as well), is the <a href=https://github.com/kubernetes-sigs/controller-runtime/blob/v0.9.0/pkg/client/apiutil/dynamicrestmapper.go#L77>dynamic <code>RESTMapper</code></a>. It caches discovery results (i.e. <code>RESTMappings</code>) in-memory and only re-discovers resources from the API server, when a client tries to use an unknown <code>GroupVersionKind</code>, i.e., when it encounters a <code>No{Kind,Resource}MatchError</code>.</li></ul></li><li>The client writes back results from the API server into the passed in-memory object.<ul><li>This means, that controllers don&rsquo;t have to worry about copying back the results and should just continue to work on the given in-memory object.</li><li>This is a nice and flexible pattern and helper functions should try to follow it wherever applicable. Meaning, if possible accept an object param, pass it down to clients and keep working on the same in-memory object instead of creating a new one in your helper function.</li><li>The benefit is, that you don&rsquo;t lose updates to the API object and always have the last-known state in memory. Therefore, you don&rsquo;t have to read it again, e.g., for getting the current <code>resourceVersion</code> when working with <a href=#conflicts-concurrency-control-and-optimistic-locking>optimistic locking</a>, and thus minimize the chances for running into conflicts.</li><li>However, controllers <em>must not</em> use the same in-memory object concurrently in multiple goroutines. For example, decoding results from the API server in multiple goroutines into the same maps (e.g., labels, annotations) will cause panics because of &ldquo;concurrent map writes&rdquo;. Also, reading from an in-memory API object in one goroutine while decoding into it in another goroutine will yield non-atomic reads, meaning data might be corrupt and represent a non-valid/non-existing API object.</li><li>Therefore, if you need to use the same in-memory object in multiple goroutines concurrently (e.g., shared state), remember to leverage proper synchronization techniques like channels, mutexes, <code>atomic.Value</code> and/or copy the object prior to use. The average controller however, will not need to share in-memory API objects between goroutines, and it&rsquo;s typically an indicator that the controller&rsquo;s design should be improved.</li></ul></li><li>The client decoder erases the object&rsquo;s <code>TypeMeta</code> (<code>apiVersion</code> and <code>kind</code> fields) after retrieval from the API server, see <a href=https://github.com/kubernetes/kubernetes/issues/80609>kubernetes/kubernetes#80609</a>, <a href=https://github.com/kubernetes-sigs/controller-runtime/issues/1517>kubernetes-sigs/controller-runtime#1517</a>.
Unstructured and metadata-only requests objects are an exception to this because the contained <code>TypeMeta</code> is the only way to identify the object&rsquo;s type.
Because of this behavior, <code>obj.GetObjectKind().GroupVersionKind()</code> is likely to return an empty <code>GroupVersionKind</code>.
I.e., you must not rely on <code>TypeMeta</code> being set or <code>GetObjectKind()</code> to return something usable.<br>If you need to identify an object&rsquo;s <code>GroupVersionKind</code>, use a scheme and its <code>ObjectKinds</code> function instead (or the helper function <code>apiutil.GVKForObject</code>).
This is not specific to controller-runtime clients and applies to client-go clients as well.</li></ul><p>[1] Other lower level, config or internal API types (e.g., such as <a href=https://github.com/kubernetes/api/blob/release-1.21/admission/v1/types.go#L29><code>AdmissionReview</code></a>) don&rsquo;t implement <code>client.Object</code>. However, you also can&rsquo;t interact with such objects via the Kubernetes API and thus also not via a client, so this can be disregarded at this point.</p><h3 id=metadata-only-clients>Metadata-Only Clients</h3><p>Additionally, controller-runtime clients can be used to easily retrieve metadata-only objects or lists.
This is useful for efficiently checking if at least one object of a given kind exists, or retrieving metadata of an object, if one is not interested in the rest (e.g., spec/status).<br>The <code>Accept</code> header sent to the API server then contains <code>application/json;as=PartialObjectMetadataList;g=meta.k8s.io;v=v1</code>, which makes the API server only return metadata of the retrieved object(s).
This saves network traffic and cpu/memory load on the API server and client side.
If the client fully lists all objects of a given kind including their spec/status, the resulting list can be quite large and easily exceed the controllers available memory.
That&rsquo;s why it&rsquo;s important to carefully check, if a full list is actually needed or if metadata-only list can be used instead.</p><p>For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx       context.Context
  c         client.Client                         <span style=color:green>// &#34;sigs.k8s.io/controller-runtime/pkg/client&#34;
</span><span style=color:green></span>  shootList = &amp;metav1.PartialObjectMetadataList{} <span style=color:green>// &#34;k8s.io/apimachinery/pkg/apis/meta/v1&#34;
</span><span style=color:green></span>)
shootList.SetGroupVersionKind(gardencorev1beta1.SchemeGroupVersion.WithKind(<span style=color:#a31515>&#34;ShootList&#34;</span>))

<span style=color:#00f>if</span> err := c.List(ctx, shootList, client.InNamespace(<span style=color:#a31515>&#34;garden-my-project&#34;</span>), client.Limit(1)); err != <span style=color:#00f>nil</span> {
  <span style=color:#00f>return</span> err
}

<span style=color:#00f>if</span> len(shootList.Items) &gt; 0 {
  <span style=color:green>// project has at least one shoot
</span><span style=color:green></span>} <span style=color:#00f>else</span> {
  <span style=color:green>// project doesn&#39;t have any shoots
</span><span style=color:green></span>}
</code></pre></div><h3 id=gardeners-client-collection-clientmaps>Gardener&rsquo;s Client Collection, ClientMaps</h3><p>The Gardener codebase has a collection of clients (<a href=https://github.com/gardener/gardener/blob/v1.29.0/pkg/client/kubernetes/types.go#L149><code>kubernetes.Interface</code></a>), which can return all the above mentioned client types.
Additionally, it contains helpers for rendering and applying helm charts (<code>ChartRender</code>, <code>ChartApplier</code>) and retrieving the API server&rsquo;s version (<code>Version</code>).<br>Client sets are managed by so called <code>ClientMap</code>s, which are a form of registry for all client set for a given type of cluster, i.e., Garden, Seed, Shoot and Plant.
ClientMaps manage the whole lifecycle of clients: they take care of creating them if they don&rsquo;t exist already, running their caches, refreshing their cached server version and invalidating them when they are no longer needed.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx   context.Context
  cm    clientmap.ClientMap <span style=color:green>// &#34;github.com/gardener/gardener/pkg/client/kubernetes/clientmap&#34;
</span><span style=color:green></span>  shoot *gardencorev1beta1.Shoot
)

cs, err := cm.GetClient(ctx, keys.ForShoot(shoot)) <span style=color:green>// kubernetes.Interface
</span><span style=color:green></span><span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
  <span style=color:#00f>return</span> err
}

c := cs.Client() <span style=color:green>// client.Client
</span></code></pre></div><p>The client collection mainly exist for historical reasons (there used to be a lot of code using the client-go style clients).
However, Gardener is in the process of moving more towards controller-runtime and only using their clients, as they provide many benefits and are much easier to use.
Also, <a href=https://github.com/gardener/gardener/issues/4251>gardener/gardener#4251</a> aims at refactoring our controller and admission components to native controller-runtime components.</p><blockquote><p>⚠️ Please always prefer controller-runtime clients over other clients when writing new code or refactoring existing code.</p></blockquote><h2 id=cache-types-informers-listers-controller-runtime-caches>Cache Types: Informers, Listers, Controller-Runtime Caches</h2><p>Similar to the different types of client(set)s, there are also different kinds of Kubernetes client caches.
However, all of them are based on the same concept: <code>Informer</code>s.
An <code>Informer</code> is a watch-based cache implementation, meaning it opens <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#efficient-detection-of-changes>watch connections</a> to the API server and continuously updates cached objects based on the received watch events (<code>ADDED</code>, <code>MODIFIED</code>, <code>DELETED</code>).
<code>Informer</code>s offer to add indices to the cache for efficient object lookup (e.g., by name or labels) and to add <code>EventHandler</code>s for the watch events.
The latter is used by controllers to fill queues with objects that should be reconciled on watch events.</p><p>Informers are used in and created via several higher-level constructs:</p><h3 id=sharedinformerfactories-listers>SharedInformerFactories, Listers</h3><p>The generated clients (built-in as well as extended) feature a <code>SharedInformerFactory</code> for every API group, which can be used to create and retrieve <code>Informers</code> for all GroupVersionKinds.
Similarly, it can be used to retrieve <code>Listers</code>, that allow getting and listing objects from the <code>Informer</code>&rsquo;s cache.
However, both of these constructs are only used for historical reasons, and we are in the process of migrating away from them in favor of cached controller-runtime clients (see <a href=https://github.com/gardener/gardener/issues/2414>gardener/gardener#2414</a>, <a href=https://github.com/gardener/gardener/issues/2822>gardener/gardener#2822</a>). Thus, they are described only briefly here.</p><p><em>Important characteristics of Listers:</em></p><ul><li>Objects read from Informers and Listers can always be slightly out-out-date (i.e., stale) because the client has to first observe changes to API objects via watch events (which can intermittently lag behind by a second or even more).</li><li>Thus, don&rsquo;t make any decisions based on data read from Listers if the consequences of deciding wrongfully based on stale state might be catastrophic (e.g. leaking infrastructure resources). In such cases, read directly from the API server via a client instead.</li><li>Objects retrieved from Informers or Listers are pointers to the cached objects, so they must not be modified without copying them first, otherwise the objects in the cache are also modified.</li></ul><h3 id=controller-runtime-caches>Controller-Runtime Caches</h3><p>controller-runtime features a cache implementation that can be used equivalently as their clients. In fact, it implements a subset of the <code>client.Client</code> interface containing the <code>Get</code> and <code>List</code> functions.
Under the hood, a <code>cache.Cache</code> dynamically creates <code>Informers</code> (i.e., opens watches) for every object GroupVersionKind that is being retrieved from it.</p><p>Note, that the underlying Informers of a controller-runtime cache (<code>cache.Cache</code>) and the ones of a <code>SharedInformerFactory</code> (client-go) are not related in any way.
Both create <code>Informers</code> and watch objects on the API server individually.
This means, that if you read the same object from different cache implementations, you may receive different versions of the object because the watch connections of the individual Informers are not synced.</p><blockquote><p>⚠️ Because of this, controllers/reconcilers should get the object from the same cache in the reconcile loop, where the <code>EventHandler</code> was also added to set up the controller. For example, if a <code>SharedInformerFactory</code> is used for setting up the controller then read the object in the reconciler from the <code>Lister</code> instead of from a cached controller-runtime client.</p></blockquote><p>By default, the <code>client.Client</code> created by a controller-runtime <code>Manager</code> is a <code>DelegatingClient</code>. It delegates <code>Get</code> and <code>List</code> calls to a <code>Cache</code> and all other calls to a client, that talks directly to the API server. Exceptions are requests with <code>*unstructured.Unstructured</code> objects and object kinds that were configured to be excluded from the cache in the <code>DelegatingClient</code>.</p><blockquote><p>ℹ️
If the <code>CachedRuntimeClients</code> feature gate is enabled (enabled by default starting from <code>v1.34</code>), <code>kubernetes.Interface.Client()</code> returns a <code>DelegatingClient</code> that uses the cache returned from <code>kubernetes.Interface.Cache()</code> under the hood. This means, all <code>Client()</code> usages need to be ready for cached clients and should be able to cater with stale cache reads.
See <a href=https://github.com/gardener/gardener/issues/2822>gardener/gardener#2822</a> for details on the graduation progress to beta.</p><p>If the feature gate is explicitly disabled, the controller-runtime client (<code>kubernetes.Interface.Client()</code>) is not cached and does not use the cache contained in the client set (<code>kubernetes.Interface.Cache()</code>). This means, the client always reads directly from the API server, but you can intentionally read from the cache if desired.</p></blockquote><p><em>Important characteristics of cached controller-runtime clients:</em></p><ul><li>Like for Listers, objects read from a controller-runtime cache can always be slightly out of date. Hence, don&rsquo;t base any important decisions on data read from the cache (see above).</li><li>In contrast to Listers, controller-runtime caches fill the passed in-memory object with the state of the object in the cache (i.e., they perform something like a &ldquo;deep copy into&rdquo;). This means that objects read from a controller-runtime cache can safely be modified without unintended side effects.</li><li>Reading from a controller-runtime cache or a cached controller-runtime client implicitly starts a watch for the given object kind under the hood. This has important consequences:<ul><li>Reading a given object kind from the cache for the first time can take up to a few seconds depending on size and amount of objects as well as API server latency. This is because the cache has to do a full list operation and wait for an initial watch sync before returning results.</li><li>⚠️ Controllers need appropriate RBAC permissions for the object kinds they retrieve via cached clients (i.e., <code>list</code> and <code>watch</code>).</li><li>⚠️ By default, watches started by a controller-runtime cache are cluster-scoped, meaning it watches and caches objects across all namespaces. Thus, be careful which objects to read from the cache as it might significantly increase the controller&rsquo;s memory footprint.</li></ul></li><li>There is no interaction with the cache on writing calls (<code>Create</code>, <code>Update</code>, <code>Patch</code> and <code>Delete</code>), see below.</li></ul><p><strong>Uncached objects, filtered caches, <code>APIReader</code>s:</strong></p><p>In order to allow more granular control over which object kinds should be cached and which calls should bypass the cache, controller-runtime offers a few mechanisms to further tweak the client/cache behavior:</p><ul><li>When creating a <code>DelegatingClient</code>, certain object kinds can be configured to always be read directly from the API instead of from the cache. Note that this does not prevent starting a new Informer when retrieving them directly from the cache.</li><li>Watches can be restricted to a given (set of) namespace(s) by using <code>cache.MultiNamespacedCacheBuilder</code> or setting <code>cache.Options.Namespace</code>.</li><li>Watches can be filtered (e.g., by label) per object kind by configuring <code>cache.Options.SelectorsByObject</code> on creation of the cache.</li><li>Retrieving metadata-only objects or lists from a cache results in a metadata-only watch/cache for that object kind.</li><li>The <code>APIReader</code> can be used to always talk directly to the API server for a given <code>Get</code> or <code>List</code> call (use with care and only as a last resort!).</li></ul><h3 id=to-cache-or-not-to-cache>To Cache or Not to Cache</h3><p>Although watch-based caches are an important factor for the immense scalability of Kubernetes, it definitely comes at a price (mainly in terms of memory consumption).
Thus, developers need to be careful when introducing new API calls and caching new object kinds.
Here are some general guidelines on choosing whether to read from a cache or not:</p><ul><li>Always try to use the cache wherever possible and make your controller able to tolerate stale reads.<ul><li>Leverage optimistic locking: use deterministic naming for objects you create (this is what the <code>Deployment</code> controller does [2]).</li><li>Leverage optimistic locking / concurrency control of the API server: send updates/patches with the last-known <code>resourceVersion</code> from the cache (see below). This will make the request fail, if there were concurrent updates to the object (conflict error), which indicates that we have operated on stale data and might have made wrong decisions. In this case, let the controller handle the error with exponential backoff. This will make the controller eventually consistent.</li><li>Track the actions you took, e.g., when creating objects with <code>generateName</code> (this is what the <code>ReplicaSet</code> controller does [3]). The actions can be tracked in memory and repeated if the expected watch events don&rsquo;t occur after a given amount of time.</li><li>Always try to write controllers with the assumption that data will only be eventually correct and can be slightly out of date (even if read directly from the API server!).</li><li>If there is already some other code that needs a cache (e.g., a controller watch), reuse it instead of doing extra direct reads.</li><li>Don&rsquo;t read an object again if you just sent a write request. Write requests (<code>Create</code>, <code>Update</code>, <code>Patch</code> and <code>Delete</code>) don&rsquo;t interact with the cache. Hence, use the current state that the API server returned (filled into the passed in-memory object), which is basically a &ldquo;free direct read&rdquo;, instead of reading the object again from a cache, because this will probably set back the object to an older <code>resourceVersion</code>.</li></ul></li><li>If you are concerned about the impact of the resulting cache, try to minimize that by using filtered or metadata-only watches.</li><li>If watching and caching an object type is not feasible, for example because there will be a lot of updates, and you are only interested in the object every ~5m, or because it will blow up the controllers memory footprint, fallback to a direct read. This can either be done by disabling caching the object type generally or doing a single request via an <code>APIReader</code>. In any case, please bear in mind that every direct API call results in a <a href=https://kubernetes.io/docs/reference/using-api/api-concepts/#the-resourceversion-parameter>quorum read from etcd</a>, which can be costly in a heavily-utilized cluster and impose significant scalability limits. Thus, always try to minimize the impact of direct calls by filtering results by namespace or labels, limiting the number of results and/or using metadata-only calls.</li></ul><p>[2] The <code>Deployment</code> controller uses the pattern <code>&lt;deployment-name>-&lt;podtemplate-hash></code> for naming <code>ReplicaSets</code>. This means, the name of a <code>ReplicaSet</code> it tries to create/update/delete at any given time is deterministically calculated based on the <code>Deployment</code> object. By this, it is insusceptible to stale reads from its <code>ReplicaSets</code> cache.</p><p>[3] In simple terms, the <code>ReplicaSet</code> controller tracks its <code>CREATE pod</code> actions as follows: when creating new <code>Pods</code>, it increases a counter of expected <code>ADDED</code> watch events for the corresponding <code>ReplicaSet</code>. As soon as such events arrive, it decreases the counter accordingly. It only creates new <code>Pods</code> for a given <code>ReplicaSet</code>, once all expected events occurred (counter is back to zero) or a timeout occurred. This way, it prevents creating more <code>Pods</code> than desired because of stale cache reads and makes the controller eventually consistent.</p><h2 id=conflicts-concurrency-control-and-optimistic-locking>Conflicts, Concurrency Control and Optimistic Locking</h2><p>Every Kubernetes API object contains the <code>metadata.resourceVersion</code> field, which identifies an object&rsquo;s version in the backing data store, i.e., etcd. Every write to an object in etcd results in a newer <code>resourceVersion</code>.
This field is mainly used for concurrency control on the API server in an optimistic locking fashion, but also for efficient resumption of interrupted watch connections.</p><p>Optimistic locking in the Kubernetes API sense means that when a client wants to update an API object then it includes the object&rsquo;s <code>resourceVersion</code> in the request to indicate the object&rsquo;s version the modifications are based on.
If the <code>resourceVersion</code> in etcd has not changed in the meantime, the update request is accepted by the API server and the updated object is written to etcd.
If the <code>resourceVersion</code> sent by the client does not match the one of the object stored in etcd, there were concurrent modifications to the object. Consequently, the request is rejected with a conflict error (status code <code>409</code>, API reason <code>Conflict</code>), for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;kind&#34;: <span style=color:#a31515>&#34;Status&#34;</span>,
  &#34;apiVersion&#34;: <span style=color:#a31515>&#34;v1&#34;</span>,
  &#34;metadata&#34;: {},
  &#34;status&#34;: <span style=color:#a31515>&#34;Failure&#34;</span>,
  &#34;message&#34;: <span style=color:#a31515>&#34;Operation cannot be fulfilled on configmaps \&#34;foo\&#34;: the object has been modified; please apply your changes to the latest version and try again&#34;</span>,
  &#34;reason&#34;: <span style=color:#a31515>&#34;Conflict&#34;</span>,
  &#34;details&#34;: {
    &#34;name&#34;: <span style=color:#a31515>&#34;foo&#34;</span>,
    &#34;kind&#34;: <span style=color:#a31515>&#34;configmaps&#34;</span>
  },
  &#34;code&#34;: 409
}
</code></pre></div><p>This concurrency control is an important mechanism in Kubernetes as there are typically multiple clients acting on API objects at the same time (humans, different controllers, etc.). If a client receives a conflict error, it should read the object&rsquo;s latest version from the API server, make the modifications based on the newest changes and retry the update.
The reasoning behind this is that a client might choose to make different decisions based on the concurrent changes made by other actors compared to the outdated version that it operated on.</p><p><em>Important points about concurrency control and conflicts:</em></p><ul><li>The <code>resourceVersion</code> field carries a string value and clients must not assume numeric values (the type and structure of versions depend on the backing data store). This means clients may compare <code>resourceVersion</code> values to detect whether objects were changed. But they must not compare <code>resourceVersion</code>s to figure out which one is newer/older, i.e., no greater/less-than comparisons are allowed.</li><li>By default, update calls (e.g. via client-go and controller-runtime clients) use optimistic locking as the passed in-memory usually object contains the latest <code>resourceVersion</code> known to the controller which is then also sent to the API server.</li><li>API servers can also choose to accept update calls without optimistic locking (i.e., without a <code>resourceVersion</code> in the object&rsquo;s metadata) for any given resource. However, sending update requests without optimistic locking is strongly discouraged as doing so overwrites the entire object discarding any concurrent changes made to it.</li><li>On the other side, patch requests can always be executed either with or without optimistic locking, by (not) including the <code>resourceVersion</code> in the patched object&rsquo;s metadata. Sending patch requests without optimistic locking might be safe and even desirable as a patch typically updates only a specific section of the object. However, there are also situations where patching without optimistic locking is not safe (see below).</li></ul><h3 id=dont-retry-on-conflict>Don’t Retry on Conflict</h3><p>Similar to how a human would typically handle a conflict error, there are helper functions implementing <code>RetryOnConflict</code>-semantics, i.e., try an update call, then re-read the object if a conflict occurs, apply the modification again and retry the update.
However, controllers should generally <em>not</em> use <code>RetryOnConflict</code>-semantics. Instead, controllers should abort their current reconciliation run and let the queue handle the conflict error with exponential backoff.
The reasoning behind this is, that a conflict error indicates that the controller has operated on stale data and might have made wrong decisions earlier on in the reconciliation.
When using a helper function that implements <code>RetryOnConflict</code>-semantics, the controller doesn&rsquo;t check which fields were changed and doesn&rsquo;t revise its previous decisions accordingly.
Instead, retrying on conflict basically just ignores any conflict error and blindly applies the modification.</p><p>To properly solve the conflict situation, controllers should immediately return with the error from the update call. This will cause retries with exponential backoff so that the cache has a chance to observe the latest changes to the object.
In a later run, the controller will then make correct decisions based on the newest version of the object, not run into conflict errors and will then be able to successfully reconcile the object. This way, the controller becomes eventually consistent.</p><p>The other way to solve the situation is to modify objects without optimistic locking in order to avoid running into a conflict in the first place (only if this is safe).
This can be a preferable solution for controllers with long-running reconciliations (which is actually an anti-pattern but quite unavoidable in some of Gardener&rsquo;s controllers).
Aborting the entire reconciliation run is rather undesirable in such cases as it will add a lot of unnecessary waiting time for end users and overhead in terms of compute and network usage.</p><p>However, in any case retrying on conflict is probably not the right option to solve the situation (there are some correct use cases for it, though, they are very rare). Hence, don&rsquo;t retry on conflict.</p><h3 id=to-lock-or-not-to-lock>To Lock or Not to Lock</h3><p>As explained before, conflicts are actually important and prevent clients from doing wrongful concurrent updates. This means, conflicts are not something we generally want to avoid or ignore.
However, in many cases controllers are exclusive owners of the fields they want to update and thus it might be safe to run without optimistic locking.</p><p>For example, the gardenlet is the exclusive owner of the <code>spec</code> section of the Extension resources it creates on behalf of a Shoot (e.g., the <code>Infrastructure</code> resource for creating VPC, etc.). Meaning, it knows the exact desired state and no other actor is supposed to update the Infrastructure&rsquo;s <code>spec</code> fields.
When the gardenlet now updates the Infrastructures <code>spec</code> section as part of the Shoot reconciliation, it can simply issue a <code>PATCH</code> request that only updates the <code>spec</code> and runs without optimistic locking.
If another controller concurrently updated the object in the meantime (e.g., the <code>status</code> section), the <code>resourceVersion</code> got changed which would cause a conflict error if running with optimistic locking.
However, concurrent <code>status</code> updates would not change the gardenlet&rsquo;s mind on the desired <code>spec</code> of the Infrastructure resource as it is determined only by looking at the Shoot&rsquo;s specification.
If the <code>spec</code> section was changed concurrently, it&rsquo;s still fine to overwrite it because the gardenlet should reconcile the <code>spec</code> back to its desired state.</p><p>Generally speaking, if a controller is the exclusive owner of a given set of fields and they are independent of concurrent changes to other fields in that object, it can patch these fields without optimistic locking.
This might ignore concurrent changes to other fields or blindly overwrite changes to the same fields, but this is fine if the mentioned conditions apply.
Obviously, this applies only to patch requests that modify only a specific set of fields but not to update requests that replace the entire object.</p><p>In such cases, it&rsquo;s even desirable to run without optimistic locking as it will be more performant and save retries.
If certain requests are made with high frequency and have a good chance of causing conflicts, retries because of optimistic locking can cause a lot of additional network traffic in a large-scale Gardener installation.</p><h2 id=updates-patches-server-side-apply>Updates, Patches, Server-side Apply</h2><p>There are different ways of modifying Kubernetes API objects.
The following snippet demonstrates how to do a given modification with the most frequently used options using a controller-runtime client:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  ctx   context.Context
  c     client.Client
  shoot *gardencorev1beta1.Shoot
)

<span style=color:green>// update
</span><span style=color:green></span>shoot.Spec.Kubernetes.Version = <span style=color:#a31515>&#34;1.22&#34;</span>
err := c.Update(ctx, shoot)

<span style=color:green>// json merge patch
</span><span style=color:green></span>patch := client.MergeFrom(shoot.DeepCopy())
shoot.Spec.Kubernetes.Version = <span style=color:#a31515>&#34;1.22&#34;</span>
err = c.Patch(ctx, shoot, patch)

<span style=color:green>// strategic merge patch
</span><span style=color:green></span>patch = client.StrategicMergeFrom(shoot.DeepCopy())
shoot.Spec.Kubernetes.Version = <span style=color:#a31515>&#34;1.22&#34;</span>
err = c.Patch(ctx, shoot, patch)
</code></pre></div><p><em>Important characteristics of the shown request types:</em></p><ul><li>Update requests always send the entire object to the API server and update all fields accordingly. By default, optimistic locking is used (<code>resourceVersion</code> is included).</li><li>Both patch types run without optimistic locking by default. However, it can be enabled explicitly if needed:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:green>// json merge patch + optimistic locking
</span><span style=color:green></span>patch := client.MergeFromWithOptions(shoot.DeepCopy(), client.MergeFromWithOptimisticLock{})
<span style=color:green>// ...
</span><span style=color:green></span>
<span style=color:green>// strategic merge patch + optimistic locking
</span><span style=color:green></span>patch = client.StrategicMergeFrom(shoot.DeepCopy(), client.MergeFromWithOptimisticLock{})
<span style=color:green>// ...
</span></code></pre></div></li><li>Patch requests only contain the changes made to the in-memory object between the copy passed to <code>client.*MergeFrom</code> and the object passed to <code>Client.Patch()</code>. The diff is calculated on the client-side based on the in-memory objects only. This means, if in the meantime some fields were changed on the API server to a different value than the one on the client-side, the fields will not be changed back as long as they are not changed on the client-side as well (there will be no diff in memory).</li><li>Thus, if you want to ensure a given state using patch requests, always read the object first before patching it, as there will be no diff otherwise, meaning the patch will be empty. Also see <a href=https://github.com/gardener/gardener/pull/4057>gardener/gardener#4057</a> and comments in <a href=https://github.com/gardener/gardener/pull/4027>gardener/gardener#4027</a>.</li><li>Also, always send updates and patch requests even if your controller hasn&rsquo;t made any changes to the current state on the API server. I.e., don&rsquo;t make any optimization for preventing empty patches or no-op updates. There might be mutating webhooks in the system that will modify the object and that rely on update/patch requests being sent (even if they are no-op). Gardener&rsquo;s extension concept makes heavy use of mutating webhooks, so it&rsquo;s important to keep this in mind.</li><li>JSON merge patches always replace lists as a whole and don&rsquo;t merge them. Keep this in mind when operating on lists with merge patch requests. If the controller is the exclusive owner of the entire list, it&rsquo;s safe to run without optimistic locking. Though, if you want to prevent overwriting concurrent changes to the list or its items made by other actors (e.g., additions/removals to the <code>metadata.finalizers</code> list), enable optimistic locking.</li><li>Strategic merge patches are able to make more granular modifications to lists and their elements without replacing the entire list. It uses Golang struct tags of the API types to determine which and how lists should be merged. See <a href=https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>this document</a> or the <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md>strategic merge patch documentation</a> for more in-depth explanations and comparison with JSON merge patches.
With this, controllers <em>might</em> be able to issue patch requests for individual list items without optimistic locking, even if they are not exclusive owners of the entire list. Remember to check the <code>patchStrategy</code> and <code>patchMergeKey</code> struct tags of the fields you want to modify before blindly adding patch requests without optimistic locking.</li><li>Strategic merge patches are only supported by built-in Kubernetes resources and custom resources served by Extension API servers. Strategic merge patches are not supported by custom resources defined by <code>CustomResourceDefinition</code>s (see <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#advanced-features-and-flexibility>this comparison</a>). In that case, fallback to JSON merge patches.</li><li><a href=https://kubernetes.io/docs/reference/using-api/server-side-apply/>Server-side Apply</a> is yet another mechanism to modify API objects, which is supported by all API resources (in newer Kubernetes versions). However, it has a few problems and more caveats preventing us from using it in Gardener at the time of writing. See <a href=https://github.com/gardener/gardener/issues/4122>gardener/gardener#4122</a> for more details.</li></ul><blockquote><p>Generally speaking, patches are often the better option compared to update requests because they can save network traffic, encoding/decoding effort and avoid conflicts under the presented conditions.
If choosing a patch type, consider which type is supported by the resource you&rsquo;re modifying and what will happen in case of a conflict. Consider whether your modification is safe to run without optimistic locking.
However, there is no simple rule of thumb on which patch type to choose.</p></blockquote><h2 id=on-helper-functions>On Helper Functions</h2><p>Here is a note on some helper functions, that should be avoided and why:</p><p><code>controllerutil.CreateOrUpdate</code> does a basic get, mutate and create or update call chain, which is often used in controllers. We should avoid using this helper function in Gardener, because it is likely to cause conflicts for cached clients and doesn&rsquo;t send no-op requests if nothing was changed, which can cause problems because of the heavy use of webhooks in Gardener extensions (see above).
That&rsquo;s why usage of this function was completely replaced in <a href=https://github.com/gardener/gardener/pull/4227>gardener/gardener#4227</a> and similar PRs.</p><p><code>controllerutil.CreateOrPatch</code> is similar to <code>CreateOrUpdate</code> but does a patch request instead of an update request. It has the same drawback as <code>CreateOrUpdate</code> regarding no-op updates.
Also, controllers can&rsquo;t use optimistic locking or strategic merge patches when using <code>CreateOrPatch</code>.
Another reason for avoiding use of this function is, that it also implicitly patches the status section if it was changed, which is confusing for others reading the code. To accomplish this, the func does some back and forth conversion, comparison and checks, which are unnecessary in most of our cases and simply wasted CPU cycles and complexity we want to avoid.</p><p>There were some <code>Try{Update,UpdateStatus,Patch,PatchStatus}</code> helper functions in Gardener that were already removed by <a href=https://github.com/gardener/gardener/pull/4378>gardener/gardener#4378</a> but are still used in some extension code at the time of writing.
The reason for eliminating these functions is that they implement <code>RetryOnConflict</code>-semantics. Meaning, they first get the object, mutate it, then try to update and retry if a conflict error occurs.
As explained above, retrying on conflict is a controller anti-pattern and should be avoided in almost every situation.
The other problem with these functions is that they read the object first from the API server (always do a direct call), although in most cases we already have a recent version of the object at hand. So, using this function generally does unnecessary API calls and therefore causes unwanted compute and network load.</p><p>For the reasons explained above, there are similar helper functions that accomplish similar things but address the mentioned drawbacks: <code>controllerutils.{GetAndCreateOrMergePatch,GetAndCreateOrStrategicMergePatch}</code>.
These can be safely used as replacements for the aforementioned helper funcs.
If they are not fitting for your use case, for example because you need to use optimistic locking, just do the appropriate calls in the controller directly.</p><h2 id=further-resources>Further Resources</h2><ul><li><a href="https://www.youtube.com/watch?v=RPsUo925PUA&t=40s">Kubernetes Client usage in Gardener</a> (Community Meeting talk, 2020-06-26)</li></ul><p>These resources are only partially related to the topics covered in this doc, but might still be interesting for developer seeking a deeper understanding of Kubernetes API machinery, architecture and foundational concepts.</p><ul><li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md>API Conventions</a></li><li><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/resource-management.md>The Kubernetes Resource Model</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21c83bbf03336ea56a38d93f1d4fa12f>4.5 - Local Setup</h1><h1 id=overview>Overview</h1><p>Conceptually, all Gardener components are designed to run as a Pod inside a Kubernetes cluster.
The Gardener API server extends the Kubernetes API via the user-aggregated API server concepts.
However, if you want to develop it, you may want to work locally with the Gardener without building a Docker image and deploying it to a cluster each and every time.
That means that the Gardener runs outside a Kubernetes cluster which requires providing a <a href=https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/>Kubeconfig</a> in your local filesystem and point the Gardener to it when starting it (see below).</p><p>Further details can be found in</p><ol><li><a href=https://kubernetes.io/docs/concepts/>Principles of Kubernetes</a>, and its <a href=https://kubernetes.io/docs/concepts/overview/components/>components</a></li><li><a href=https://github.com/kubernetes/community/tree/master/contributors/devel>Kubernetes Development Guide</a></li><li><a href=https://github.com/gardener/documentation/wiki/Architecture>Architecture of Gardener</a></li></ol><p>This guide is split into three main parts:</p><ul><li><a href=#preparing-the-setup>Preparing your setup by installing all dependencies and tools</a></li><li><a href=#start-gardener-locally>Building and starting Gardener components locally</a></li><li><a href=#create-a-shoot>Using your local Gardener setup to create a Shoot</a></li></ul><h2 id=limitations-of-the-local-development-setup>Limitations of the local development setup</h2><p>You can run Gardener (API server, controller manager, scheduler, gardenlet) against any local Kubernetes cluster, however, your seed and shoot clusters must be deployed to a cloud provider.
Currently, it is not possible to run Gardener entirely isolated from any cloud provider. This means that to be able create Shoot clusters you need to register an external Seed cluster (e.g., one created in AWS).</p><h1 id=preparing-the-setup>Preparing the Setup</h1><h2 id=macos-only-installing-homebrew>[macOS only] Installing homebrew</h2><p>The copy-paste instructions in this guide are designed for macOS and use the package manager <a href=https://brew.sh/>Homebrew</a>.</p><p>On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>/bin/bash -c <span style=color:#a31515>&#34;</span><span style=color:#00f>$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span style=color:#00f>)</span><span style=color:#a31515>&#34;</span>
</code></pre></div><h2 id=installing-git>Installing git</h2><p>We use <code>git</code> as VCS which you need to install. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install git
</code></pre></div><p>For other OS, please check the <a href=https://git-scm.com/book/en/v2/Getting-Started-Installing-Git>Git installation documentation</a>.</p><h2 id=installing-go>Installing Go</h2><p>Install the latest version of Go. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install go
</code></pre></div><p>For other OS, please check <a href=https://golang.org/doc/install>Go installation documentation</a>.</p><h2 id=installing-kubectl>Installing kubectl</h2><p>Install <code>kubectl</code>. Please make sure that the version of <code>kubectl</code> is at least <code>v1.11.x</code>. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubernetes-cli
</code></pre></div><p>For other OS, please check the <a href=https://kubernetes.io/docs/tasks/tools/install-kubectl/>kubectl installation documentation</a>.</p><h2 id=installing-helm>Installing helm</h2><p>You also need the <a href=https://github.com/kubernetes/helm>Helm</a> CLI. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install helm
</code></pre></div><p>For other OS please check the <a href=https://helm.sh/docs/intro/install/>Helm installation documentation</a>.</p><h2 id=installing-openvpn>Installing openvpn</h2><p>We use <code>OpenVPN</code> to establish network connectivity from the control plane running in the Seed cluster to the Shoot&rsquo;s worker nodes running in private networks.
To harden the security we need to generate another secret to encrypt the network traffic (<a href=https://openvpn.net/index.php/open-source/documentation/howto.html#security>details</a>).
Please install the <code>openvpn</code> binary. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install openvpn
export PATH=<span style=color:#00f>$(</span>brew --prefix openvpn<span style=color:#00f>)</span>/sbin:$PATH
</code></pre></div><p>For other OS, please check the <a href=https://openvpn.net/index.php/open-source/downloads.html>OpenVPN downloads page</a>.</p><h2 id=installing-docker>Installing Docker</h2><p>You need to have docker installed and running. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install --cask docker
</code></pre></div><p>For other OS please check the <a href=https://docs.docker.com/get-docker/>docker installation documentation</a>.</p><h2 id=installing-iproute2>Installing iproute2</h2><p><code>iproute2</code> provides a collection of utilities for network administration and configuration. On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install iproute2mac
</code></pre></div><h2 id=installing-jq>Installing jq</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install jq
</code></pre></div><h2 id=installing-gnu-parallel>Installing GNU Parallel</h2><p><a href=https://www.gnu.org/software/parallel/>GNU Parallel</a> is a shell tool for executing jobs in parallel, used by the code generation scripts (<code>make generate</code>). On macOS run</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install parallel
</code></pre></div><h2 id=macos-only-install-gnu-core-utilities>[macOS only] Install GNU core utilities</h2><p>When running on macOS, install the GNU core utilities and friends:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install coreutils gnu-sed gnu-tar grep
</code></pre></div><p>This will create symbolic links for the GNU utilities with <code>g</code> prefix in <code>/usr/local/bin</code>, e.g., <code>gsed</code> or <code>gbase64</code>. To allow using them without the <code>g</code> prefix please put <code>/usr/local/opt/coreutils/libexec/gnubin</code> etc. at the beginning of your <code>PATH</code> environment variable, e.g., <code>export PATH=/usr/local/opt/coreutils/libexec/gnubin:$PATH</code> (<code>brew</code> will print out instructions for each installed formula).</p><h2 id=windows-only-wsl2>[Windows only] WSL2</h2><p>Apart from Linux distributions and macOS, the local gardener setup can also run on the Windows Subsystem for Linux 2.</p><p>While WSL1, plain docker for windows and various Linux distributions and local Kubernetes environments may be supported, this setup was verified with:</p><ul><li><a href=https://docs.microsoft.com/en-us/windows/wsl/wsl2-index>WSL2</a></li><li><a href=https://docs.docker.com/docker-for-windows/wsl/>Docker Desktop WSL2 Engine</a></li><li><a href=https://ubuntu.com/blog/ubuntu-on-wsl-2-is-generally-available>Ubuntu 18.04 LTS on WSL2</a></li><li>Nodeless local garden (see below)</li></ul><p>The Gardener repository and all the above-mentioned tools (git, golang, kubectl, &mldr;) should be installed in your WSL2 distro, according to the distribution-specific Linux installation instructions.</p><h1 id=start-gardener-locally>Start Gardener locally</h1><h2 id=get-the-sources>Get the sources</h2><p>Clone the repository from GitHub into your <code>$GOPATH</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir -p $GOPATH/src/github.com/gardener
cd $GOPATH/src/github.com/gardener
git clone git@github.com:gardener/gardener.git
cd gardener
</code></pre></div><blockquote><p>Note: Gardener is using Go modules and cloning the repository into <code>$GOPATH</code> is not a hard requirement. However it is still recommended to clone into <code>$GOPATH</code> because <code>k8s.io/code-generator</code> does not work yet outside of <code>$GOPATH</code> - <a href=https://github.com/kubernetes/kubernetes/issues/86753>kubernetes/kubernetes#86753</a>.</p></blockquote><h2 id=start-the-gardener>Start the Gardener</h2><p>ℹ️ In the following guide, you have to define the configuration (<code>CloudProfile</code>s, <code>SecretBinding</code>s, <code>Seed</code>s, etc.) manually for the infrastructure environment you want to develop against.
Additionally, you have to register the respective Gardener extensions manually.
If you are rather looking for a quick start guide to develop entirely locally on your machine (no real cloud provider or infrastructure involved) then you should rather follow <a href=/docs/gardener/development/getting_started_locally/>this guide</a>.</p><h3 id=start-a-local-kubernetes-cluster>Start a local kubernetes cluster</h3><p>For the development of Gardener you need a Kubernetes API server on which you can register Gardener&rsquo;s own Extension API Server as <code>APIService</code>. This cluster doesn&rsquo;t need any worker nodes to run pods, though, therefore, you can use the &ldquo;nodeless Garden cluster setup&rdquo; residing in <code>hack/local-garden</code>. This will start all minimally required components of a Kubernetes cluster (<code>etcd</code>, <code>kube-apiserver</code>, <code>kube-controller-manager</code>)
and an <code>etcd</code> Instance for the <code>gardener-apiserver</code> as Docker containers. This is the easiest way to get your
Gardener development setup up and running.</p><p><strong>Using the nodeless cluster setup</strong></p><p>Use the provided Makefile rules to start your local Garden:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make local-garden-up
[...]
Starting gardener-dev kube-etcd cluster..!
Starting gardener-dev kube-apiserver..!
Starting gardener-dev kube-controller-manager..!
Starting gardener-dev gardener-etcd cluster..!
namespace/garden created
clusterrole.rbac.authorization.k8s.io/gardener.cloud:admin created
clusterrolebinding.rbac.authorization.k8s.io/front-proxy-client created
[...]
</code></pre></div><p>ℹ️ [Optional] If you want to develop the <code>SeedAuthorization</code> feature then you have to run <code>make ACTIVATE_SEEDAUTHORIZER=true local-garden-up</code>. However, please note that this forces you to start the <code>gardener-admission-controller</code> via <code>make start-admission-controller</code>.</p><p>To tear down the local Garden cluster and remove the Docker containers, simply run:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make local-garden-down
</code></pre></div><details><summary><b>Alternative: Using a local kubernetes cluster</b></summary><p>Instead of starting a kubernetes API server and etcd as docker containers, you can also opt for running a local kubernetes cluster, provided by e.g. <a href=https://minikube.sigs.k8s.io/docs/start/>minikube</a>, <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>kind</a> or docker desktop.</p><blockquote><p>Note: Gardener requires self-contained kubeconfig files because of a <a href=https://banzaicloud.com/blog/kubeconfig-security/>security issue</a>. You can configure your minikube to create self-contained kubeconfig files via:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube config set embed-certs true
</code></pre></div><p>or when starting the local cluster</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube start --embed-certs
</code></pre></div></blockquote></details><details><summary><b>Alternative: Using a remote kubernetes cluster</b></summary><p>For some testing scenarios, you may want to use a remote cluster instead of a local one as your Garden cluster.
To do this, you can use the &ldquo;remote Garden cluster setup&rdquo; residing in <code>hack/remote-garden</code>. This will start an <code>etcd</code> instance for the <code>gardener-apiserver</code> as a Docker container, and open tunnels for accessing local gardener components from the remote cluster.</p><p>To avoid mistakes, the remote cluster must have a <code>garden</code> namespace labeled with <code>gardener.cloud/purpose=remote-garden</code>.
You must create the <code>garden</code> namespace and label it manually before running <code>make remote-garden-up</code> as described below.</p><p>Use the provided <code>Makefile</code> rules to bootstrap your remote Garden:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>export KUBECONFIG=&lt;path to kubeconfig&gt;
make remote-garden-up
[...]
<span style=color:green># Start gardener etcd used to store gardener resources (e.g., seeds, shoots)</span>
Starting gardener-dev-remote gardener-etcd cluster!
[...]
<span style=color:green># Open tunnels for accessing local gardener components from the remote cluster</span>
[...]
</code></pre></div><p>To close the tunnels and remove the locally-running Docker containers, run:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make remote-garden-down
</code></pre></div><blockquote><p>Note: The minimum K8S version of the remote cluster that can be used as Garden cluster is <code>1.19.x</code>.</p></blockquote><p>ℹ️ [Optional] If you want to use the remote Garden cluster setup with the <code>SeedAuthorization</code> feature you have to adapt the <code>kube-apiserver</code> process of your remote Garden cluster. To do this, perform the following steps after running <code>make remote-garden-up</code>:</p><ul><li><p>Create an <a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/#configuration-file-format>authorization webhook configuration file</a> using the IP of the <code>garden/quic-server</code> pod running in your remote Garden cluster and port 10444 that tunnels to your locally running <code>gardener-admission-controller</code> process.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
current-context: seedauthorizer
clusters:
- name: gardener-admission-controller
  cluster:
    insecure-skip-tls-verify: <span style=color:#00f>true</span>
    server: https://&lt;quic-server-pod-ip&gt;:10444/webhooks/auth/seed
users:
- name: kube-apiserver
  user: {}
contexts:
- name: seedauthorizer
  context:
    cluster: gardener-admission-controller
    user: kube-apiserver
</code></pre></div></li><li><p>Change or add the following command line parameters to your <code>kube-apiserver</code> process:</p><ul><li><code>--authorization-mode=&lt;...>,Webhook</code></li><li><code>--authorization-webhook-config-file=&lt;path to config file></code></li><li><code>--authorization-webhook-cache-authorized-ttl=0</code></li><li><code>--authorization-webhook-cache-unauthorized-ttl=0</code></li></ul></li><li><p>Delete the cluster role and rolebinding <code>gardener.cloud:system:seeds</code> from your remote Garden cluster.</p></li></ul><p>If your remote Garden cluster is a Gardener shoot, and you can access the seed on which this shoot is scheduled, you can automate the above steps by running the <a href=https://github.com/gardener/gardener/blob/master/hack/local-development/remote-garden/enable-seed-authorizer><code>enable-seed-authorizer</code> script</a> and passing the kubeconfig of the seed cluster and the shoot namespace as parameters:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>hack/local-development/remote-garden/enable-seed-authorizer &lt;seed kubeconfig&gt; &lt;namespace&gt;
</code></pre></div><blockquote><p>Note: The configuration changes introduced by this script result in a working <code>SeedAuthorization</code> feature only on shoots for which the <code>ReversedVPN</code> feature is not enabled. If the corresponding feature gate is enabled in <code>gardenlet</code>, add the annotation <code>alpha.featuregates.shoot.gardener.cloud/reversed-vpn: 'false'</code> to the remote Garden shoot to disable it for that particular shoot.</p></blockquote><p>To prevent Gardener from reconciling the shoot and overwriting your changes, add the annotation <code>shoot.gardener.cloud/ignore: 'true'</code> to the remote Garden shoot. Note that this annotation takes effect only if it is enabled via the <code>constollers.shoot.respectSyncPeriodOverwrite: true</code> option in the <code>gardenlet</code> configuration.</p><p>To disable the seed authorizer again, run the same script with <code>-d</code> as a third parameter:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>hack/local-development/remote-garden/enable-seed-authorizer &lt;seed kubeconfig&gt; &lt;namespace&gt; -d
</code></pre></div><p>If the seed authorizer is enabled, you also have to start the <code>gardener-admission-controller</code> via <code>make start-admission-controller</code>.</p><blockquote><p>⚠️ In the remote garden setup all Gardener components run with administrative permissions, i.e., there is no fine-grained access control via RBAC (as opposed to productive installations of Gardener).</p></blockquote></details><h3 id=prepare-the-gardener>Prepare the Gardener</h3><p>Now, that you have started your local cluster, we can go ahead and register the Gardener API Server.
Just point your <code>KUBECONFIG</code> environment variable to the cluster you created in the previous step and run:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make dev-setup
[...]
namespace/garden created
namespace/garden-dev created
deployment.apps/etcd created
service/etcd created
service/gardener-apiserver created
service/gardener-admission-controller created
endpoints/gardener-apiserver created
endpoints/gardener-admission-controller created
apiservice.apiregistration.k8s.io/v1alpha1.core.gardener.cloud created
apiservice.apiregistration.k8s.io/v1beta1.core.gardener.cloud created
apiservice.apiregistration.k8s.io/v1alpha1.seedmanagement.gardener.cloud created
apiservice.apiregistration.k8s.io/v1alpha1.settings.gardener.cloud created
</code></pre></div><p>ℹ️ [Optional] If you want to enable logging, in the Gardenlet configuration add:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>logging:
  enabled: <span style=color:#00f>true</span>
</code></pre></div><p>The Gardener exposes the API servers of Shoot clusters via Kubernetes services of type <code>LoadBalancer</code>.
In order to establish stable endpoints (robust against changes of the load balancer address), it creates DNS records pointing to these load balancer addresses. They are used internally and by all cluster components to communicate.
You need to have control over a domain (or subdomain) for which these records will be created.
Please provide an <em>internal domain secret</em> (see <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-internal-domain.yaml>this</a> for an example) which contains credentials with the proper privileges. Further information can be found <a href=/docs/gardener/usage/configuration/>here</a>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f example/10-secret-internal-domain-unmanaged.yaml
secret/internal-domain-unmanaged created
</code></pre></div><h3 id=run-the-gardener>Run the Gardener</h3><p>Next, run the Gardener API Server, the Gardener Controller Manager (optionally), the Gardener Scheduler (optionally), and the Gardenlet in different terminal windows/panes using rules in the <code>Makefile</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-apiserver
[...]
I0306 15:23:51.044421   74536 plugins.go:84] Registered admission plugin <span style=color:#a31515>&#34;ResourceReferenceManager&#34;</span>
I0306 15:23:51.044523   74536 plugins.go:84] Registered admission plugin <span style=color:#a31515>&#34;DeletionConfirmation&#34;</span>
[...]
I0306 15:23:51.626836   74536 secure_serving.go:116] Serving securely on [::]:8443
[...]
</code></pre></div><p>(Optional) Now you are ready to launch the Gardener Controller Manager.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-controller-manager
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting Gardener controller manager...&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Feature Gates: &#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting HTTP server on 0.0.0.0:2718&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Acquired leadership, starting controllers.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting HTTPS server on 0.0.0.0:2719&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Found internal domain secret internal-domain-unmanaged for domain nip.io.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Successfully bootstrapped the Garden cluster.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Gardener controller manager (version 1.0.0-dev) initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;ControllerRegistration controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;SecretBinding controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Project controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Quota controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-03-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;CloudProfile controller initialized.&#34;</span>
[...]
</code></pre></div><p>(Optional) Now you are ready to launch the Gardener Scheduler.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-scheduler
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting Gardener scheduler ...&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting HTTP server on 0.0.0.0:10251&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Acquired leadership, starting scheduler.&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Gardener scheduler initialized (with Strategy: SameRegion)&#34;</span>
time=<span style=color:#a31515>&#34;2019-05-02T16:31:50+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Scheduler controller initialized.&#34;</span>
[...]
</code></pre></div><p>The Gardener should now be ready to operate on Shoot resources. You can use</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get shoots
No resources found.
</code></pre></div><p>to operate against your local running Gardener API Server.</p><blockquote><p>Note: It may take several seconds until the Gardener API server has been started and is available. <code>No resources found</code> is the expected result of our initial development setup.</p></blockquote><h1 id=create-a-shoot>Create a Shoot</h1><p>The steps below describe the general process of creating a Shoot. Have in mind that the steps do not provide full example manifests. The reader needs to check the provider documentation and adapt the manifests accordingly.</p><h4 id=1-copy-the-example-manifests>1. Copy the example manifests</h4><p>The next steps require modifications of the example manifests. These modifications are part of local setup and should not be <code>git push</code>-ed. To do not interfere with git, let&rsquo;s copy the example manifests to <code>dev/</code> which is ignored by git.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cp example/*.yaml dev/
</code></pre></div><h4 id=2-create-a-project>2. Create a Project</h4><p>Every Shoot is associated with a Project. Check the corresponding example manifests <code>dev/00-namespace-garden-dev.yaml</code> and <code>dev/05-project-dev.yaml</code>. Adapt them and create them.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/00-namespace-garden-dev.yaml
kubectl apply -f dev/05-project-dev.yaml
</code></pre></div><p>Make sure that the Project is successfully reconciled:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get project dev
NAME   NAMESPACE    STATUS   OWNER                  CREATOR            AGE
dev    garden-dev   Ready    john.doe@example.com   kubernetes-admin   6s
</code></pre></div><h4 id=3-create-a-cloudprofile>3. Create a CloudProfile</h4><p>The <code>CloudProfile</code> resource is provider specific and describes the underlying cloud provider (available machine types, regions, machine images, etc.). Check the corresponding example manifest <code>dev/30-cloudprofile.yaml</code>. Check also the documentation and example manifests of the provider extension. Adapt <code>dev/30-cloudprofile.yaml</code> and apply it.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/30-cloudprofile.yaml
</code></pre></div><h4 id=4-install-necessary-gardener-extensions>4. Install necessary Gardener Extensions</h4><p>The <a href=https://github.com/gardener/gardener/blob/master/extensions/README.md#known-extension-implementations>Known Extension Implementations</a> section contains a list of available extension implementations. You need to create a ControllerRegistration and ControllerDeployment for</p><ul><li>at least one infrastructure provider</li><li>a dns provider (if the DNS for the Seed is not disabled)</li><li>at least one operating system extension</li><li>at least one network plugin extension</li></ul><p>As a convention, the example ControllerRegistration manifest (containing also the necessary ControllerDeployment) for an extension is located under <code>example/controller-registration.yaml</code> in the corresponding repository (for example for AWS the ControllerRegistration can be found <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/controller-registration.yaml>here</a>). An example creation for provider-aws (make sure to replace <code>&lt;version></code> with the newest released version tag):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f https://raw.githubusercontent.com/gardener/gardener-extension-provider-aws/&lt;version&gt;/example/controller-registration.yaml
</code></pre></div><p>Instead of updating extensions manually you can use <a href=https://github.com/gardener/gem>Gardener Extensions Manager</a> to install and update extension controllers. This is especially useful if you want to keep and maintain your development setup for a longer time.
Also, please refer to <a href=/docs/gardener/extensions/controllerregistration/>this document</a> for further information about how extensions are registered in case you want to use other versions than the latest releases.</p><h4 id=5-register-a-seed>5. Register a Seed</h4><p>Shoot controlplanes run in seed clusters, so we need to create our first Seed now.</p><p>Check the corresponding example manifest <code>dev/40-secret-seed.yaml</code> and <code>dev/50-seed.yaml</code>. Update <code>dev/40-secret-seed.yaml</code> with base64 encoded kubeconfig of the cluster that will be used as Seed (the scope of the permissions should be identical to the kubeconfig that the Gardenlet creates during bootstrapping - for now, <code>cluster-admin</code> privileges are recommended).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/40-secret-seed.yaml
</code></pre></div><p>Adapt <code>dev/50-seed.yaml</code> - adjust <code>.spec.secretRef</code> to refer the newly created Secret, adjust <code>.spec.provider</code> with the Seed cluster provider and revise the other fields.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/50-seed.yaml
</code></pre></div><h4 id=6-start-gardenlet>6. Start Gardenlet</h4><p>Once the Seed is created, start the Gardenlet to reconcile it. The <code>make start-gardenlet</code> command will automatically configure the local Gardenlet process to use the Seed and its kubeconfig. If you have multiple Seeds, you have to specify which to use by setting the <code>SEED_NAME</code> environment variable like in <code>make start-gardenlet SEED_NAME=my-first-seed</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make start-gardenlet
time=<span style=color:#a31515>&#34;2019-11-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Starting Gardenlet...&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Feature Gates: HVPA=true, Logging=true&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:17+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Acquired leadership, starting controllers.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Found internal domain secret internal-domain-unmanaged for domain nip.io.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Gardenlet (version 1.0.0-dev) initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;ControllerInstallation controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Shoot controller initialized.&#34;</span>
time=<span style=color:#a31515>&#34;2019-11-06T15:24:18+02:00&#34;</span> level=info msg=<span style=color:#a31515>&#34;Seed controller initialized.&#34;</span>
[...]
</code></pre></div><p>The Gardenlet will now reconcile the Seed. Check the progess from time to time until it&rsquo;s <code>Ready</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get seed
NAME       STATUS    PROVIDER    REGION      AGE    VERSION       K8S VERSION
seed-aws   Ready     aws         eu-west-1   4m     v1.11.0-dev   v1.18.12
</code></pre></div><h4 id=7-create-a-shoot>7. Create a Shoot</h4><p>A Shoot requires a SecretBinding. The SecretBinding refers to a Secret that contains the cloud provider credentials. The Secret data keys are provider specific and you need to check the documentation of the provider to find out which data keys are expected (for example for AWS the related documentation can be found <a href=/docs/extensions/infrastructure-extensions/gardener-extension-provider-aws/docs/usage-as-end-user/#provider-secret-data>here</a>). Adapt <code>dev/70-secret-provider.yaml</code> and <code>dev/80-secretbinding.yaml</code> and apply them.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/70-secret-provider.yaml
kubectl apply -f dev/80-secretbinding.yaml
</code></pre></div><p>After the SecretBinding creation, you are ready to proceed with the Shoot creation. You need to check the documentation of the provider to find out the expected configuration (for example for AWS the related documentation and example Shoot manifest can be found <a href=/docs/extensions/infrastructure-extensions/gardener-extension-provider-aws/docs/usage-as-end-user/>here</a>). Adapt <code>dev/90-shoot.yaml</code> and apply it.</p><p>To make sure that a specific Seed cluster will be chosen or to skip the scheduling (the sheduling requires Gardener Scheduler to be running), specify the <code>.spec.seedName</code> field (see <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L317-L318>here</a>).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f dev/90-shoot.yaml
</code></pre></div><p>Watch the progress of the operation and make sure that the Shoot will be successfully created.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>watch kubectl get shoot --all-namespaces
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-ba2932673ad3c4565462541e83ca1ede>4.6 - Log Parsers</h1><h1 id=how-to-create-log-parser-for-container-into-fluent-bit>How to create log parser for container into fluent-bit</h1><p>If our log message is parsed correctly, it has to be showed in Grafana like this:</p><pre><code class=language-jsonc data-lang=jsonc>  {&quot;log&quot;:&quot;OpenAPI AggregationController: Processing item v1beta1.metrics.k8s.io&quot;,&quot;pid&quot;:&quot;1&quot;,&quot;severity&quot;:&quot;INFO&quot;,&quot;source&quot;:&quot;controller.go:107&quot;}
</code></pre><p>Otherwise it will looks like this:</p><pre><code class=language-jsonc data-lang=jsonc>{
  &quot;log&quot;:&quot;{
  \&quot;level\&quot;:\&quot;info\&quot;,\&quot;ts\&quot;:\&quot;2020-06-01T11:23:26.679Z\&quot;,\&quot;logger\&quot;:\&quot;gardener-resource-manager.health-reconciler\&quot;,\&quot;msg\&quot;:\&quot;Finished ManagedResource health checks\&quot;,\&quot;object\&quot;:\&quot;garden/provider-aws-dsm9r\&quot;
  }\n&quot;
  }
}
</code></pre><h2 id=lets-make-a-custom-parser-now>Lets make a custom parser now</h2><ul><li><p>First of all we need to know how does the log for the specific container look like (for example lets take a log from the <code>alertmanager</code> :
<code>level=info ts=2019-01-28T12:33:49.362015626Z caller=main.go:175 build_context="(go=go1.11.2, user=root@4ecc17c53d26, date=20181109-15:40:48)</code>)</p></li><li><p>We can see that this log contains 4 subfields(severity=info, timestamp=2019-01-28T12:33:49.362015626Z, source=main.go:175 and the actual message).
So we have to write a regex which matches this log in 4 groups(We can use <a href=https://regex101.com/>https://regex101.com/</a> like helping tool). So for this purpose our regex
looks like this:</p></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>^level=(?&lt;severity&gt;\w+)\s+ts=(?&lt;time&gt;\d{4}-\d{2}-\d{2}[Tt].*[zZ])\s+caller=(?&lt;source&gt;[^\s]*+)\s+(?&lt;log&gt;.*)
</code></pre></div><ul><li>Now we have to create correct time format for the timestamp(We can use this site for this purpose: <a href=http://ruby-doc.org/stdlib-2.4.1/libdoc/time/rdoc/Time.html#method-c-strptime)>http://ruby-doc.org/stdlib-2.4.1/libdoc/time/rdoc/Time.html#method-c-strptime)</a>.
So our timestamp matches correctly the following format:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>%Y-%m-%dT%H:%M:%S.%L
</code></pre></div><ul><li>It&rsquo;s a time to apply our new regex into fluent-bit configuration. Go to fluent-bit-configmap.yaml and create new filter using the following template:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[FILTER]
        Name                parser
        Match               kubernetes.&lt;&lt; pod-name &gt;&gt;*&lt;&lt; container-name &gt;&gt;*
        Key_Name            log
        Parser              &lt;&lt; parser-name &gt;&gt;
        Reserve_Data        True
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>EXAMPLE
[FILTER]
        Name                parser
        Match               kubernetes.alertmanager*alertmanager*
        Key_Name            log
        Parser              alermanagerParser
        Reserve_Data        True
</code></pre></div><ul><li>Now lets check if there is already exists parser with such a regex and time format that we need. if not, let`s create one:</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>[PARSER]
        Name        &lt;&lt; parser-name &gt;&gt;
        Format      regex
        Regex       &lt;&lt; regex &gt;&gt;
        Time_Key    time
        Time_Format &lt;&lt; time-format &gt;&gt;
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>EXAMPLE
[PARSER]
        Name        alermanagerParser
        Format      regex
        Regex       ^level=(?&lt;severity&gt;\w+)\s+ts=(?&lt;time&gt;\d{4}-\d{2}-\d{2}[Tt].*[zZ])\s+caller=(?&lt;source&gt;[^\s]*+)\s+(?&lt;log&gt;.*)
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>Follow your development setup to validate that parsers are working correctly.
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6072f273ee0aa37eba651d226b098168>4.7 - Logging</h1><h1 id=logging-in-gardener-components>Logging in Gardener Components</h1><p>This document aims at providing a general developer guideline on different aspects of logging practices and conventions used in the Gardener codebase.
It contains mostly Gardener-specific points and references other existing and commonly accepted logging guidelines for general advice.
Developers and reviewers should consult this guide when writing, refactoring and reviewing Gardener code.
If parts are unclear or new learnings arise, this guide should be adapted accordingly.</p><h2 id=logging-libraries--implementations>Logging Libraries / Implementations</h2><p>Historically, Gardener components have been using <a href=https://github.com/sirupsen/logrus>logrus</a>.
There is a global logrus logger (<a href=https://github.com/gardener/gardener/blob/626ba7c10e1150819b3905116d3988512c18c9ee/pkg/logger/logrus.go#L28><code>logger.Logger</code></a>) that is initialized by components on startup and used across the codebase.
In most places, it is used as a <code>printf</code>-style logger and only in some instances we make use of logrus' structured logging functionality.</p><p>In the process of migrating our components to native controller-runtime components (see <a href=https://github.com/gardener/gardener/issues/4251>gardener/gardener#4251</a>), we also want to make use of controller-runtime&rsquo;s built-in mechanisms for streamlined logging.
controller-runtime uses <a href=https://github.com/go-logr/logr>logr</a>, a simple structured logging interface, for library-internal logging and logging in controllers.</p><p>logr itself is only an interface and doesn&rsquo;t provide an implementation out of the box.
Instead, it needs to be backed by a logging implementation like <a href=https://github.com/go-logr/zapr>zapr</a>. Code that uses the logr interface is thereby not tied to a specific logging implementation and makes the implementation easily exchangeable.
controller-runtime already provides a <a href=https://github.com/kubernetes-sigs/controller-runtime/tree/v0.11.0/pkg/log/zap>set of helpers</a> for constructing zapr loggers, i.e., logr loggers backed by <a href=https://github.com/uber-go/zap>zap</a>, which is a popular logging library in the go community.
Hence, we are migrating our component logging from logrus to logr (backed by zap) as part of <a href=https://github.com/gardener/gardener/issues/4251>gardener/gardener#4251</a>.</p><blockquote><p>⚠️ <code>logger.Logger</code> (logrus logger) is deprecated in Gardener and shall not be used in new code – use logr loggers when writing new code! (also see <a href=#migration-from-logrus-to-logr>Migration from logrus to logr</a>)</p><p>ℹ️ Don&rsquo;t use zap loggers directly, always use the logr interface in order to avoid tight coupling to a specific logging implementation.</p></blockquote><p>gardener-apiserver differs from the other components as it is based on the <a href=https://github.com/kubernetes/apiserver>apiserver library</a> and therefore uses <a href=https://github.com/kubernetes/klog>klog</a> – just like kube-apiserver.
As gardener-apiserver writes (almost) no logs in our coding (outside the apiserver library), there is currently no plan for switching the logging implementation.
Hence, the following sections focus on logging in the controller and admission components only.</p><h2 id=logcheck-tool><code>logcheck</code> Tool</h2><p>To ensure a smooth migration to logr and make logging in Gardener components more consistent, the <a href=https://github.com/gardener/gardener/tree/master/hack/tools/logcheck><code>logcheck</code> tool</a> was added.
It enforces (parts of) this guideline and detects programmer-level errors early on in order to prevent bugs.
Please check out the <a href=https://github.com/gardener/gardener/tree/master/hack/tools/logcheck>tool&rsquo;s documentation</a> for a detailed description.</p><h2 id=structured-logging>Structured Logging</h2><p>Similar to <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/migration-to-structured-logging.md>efforts in the Kubernetes project</a>, we want to migrate our component logs to structured logging.
As motivated above, we will use the logr interface instead of klog though.</p><p>You can read more about the motivation behind structured logging in <a href=https://github.com/go-logr/logr#background>logr&rsquo;s background and FAQ</a> (also see <a href=http://dave.cheney.net/2015/11/05/lets-talk-about-logging>this blog post by Dave Cheney</a>).
Also, make sure to check out controller-runtime&rsquo;s <a href=https://github.com/kubernetes-sigs/controller-runtime/blob/v0.11.0/TMP-LOGGING.md>logging guideline</a> with specifics for projects using the library.
The following sections will focus on the most important takeaways from those guidelines and give general instructions on how to apply them to Gardener and its controller-runtime components.
Note: some parts in this guideline differ slightly from controller-runtime&rsquo;s document.</p><h3 id=tldr-of-structured-logging>TL;DR of Structured Logging</h3><p>❌ stop using <code>printf</code>-style logging:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> logger *logrus.Logger
logger.Infof(<span style=color:#a31515>&#34;Scaling deployment %s/%s to %d replicas&#34;</span>, deployment.Namespace, deployment.Name, replicaCount)
</code></pre></div><p>✅ instead, write static log messages and enrich them with additional structured information in form of key-value pairs:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> logger logr.Logger
logger.Info(<span style=color:#a31515>&#34;Scaling deployment&#34;</span>, <span style=color:#a31515>&#34;deployment&#34;</span>, client.ObjectKeyFromObject(deployment), <span style=color:#a31515>&#34;replicas&#34;</span>, replicaCount)
</code></pre></div><h2 id=log-configuration>Log Configuration</h2><p>Gardener components can be configured to either log in <code>json</code> (default) or <code>text</code> format:
<code>json</code> format is supposed to be used in production, while <code>text</code> format might be nicer for development.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># json
{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2021-12-16T08:32:21.059+0100&#34;,&#34;msg&#34;:&#34;Hello botanist&#34;,&#34;garden&#34;:&#34;eden&#34;}

# text
2021-12-16T08:32:21.059+0100    INFO    Hello botanist  {&#34;garden&#34;: &#34;eden&#34;}
</code></pre></div><p>Components can be set to one of the following log levels (with increasing verbosity): <code>error</code>, <code>info</code> (default), <code>debug</code>.</p><blockquote><p>ℹ️ Note: some Gardener components don&rsquo;t feature a configurable log level and format yet.
In this case, they log at <code>info</code> in <code>json</code> format.
We might add configuration options via command line flags that can be used in all components in the future though (see <a href=https://github.com/gardener/gardener/issues/5191>gardener/gardener#5191</a>).</p></blockquote><h2 id=log-levels>Log Levels</h2><p>logr uses <a href=https://github.com/go-logr/logr#why-v-levels>V-levels</a> (numbered log levels), higher V-level means higher verbosity.
V-levels are relative (in contrast to <code>klog</code>&rsquo;s absolute V-levels), i.e., <code>V(1)</code> creates a logger, that is one level more verbose than its parent logger.</p><p>In Gardener components, the mentioned log levels in the component config (<code>error</code>, <code>info</code>, <code>debug</code>) map to the zap levels with the same names (see <a href=https://github.com/gardener/gardener/blob/770fc01a34b70f6cb77b8cfe929d9daef0026d1c/pkg/logger/zap.go#L43-L55>here</a>).
Hence, our loggers follow the same mapping from numerical logr levels to named zap levels like described in <a href=https://github.com/go-logr/zapr/tree/v1.1.0#increasing-verbosity>zapr</a>, i.e.:</p><ul><li>component config specifies <code>debug</code> ➡️ both <code>V(0)</code> and <code>V(1)</code> are enabled</li><li>component config specifies <code>info</code> ➡️ <code>V(0)</code> is enabled, <code>V(1)</code> will not be shown</li><li>component config specifies <code>error</code> ➡️ neither <code>V(0)</code> nor <code>V(1)</code> will be shown</li><li><code>Error()</code> logs will always be shown</li></ul><p>This mapping applies to the components' root loggers (the ones that are not &ldquo;derived&rdquo; from any other logger; constructed on component startup).
If you derive a new logger with e.g. <code>V(1)</code>, the mapping will shift by one. For example, <code>V(0)</code> will then log at zap&rsquo;s <code>debug</code> level.</p><p>There is no <code>warning</code> level (see <a href=https://dave.cheney.net/2015/11/05/lets-talk-about-logging>Dave Cheney&rsquo;s post</a>).
If there is an error condition (e.g., unexpected error received from a called function), the error should either be handled or logged at <code>error</code> if it is neither handled nor returned.
If you have an <code>error</code> value at hand that doesn&rsquo;t represent an actual error condition, but you still want to log it as an informational message, log it at <code>info</code> level with key <code>err</code>.</p><p>We might consider to make use of a broader range of log levels in the future when introducing more logs and common command line flags for our components (comparable to <code>--v</code> of Kubernetes components).
For now, we stick to the mentioned two log levels like controller-runtime: info (<code>V(0)</code>) and debug (<code>V(1)</code>).</p><h2 id=logging-in-controllers>Logging in Controllers</h2><h3 id=named-loggers>Named Loggers</h3><p>Controllers should use named loggers that include their name, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>controllerLogger := rootLogger.WithName(<span style=color:#a31515>&#34;controller&#34;</span>).WithName(<span style=color:#a31515>&#34;shoot&#34;</span>)
controllerLogger.Info(<span style=color:#a31515>&#34;Deploying kube-apiserver&#34;</span>)
</code></pre></div><p>results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>2021-12-16T09:27:56.550+0100    INFO    controller.shoot    Deploying kube-apiserver
</code></pre></div><p>Logger names are hierarchical. You can make use of it, where controllers are composed of multiple &ldquo;subcontrollers&rdquo;, e.g., <code>controller.shoot.hibernation</code> or <code>controller.shoot.maintenance</code>.</p><p>Using the global logger <code>logf.Log</code> directly is discouraged and should be rather exceptional because it makes correlating logs with code harder.
Preferably, all parts of the code should use some named logger.</p><h3 id=reconciler-loggers>Reconciler Loggers</h3><p>In your <code>Reconcile</code> function, retrieve a logger from the given <code>context.Context</code>.
It inherits from the controller&rsquo;s logger (i.e., is already named) and is preconfigured with <code>name</code> and <code>namespace</code> values for the reconciliation request:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>func</span> (r *reconciler) Reconcile(ctx context.Context, request reconcile.Request) (reconcile.Result, <span style=color:#2b91af>error</span>) {
  log := logf.FromContext(ctx)
  log.Info(<span style=color:#a31515>&#34;Reconciling Shoot&#34;</span>)
  <span style=color:green>// ...
</span><span style=color:green></span>  <span style=color:#00f>return</span> reconcile.Result{}, <span style=color:#00f>nil</span>
}
</code></pre></div><p>results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>2021-12-16T09:35:59.099+0100    INFO    controller.shoot    Reconciling Shoot        {&#34;name&#34;: &#34;sunflower&#34;, &#34;namespace&#34;: &#34;garden-greenhouse&#34;}
</code></pre></div><p>The logger is injected by controller-runtime&rsquo;s <code>Controller</code> implementation and our <code>controllerutils.CreateWorker</code> alike (if a logger is passed using <code>controllerutils.WithLogger</code>). The logger returned by <code>logf.FromContext</code> is never <code>nil</code>. If the context doesn&rsquo;t carry a logger, it falls back to the global logger (<code>logf.Log</code>), which might discard logs if not configured, but is also never <code>nil</code>.</p><p>The controller implementation (controller-runtime / <code>CreateWorker</code>) itself takes care of logging the error returned by reconcilers.
Hence, don&rsquo;t log an error that you are returning.
Generally, functions should not return an error, if they already logged it, because that means the error is already handled and not an error anymore.
See <a href=https://dave.cheney.net/2015/11/05/lets-talk-about-logging>Dave Cheney&rsquo;s post</a> for more on this.</p><h3 id=messages>Messages</h3><ul><li>Log messages should be static. Don&rsquo;t put variable content in there, i.e., no <code>fmt.Sprintf</code> or string concatenation (<code>+</code>). Use key-value pairs instead.</li><li>Log messages should be capitalized. Note: this contrasts with error messages, that should not be capitalized. However, both should not end with a punctuation mark.</li></ul><h3 id=keys-and-values>Keys and Values</h3><ul><li><p>Use <code>WithValues</code> instead of repeatedly adding key-value pairs for multiple log statements. <code>WithValues</code> creates a new logger from the parent, that carries the given key-value pairs. E.g., use it when acting on one object in multiple steps and logging something for each step:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>log := parentLog.WithValues(<span style=color:#a31515>&#34;infrastructure&#34;</span>, client.ObjectKeyFromObject(infrastrucutre))
<span style=color:green>// ...
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Creating Infrastructure&#34;</span>)
<span style=color:green>// ...
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Waiting for Infrastructure to be reconciled&#34;</span>)
<span style=color:green>// ...
</span></code></pre></div><p>Note: <code>WithValues</code> bypasses controller-runtime&rsquo;s special zap encoder that nicely encodes <code>ObjectKey</code>/<code>NamespacedName</code> and <code>runtime.Object</code> values, see <a href=https://github.com/kubernetes-sigs/controller-runtime/issues/1290>kubernetes-sigs/controller-runtime#1290</a>.
Thus, the end result might look different depending on the value and its <code>Stringer</code> implementation.</p></li><li><p>Use <a href=https://en.wiktionary.org/wiki/lowerCamelCase>lowerCamelCase</a> for keys. Don&rsquo;t put spaces in keys, as it will make log processing with simple tools like <code>jq</code> harder.</p></li><li><p>Keys should be constant, human-readable, consistent across the codebase and naturally match parts of the log message, see <a href=https://github.com/go-logr/logr#how-do-i-choose-my-keys>logr guideline</a>.</p></li><li><p>When logging object keys (name and namespace), use the object&rsquo;s type as the log key and a <code>client.ObjectKey</code>/<code>types.NamespacedName</code> value as value, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> deployment *appsv1.Deployment
log.Info(<span style=color:#a31515>&#34;Creating Deployment&#34;</span>, <span style=color:#a31515>&#34;deployment&#34;</span>, client.ObjectKeyFromObject(deployment))
</code></pre></div><p>which results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2021-12-16T08:32:21.059+0100&#34;,&#34;msg&#34;:&#34;Creating Deployment&#34;,&#34;deployment&#34;:{&#34;name&#34;: &#34;bar&#34;, &#34;namespace&#34;: &#34;foo&#34;}}
</code></pre></div><p>Earlier, we often used <code>kutil.ObjectName()</code> for logging object keys, which encodes them into a flat string like <code>foo/bar</code>. However, this flat string cannot be processed so easily by logging stacks (or <code>jq</code>) like a structured log. Hence, the use of <code>kutil.ObjectName()</code> for logging object keys is discouraged. Existing usages should be refactored to use <code>client.ObjectKeyFromObject()</code> instead.</p></li><li><p>There are cases where you don&rsquo;t have the full object key or the object itself at hand, e.g., if an object references another object (in the same namespace) by name (think <code>secretRef</code> or similar).
In such a cases, either construct the full object key including the implied namespace or log the object name under a key ending in <code>Name</code>, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> (
  <span style=color:green>// object to reconcile
</span><span style=color:green></span>  shoot *gardencorev1beta1.Shoot
  <span style=color:green>// retrieved via logf.FromContext, preconfigured by controller with namespace and name of reconciliation request
</span><span style=color:green></span>  log logr.Logger
)

<span style=color:green>// option a: full object key, manually constructed
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Shoot uses SecretBinding&#34;</span>, <span style=color:#a31515>&#34;secretBinding&#34;</span>, client.ObjectKey{Namespace: shoot.Namespace, Name: shoot.Spec.SecretBindingName})
<span style=color:green>// option b: only name under respective *Name log key
</span><span style=color:green></span>log.Info(<span style=color:#a31515>&#34;Shoot uses SecretBinding&#34;</span>, <span style=color:#a31515>&#34;secretBindingName&#34;</span>, shoot.Spec.SecretBindingName)
</code></pre></div><p>Both options result in well-structured logs, that are easy to interpret and process:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2022-01-18T18:00:56.672+0100&#34;,&#34;msg&#34;:&#34;Shoot uses SecretBinding&#34;,&#34;name&#34;:&#34;my-shoot&#34;,&#34;namespace&#34;:&#34;garden-project&#34;,&#34;secretBinding&#34;:{&#34;namespace&#34;:&#34;garden-project&#34;,&#34;name&#34;:&#34;aws&#34;}}
{&#34;level&#34;:&#34;info&#34;,&#34;ts&#34;:&#34;2022-01-18T18:00:56.673+0100&#34;,&#34;msg&#34;:&#34;Shoot uses SecretBinding&#34;,&#34;name&#34;:&#34;my-shoot&#34;,&#34;namespace&#34;:&#34;garden-project&#34;,&#34;secretBindingName&#34;:&#34;aws&#34;}
</code></pre></div></li><li><p>When handling generic <code>client.Object</code> values (e.g. in helper funcs), use <code>object</code> as key.</p></li><li><p>When adding timestamps to key-value pairs, use <code>time.Time</code> values. By this, they will be encoded in the same format as the log entry&rsquo;s timestamp.<br>Don&rsquo;t use <code>metav1.Time</code> values, as they will be encoded in a different format by their <code>Stringer</code> implementation. Pass <code>&lt;someTimestamp>.Time</code> to loggers in case you have a <code>metav1.Time</code> value at hand.</p></li><li><p>Same applies to durations. Use <code>time.Duration</code> values instead of <code>*metav1.Duration</code>. Durations can be handled specially by zap just like timestamps.</p></li><li><p>Event recorders not only create <code>Event</code> objects but also log them.
However, both Gardener&rsquo;s manually instantiated event recorders and the ones that controller-runtime provides log to <code>debug</code> level and use generic formats, that are not very easy to interpret or process (no structured logs).
Hence, don&rsquo;t use event recorders as replacements for well-structured logs.
If a controller records an event for a completed action or important information, it should probably log it as well, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>log.Info(<span style=color:#a31515>&#34;Creating ManagedSeed&#34;</span>, <span style=color:#a31515>&#34;replica&#34;</span>, r.GetObjectKey())
a.recorder.Eventf(managedSeedSet, corev1.EventTypeNormal, EventCreatingManagedSeed, <span style=color:#a31515>&#34;Creating ManagedSeed %s&#34;</span>, r.GetFullName())
</code></pre></div></li></ul><h2 id=logging-in-test-code>Logging in Test Code</h2><ul><li>If the tested production code requires a logger, you can pass <code>logr.Discard()</code> or <code>logf.NullLogger{}</code> in your test, which simply discards all logs.</li><li>Pass <code>logzap.New(logzap.WriteTo(GinkgoWriter))</code> in tests where you want to see the logs on test failure but not on success.</li><li><code>logf.Log</code> is safe to use in tests and will not cause a nil pointer deref, even if it&rsquo;s not initialized via <code>logf.SetLogger</code>.
It is initially set to a <code>NullLogger</code> by default, which means all logs are discarded, unless <code>logf.SetLogger</code> is called in the first 30 seconds of execution.</li></ul><h2 id=migration-from-logrus-to-logr>Migration from logrus to logr</h2><p>These points might be helpful when refactoring existing code during the migration period:</p><ul><li>For migrating an existing controller to logr:<ul><li>Create a named logger (<a href=https://github.com/gardener/gardener/blob/ce9d741798eac2df8c470190ab483aa4c5818ebf/pkg/controllermanager/controller/cloudprofile/cloudprofile.go#L63>example</a>).</li><li>Pass <code>controllerutils.WithLogger</code> to <code>CreateWorker</code> (<a href=https://github.com/gardener/gardener/blob/ce9d741798eac2df8c470190ab483aa4c5818ebf/pkg/controllermanager/controller/cloudprofile/cloudprofile.go#L113>example</a>). This allows <code>logf.FromContext</code> to be used in reconcilers.</li><li>Use <code>logf.FromContext</code> in <code>Reconcile</code> to retrieve the logr logger and use it from there on (<a href=https://github.com/gardener/gardener/blob/ce9d741798eac2df8c470190ab483aa4c5818ebf/pkg/controllermanager/controller/cloudprofile/cloudprofile_control.go#L72>example</a>).</li><li>Make sure to follow the other guidelines mentioned above as well (see <a href=#logging-in-controllers>Logging in Controllers</a>).</li></ul></li><li>Libraries might expect a different logging implementation than the component which uses it. E.g., a controller that already uses logr might want to use the <code>flow</code> package which still uses logrus. In such cases:<ul><li>You can consider refactoring the library along with the component itself, if feasible.</li><li>It is acceptable for the migration period to use a logger derived from the respective global logger (<code>logger.Logger</code> or <code>logf.Log</code>) and pass it to the library.
However, please add a <code>TODO</code> for cleaning it up later on, once the migration is completed. E.g.:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:green>// TODO: switch to logr once flow package is migrated
</span><span style=color:green></span>err := shootFlow.Run(flow.Opts{
  Logger: logger.Logger.WithFields(logrus.Fields{<span style=color:#a31515>&#34;logger&#34;</span>: <span style=color:#a31515>&#34;controller.&#34;</span> + ControllerName, <span style=color:#a31515>&#34;name&#34;</span>: shoot.Name, <span style=color:#a31515>&#34;namespace&#34;</span>: shoot.Namespace})
})
</code></pre></div></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d42cb3e424a70c7c39b9f2acb996f1c8>4.8 - Monitoring Stack</h1><h1 id=extending-the-monitoring-stack>Extending the Monitoring Stack</h1><p>This document provides instructions to extend the Shoot cluster monitoring stack by integrating new scrape targets, alerts and dashboards.</p><p>Please ensure that you have understood the basic principles of <a href=https://prometheus.io/docs/introduction/overview/>Prometheus</a> and its ecosystem before you continue.</p><p>‼️ <strong>The purpose of the monitoring stack is to observe the behaviour of the control plane and the system components deployed by Gardener onto the worker nodes. Monitoring of custom workloads running in the cluster is out of scope.</strong></p><h2 id=overview>Overview</h2><p><img src=/__resources/monitoring-architecture_cd945d.png alt="Monitoring Architecture"></p><p>Each Shoot cluster comes with its own monitoring stack. The following components are deployed into the seed and shoot:</p><ul><li>Seed<ul><li><a href=https://github.com/prometheus/prometheus>Prometheus</a></li><li><a href=https://github.com/grafana/grafana>Grafana</a></li><li><a href=https://github.com/prometheus/blackbox_exporter>blackbox-exporter</a></li><li><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a> (Seed metrics)</li><li><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a> (Shoot metrics)</li><li><a href=https://github.com/prometheus/alertmanager>Alertmanager</a> (Optional)</li></ul></li><li>Shoot<ul><li><a href=https://github.com/prometheus/node_exporter>node-exporter(s)</a></li><li><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a></li><li><a href=https://github.com/prometheus/blackbox_exporter>blackbox-exporter</a></li></ul></li></ul><p>In each Seed cluster there is a Prometheus in the <code>garden</code> namespace responsible for collecting metrics from the Seed kubelets and cAdvisors. These metrics are provided to each Shoot Prometheus via federation.</p><p>The alerts for all Shoot clusters hosted on a Seed are routed to a central Alertmanger running in the <code>garden</code> namespace of the Seed. The purpose of this central alertmanager is to forward all important alerts to the operators of the Gardener setup.</p><p>The Alertmanager in the Shoot namespace on the Seed is only responsible for forwarding alerts from its Shoot cluster to a cluster owner/cluster alert receiver via email. The Alertmanager is optional and the conditions for a deployment are already described <a href=/docs/gardener/monitoring/alerting/>here</a>.</p><h2 id=adding-new-monitoring-targets>Adding New Monitoring Targets</h2><p>After exploring the metrics which your component provides or adding new metrics, you should be aware which metrics are required to write the needed alerts and dashboards.</p><p>Prometheus prefers a pull based metrics collection approach and therefore the targets to observe need to be defined upfront. The targets are defined in <code>charts/seed-monitoring/charts/prometheus/templates/config.yaml</code>.
New scrape jobs can be added in the section <code>scrape_configs</code>. Detailed information how to configure scrape jobs and how to use the kubernetes service discovery are available in the <a href=https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config>Prometheus documentation</a>.</p><p>The <code>job_name</code> of a scrape job should be the name of the component e.g. <code>kube-apiserver</code> or <code>vpn</code>. The collection interval should be the default of <code>30s</code>. You do not need to specify this in the configuration.</p><p>Please do not ingest all metrics which are provided by a component. Rather collect only those metrics which are needed to define the alerts and dashboards (i.e. whitelist). This can be achieved by adding the following <code>metric_relabel_configs</code> statement to your scrape jobs (replace <code>exampleComponent</code> with component name).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>    - job_name: example-component
      ...
      metric_relabel_configs:
{{ include &#34;prometheus.keep-metrics.metric-relabel-config&#34; .Values.allowedMetrics.exampleComponent | indent 6 }}
</code></pre></div><p>The whitelist for the metrics of your job can be maintained in <code>charts/seed-monitoring/charts/prometheus/values.yaml</code> in section <code>allowedMetrics.exampleComponent</code> (replace <code>exampleComponent</code> with component name). Check the following example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>allowedMetrics:
  ...
  exampleComponent:
  * metrics_name_1
  * metrics_name_2
  ...
</code></pre></div><h2 id=adding-alerts>Adding Alerts</h2><p>The alert definitons are located in <code>charts/seed-monitoring/charts/prometheus/rules</code>. There are two approaches for adding new alerts.</p><ol><li>Adding additional alerts for a component which already has a set of alerts. In this case you have to extend the existing rule file for the component.</li><li>Adding alerts for a new component. In this case a new rule file with name scheme <code>example-component.rules.yaml</code> needs to be added.</li><li>Add the new alert to <code>alertInhibitionGraph.dot</code>, add any required inhibition flows and render the new graph. To render the graph run:</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>dot -Tpng ./content/alertInhibitionGraph.dot -o ./content/alertInhibitionGraph.png
</code></pre></div><ol><li>Create a test for the new alert. See <code>Alert Tests</code>.</li></ol><p>Example alert:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>groups:
* name: example.rules
  rules:
  * alert: ExampleAlert
    expr: absent(up{job=&#34;exampleJob&#34;} == 1)
    for: 20m
    labels:
      service: example
      severity: critical <span style=color:green># How severe is the alert? (blocker|critical|info|warning)</span>
      type: shoot <span style=color:green># For which topology is the alert relevant? (seed|shoot)</span>
      visibility: all <span style=color:green># Who should receive the alerts? (all|operator|owner)</span>
    annotations:
      description: A longer description of the example alert that should also explain the impact of the alert.
      summary: Short summary of an example alert.
</code></pre></div><p>If the deployment of component is optional then the alert definitions needs to be added to <code>charts/seed-monitoring/charts/prometheus/optional-rules</code> instead. Furthermore the alerts for component need to be activatable in <code>charts/seed-monitoring/charts/prometheus/values.yaml</code> via <code>rules.optional.example-component.enabled</code>. The default should be <code>true</code>.</p><p>Basic instruction how to define alert rules can be found in the <a href=https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules>Prometheus documentation</a>.</p><h3 id=routing-tree>Routing tree</h3><p>The Alertmanager is grouping incoming alerts based on labels into buckets. Each bucket has its own configuration like alert receivers, initial delaying duration or resending frequency etc. You can find more information about Alertmanager routing in the <a href=https://prometheus.io/docs/alerting/configuration/#route>Prometheus/Alertmanager documentation</a>. The routing trees for the Alertmanagers deployed by Gardener are depicted below.</p><p>Central Seed Alertmanager</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>∟ main route (all alerts for all shoots on the seed will enter)
  ∟ group by project and shoot name
    ∟ group by visibility &#34;all&#34; and &#34;operator&#34;
      ∟ group by severity &#34;blocker&#34;, &#34;critical&#34;, and &#34;info&#34; → route to Garden operators
      ∟ group by severity &#34;warning&#34; (dropped)
    ∟ group by visibility &#34;owner&#34; (dropped)
</code></pre></div><p>Shoot Alertmanager</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>∟ main route (only alerts for one Shoot will enter)
  ∟ group by visibility &#34;all&#34; and &#34;owner&#34;
    ∟ group by severity &#34;blocker&#34;, &#34;critical&#34;, and &#34;info&#34; → route to cluster alert receiver
    ∟ group by severity &#34;warning&#34; (dropped, will change soon → route to cluster alert receiver)
  ∟ group by visibility &#34;operator&#34; (dropped)
</code></pre></div><h3 id=alert-inhibition>Alert Inhibition</h3><p>All alerts related to components running on the Shoot workers are inhibited in case of an issue with the vpn connection, because those components can&rsquo;t be scraped anymore and Prometheus will fire alerts in consequence. The components running on the workers are probably healthy and the alerts are presumably false positives. The inhibition flow is shown in the figure below. If you add a new alert make sure to add it to the diagram.</p><p><img src=/__resources/alertInhibitionGraph_ceaef0.png alt=alertDiagram></p><h3 id=alert-attributes>Alert Attributes</h3><p>Each alert rule definition has to contain the following annotations:</p><ul><li><strong>summary</strong>: A short description of the issue.</li><li><strong>description</strong>: A detailed explanation of the issue with hints to the possible root causes and the impact assessment of the issue.</li></ul><p>In addtion each alert must contain the following labels:</p><ul><li><strong>type</strong><ul><li><code>shoot</code>: Components running on the Shoot worker nodes in the <code>kube-system</code> namespace.</li><li><code>seed</code>: Components running on the Seed in the Shoot namespace as part of/next to the control plane.</li></ul></li><li><strong>service</strong><ul><li>Name of the component (in lowercase) e.g. <code>kube-apiserver</code>, <code>alertmanager</code> or <code>vpn</code>.</li></ul></li><li><strong>severity</strong><ul><li><code>blocker</code>: All issues which make the cluster entirely unusable e.g. <code>KubeAPIServerDown</code> or <code>KubeSchedulerDown</code></li><li><code>critical</code>: All issues which affect single functionalities/components but not affect the cluster in its core functionality e.g. <code>VPNDown</code> or <code>KubeletDown</code>.</li><li><code>info</code>: All issues that do not affect the cluster or its core functionality, but if this component is down we cannot determine if a blocker alert is firing. (i.e. A component with an info level severity is a dependency for a component with a blocker severity)</li><li><code>warning</code>: No current existing issue, rather a hint for situations which could lead to real issue in the close future e.g. <code>HighLatencyApiServerToWorkers</code> or <code>ApiServerResponseSlow</code>.</li></ul></li></ul><h3 id=alert-tests>Alert Tests</h3><p>To test the Prometheus alerts:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test-prometheus
</code></pre></div><p>If you want to add alert tests:</p><ol><li><p>Create a new file in <code>rules-tests</code> in the form <code>&lt;alert-group-name>.rules.test.yaml</code> or if the alerts are for an existing component with existing tests, simply add the tests to the appropriate files.</p></li><li><p>Make sure that newly added tests succeed. See above.</p></li></ol><h2 id=adding-grafana-dashboards>Adding Grafana Dashboards</h2><p>The dashboard definition files are located in <code>charts/seed-monitoring/charts/grafana/dashboards</code>. Every dashboard needs its own file.</p><p>If you are adding a new component dashboard please also update the overview dashboard by adding a chart for its current up/down status and with a drill down option to the component dashboard.</p><h3 id=dashboard-structure>Dashboard Structure</h3><p>The dashboards should be structured in the following way. The assignment of the component dashboards to the categories should be handled via dashboard tags.</p><ul><li>Kubernetes control plane components (Tag: <code>control-plane</code>)<ul><li>All components which are part of the Kubernetes control plane e. g. Kube API Server, Kube Controller Manager, Kube Scheduler and Cloud Controller Manager</li><li>ETCD + Backup/Restore</li><li>Kubernetes Addon Manager</li></ul></li><li>Node/Machine components (Tag: <code>node/machine</code>)<ul><li>All metrics which are related to the behaviour/control of the Kubernetes nodes and kubelets</li><li>Machine-Controller-Manager + Cluster Autoscaler</li></ul></li><li>Networking components (Tag: <code>network</code>)<ul><li>CoreDNS, KubeProxy, Calico, VPN, Nginx Ingress</li></ul></li><li>Addon components (Tag: <code>addon</code>)<ul><li>Cert Broker</li></ul></li><li>Monitoring components (Tag: <code>monitoring</code>)</li><li>Logging components (Tag: <code>logging</code>)</li></ul><h4 id=mandatory-charts-for-component-dashboards>Mandatory Charts for Component Dashboards</h4><p>For each new component, its corresponding dashboard should contain the following charts in the first row, before adding custom charts for the component in the subsequent rows.</p><ol><li>Pod up/down status <code>up{job="example-component"}</code></li><li>Pod/containers cpu utilization</li><li>Pod/containers memorty consumption</li><li>Pod/containers network i/o</li></ol><p>These information is provided by the cAdvisor metrics. These metrics are already integrated. Please check the other dashboards for detailed information on how to query.</p><h5 id=chart-requirements>Chart Requirements</h5><p>Each chart needs to contain:</p><ul><li>a meaningful name</li><li>a detailed description (for non trivial charts)</li><li>appropriate x/y axis descriptions</li><li>appropriate scaling levels for the x/y axis</li><li>proper units for the x/y axis</li></ul><h5 id=dashboard-parameters>Dashboard Parameters</h5><p>The following parameters should be added to all dashboards to ensure a homogeneous experience across all dashboards.</p><p>Dashboards have to &mldr;</p><ul><li>contain a title which refers to the component name(s)</li><li>contain a timezone statement which should be the browser time</li><li>contain tags which express where the component is running (<code>seed</code> or <code>shoot</code>) and to which category the component belong (see dashboard structure)</li><li>contain a version statement with a value of 1</li><li>be immutable</li></ul><p>Example dashboard configuration</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;title&#34;: <span style=color:#a31515>&#34;example-component&#34;</span>,
  &#34;timezone&#34;: <span style=color:#a31515>&#34;utc&#34;</span>,
  &#34;tags&#34;: [
    <span style=color:#a31515>&#34;seed&#34;</span>,
    <span style=color:#a31515>&#34;control-plane&#34;</span>
  ],
  &#34;version&#34;: 1,
  &#34;editable&#34;: <span style=color:#a31515>&#34;false&#34;</span>
}
</code></pre></div><p>Furthermore all dashboards should contain the following time options:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;time&#34;: {
    &#34;from&#34;: <span style=color:#a31515>&#34;now-1h&#34;</span>,
    &#34;to&#34;: <span style=color:#a31515>&#34;now&#34;</span>
  },
  &#34;timepicker&#34;: {
    &#34;refresh_intervals&#34;: [
      <span style=color:#a31515>&#34;30s&#34;</span>,
      <span style=color:#a31515>&#34;1m&#34;</span>,
      <span style=color:#a31515>&#34;5m&#34;</span>
    ],
    &#34;time_options&#34;: [
      <span style=color:#a31515>&#34;5m&#34;</span>,
      <span style=color:#a31515>&#34;15m&#34;</span>,
      <span style=color:#a31515>&#34;1h&#34;</span>,
      <span style=color:#a31515>&#34;6h&#34;</span>,
      <span style=color:#a31515>&#34;12h&#34;</span>,
      <span style=color:#a31515>&#34;24h&#34;</span>,
      <span style=color:#a31515>&#34;2d&#34;</span>,
      <span style=color:#a31515>&#34;10d&#34;</span>
    ]
  }
}
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0323918722a5b41e437d646bc4e3ca40>4.9 - New Cloud Provider</h1><h1 id=adding-cloud-providers>Adding Cloud Providers</h1><p>This document provides an overview of how to integrate a new cloud provider into Gardener. Each component that requires integration has a detailed description of how to integrate it and the steps required.</p><h2 id=cloud-components>Cloud Components</h2><p>Gardener is composed of 2 or more Kubernetes clusters:</p><ul><li>Shoot: These are the end-user clusters, the regular Kubernetes clusters you have seen. They provide places for your workloads to run.</li><li>Seed: This is the &ldquo;management&rdquo; cluster. It manages the control planes of shoots by running them as native Kubernetes workloads.</li></ul><p>These two clusters can run in the same cloud provider, but they do not need to. For example, you could run your Seed in AWS, while having one shoot in Azure, two in Google, two in Alicloud, and three in Equinix Metal.</p><p>The Seed cluster deploys and manages the Shoot clusters. Importantly, for this discussion, the <code>etcd</code> data store backing each Shoot runs as workloads inside the Seed. Thus, to use the above example, the clusters in Azure, Google, Alicloud and Equinix Metal will have their worker nodes and master nodes running in those clouds, but the <code>etcd</code> clusters backing them will run as separate <a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>deployments</a> in the Seed Kubernetes cluster on AWS.</p><p>This distinction becomes important when preparing the integration to a new cloud provider.</p><h2 id=gardener-cloud-integration>Gardener Cloud Integration</h2><p>Gardener and its related components integrate with cloud providers at the following key lifecycle elements:</p><ul><li>Create/destroy/get/list machines for the Shoot</li><li>Create/destroy/get/list infrastructure components for the Shoot, e.g. VPCs, subnets, routes, etc.</li><li>Backup/restore etcd for the Seed via writing files to and reading them from object storage</li></ul><p>Thus, the integrations you need for your cloud provider depend on whether you want to deploy Shoot clusters to the provider, Seed or both.</p><ul><li>Shoot Only: machine lifecycle management, infrastructure.</li><li>Seed: etcd backup/restore</li></ul><h2 id=gardener-api>Gardener API</h2><p>In addition to the requirements to integrate with the cloud provider, you also need to enable the core Gardener app to receive, validate and process requests to use that cloud provider.</p><ul><li>Expose the cloud provider to the consumers of the Gardener API, so it can be told to use that cloud provider as an option</li><li>Validate that API as requests come in</li><li>Write cloud provider specific implementation (called &ldquo;provider extension&rdquo;)</li></ul><h2 id=cloud-provider-api-requirements>Cloud Provider API Requirements</h2><p>In order for a cloud provider to integrate with Gardener, the provider must have an API to perform machine lifecycle events, specifically:</p><ul><li>Create a machine</li><li>Destroy a machine</li><li>Get information about a machine and its state</li><li>List machines</li></ul><p>In addition, if the Seed is to run on the given provider, it also must have an API to save files to block storage and retrieve them, for etcd backup/restore.</p><p>The current integration with cloud providers is to add their API calls to Gardener and the Machine Controller Manager. As both Gardener and the Machine Controller Manager are written in <a href=https://golang.org>go</a>, the cloud provider should have a go SDK. However, if it has an API that is wrappable in go, e.g. a REST API, then you can use that to integrate.</p><p>The Gardener team is working on bringing cloud provider integrations out-of-tree, making them pluggable, which should simplify the process and make it possible to use other SDKs.</p><h2 id=summary>Summary</h2><p>To add a new cloud provider, you need some or all of the following. Each repository contains instructions on how to extend it to a new cloud provider.</p><table><thead><tr><th>Type</th><th>Purpose</th><th>Location</th><th>Documentation</th></tr></thead><tbody><tr><td>Seed or Shoot</td><td>Machine Lifecycle</td><td><a href=https://github.com/gardener/machine-controller-manager>machine-controller-manager</a></td><td><a href=/docs/other-components/machine-controller-manager/docs/development/cp_support_new/>MCM new cloud provider</a></td></tr><tr><td>Seed only</td><td>etcd backup/restore</td><td><a href=https://github.com/gardener/etcd-backup-restore/>etcd-backup-restore</a></td><td>In process</td></tr><tr><td>All</td><td>Extension implementation</td><td><a href=https://github.com/gardener/gardener>gardener</a></td><td><a href=/docs/gardener/extensions/overview/>Extension controller</a></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-d926243c7cdf1cf05524b388093c464b>4.10 - New Kubernetes Version</h1><h1 id=adding-support-for-a-new-kubernetes-version>Adding Support For A New Kubernetes Version</h1><p>This document describes the steps needed to perform in order to confidently add support for a new Kubernetes <strong>minor</strong> version.</p><blockquote><p>⚠️ Typically, once a minor Kubernetes version <code>vX.Y</code> is supported by Gardener then all patch versions <code>vX.Y.Z</code> are also automatically supported without any required action.
This is because patch versions do not introduce any new feature or API changes, so there is nothing that needs to be adapted in <code>gardener/gardener</code> code.</p></blockquote><p>The Kubernetes community release a new minor version roughly every 4 months.
Please refer to the <a href=https://kubernetes.io/releases/release/>official documentation</a> about their release cycles for any additional information.</p><p>Shortly before a new release, an &ldquo;umbrella&rdquo; issue should be opened which is used to collect the required adaptations and to track the work items.
For example, <a href=https://github.com/gardener/gardener/issues/5102>#5102</a> can be used as a template for the issue description.<br>As you can see, the task of supporting a new Kubernetes version also includes the provider extensions maintained in the <code>gardener</code> GitHub organization and is not restricted to <code>gardener/gardener</code> only.</p><p>Generally, the work items can be split into two groups:
The first group contains Kubernetes release-independent tasks, the second group contains tasks specific to the changes in the given Kubernetes release.</p><blockquote><p>ℹ️ Upgrading the <code>k8s.io/*</code> and <code>sigs.k8s.io/controller-runtime</code> Golang dependencies is typically tracked and worked on separately (see e.g. <a href=https://github.com/gardener/gardener/issues/4772>#4772</a> or <a href=https://github.com/gardener/gardener/issues/5282>#5282</a>).</p></blockquote><h2 id=deriving-release-specific-tasks>Deriving Release-Specific Tasks</h2><p>Most new minor Kubernetes releases incorporate API changes, deprecations or new features.
The community announces them via their <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/>change logs</a>.
In order to derive the release-specific tasks, the respective change log for the new version <code>vX.Y</code> has to be read and understood (for example, <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md>this document</a> for <code>v1.24</code>).</p><p>As already mentioned, typical changes to watch out for are:</p><ul><li>API version promotions or deprecations</li><li>Feature gate promotions or deprecations</li><li>CLI flag changes for Kubernetes components</li><li>New default values in resources</li><li>New available fields in resources</li><li>New features potentially relevant for the Gardener system</li><li>Changes of labels or annotations Gardener relies on</li><li>&mldr;</li></ul><p>Obviously, this requires a certain experience and understanding of the Gardener project so that all &ldquo;relevant changes&rdquo; can be identified.
While reading the change log, add the tasks (along with the respective PR in <code>kubernetes/kubernetes</code> to the umbrella issue).</p><blockquote><p>ℹ️ Some of the changes might be specific to certain cloud providers. Pay attention to those as well and add related tasks to the issue.</p></blockquote><h2 id=list-of-release-independent-tasks>List Of Release-Independent Tasks</h2><p>The following paragraphs describe recurring tasks that need to be performed for each new release.</p><h3 id=releasing-a-new-hyperkube-image>Releasing A New <code>hyperkube</code> Image</h3><p>The <a href=https://github.com/gardener/hyperkube><code>gardener/hyperkube</code></a> repository is used to release container images consisting of the <code>kubectl</code> and <code>kubelet</code> binaries.</p><p>Run the <a href=https://github.com/gardener/hyperkube/blob/master/.ci/check-and-release><code>.ci/check-and-release</code></a> script to automatically build the image (make sure Docker is running!), push the images to the GCR (make sure <code>gcloud</code> is configured properly!) and publish the release on GitHub (make sure <code>git</code> is configured properly!).</p><h3 id=adapting-gardener>Adapting Gardener</h3><ul><li>Allow instantiation of a Kubernetes client for the new minor version and update the <code>README.md</code>:<ul><li>See <a href=https://github.com/gardener/gardener/pull/5255/commits/63bdae022f1cb1c9cbd1cd49b557545dca2ec32a>this</a> example commit.</li></ul></li><li>Maintain the Kubernetes feature gates used for validation of <code>Shoot</code> resources:<ul><li>The feature gates are maintained in <a href=https://github.com/gardener/gardener/blob/master/pkg/utils/validation/features/featuregates.go>this</a> file.</li><li>To maintain this list for new Kubernetes versions, run <code>hack/compare-k8s-feature-gates.sh &lt;old-version> &lt;new-version></code> (e.g. <code>hack/compare-k8s-feature-gates.sh v1.22 v1.23</code>).</li><li>It will present 2 lists of feature gates: those added and those removed in <code>&lt;new-version></code> compared to <code>&lt;old-version></code>.</li><li>Add all added feature gates to the map with <code>&lt;new-version></code> as <code>AddedInVersion</code> and no <code>RemovedInVersion</code>.</li><li>For any removed feature gates, add <code>&lt;new-version></code> as RemovedInVersion to the already existing feature gate in the map.</li><li>See <a href=https://github.com/gardener/gardener/pull/5255/commits/97923b0604300ff805def8eae981ed388d5e4a83>this</a> example commit.</li></ul></li><li>Maintain the <code>ServiceAccount</code> names for the controllers part of <code>kube-controller-manager</code>:<ul><li>The names are maintained in <a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/shootsystem/shootsystem.go>this</a> file.</li><li>To maintain this list for new Kubernetes versions, run <code>hack/compare-k8s-controllers.sh &lt;old-version> &lt;new-version></code> (e.g. <code>hack/compare-k8s-controllers.sh 1.22 1.23</code>).</li><li>It will present 2 lists of controllers: those added and those removed in <code>&lt;new-version></code> compared to <code>&lt;old-version></code>.</li><li>Double check whether such <code>ServiceAccount</code> indeed appears in the <code>kube-system</code> namespace when creating a cluster with <code>&lt;new-version></code>. Note that it sometimes might be hidden behind a default-off feature gate. You can create a local cluster with the new version using the <a href=/docs/gardener/development/getting_started_locally/>local provider</a>.</li><li>If it appears, add all added controllers to the list based on the Kubernetes version (<a href=https://github.com/gardener/gardener/blob/5f87b18b951e104c2c25a7145548c8a2d08adefc/pkg/operation/botanist/component/shootsystem/shootsystem.go#L170-L174>example</a>).</li><li>For any removed controllers, add them only to the Kubernetes version if it is low enough.</li></ul></li><li>Bump the used Kubernetes version for local <code>Shoot</code> and local e2e test.<ul><li>See <a href=https://github.com/gardener/gardener/pull/5255/commits/5707c4c7a4fd265b176387178b755cabeea89ffe>this</a> example commit.</li></ul></li></ul><h4 id=filing-the-pull-request>Filing The Pull Request</h4><p>Work on all the tasks you have collected and validate them using the <a href=/docs/gardener/development/getting_started_locally/>local provider</a>.
Execute the e2e tests and if everything looks good, then go ahead and file the PR (<a href=https://github.com/gardener/gardener/pull/5255>example PR</a>).
Generally, it is great if you add the PRs also to the umbrella issue so that they can be tracked more easily.</p><h3 id=adapting-provider-extensions>Adapting Provider Extensions</h3><p>After the PR in <code>gardener/gardener</code> for the support of the new version has been merged, you can go ahead and work on the provider extensions.</p><blockquote><p>Actually, you can already start even if the PR is not yet merged and use the branch of your fork.</p></blockquote><ul><li>Revendor the <code>github.com/gardener/gardener</code> dependency in the extension and update the <code>README.md</code>.</li><li>Work on release-specific tasks related to this provider.</li></ul><h4 id=maintaining-the-cloud-controller-manager-images>Maintaining The <code>cloud-controller-manager</code> Images</h4><p>Some of the cloud providers are not yet using upstream <code>cloud-controller-manager</code> images.
Instead, we build and maintain them ourselves:</p><ul><li><a href=https://github.com/gardener/cloud-provider-aws>https://github.com/gardener/cloud-provider-aws</a></li><li><a href=https://github.com/gardener/cloud-provider-azure>https://github.com/gardener/cloud-provider-azure</a> (since <code>v1.23</code>, we use the upstream image)</li><li><a href=https://github.com/gardener/cloud-provider-gcp>https://github.com/gardener/cloud-provider-gcp</a></li></ul><p>Until we switch to upstream images, you need to revendor the Kubernetes dependencies and release a new image.
The required steps are as follows:</p><ul><li>Checkout the <code>legacy-cloud-provider</code> branch of the respective repository</li><li>Bump the versions in the <code>Dockerfile</code> (<a href=https://github.com/gardener/cloud-provider-gcp/commit/b7eb3f56b252aaf29adc78406672574b1bc17495>example commit</a>).</li><li>Update the <code>VERSION</code> to <code>vX.Y.Z-dev</code> where <code>Z</code> is the latest available Kubernetes patch version for the <code>vX.Y</code> minor version.</li><li>Update the <code>k8s.io/*</code> dependencies in the <code>go.mod</code> file to <code>vX.Y.Z</code> and run <code>go mod vendor</code> and <code>go mod tidy</code> (<a href=https://github.com/gardener/cloud-provider-gcp/commit/d41cc9f035bcc4893b40d90a4f617c4d436c5d62>example commit</a>).</li><li>Checkout a new <code>release-vX.Y</code> branch and release it (<a href=https://github.com/gardener/cloud-provider-gcp/commits/release-v1.23>example</a>)</li></ul><blockquote><p>As you are already on it, it is great if you also bump the <code>k8s.io/*</code> dependencies for the last three minor releases as well.
In this case, you need to checkout the <code>release-vX.{Y-{1,2,3}}</code> branches and only perform the last three steps (<a href=https://github.com/gardener/cloud-provider-gcp/commits/release-v1.20>example branch</a>, <a href=https://github.com/gardener/cloud-provider-gcp/commit/372aa43fbacdeb76b3da9f6fad6cfd924d916227>example commit</a>).</p></blockquote><p>Now you need to update the new releases in the <code>charts/images.yaml</code> of the respective provider extension so that they are used (see this <a href=https://github.com/gardener/gardener-extension-provider-aws/pull/480/commits/76256de933d5a508aba26a8f589dd1a39026142e>example commit</a> for reference).</p><h4 id=filing-the-pull-request-1>Filing The Pull Request</h4><p>Again, work on all the tasks you have collected.
This time, you cannot use the local provider for validation but should create real clusters on the various infrastructures.
Typically, the following validations should be performed:</p><ul><li>Create new clusters with versions &lt; <code>vX.Y</code></li><li>Create new clusters with version = <code>vX.Y</code></li><li>Upgrade old clusters from version <code>vX.{Y-1}</code> to version <code>vX.Y</code></li><li>Delete clusters with versions &lt; <code>vX.Y</code></li><li>Delete clusters with version = <code>vX.Y</code></li></ul><p>If everything looks good, then go ahead and file the PR (<a href=https://github.com/gardener/gardener-extension-provider-aws/pull/480>example PR</a>).
Generally, it is again great if you add the PRs also to the umbrella issue so that they can be tracked more easily.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00cd3641980cfeb33469951e8feeb244>4.11 - Process</h1><h1 id=releases-features-hotfixes>Releases, Features, Hotfixes</h1><p>This document describes how to contribute features or hotfixes, and how new Gardener releases are usually scheduled, validated, etc.</p><ul><li><a href=#releases>Releases</a></li><li><a href=#contributing-new-features-or-fixes>Contributing new Features or Fixes</a></li><li><a href=#cherry-picks>Cherry Picks</a></li></ul><h2 id=releases>Releases</h2><p>The <a href=https://github.com/orgs/gardener/teams/gardener-maintainers>@gardener-maintainers</a> are trying to provide a new release roughly every other week (depending on their capacity and the stability/robustness of the <code>master</code> branch).</p><p>Hotfixes are usually maintained for the latest three minor releases, though, there are no fixed release dates.</p><h3 id=release-responsible-plan>Release Responsible Plan</h3><table><thead><tr><th>Version</th><th>Week No</th><th>Begin Validation Phase</th><th>Due Date</th><th>Release Responsible</th></tr></thead><tbody><tr><td>v1.42</td><td>Week 09-10</td><td>February 28, 2022</td><td>March 13, 2022</td><td><a href=https://github.com/kris94>@kris94</a></td></tr><tr><td>v1.43</td><td>Week 11-12</td><td>March 14, 2022</td><td>March 27, 2022</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.44</td><td>Week 13-14</td><td>March 28, 2022</td><td>April 10, 2022</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.45</td><td>Week 15-16</td><td>April 11, 2022</td><td>April 24, 2022</td><td><a href=https://github.com/acumino>@acumino</a></td></tr><tr><td>v1.46</td><td>Week 17-18</td><td>April 25, 2022</td><td>May 8, 2022</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a></td></tr><tr><td>v1.47</td><td>Week 19-20</td><td>May 9, 2022</td><td>May 22, 2022</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.48</td><td>Week 21-22</td><td>May 23, 2022</td><td>June 5, 2022</td><td><a href=https://github.com/ary1992>@ary1992</a></td></tr><tr><td>v1.49</td><td>Week 23-24</td><td>June 6, 2022</td><td>June 19, 2022</td><td><a href=https://github.com/plkokanov>@plkokanov</a></td></tr><tr><td>v1.50</td><td>Week 25-26</td><td>June 20, 2022</td><td>July 3, 2022</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.51</td><td>Week 27-28</td><td>July 4, 2022</td><td>July 17, 2022</td><td><a href=https://github.com/shafeeqes>@shafeeqes</a></td></tr></tbody></table><p>Apart from the release of the next version, the release responsible is also taking care of potential hotfix releases of the last three minor versions.
The release responsible is the main contact person for coordinating new feature PRs for the next minor versions or cherry-pick PRs for the last three minor versions.</p><details><summary>Click to expand the archived release responsible associations!</summary><table><thead><tr><th>Version</th><th>Week No</th><th>Begin Validation Phase</th><th>Due Date</th><th>Release Responsible</th></tr></thead><tbody><tr><td>v1.17</td><td>Week 07-08</td><td>February 15, 2021</td><td>February 28, 2021</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.18</td><td>Week 09-10</td><td>March 1, 2021</td><td>March 14, 2021</td><td><a href=https://github.com/danielfoehrKn>@danielfoehrKn</a></td></tr><tr><td>v1.19</td><td>Week 11-12</td><td>March 15, 2021</td><td>March 28, 2021</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.20</td><td>Week 13-14</td><td>March 29, 2021</td><td>April 11, 2021</td><td><a href=https://github.com/vpnachev>@vpnachev</a></td></tr><tr><td>v1.21</td><td>Week 15-16</td><td>April 12, 2021</td><td>April 25, 2021</td><td><a href=https://github.com/timuthy>@timuthy</a></td></tr><tr><td>v1.22</td><td>Week 17-18</td><td>April 26, 2021</td><td>May 9, 2021</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.23</td><td>Week 19-20</td><td>May 10, 2021</td><td>May 23, 2021</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a></td></tr><tr><td>v1.24</td><td>Week 21-22</td><td>May 24, 2021</td><td>June 5, 2021</td><td><a href=https://github.com/stoyanr>@stoyanr</a></td></tr><tr><td>v1.25</td><td>Week 23-24</td><td>June 7, 2021</td><td>June 20, 2021</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.26</td><td>Week 25-26</td><td>June 21, 2021</td><td>July 4, 2021</td><td><a href=https://github.com/danielfoehrKn>@danielfoehrKn</a></td></tr><tr><td>v1.27</td><td>Week 27-28</td><td>July 5, 2021</td><td>July 18, 2021</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.28</td><td>Week 29-30</td><td>July 19, 2021</td><td>August 1, 2021</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a></td></tr><tr><td>v1.29</td><td>Week 31-32</td><td>August 2, 2021</td><td>August 15, 2021</td><td><a href=https://github.com/timuthy>@timuthy</a></td></tr><tr><td>v1.30</td><td>Week 33-34</td><td>August 16, 2021</td><td>August 29, 2021</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.31</td><td>Week 35-36</td><td>August 30, 2021</td><td>September 12, 2021</td><td><a href=https://github.com/stoyanr>@stoyanr</a></td></tr><tr><td>v1.32</td><td>Week 37-38</td><td>September 13, 2021</td><td>September 26, 2021</td><td><a href=https://github.com/vpnachev>@vpnachev</a></td></tr><tr><td>v1.33</td><td>Week 39-40</td><td>September 27, 2021</td><td>October 10, 2021</td><td><a href=https://github.com/voelzmo>@voelzmo</a></td></tr><tr><td>v1.34</td><td>Week 41-42</td><td>October 11, 2021</td><td>October 24, 2021</td><td><a href=https://github.com/plkokanov>@plkokanov</a></td></tr><tr><td>v1.35</td><td>Week 43-44</td><td>October 25, 2021</td><td>November 7, 2021</td><td><a href=https://github.com/kris94>@kris94</a></td></tr><tr><td>v1.36</td><td>Week 45-46</td><td>November 8, 2021</td><td>November 21, 2021</td><td><a href=https://github.com/timebertt>@timebertt</a></td></tr><tr><td>v1.37</td><td>Week 47-48</td><td>November 22, 2021</td><td>December 5, 2021</td><td><a href=https://github.com/danielfoehrKn>@danielfoehrKn</a></td></tr><tr><td>v1.38</td><td>Week 49-50</td><td>December 6, 2021</td><td>December 19, 2021</td><td><a href=https://github.com/rfranzke>@rfranzke</a></td></tr><tr><td>v1.39</td><td>Week 01-04</td><td>January 3, 2022</td><td>January 30, 2022</td><td><a href=https://github.com/ialidzhikov>@ialidzhikov</a>, <a href=https://github.com/timuthy>@timuthy</a></td></tr><tr><td>v1.40</td><td>Week 05-06</td><td>January 31, 2022</td><td>February 13, 2022</td><td><a href=https://github.com/BeckerMax>@BeckerMax</a></td></tr><tr><td>v1.41</td><td>Week 07-08</td><td>February 14, 2022</td><td>February 27, 2022</td><td><a href=https://github.com/plkokanov>@plkokanov</a></td></tr></tbody></table></details><h3 id=release-validation>Release Validation</h3><p>The release phase for a new minor version lasts two weeks.
Typically, the first week is used for the validation of the release.
This phase includes the following steps:</p><ol><li><code>master</code> (or latest <code>release-*</code> branch) is deployed to a development landscape that already hosts some existing seed and shoot clusters.</li><li>An extended test suite is triggered by the &ldquo;release responsible&rdquo; which<ol><li>executes the Gardener integration tests for different Kubernetes versions, infrastructures, and <code>Shoot</code> settings.</li><li>executes the Kubernetes conformance tests.</li><li>executes further tests like Kubernetes/OS patch/minor version upgrades.</li></ol></li><li>Additionally, every four hours (or on demand) more tests (e.g., including the Kubernetes e2e test suite) are executed for different infrastructures.</li><li>The &ldquo;release responsible&rdquo; is verifying new features or other notable changes (derived of the draft release notes) in this development system.</li></ol><p>Usually, the new release is triggered in the beginning of the second week if all tests are green, all checks were successful, and if all of the planned verifications were performed by the release responsible.</p><h2 id=contributing-new-features-or-fixes>Contributing new Features or Fixes</h2><p>Please refer to the <a href=https://gardener.cloud/docs/contribute/>Gardener contributor guide</a>.
Besides a lot of a general information, it also provides a checklist for newly created pull requests that may help you to prepare your changes for an efficient review process.
If you are contributing a fix or major improvement, please take care to open cherry-pick PRs to all affected and still supported versions once the change is approved and merged in the <code>master</code> branch.</p><p>⚠️ Please ensure that your modifications pass the verification checks (linting, formatting, static code checks, tests, etc.) by executing</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make verify
</code></pre></div><p>before filing your pull request.</p><p>The guide applies for both changes to the <code>master</code> and to any <code>release-*</code> branch.
All changes must be submitted via a pull request and be reviewed and approved by at least one code owner.</p><h2 id=cherry-picks>Cherry Picks</h2><p>This section explains how to initiate cherry picks on release branches within the <code>gardener/gardener</code> repository.</p><ul><li><a href=#prerequisites>Prerequisites</a></li><li><a href=#initiate-a-cherry-pick>Initiate a Cherry Pick</a></li></ul><h3 id=prerequisites>Prerequisites</h3><p>Before you initiate a cherry pick, make sure that the following prerequisites are accomplished.</p><ul><li>A pull request merged against the <code>master</code> branch.</li><li>The release branch exists (check in the <a href=https://github.com/gardener/gardener/branches>branches section</a>)</li><li>Have the <code>gardener/gardener</code> repository cloned as follows:<ul><li>the <code>origin</code> remote should point to your fork (alternatively this can be overwritten by passing <code>FORK_REMOTE=&lt;fork-remote></code>)</li><li>the <code>upstream</code> remote should point to the Gardener github org (alternatively this can be overwritten by passing <code>UPSTREAM_REMOTE=&lt;upstream-remote></code>)</li></ul></li><li>Have <code>hub</code> installed, which is most easily installed via
<code>go get github.com/github/hub</code> assuming you have a standard golang
development environment.</li><li>A github token which has permissions to create a PR in an upstream branch.</li></ul><h3 id=initiate-a-cherry-pick>Initiate a Cherry Pick</h3><ul><li><p>Run the <a href=https://github.com/gardener/gardener/blob/master/hack/cherry-pick-pull.sh>cherry pick script</a></p><p>This example applies a master branch PR #3632 to the remote branch
<code>upstream/release-v3.14</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>GITHUB_USER=&lt;your-user&gt; hack/cherry-pick-pull.sh upstream/release-v3.14 3632
</code></pre></div><ul><li><p>Be aware the cherry pick script assumes you have a git remote called
<code>upstream</code> that points at the Gardener github org.</p></li><li><p>You will need to run the cherry pick script separately for each patch
release you want to cherry pick to. Cherry picks should be applied to all
active release branches where the fix is applicable.</p></li><li><p>When asked for your github password, provide the created github token
rather than your actual github password.
Refer <a href=https://github.com/github/hub/issues/2655#issuecomment-735836048>https://github.com/github/hub/issues/2655#issuecomment-735836048</a></p></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-165b95fb0235157f8762cac8f525c5ab>4.12 - Secrets Management</h1><h1 id=secrets-management-for-seed-and-shoot-cluster>Secrets Management for Seed and Shoot Cluster</h1><blockquote><p>🚧️ Please note that the work in the new secrets management is ongoing and hence not yet completed.
Accordingly, expect adaptations to this document and implementation details.</p></blockquote><p>The gardenlet needs to create quite some amount of credentials (certificates, private keys, passwords, etc.) for seed and shoot clusters in order to ensure secure deployments.
Such credentials typically should be rotated regularly, and they potentially need to be persisted such that they don&rsquo;t get lost in case of a control plane migration or a lost seed cluster.</p><h2 id=secretsmanager-introduction>SecretsManager Introduction</h2><p>These requirements can be covered by using the <code>SecretsManager</code> package maintained in <a href=https://github.com/gardener/gardener/tree/master/docs/development/pkg/utils/secrets/manager><code>pkg/utils/secrets/manager</code></a>.
It is built on top of the <code>ConfigInterface</code> and <code>DataInterface</code> interfaces part of <a href=https://github.com/gardener/gardener/tree/master/docs/development/pkg/utils/secrets><code>pkg/utils/secrets</code></a> and provides the following functions:</p><ul><li><p><code>Generate(context.Context, secrets.ConfigInterface, ...GenerateOption) (*corev1.Secret, error)</code></p><p>This method either retrieves the current secret for the given configuration or it (re)generates it in case the configuration changed, the signing CA changed (for certificate secrets), or when proactive rotation was triggered.
If the configuration describes a certificate authority secret then this method automatically generates a bundle secret containing the current and potentially the old certificate.<br>Available <code>GenerateOption</code>s:</p><ul><li><code>SignedByCA(string)</code>: This is only valid for certificate secrets and automatically retrieves the correct certificate authority in order to sign the provided server or client certificate.</li><li><code>Persist()</code>: This marks the secret such that it gets persisted in the <code>ShootState</code> resource in the garden cluster. Consequently, it should only be used for secrets related to a shoot cluster.</li><li><code>Rotate(rotationStrategy)</code>: This specifies the strategy in case this secret is to be rotated or regenerated (either <code>InPlace</code> which immediately forgets about the old secret, or <code>KeepOld</code> which keeps the old secret in the system).</li><li><code>IgnoreOldSecrets()</code>: This specifies whether old secrets should be considered and loaded (which is done by default). It should be used when old secrets are no longer important and can be &ldquo;forgotten&rdquo; (e.g. in <a href=/docs/gardener/proposals/18-shoot-ca-rotation/#rotation-sequence-for-cluster-and-client-ca>&ldquo;phase 2&rdquo; (<code>t2</code>) of the CA certificate rotation</a>).</li></ul></li><li><p><code>Get(string, ...GetOption) (*corev1.Secret, bool)</code></p><p>This method retrieves the current secret for the given name.
In case the secret in question is a certificate authority secret then it retrieves the bundle secret by default.
It is important that this method only knows about secrets for which there were prior <code>Generate</code> calls.<br>Available <code>GetOption</code>s:</p><ul><li><code>Bundle</code> (default): This retrieves the bundle secret.</li><li><code>Current</code>: This retrieves the current secret.</li><li><code>Old</code>: This retrieves the old secret.</li></ul></li><li><p><code>Cleanup(context.Context) error</code></p><p>This method deletes secrets which are no longer required.
No longer required secrets are those still existing in the system which weren&rsquo;t detected by prior <code>Generate</code> calls.
Consequently, only call <code>Cleanup</code> after you have executed <code>Generate</code> calls for all desired secrets.</p></li></ul><p>Some exemplary usages would look as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>secret, err := k.secretsManager.Generate(
    ctx,
    &amp;secrets.CertificateSecretConfig{
        Name:                        <span style=color:#a31515>&#34;my-server-secret&#34;</span>,
        CommonName:                  <span style=color:#a31515>&#34;server-abc&#34;</span>,
        DNSNames:                    []<span style=color:#2b91af>string</span>{<span style=color:#a31515>&#34;first-name&#34;</span>, <span style=color:#a31515>&#34;second-name&#34;</span>},
        CertType:                    secrets.ServerCert,
        SkipPublishingCACertificate: <span style=color:#00f>true</span>,
    },
    secretsmanager.SignedByCA(<span style=color:#a31515>&#34;my-ca&#34;</span>),
    secretsmanager.Persist(),
    secretsmanager.Rotate(secretsmanager.InPlace),
)
<span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
    <span style=color:#00f>return</span> err
}
</code></pre></div><p>As explained above, the caller does not need to care about the rotation or the persistence of this secret - all of these concerns are handled by the secrets manager.</p><p>In case a CA certificate is needed by some component then it can be retrieved as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>caSecret, found := k.secretsManager.Get(<span style=color:#a31515>&#34;my-ca&#34;</span>)
<span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
    <span style=color:#00f>return</span> fmt.Errorf(<span style=color:#a31515>&#34;secret my-ca not found&#34;</span>)
}
</code></pre></div><p>As explained above, this returns the bundle secret for the CA <code>my-ca</code> which might potentially contain both the current and the old CA (in case of rotation/regeneration).</p><h2 id=reusing-the-secretsmanager-in-other-components>Reusing the SecretsManager in Other Components</h2><p>While the <code>SecretsManager</code> is primarily used by gardenlet, it can be reused by other components (e.g. extensions) as well for managing secrets that are specific to the component or extension. For example, provider extensions might use their own <code>SecretsManager</code> instance for managing the serving certificate of <code>cloud-controller-manager</code>.</p><p>External components that want to reuse the <code>SecretsManager</code> should consider the following aspects:</p><ul><li>On initialization of a <code>SecretsManager</code>, pass an <code>identity</code> specific to the component, for example the extension name (gardenlet uses <code>gardenlet</code> as the <code>SecretsManager</code>&rsquo;s identity).
The given identity is added as a value for the <code>manager-identity</code> label on managed <code>Secret</code>s.
This label is used by the <code>Cleanup</code> function to select only those <code>Secret</code>s that are actually managed by the particular <code>SecretManager</code> instance. This is done to prevent removing still needed <code>Secret</code>s that are managed by other instances.</li><li>Generate dedicated CAs for signing certificates instead of depending on CAs managed by gardenlet.</li><li>Names of <code>Secret</code>s managed by external <code>SecretsManager</code> instances must not conflict with <code>Secret</code> names from other instances (e.g. gardenlet).</li><li>For CAs that should be rotated in lock-step with the Shoot CAs managed by gardenlet, components need to pass information about the last rotation initiation time and the current rotation phase to the <code>SecretsManager</code> upon initialization.
The relevant information can be retrieved from the <code>Cluster</code> resource under <code>.spec.shoot.status.credentials.rotation.certificateAuthorities</code>.</li><li>Independent of the specific identity, secrets marked with the <code>Persist</code> option are automatically saved in the <code>ShootState</code> resource by gardenlet and are also restored by gardenlet on Control Plane Migration to the new Seed.</li></ul><h2 id=implementation-details>Implementation Details</h2><p>The source of truth for the secrets manager is the list of <code>Secret</code>s in the Kubernetes cluster it acts upon (typically, the seed cluster).
The persisted secrets in the <code>ShootState</code> are only used if and only if the shoot is in the <code>Restore</code> phase - in this case all secrets are just synced to the seed cluster so that they can be picked up by the secrets manager.</p><p>In order to prevent kubelets from unneeded watches (thus, causing some significant traffic against the <code>kube-apiserver</code>), the <code>Secret</code>s are marked as immutable.
Consequently, they have a unique, deterministic name which is computed as follows:</p><ul><li>For CA secrets, the name is just exactly the name specified in the configuration (e.g., <code>ca</code>). This is for backwards-compatibility and will be dropped in a future release once all components depending on the static name have been adapted.</li><li>For all other secrets, the name specified in the configuration is used as prefix followed by an 8-digit hash. This hash is computed out of the checksum of the secret configuration and the checksum of the certificate of the signing CA (only for certificate configurations).</li></ul><p>In all cases, the name of the secrets is suffixed with a 5-digit hash computed out of the time when the rotation for this secret was last started.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-23d6dea7b372c9f66b2ff9c33cb18db8>4.13 - Seed Network Policies</h1><h1 id=network-policies-in-the-seed-cluster>Network Policies in the Seed Cluster</h1><p>This document describes the <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>Kubernetes network policies</a> deployed by Gardener into the Seed cluster.
For network policies deployed into the Shoot <code>kube-system</code> namespace, please see the <a href=/docs/gardener/usage/shoot_network_policies/>usage section</a>.</p><p>Network policies deployed by Gardener have names and annotations describing their purpose, so this document does only highlight a subset of the policies in detail.</p><h2 id=network-policies-in-the-shoot-namespace-in-the-seed>Network policies in the Shoot namespace in the Seed</h2><p>The network policies in the Shoot namespace in the Seed can roughly be grouped into policies required for the control plane components and for logging & monitoring.</p><p>The network policy <code>deny-all</code> plays a special role. This policy <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic>denies all ingress and egress traffic</a> from each pod in the Shoot namespace.
So per default, a pod running in the control plane cannot talk to any other pod in the whole Seed cluster.
This means the pod needs to have labels matching to appropriate network policies allowing it to talk to exactly the components required to execute its desired functionality.
<a href=#implications-for-gardener-extensions>This has also implications for Gardener extensions</a> that need to deploy additional components into the <code>Shoot's</code> control plane.</p><h3 id=network-policies-for-control-plane-components>Network Policies for Control Plane Components</h3><p>This section highlights a selection of network policies that exist in the Shoot namespace in the Seed cluster.
In general, the control plane components serve different purposes and thus need access to different pods and network ranges.</p><p>In contrast to other network policies, the policy <code>allow-to-shoot-networks</code> is tailored to the individual Shoot cluster,
because it is based on the network configuration in the Shoot manifest.
It allows pods with the label <code>networking.gardener.cloud/to-shoot-networks=allowed</code> to access pods in the Shoot pod,
service and node CIDR range. This is used by the Shoot API Server and the prometheus pods to communicate over VPN/proxy with pods in the Shoot cluster.</p><p>The policy <code>allow-to-blocked-cidrs</code> allows pods with the label <code>networking.gardener.cloud/to-blocked-cidrs=allowed</code> to access IPs that are explicitly blocked for all control planes in a Seed cluster (configurable via <code>spec.networks.blockCIDRS</code>).
This is used for instance to block the cloud provider&rsquo;s metadata service.</p><p>Another network policy to be highlighted is <code>allow-to-seed-apiserver</code>.
Some components need access to the Seed API Server. This can be allowed by labeling the pod with <code>networking.gardener.cloud/to-seed-apiserver=allowed</code>.
This policy allows exactly the IPs of the <code>kube-apiserver</code> of the Seed.
While all other policies have a static set of permissions (do not change during the lifecycle of the Shoot), the policy <code>allow-to-seed-apiserver</code> is reconciled to reflect the endpoints in the <code>default</code> namespace.
This is required because endpoint IPs are not necessarily stable (think of scaling the Seed API Server pods or hibernating the Seed cluster (acting as a managed seed) in a local development environment).</p><p>Furthermore, the following network policies exist in the Shoot namespace.
These policies are the same for every Shoot control plane.</p><pre><code>NAME                              POD-SELECTOR      
# Pods that need to access the Shoot API server. Used by all Kubernetes control plane components.
allow-to-shoot-apiserver          networking.gardener.cloud/to-shoot-apiserver=allowed

# allows access to kube-dns/core-dns pods for DNS queries                       
allow-to-dns                      networking.gardener.cloud/to-dns=allowed

# allows access to private IP address ranges 
allow-to-private-networks         networking.gardener.cloud/to-private-networks=allowed

# allows access to all but private IP address ranges 
allow-to-public-networks          networking.gardener.cloud/to-public-networks=allowed

# allows Ingress to etcd pods from the Shoot's Kubernetes API Server
allow-etcd                        app=etcd-statefulset,garden.sapcloud.io/role=controlplane

# used by the Shoot API server to allows ingress from pods labeled
# with'networking.gardener.cloud/to-shoot-apiserver=allowed', from Prometheus, and allows Egress to etcd pods
allow-kube-apiserver              app=kubernetes,gardener.cloud/role=controlplane,role=apiserver
</code></pre><h3 id=network-policies-for-logging--monitoring>Network policies for Logging & Monitoring</h3><p>Gardener currently introduces a logging stack based on <a href=https://github.com/grafana/loki>Loki</a>. So this section is subject to change.
Please checkout <a href="https://www.youtube.com/watch?v=345b8xCcB-U&t=1166s">the Community Meeting for more information</a>.</p><p>These are the logging and monitoring related network policies:</p><pre><code>NAME                              POD-SELECTOR                                                             
allow-from-prometheus             networking.gardener.cloud/from-prometheus=allowed
allow-grafana                     component=grafana,gardener.cloud/role=monitoring
allow-prometheus                  app=prometheus,gardener.cloud/role=monitoring,role=monitoring
allow-to-aggregate-prometheus     networking.gardener.cloud/to-aggregate-prometheus=allowed
allow-to-loki                     networking.gardener.cloud/to-loki=allowed
</code></pre><p>Let&rsquo;s take for instance a look at the network policy <code>from-prometheus</code>.
As part of the shoot reconciliation flow, Gardener deploys a shoot-specific Prometheus into the shoot namespace.
Each pod that should be scraped for metrics must be labeled with <code>networking.gardener.cloud/from-prometheus=allowed</code> to allow incoming network requests by the prometheus pod.
Most components of the Shoot cluster&rsquo;s control plane expose metrics and are therefore labeled appropriately.</p><h3 id=implications-for-gardener-extensions>Implications for Gardener Extensions</h3><p>Gardener extensions sometimes need to deploy additional components into the Shoot namespace in the Seed hosting the control plane.
For example the Gardener extension <a href=https://github.com/gardener/gardener-extension-provider-aws>provider-aws</a> deploys the <code>MachineControllerManager</code> into the Shoot namespace, that is ultimately responsible to create the VMs with the cloud provider AWS.</p><p>Every Shoot namespace in the Seed contains the network policy <code>deny-all</code>.
This requires a pod deployed by a Gardener extension to have labels from network policies, that exist in the Shoot namespace, that allow the required network ranges.</p><p>Additionally, extensions could also deploy their own network policies. This is used e.g by the Gardener extension <a href=https://github.com/gardener/gardener-extension-provider-aws>provider-aws</a>
to serve <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>Admission Webhooks</a> for the Shoot API server that need to be reachable from within the Shoot namespace.</p><p>The pod can use an arbitrary combination of network policies.</p><h2 id=network-policies-in-the-garden-namespace>Network policies in the <code>garden</code> namespace</h2><p>The network policies in the <code>garden</code> namespace are, with a few exceptions (e.g Kubernetes control plane specific policies), the same as in the Shoot namespaces.
For your reference, these are all the deployed network policies.</p><pre><code>NAME                              POD-SELECTOR  
allow-fluentbit                   app=fluent-bit,gardener.cloud/role=logging,role=logging              
allow-from-aggregate-prometheus   networking.gardener.cloud/from-aggregate-prometheus=allowed              
allow-to-aggregate-prometheus     networking.gardener.cloud/to-aggregate-prometheus=allowed                
allow-to-all-shoot-apiservers     networking.gardener.cloud/to-all-shoot-apiservers=allowed                
allow-to-blocked-cidrs            networking.gardener.cloud/to-blocked-cidrs=allowed                       
allow-to-dns                      networking.gardener.cloud/to-dns=allowed                                 
allow-to-loki                     networking.gardener.cloud/to-loki=allowed                       
allow-to-private-networks         networking.gardener.cloud/to-private-networks=allowed                    
allow-to-public-networks          networking.gardener.cloud/to-public-networks=allowed                     
allow-to-seed-apiserver           networking.gardener.cloud/to-seed-apiserver=allowed                      
deny-all                          networking.gardener.cloud/to-all=disallowed                              
</code></pre><p>This section describes the network policies that are unique to the <code>garden</code> namespace.</p><p>The network policy <code>allow-to-all-shoot-apiservers</code> allows pods to access every <code>Shoot</code> API server in the <code>Seed</code>.
This is for instance used by the <a href=https://github.com/gardener/dependency-watchdog>dependency watchdog</a> to regularly check
the health of all the Shoot API servers.</p><p><a href=/docs/gardener/extensions/logging-and-monitoring/#monitoring>Gardener deploys a central Prometheus instance</a> in the <code>garden</code> namespace that fetches metrics and data from all seed cluster nodes and all seed cluster pods.
The network policies <code>allow-to-aggregate-prometheus</code> and <code>allow-from-aggregate-prometheus</code> allow traffic from and to this prometheus instance.</p><p>Worth mentioning is, that the network policy <code>allow-to-shoot-networks</code> does not exist in the <code>garden</code> namespace. This is to forbid Gardener system components to talk to workload deployed in the Shoot VPC.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b3aa3f61ef7670f29a90ef82a24cb955>4.14 - Testing</h1><h1 id=testing>Testing</h1><h2 id=unit-tests>Unit Tests</h2><p>We follow the BDD-style testing principles and are leveraging the <a href=https://onsi.github.io/ginkgo/>Ginkgo</a> framework along with <a href=http://onsi.github.io/gomega/>Gomega</a> as matcher library. In order to execute the existing tests, you can use</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test         <span style=color:green># runs tests</span>
make verify       <span style=color:green># runs static code checks and tests (unit and integration)</span>
</code></pre></div><p>There is an additional command for analyzing the code coverage of the tests. Ginkgo will generate standard Go cover profiles which will be translated into an HTML file by the <a href=https://blog.golang.org/cover>Go Cover Tool</a>. Another command helps you to clean up the filesystem from the temporary cover profile files and the HTML report:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test-cov
open gardener.coverage.html
make test-cov-clean
</code></pre></div><h2 id=integration-tests-envtests>Integration Tests (envtests)</h2><p>Integration tests in Gardener use the <code>sigs.k8s.io/controller-runtime/pkg/envtest</code> package.
It sets up a temporary control plane (etcd + kube-apiserver) and runs the test against it.
The <code>test-integration</code> make rule prepares the environment automatically by downloading the respective binaries (if not yet present) and sets the necessary environment variables.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make test-integration
</code></pre></div><p>If you want to run a specific set of integration tests, you can also execute them using <code>./hack/test-integration.sh</code> directly instead of using the <code>test-integration</code> rule. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./hack/test-integration.sh ./test/integration/resourcemanager/tokenrequestor
</code></pre></div><p>The script takes care of preparing the environment for you.
If you want to execute the test suites directly via <code>go test</code> or <code>ginkgo</code>, you have to point the <code>KUBEBUILDER_ASSETS</code> environment variable to the path that contains the etcd and kube-apiserver binaries. Alternatively, you can install the binaries to <code>/usr/local/kubebuilder/bin</code>.</p><h3 id=debugging-integration-tests>Debugging Integration Tests</h3><p>You can configure envtest to use an existing cluster instead of starting a temporary control plane for your test.
This can be helpful for debugging integration tests, because you can easily inspect what is going on in your test cluster.
For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up
export KUBECONFIG=$PWD/example/gardener-local/kind/kubeconfig
export USE_EXISTING_CLUSTER=true

<span style=color:green># run test with verbose output</span>
./hack/test-integration.sh -v ./test/integration/resourcemanager/health -ginkgo.v
</code></pre></div><h2 id=end-to-end-tests-using-provider-local>End-to-end Tests (using provider-local)</h2><p>We run a suite of e2e tests on every pull request and periodically on the <code>master</code> branch.
It uses a <a href=https://kind.sigs.k8s.io/>KinD cluster</a> and <a href=https://skaffold.dev/>skaffold</a> to boostrap a full installation of Gardener based on the current revision, including <a href=/docs/gardener/extensions/provider-local/>provider-local</a>.
This allows us to run e2e tests in an isolated test environment and fully locally without any infrastructure interaction.
The tests perform a set of operations on Shoot clusters, e.g. creating, deleting, hibernating and waking up.</p><p>These tests are executed in our prow instance at <a href=https://prow.gardener.cloud/>prow.gardener.cloud</a>, see <a href=https://github.com/gardener/ci-infra/blob/e324cb79c39c013d7f253c33690b7fcc92c001d8/config/jobs/gardener/gardener-e2e-kind.yaml>job definition</a> and <a href="https://prow.gardener.cloud/?repo=gardener%2Fgardener&job=*gardener-e2e-kind">job history</a>.</p><p>You can also run these tests on your development machine, using the following commands:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>make kind-up
export KUBECONFIG=$PWD/example/gardener-local/kind/kubeconfig
make gardener-up
make test-e2e-local  <span style=color:green># alternatively: make test-e2e-local-fast</span>
</code></pre></div><p>If you want to run a specific set of e2e test cases, you can also execute them using <code>./hack/test-e2e-local.sh</code> directly in combination with <a href=https://onsi.github.io/ginkgo/#spec-labels>ginkgo label filters</a>. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./hack/test-e2e-local.sh --label-filter <span style=color:#a31515>&#34;Shoot &amp;&amp; ca-rotation&#34;</span>
</code></pre></div><p>Also see: <a href=/docs/gardener/development/getting_started_locally/>developing Gardener locally</a> and <a href=/docs/gardener/deployment/getting_started_locally/>deploying Gardener locally</a>.</p><h2 id=test-machinery-tests>Test Machinery Tests</h2><p>Please see <a href=/docs/gardener/development/testmachinery_tests/>Test Machinery Tests</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e4015db9c3c500c41833f0a4177f9f0e>4.15 - Testmachinery Tests</h1><h1 id=test-machinery-tests>Test Machinery Tests</h1><p>In order to automatically qualify Gardener releases, we execute a set of end-to-end tests using <a href=https://github.com/gardener/test-infra>Test Machinery</a>.
This requires a full Gardener installation including infrastructure extensions as well as a setup of Test Machinery itself.
These tests operate on Shoot clusters across different Cloud Providers, using different supported Kubernetes versions and various configuration options (huge test matrix).</p><p>This manual gives an overview about test machinery tests in Gardener.</p><ul><li><a href=#structure>Structure</a></li><li><a href=#add-a-new-test>Add a new test</a></li><li><a href=#test-labels>Test Labels</a></li><li><a href=#framework>Framework</a></li></ul><h2 id=structure>Structure</h2><p>Gardener test machinery tests are split into two test suites that can be found under <a href=https://github.com/gardener/gardener/tree/master/test/testmachinery/suites><code>test/testmachinery/suites</code></a>:</p><ul><li>The <strong>Gardener Test Suite</strong> contains all tests that only require a running gardener instance.</li><li>The <strong>Shoot Test Suite</strong> contains all tests that require a predefined running shoot cluster.</li></ul><p>The corresponding tests of a test suite are defined in the import statement of the suite definition see <a href=https://github.com/gardener/gardener/blob/master/test/testmachinery/suites/shoot/run_suite_test.go><code>shoot/run_suite_test.go</code></a>
and their source code can be found under <a href=https://github.com/gardener/gardener/tree/master/test/testmachinery><code>test/testmachinery</code></a></p><p>The <code>test</code> directory is structured as follows:</p><pre><code class=language-console data-lang=console>test
├── e2e           # end-to-end tests (using provider-local)
│  └── shoot
├── framework     # helper code shared across integration, e2e and testmachinery tests
├── integration   # integration tests (envtests)
│  ├── controllermanager
│  ├── envtest
│  ├── resourcemanager
│  ├── scheduler
│  ├── seedadmissioncontroller
│  ├── shootmaintenance
│  └── ...
└── testmachinery # test machinery tests
   ├── gardener   # actual test cases imported by suites/gardener
   │  └── security
   ├── plants
   ├── shoots     # actual test cases imported by suites/shoot
   │  ├── applications
   │  ├── care
   │  ├── logging
   │  ├── operatingsystem
   │  ├── operations
   │  └── vpntunnel
   ├── suites     # suites that run agains a running garden or shoot cluster
   │  ├── gardener
   │  └── shoot
   └── system     # suites that are used for building a full test flow
      ├── complete_reconcile
      ├── managed_seed_creation
      ├── managed_seed_deletion
      ├── shoot_cp_migration
      ├── shoot_creation
      ├── shoot_deletion
      ├── shoot_hibernation
      ├── shoot_hibernation_wakeup
      └── shoot_update
</code></pre><p>A suite can be executed by running the suite definition with ginkgo&rsquo;s <code>focus</code> and <code>skip</code> flags
to control the execution of specific labeled test. See example below:</p><pre><code class=language-console data-lang=console>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/shoot \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      --disable-dump=false \                               # disables dumping of teh current state if a test fails
      -kubecfg=/path/to/gardener/kubeconfig \
      -shoot-name=&lt;shoot-name&gt; \                           # Name of the shoot to test
      -project-namespace=&lt;gardener project namespace&gt; \    # Name of the gardener project the test shoot resides
      -ginkgo.focus=&quot;\[RELEASE\]&quot; \                        # Run all tests that are tagged as release
      -ginkgo.skip=&quot;\[SERIAL\]|\[DISRUPTIVE\]&quot;             # Exclude all tests that are tagged SERIAL or DISRUPTIVE
</code></pre><h2 id=add-a-new-test>Add a new test</h2><p>To add a new test the framework requires the following steps (step 1. and 2. can be skipped if the test is added to an existing package):</p><ol><li>Create a new test file e.g. <code>test/testmachinery/shoot/security/my-sec-test.go</code></li><li>Import the test into the appropriate test suite (gardener or shoot): <code>import _ "github.com/gardener/gardener/test/testmachinery/shoot/security"</code></li><li>Define your test with the testframework. The framework will automatically add its initialization, cleanup and dump functions.</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#00f>var</span> _ = ginkgo.Describe(<span style=color:#a31515>&#34;my suite&#34;</span>, <span style=color:#00f>func</span>(){
  f := framework.NewShootFramework(<span style=color:#00f>nil</span>)

  f.Beta().CIt(<span style=color:#a31515>&#34;my first test&#34;</span>, <span style=color:#00f>func</span>(ctx context.Context) {
    f.ShootClient.Get(xx)
    <span style=color:green>// testing ...
</span><span style=color:green></span>  })
})
</code></pre></div><p>The newly created test can be tested by focusing the test with the default ginkgo focus <code>f.Beta().FCIt("my first test", func(ctx context.Context)</code>
and run the shoot test suite with:</p><pre><code>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/shoot \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      --disable-dump=false \                               # disables dumping of the current state if a test fails
      -kubecfg=/path/to/gardener/kubeconfig \
      -shoot-name=&lt;shoot-name&gt; \                           # Name of the shoot to test
      -project-namespace=&lt;gardener project namespace&gt; \
      -fenced=&lt;true|false&gt;                                 # Tested shoot is running in a fenced environment and cannot be reached by gardener
</code></pre><p>or for the gardener suite with:</p><pre><code>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/gardener \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      --disable-dump=false \                               # disables dumping of the current state if a test fails
      -kubecfg=/path/to/gardener/kubeconfig \
      -project-namespace=&lt;gardener project namespace&gt;
</code></pre><p>⚠️ Make sure that you do not commit any focused specs as this feature is only intended for local development! Ginkgo will fail the test suite if there are any focused specs.</p><p>Alternatively, a test can be triggered by specifying a ginkgo focus regex with the name of the test e.g.</p><pre><code>go test -timeout=0 -mod=vendor ./test/testmachinery/suites/gardener \
      --v -ginkgo.v -ginkgo.progress -ginkgo.no-color \
      --report-file=/tmp/report.json \                     # write elasticsearch formatted output to a file
      -kubecfg=/path/to/gardener/kubeconfig \
      -project-namespace=&lt;gardener project namespace&gt; \
      -ginkgo.focus=&quot;my first test&quot;                        # regex to match test cases
</code></pre><h2 id=test-labels>Test Labels</h2><p>Every test should be labeled by using the predefined labels available with every framework to have consistent labeling across
all test machinery tests.</p><p>The labels are applied to every new <code>It()/CIt()</code> definition by:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang>f := framework.NewCommonFramework()
f.Default().Serial().It(<span style=color:#a31515>&#34;my test&#34;</span>) =&gt; <span style=color:#a31515>&#34;[DEFAULT] [SERIAL] my test&#34;</span>

f := framework.NewShootFramework()
f.Default().Serial().It(<span style=color:#a31515>&#34;my test&#34;</span>) =&gt; <span style=color:#a31515>&#34;[DEFAULT] [SERIAL] [SHOOT] my test&#34;</span>

f := framework.NewGardenerFramework()
f.Default().Serial().It(<span style=color:#a31515>&#34;my test&#34;</span>) =&gt; <span style=color:#a31515>&#34;[DEFAULT] [GARDENER] [SERIAL] my test&#34;</span>
</code></pre></div><p>Labels:</p><ul><li><em>Beta</em>: Newly created tests with no experience on stableness should be first labeled as beta tests.
They should be watched (and probably improved) until stable enough to be promoted to <em>Default</em>.</li><li><em>Default</em>: Tests that were <em>Beta</em> before and proved to be stable are promoted to <em>Default</em> eventually.
<em>Default</em> tests run more often, produce alerts and are <em>considered</em> during the release decision although they don&rsquo;t necessarily block a release.</li><li><em>Release</em>: Test are release relevant. A failing <em>Release</em> test blocks the release pipeline.
Therefore these tests need to be stable. Only tests proven to be stable will eventually be promoted to <em>Release</em>.</li></ul><p>Behavior Labels:</p><ul><li><em>Serial</em>: The test should always be executed in serial with no other tests running as it may impact other tests.</li><li><em>Destructive</em>: The test is destructive. Which means that is runs with no other tests and may break gardener or the shoot.
Only create such tests if really necessary as the execution will be expensive (neither gardener nor the shoot can be reused in this case for other tests).</li></ul><h2 id=framework>Framework</h2><p>The framework directory contains all the necessary functions / utilities for running test machinery tests.
For example, there are methods for creation/deletion of shoots, waiting for shoot deletion/creation, downloading/installing/deploying helm charts, logging, etc.</p><p>The framework itself consists of 3 different framework that expect different prerequisites and offer context specific functionality.</p><ul><li><strong>CommonFramework</strong>: The common framework is the base framework that handles logging and setup of commonly needed resources like helm.
It also contains common functions for interacting with kubernetes clusters like <code>Waiting for resources to be ready</code> or <code>Exec into a running pod</code>.</li><li><strong>GardenerFramework</strong> contains all functions of the common framework and expects a running gardener instance with the provided gardener kubeconfig and a project namespace.
It also contains functions to interact with gardener like <code>Waiting for a shoot to be reconciled</code> or <code>Patch a shoot</code> or <code>Get a seed</code>.</li><li><strong>ShootFramework</strong>: contains all functions of the common and the gardener framework.
It expects a running shoot cluster defined by the shoot&rsquo;s name and namespace(project namespace).
This framework contains functions to directly interact with the specific shoot.</li></ul><p>The whole framework also includes commonly used checks, ginkgo wrapper, etc. as well as commonly used tests.
Theses common application tests (like the guestbook test) can be used within multiple tests to have a default application (with ingress, deployment, stateful backend) to test external factors.</p><p><strong>Config</strong></p><p>Every framework commandline flag can also be defined by a configuration file (the value of the configuration file is only used if flag is not specified by commandline).
The test suite searches for a configuration file (yaml is preferred) if the command line flag <code>--config=/path/to/config/file</code> is provided.
A framework can be defined in the configuration file by just using the flag name as root key e.g.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>verbose: debug
kubecfg: /kubeconfig/path
project-namespace: garden-it
</code></pre></div><p><strong>Report</strong></p><p>The framework automatically writes the default ginkgo default report to stdout and a specifically structured elastichsearch bulk report file to a specified location.
The elastichsearch bulk report will write one json document per testcase and injects metadata of the whole testsuite.
An example document for one test case would look like the following document:</p><pre><code>{
    &quot;suite&quot;: {
        &quot;name&quot;: &quot;Shoot Test Suite&quot;,
        &quot;phase&quot;: &quot;Succeeded&quot;,
        &quot;tests&quot;: 3,
        &quot;failures&quot;: 1,
        &quot;errors&quot;: 0,
        &quot;time&quot;: 87.427
    },
    &quot;name&quot;: &quot;Shoot application testing  [DEFAULT] [RELEASE] [SHOOT] should download shoot kubeconfig successfully&quot;,
    &quot;shortName&quot;: &quot;should download shoot kubeconfig successfully&quot;,
    &quot;labels&quot;: [
        &quot;DEFAULT&quot;,
        &quot;RELEASE&quot;,
        &quot;SHOOT&quot;
    ],
    &quot;phase&quot;: &quot;Succeeded&quot;,
    &quot;time&quot;: 0.724512057
}
</code></pre><p><strong>Resources</strong></p><p>The resources directory contains all the templates, helm config files (e.g., repositories.yaml, charts, and cache index which are downloaded upon the start of the test), shoot configs, etc.</p><pre><code class=language-console data-lang=console>resources
├── charts
├── repository
│   └── repositories.yaml
└── templates
    ├── guestbook-app.yaml.tpl
    └── logger-app.yaml.tpl
</code></pre><p>There are two special directories that are dynamically filled with the correct test files:</p><ul><li><strong>charts:</strong> the charts will be downloaded and saved in this directory</li><li><strong>repository</strong> contains the repository.yaml file that the target helm repos will be read from and the cache where the <code>stable-index.yaml</code> file will be created</li></ul><h3 id=system-tests>System Tests</h3><p>This directory contains the system tests that have a special meaning for the testmachinery with their own Test Definition.
Currently these system tests consists of:</p><ul><li>Shoot creation</li><li>Shoot deletion</li><li>Shoot Kubernetes update</li><li>Gardener Full reconcile check</li></ul><h4 id=shoot-creation-test>Shoot Creation test</h4><p>Create Shoot test is meant to test shoot creation.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 ./test/testmachinery/system/shoot_creation \
  --v -ginkgo.v -ginkgo.progress \
  -kubecfg=$HOME/.kube/config \
  -shoot-name=$SHOOT_NAME \
  -cloud-profile=$CLOUDPROFILE \
  -seed=$SEED \
  -secret-binding=$SECRET_BINDING \
  -provider-type=$PROVIDER_TYPE \
  -region=$REGION \
  -k8s-version=$K8S_VERSION \
  -project-namespace=$PROJECT_NAMESPACE \
  -annotations=$SHOOT_ANNOTATIONS \
  -infrastructure-provider-config-filepath=$INFRASTRUCTURE_PROVIDER_CONFIG_FILEPATH \
  -controlplane-provider-config-filepath=$CONTROLPLANE_PROVIDER_CONFIG_FILEPATH \
  -workers-config-filepath=$$WORKERS_CONFIG_FILEPATH \
  -worker-zone=$ZONE \
  -networking-pods=$NETWORKING_PODS \
  -networking-services=$NETWORKING_SERVICES \
  -networking-nodes=$NETWORKING_NODES \
  -start-hibernated=$START_HIBERNATED
</code></pre><h4 id=shoot-deletion-test>Shoot Deletion test</h4><p>Delete Shoot test is meant to test the deletion of a shoot.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 -ginkgo.v -ginkgo.progress \
  ./test/testmachinery/system/shoot_deletion \
  -kubecfg=$HOME/.kube/config \
  -shoot-name=$SHOOT_NAME \
  -project-namespace=$PROJECT_NAMESPACE
</code></pre><h4 id=shoot-update-test>Shoot Update test</h4><p>The Update Shoot test is meant to test the kubernetes version update of a existing shoot.
If no specific version is provided the next patch version is automatically selected.
If there is no available newer version this test is a noop.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 ./test/testmachinery/system/shoot_update \
  --v -ginkgo.v -ginkgo.progress \
  -kubecfg=$HOME/.kube/config \
  -shoot-name=$SHOOT_NAME \
  -project-namespace=$PROJECT_NAMESPACE \
  -version=$K8S_VERSION
</code></pre><h4 id=gardener-full-reconcile-test>Gardener Full Reconcile test</h4><p>The Gardener Full Reconcile test is meant to test if all shoots of a gardener instance are successfully reconciled.</p><p><strong>Example Run</strong></p><pre><code class=language-console data-lang=console>go test -mod=vendor -timeout=0 ./test/testmachinery/system/complete_reconcile \
  --v -ginkgo.v -ginkgo.progress \
  -kubecfg=$HOME/.kube/config \
  -project-namespace=$PROJECT_NAMESPACE \
  -gardenerVersion=$GARDENER_VERSION # needed to validate the last acted gardener version of a shoot
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-06612ee007f8c645961e7f6c98417686>5 - Extensions</h1></div><div class=td-content><h1 id=pg-976400864159d95d6036cf8762b0583b>5.1 - Admission</h1><h1 id=extension-admission>Extension Admission</h1><p>The extensions are expected to validate their respective resources for their extension specific configurations, when the resources are newly created or updated. For example, <a href=https://github.com/gardener/gardener/blob/master/extensions/README.md#infrastructure-provider>provider extensions</a> would validate <code>spec.provider.infrastructureConfig</code> and <code>spec.provider.controlPlaneConfig</code> in the <code>Shoot</code> resource and <code>spec.providerConfig</code> in the <code>CloudProfile</code> resource, <a href=https://github.com/gardener/gardener/blob/master/extensions/README.md#network-plugin>networking extensions</a> would validate <code>spec.networking.providerConfig</code> in the <code>Shoot</code> resource. As best practice, the validation should be performed only if there is a change in the <code>spec</code> of the resource. Please find an exemplary implementation <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/admission/validator>here</a>.</p><p>When a resource is newly created or updated, Gardener adds an extension label for all the extension types referenced in the <code>spec</code> of the resource. This label is of the form <code>&lt;extension-type>.extensions.gardener.cloud/&lt;extension-name> : "true"</code>. For example, an extension label for provider extension type <code>aws</code>, looks like <code>provider.extensions.gardener.cloud/aws : "true"</code>. The extensions should add object selectors in their admission webhooks for these labels, to filter out the objects they are responsible for. At present, these labels are added to <code>BackupEntry</code>s, <code>BackupBucket</code>s, <code>CloudProfile</code>s, <code>Seed</code>s, and <code>Shoot</code>s. Please see <a href=https://github.com/gardener/gardener/tree/master/pkg/apis/core/v1beta1/constants/types_constants.go>this</a> for the full list of extension labels.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-14974039d50fb15810aafaf28cbdcf7d>5.2 - Backupbucket</h1><h1 id=contract-backupbucket-resource>Contract: <code>BackupBucket</code> resource</h1><p>The Gardener project features a sub-project called <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a> to take periodic backups of etcd backing Shoot clusters. It demands the bucket (or its equivalent in different object store providers) to be created and configured externally with appropriate credentials. The <code>BackupBucket</code> resource takes this responsibility in Gardener.</p><p>Before introducing the <code>BackupBucket</code> extension resource Gardener was using Terraform in order to create and manage these provider-specific resources (e.g., see <a href=https://github.com/gardener/gardener/tree/0.27.0/charts/seed-terraformer/charts/aws-backup>here</a>).
Now, Gardener commissions an external, provider-specific controller to take over this task. You can also refer to backupInfra proposal documentation to get idea about how the transition was done and understand the resource in broader scope.</p><h2 id=what-is-the-scope-of-bucket>What is the scope of bucket?</h2><p>A bucket will be provisioned per <code>Seed</code>. So, backup of every <code>Shoot</code> created on that <code>Seed</code> will be stored under different shoot specific prefix under the bucket.
For the backup of the <code>Shoot</code> rescheduled on different <code>Seed</code> it will continue to use the same bucket.</p><h2 id=what-is-the-lifespan-of-backupbucket>What is the lifespan of <code>BackupBucket</code>?</h2><p>The bucket associated with <code>BackupBucket</code> will be created at creation of <code>Seed</code>. And as per current implementation, it will be deleted on deletion of <code>Seed</code> and there isn&rsquo;t any <code>BackupEntry</code> resource associated with it.</p><p>In the future, we plan to introduce schedule for <code>BackupBucket</code> the deletion logic for <code>BackupBucket</code> resource, which will reschedule the it on different available <code>Seed</code>, on deletion or failure of health check for current associated <code>seed</code>. In that case, <code>BackupBucket</code> will be deleted only if there isn&rsquo;t any schedulable <code>Seed</code> available and there isn&rsquo;t any associated <code>BackupEntry</code> resource.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?</h2><p>As part of the seed flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: BackupBucket
metadata:
  name: foo
spec:
  type: azure
  providerConfig:
    &lt;some-optional-provider-specific-backupbucket-configuration&gt;
  region: eu-west-1
  secretRef:
    name: backupprovider
    namespace: shoot--foo--bar
</code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed resources. This provider secret will be configured
by Gardener operator in the <code>Seed</code> resource and propagated over there by seed controller.</p><p>After your controller has created the required bucket, if required it generates the secret to access the objects in buckets and put reference to it in <code>status</code>. This secret is
supposed to be used by Gardener or eventually <code>BackupEntry</code> resource and etcd-backup-restore component to backup the etcd.</p><p>In order to support a new infrastructure provider you need to write a controller that watches all <code>BackupBucket</code>s with <code>.spec.type=&lt;my-provider-name></code>. You can take a look at the below referenced example implementation for the Azure provider.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=/docs/gardener/api-reference/extensions/#backupbucket><code>BackupBucket</code> API Reference</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/backupbucket>Exemplary implementation for the Azure provider</a></li><li><a href=/docs/gardener/extensions/backupentry/><code>BackupEntry</code> resource documentation</a></li><li><a href=/docs/gardener/proposals/02-backupinfra/>Shared bucket proposal</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b1fda6ecdcfcb6e58a7f82c09b95f838>5.3 - Backupentry</h1><h1 id=contract-backupentry-resource>Contract: <code>BackupEntry</code> resource</h1><p>The Gardener project features a sub-project called <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a> to take periodic backups of etcd backing Shoot clusters. It demands the bucket (or its equivalent in different object store providers) access credentials to be created and configured externally with appropriate credentials. The <code>BackupEntry</code> resource takes this responsibility in Gardener to provide this information by creating a secret specific to the component. Said that, the core motivation for introducing this resource was to support retention of backups post deletion of <code>Shoot</code>. The etcd-backup-restore components takes responsibility of garbage collecting old backups out of the defined period. Once a shoot is deleted, we need to persist the backups for few days. Hence, Gardener uses the <code>BackupEntry</code> resource for this housekeeping work post deletion of a <code>Shoot</code>. The <code>BackupEntry</code> resource is responsible for shoot specific prefix under referred bucket.</p><p>Before introducing the <code>BackupEntry</code> extension resource Gardener was using Terraform in order to create and manage these provider-specific resources (e.g., see <a href=https://github.com/gardener/gardener/tree/0.27.0/charts/seed-terraformer/charts/aws-backup>here</a>).
Now, Gardener commissions an external, provider-specific controller to take over this task. You can also refer to backupInfra proposal documentation to get idea about how the transition was done and understand the resource in broader scope.</p><h2 id=what-is-the-lifespan-of-backupentry>What is the lifespan of <code>BackupEntry</code>?</h2><p>The bucket associated with <code>BackupEntry</code> will be created at using <code>BackupBucket</code> resource. The <code>BackupEntry</code> resource will be created as a part of a <code>Shoot</code> creation. But resource might continue to exist post deletion of a <code>Shoot</code> (see <a href=/docs/gardener/concepts/gardenlet/#backupentry-controller>this</a> for more details).</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: BackupEntry
metadata:
  name: shoot--foo--bar
spec:
  type: azure
  providerConfig:
    &lt;some-optional-provider-specific-backup-bucket-configuration&gt;
  backupBucketProviderStatus:
    &lt;some-optional-provider-specific-backup-bucket-status&gt;
  region: eu-west-1
  bucketName: foo
  secretRef:
    name: backupprovider
    namespace: shoot--foo--bar
</code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed resources. This provider secret will be propagated from <code>BackupBucket</code> resource by Shoot controller.</p><p>Your controller is supposed to create the <code>etcd-backup</code> secret in control-plane namespace of a shoot. This secret is supposed to be used by Gardener or eventually the etcd-backup-restore component to backup the etcd. The controller implementation should cleanup the objects created under shoot specific prefix in bucket equivalent to name of <code>BackupEntry</code> resource.</p><p>In order to support a new infrastructure provider you need to write a controller that watches all <code>BackupBucket</code>s with <code>.spec.type=&lt;my-provider-name></code>. You can take a look at the below referenced example implementation for the Azure provider.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=/docs/gardener/api-reference/extensions/#backupbucket><code>BackupEntry</code> API Reference</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/backupentry>Exemplary implementation for the Azure provider</a></li><li><a href=/docs/gardener/extensions/backupbucket/><code>BackupBucket</code> resource documentation</a></li><li><a href=/docs/gardener/proposals/02-backupinfra/>Shared bucket proposal</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/controllermanager/apis/config/types.go#L101-%23L107>Gardener-controller-manager-component-config API specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-852c52090550872df673db8e9fb654ba>5.4 - Bastion</h1><h1 id=contract-bastion-resource>Contract: <code>Bastion</code> resource</h1><p>The Gardener project allows users to connect to Shoot worker nodes via SSH. As nodes are usually firewalled and not directly accessible from the public internet, <a href=/docs/gardener/proposals/15-manage-bastions-and-ssh-key-pair-rotation/>GEP-15</a> introduced the concept of &ldquo;Bastions&rdquo;. A bastion is a dedicated server that only serves to allow SSH ingress to the worker nodes.</p><p><code>Bastion</code> resources contain the user&rsquo;s public SSH key and IP address, in order to provision the server accordingly: The public key is put onto the Bastion and SSH ingress is only authorized for the given IP address (in fact, it&rsquo;s not a single IP address, but a set of IP ranges, however for most purposes a single IP is be used).</p><h2 id=what-is-the-lifespan-of-bastion>What is the lifespan of <code>Bastion</code>?</h2><p>Once a <code>Bastion</code> has been created in the garden, it will be replicated to the appropriate seed cluster, where a controller then reconciles a server and firewall rules etc. on the cloud provider used by the target Shoot. When the Bastion is ready (i.e. has a public IP), that IP is stored in the <code>Bastion</code>&rsquo;s status and from there is picked up by the garden cluster and <code>gardenctl</code> eventually.</p><p>To make multiple SSH sessions possible, the existence of the <code>Bastion</code> is not directly tied to the execution of <code>gardenctl</code>: users can exit out of <code>gardenctl</code> and use <code>ssh</code> manually to connect to the bastion and worker nodes.</p><p>However, <code>Bastion</code>s have an expiry date, after which they will be garbage collected.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Bastion
metadata:
  name: mybastion
  namespace: shoot--foo--bar
spec:
  type: aws
  <span style=color:green># userData is base64-encoded cloud provider user data; this contains the</span>
  <span style=color:green># user&#39;s SSH key</span>
  userData: IyEvYmluL2Jhc2ggL....Nlcgo=
  ingress:
    - ipBlock:
        cidr: 192.88.99.0/32 <span style=color:green># this is most likely the user&#39;s IP address</span>
</code></pre></div><p>Your controller is supposed to create a new instance at the given cloud provider, firewall it to only allow SSH (TCP port 22) from the given IP blocks, and then to configure the firewall for the worker nodes to allow SSH from the bastion instance. When a <code>Bastion</code> is deleted, all these changes need to be reverted.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=/docs/gardener/api-reference/extensions/#bastion><code>Bastion</code> API Reference</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/bastion>Exemplary implementation for the AWS provider</a></li><li><a href=/docs/gardener/proposals/15-manage-bastions-and-ssh-key-pair-rotation/>GEP-15</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1dcf839b2e87160673811784e7578d4a>5.5 - Cluster</h1><h1 id=cluster-resource><code>Cluster</code> resource</h1><p>As part of the extensibility epic a lot of responsibility that was previously taken over by Gardener directly has now been shifted to extension controllers running in the seed clusters.
These extensions often serve a well-defined purpose, e.g. the management of <a href=/docs/gardener/extensions/dns/>DNS records</a>, <a href=/docs/gardener/extensions/infrastructure/>infrastructure</a>, etc.
We have introduced a couple of extension CRDs in the seeds whose specification is written by Gardener, and which are acted up by the extensions.</p><p>However, the extensions sometimes require more information that is not directly part of the specification.
One example of that is the GCP infrastructure controller which needs to know the shoot&rsquo;s pod and service network.
Another example is the Azure infrastructure controller which requires some information out of the <code>CloudProfile</code> resource.
The problem is that Gardener does not know which extension requires which information so that it can write it into their specific CRDs.</p><p>In order to deal with this problem we have introduced the <code>Cluster</code> extension resource.
This CRD is written into the seeds, however, it does not contain a <code>status</code>, so it is not expected that something acts upon it.
Instead, you can treat it like a <code>ConfigMap</code> which contains data that might be interesting for you.
In the context of Gardener, seeds and shoots, and extensibility the <code>Cluster</code> resource contains the <code>CloudProfile</code>, <code>Seed</code>, and <code>Shoot</code> manifest.
Extension controllers can take whatever information they want out of it that might help completing their individual tasks.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---

apiVersion: extensions.gardener.cloud/v1alpha1
kind: Cluster
metadata:
  name: shoot--foo--bar
spec:
  cloudProfile:
    apiVersion: core.gardener.cloud/v1beta1
    kind: CloudProfile
    ...
  seed:
    apiVersion: core.gardener.cloud/v1beta1
    kind: Seed
    ...
  shoot:
    apiVersion: core.gardener.cloud/v1beta1
    kind: Shoot
    ...
</code></pre></div><p>The resource is written by Gardener before it starts the reconciliation flow of the shoot.</p><p>⚠️ All Gardener components use the <code>core.gardener.cloud/v1beta1</code> version, i.e., the <code>Cluster</code> resource will contain the objects in this version.</p><h2 id=important-information-that-should-be-taken-into-account>Important information that should be taken into account</h2><p>There are some fields in the <code>Shoot</code> specification that might be interesting to take into account.</p><ul><li><code>.spec.hibernation.enabled={true,false}</code>: Extension controllers might want to behave differently if the shoot is hibernated or not (probably they might want to scale down their control plane components, for example).</li><li><code>.status.lastOperation.state=Failed</code>: If Gardener sets the shoot&rsquo;s last operation state to <code>Failed</code> it means that Gardener won&rsquo;t automatically retry to finish the reconciliation/deletion flow because an error occurred that could not be resolved within the last <code>24h</code> (default). In this case end-users are expected to manually re-trigger the reconciliation flow in case they want Gardener to try again. Extension controllers are expected to follow the same principle. This means they have to read the shoot state out of the <code>Cluster</code> resource.</li></ul><h2 id=extension-resources-not-associated-with-a-shoot>Extension resources not associated with a shoot</h2><p>In some cases, Gardener may create extension resources that are not associated with a shoot, but are needed to support some functionality internal to Gardener. Such resources will be created in the <code>garden</code> namespace of a seed cluster.</p><p>For example, if the <a href=/docs/gardener/deployment/deploy_gardenlet_manually/>managed ingress controller</a> is active on the seed, Gardener will create a <a href=/docs/gardener/extensions/dns/>DNSProvider / DNSEntry</a> or a <a href=/docs/gardener/extensions/dnsrecord/>DNSRecord</a> resource(s) in the <code>garden</code> namespace of the seed cluster for the ingress DNS record.</p><p>Extension controllers that may be expected to reconcile extension resources in the <code>garden</code> namespace should make sure that they can tolerate the absence of a cluster resource. This means that they should not attempt to read the cluster resource in such cases, or if they do they should ignore the &ldquo;not found&rdquo; error.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_cluster.go><code>Cluster</code> API (Golang specification)</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bd0f3158741613ba8829c3093bc71acd>5.6 - Containerruntime</h1><h1 id=gardener-container-runtime-extension>Gardener Container Runtime Extension</h1><p>At the lowest layers of a Kubernetes node is the software that, among other things, starts and stops containers. It is called “Container Runtime”.
The most widely known container runtime is Docker, but it is not alone in this space. In fact, the container runtime space has been rapidly evolving.</p><p>Kubernetes supports different container runtimes using Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes.</p><p>Gardener supports creation of Worker machines using CRI, more information can be found here: <a href=/docs/gardener/extensions/operatingsystemconfig/#cri-support>CRI Support</a>.</p><h2 id=motivation>Motivation</h2><p>Prior to the <code>Container Runtime Extensibility</code> concept, Gardener used Docker as the only
container runtime to use in shoot worker machines. Because of the wide variety of different container runtimes
offers multiple important features (for example enhanced security concepts) it is important to enable end users to use other container runtimes as well.</p><h2 id=the-containerruntime-extension-resource>The <code>ContainerRuntime</code> Extension Resource</h2><p>Here is what a typical <code>ContainerRuntime</code> resource would look-like:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: ContainerRuntime
metadata:
  name: my-container-runtime
spec:
  binaryPath: /var/bin/containerruntimes
  type: gvisor
  workerPool:
    name: worker-ubuntu
    selector:
      matchLabels:
        worker.gardener.cloud/pool: worker-ubuntu
</code></pre></div><p>Gardener deploys one <code>ContainerRuntime</code> resource per worker pool per CRI.
To exemplify this, consider a Shoot having two worker pools (<code>worker-one</code>, <code>worker-two</code>) using <code>containerd</code> as the CRI as well as <code>gvisor</code> and <code>kata</code> as enabled container runtimes.
Gardener would deploy four <code>ContainerRuntime</code> resources. For <code>worker-one</code>: one <code>ContainerRuntime</code> for type <code>gvisor</code> and one for type <code>kata</code>. The same resource are being deployed for <code>worker-two</code>.</p><h2 id=supporting-a-new-container-runtime-provider>Supporting a new Container Runtime Provider</h2><p>To add support for another container runtime (e.g., gvisor, kata-containers, etc.) a container runtime extension controller needs to be implemented. It should support Gardener&rsquo;s supported CRI plugins.</p><p>The container runtime extension should install the necessary resources into the shoot cluster (e.g., <code>RuntimeClass</code>es), and it should copy the runtime binaries to the relevant worker machines in path: <code>spec.binaryPath</code>.
Gardener labels the shoot nodes according to the CRI configured: <code>worker.gardener.cloud/cri-name=&lt;value></code> (e.g <code>worker.gardener.cloud/cri-name=containerd</code>) and multiple labels for each of the container runtimes configured for the shoot Worker machine:
<code>containerruntime.worker.gardener.cloud/&lt;container-runtime-type-value>=true</code> (e.g <code>containerruntime.worker.gardener.cloud/gvisor=true</code>).
The way to install the binaries is by creating a daemon set which copies the binaries from an image in a docker registry to the relevant labeled Worker&rsquo;s nodes (avoid downloading binaries from internet to also cater with isolated environments).</p><p>For additional reference, please have a look at the <a href=https://github.com/gardener/gardener-extension-runtime-gvisor>runtime-gvsior</a> provider extension, which provides more information on how to configure the necessary charts as well as the actuators required to reconcile container runtime inside the <code>Shoot</code> cluster to the desired state.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6a93f55712b73e1c9926ae9a1827ffc1>5.7 - Controllerregistration</h1><h1 id=registering-extension-controllers>Registering Extension Controllers</h1><p>Extensions are registered in the garden cluster via <a href=https://github.com/gardener/gardener/blob/master/example/25-controllerregistration.yaml><code>ControllerRegistration</code></a> resources.
Gardener is evaluating the registrations and creates <a href=https://github.com/gardener/gardener/blob/master/example/25-controllerinstallation.yaml><code>ControllerInstallation</code></a> resources which describe the request &ldquo;please install this controller <code>X</code> to this seed <code>Y</code>&rdquo;.</p><p>Similar to how <code>CloudProfile</code> or <code>Seed</code> resources get into the system, the Gardener administrator must deploy the <code>ControllerRegistration</code> resources (this does not happen automatically in any way - the administrator decides which extensions shall be enabled).</p><p>The specification mainly describes which of Gardener&rsquo;s extension CRDs are managed, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: ControllerDeployment
metadata:
  name: os-gardenlinux
type: helm
providerConfig:
  chart: H4sIFAAAAAAA/yk... <span style=color:green># &lt;base64-gzip-chart&gt;</span>
  values:
    foo: bar
---
apiVersion: core.gardener.cloud/v1beta1
kind: ControllerRegistration
metadata:
  name: os-gardenlinux
spec:
  deployment:
    deploymentRefs:
    - name: os-gardenlinux
  resources:
  - kind: OperatingSystemConfig
    type: gardenlinux
    primary: <span style=color:#00f>true</span>
</code></pre></div><p>This information tells Gardener that there is an extension controller that can handle <code>OperatingSystemConfig</code> resources of type <code>gardenlinux</code>.
A reference to the shown <code>ControllerDeployment</code> specifies how the deployment of the extension controller is accomplished.</p><p>Also, it specifies that this controller is the primary one responsible for the lifecycle of the <code>OperatingSystemConfig</code> resource.
Setting <code>primary</code> to <code>false</code> would allow to register additional, secondary controllers that may also watch/react on the <code>OperatingSystemConfig/coreos</code> resources, however, only the primary controller may change/update the main <code>status</code> of the extension object (that are used to &ldquo;communicate&rdquo; with the Gardenlet).
Particularly, only the primary controller may set <code>.status.lastOperation</code>, <code>.status.lastError</code>, <code>.status.observedGeneration</code>, and <code>.status.state</code>.
Secondary controllers may contribute to the <code>.status.conditions[]</code> if they like, of course.</p><p>Secondary controllers might be helpful in scenarios where additional tasks need to be completed which are not part of the reconciliation logic of the primary controller but separated out into a dedicated extension.</p><p>⚠️ There must be exactly one primary controller for every registered kind/type combination.
Also, please note that the <code>primary</code> field cannot be changed after creation of the <code>ControllerRegistration</code>.</p><h2 id=deploying-extension-controllers>Deploying Extension Controllers</h2><p>Submitting above <code>ControllerDeployment</code> and <code>ControllerRegistration</code> will create a <code>ControllerInstallation</code> resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: ControllerInstallation
metadata:
  name: os-gardenlinux
spec:
  deploymentRef:
    name: networking-calico
  registrationRef:
    name: os-gardenlinux
  seedRef:
    name: aws-eu1
</code></pre></div><p>This resource expresses that Gardener requires the <code>os-gardenlinux</code> extension controller to run on the <code>aws-eu1</code> seed cluster.</p><p>The Gardener Controller Manager does automatically determine which extension is required on which seed cluster and will only create <code>ControllerInstallation</code> objects for those.
Also, it will automatically delete <code>ControllerInstallation</code>s referencing extension controllers that are no longer required on a seed (e.g., because all shoots on it have been deleted).
There are additional configuration options, please see <a href=#deployment-configuration-options>this section</a>.</p><h2 id=how-do-extension-controllers-get-deployed-to-seeds>How do extension controllers get deployed to seeds?</h2><p>After Gardener has written the <code>ControllerInstallation</code> resource some component must satisfy this request and start deploying the extension controller to the seed.
Depending on the complexity of the controller&rsquo;s lifecycle management, configuration, etc. there are two possible scenarios:</p><h3 id=scenario-1-deployed-by-gardener>Scenario 1: Deployed by Gardener</h3><p>In many cases the extension controllers are easy to deploy and configure.
It is sufficient to simply create a Helm chart (standardized way of packaging software in the Kubernetes context) and deploy it together with some static configuration values.
Gardener supports this scenario and allows to provide arbitrary deployment information in the <code>ControllerDeployment</code> resource&rsquo;s <code>.providerConfig</code> section:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>...
type: helm
providerConfig:
  chart: H4sIFAAAAAAA/yk...
  values:
    foo: bar
</code></pre></div><p>If <code>.type=helm</code> then Gardener itself will take over the responsibility the deployment.
It base64-decodes the provided Helm chart (<code>.providerConfig.chart</code>) and deploys it with the provided static configuration (<code>.providerConfig.values</code>).
The chart and the values can be updated at any time - Gardener will recognize and re-trigger the deployment process.</p><p>In order to allow extensions to get information about the garden and the seed cluster Gardener does mix-in certain properties into the values (root level) of every deployed Helm chart:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>gardener:
  garden:
    identifier: &lt;uuid-of-gardener-installation&gt;
  seed:
    identifier: &lt;seed-name&gt;
    region: europe
    spec: &lt;complete-seed-spec&gt;
</code></pre></div><p>Extensions can use this information in their Helm chart in case they require knowledge about the garden and the seed environment.
The list might be extended in the future.</p><p>ℹ️ Gardener uses the UUID of the <code>garden</code> <code>Namespace</code> object in the <code>.gardener.garden.identifier</code> property.</p><h3 id=scenario-2-deployed-by-a-non-human-kubernetes-operator>Scenario 2: Deployed by a (non-human) Kubernetes operator</h3><p>Some extension controllers might be more complex and require additional domain-specific knowledge wrt. lifecycle or configuration.
In this case, we encourage to follow the Kubernetes operator pattern and deploy a dedicated operator for this extension into the garden cluster.
The <code>ControllerDeployments</code>&rsquo;s <code>.type</code> field would then not be <code>helm</code>, and no Helm chart or values need to be provided there.
Instead, the operator itself knows how to deploy the extension into the seed.
It must watch <code>ControllerInstallation</code> resources and act one those referencing a <code>ControllerRegistration</code> the operator is responsible for.</p><p>In order to let Gardener know that the extension controller is ready and running in the seed the <code>ControllerInstallation</code>&rsquo;s <code>.status</code> field supports two conditions: <code>RegistrationValid</code> and <code>InstallationSuccessful</code> - both must be provided by the responsible operator:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>...
status:
  conditions:
  - lastTransitionTime: <span style=color:#a31515>&#34;2019-01-22T11:51:11Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2019-01-22T11:51:11Z&#34;</span>
    message: Chart could be rendered successfully.
    reason: RegistrationValid
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: Valid
  - lastTransitionTime: <span style=color:#a31515>&#34;2019-01-22T11:51:12Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2019-01-22T11:51:12Z&#34;</span>
    message: Installation of new resources succeeded.
    reason: InstallationSuccessful
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: Installed
</code></pre></div><p>Additionally, the <code>.status</code> field has a <code>providerStatus</code> section into which the operator can (optionally) put any arbitrary data associated with this installation.</p><h2 id=extensions-in-the-garden-cluster-itself>Extensions in the garden cluster itself</h2><p>The <code>Shoot</code> resource itself will contain some provider-specific data blobs.
As a result, some extensions might also want to run in the garden cluster, e.g., to provide <code>ValidatingWebhookConfiguration</code>s for validating the correctness of their provider-specific blobs:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: johndoe-aws
  namespace: garden-dev
spec:
  ...
  cloud:
    type: aws
    region: eu-west-1
    providerConfig:
      apiVersion: aws.cloud.gardener.cloud/v1alpha1
      kind: InfrastructureConfig
      networks:
        vpc: <span style=color:green># specify either &#39;id&#39; or &#39;cidr&#39;</span>
        <span style=color:green># id: vpc-123456</span>
          cidr: 10.250.0.0/16
        internal:
        - 10.250.112.0/22
        public:
        - 10.250.96.0/22
        workers:
        - 10.250.0.0/19
      zones:
      - eu-west-1a
...
</code></pre></div><p>In the above example, Gardener itself does not understand the AWS-specific provider configuration for the infrastructure.
However, if this part of the <code>Shoot</code> resource should be validated then you should run an AWS-specific component in the garden cluster that registers a webhook. You can do it similarly if you want to default some fields of a resource (by using a <code>MutatingWebhookConfiguration</code>).</p><p>Again, similar to how Gardener is deployed to the garden cluster, these components must be deployed and managed by the Gardener administrator.</p><h3 id=extension-resource-configurations><code>Extension</code> resource configurations</h3><p>The <code>Extension</code> resource allows injecting arbitrary steps into the shoot reconciliation flow that are unknown to Gardener.
Hence, it is slightly special and allows further configuration when registering it:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: ControllerRegistration
metadata:
  name: extension-foo
spec:
  resources:
  - kind: Extension
    type: foo
    primary: <span style=color:#00f>true</span>
    globallyEnabled: <span style=color:#00f>true</span>
    reconcileTimeout: 30s
</code></pre></div><p>The <code>globallyEnabled=true</code> option specifies that the <code>Extension/foo</code> object shall be created by default for all shoots (unless they opted out by setting <code>.spec.extensions[].enabled=false</code> in the <code>Shoot</code> spec).</p><p>The <code>reconcileTimeout</code> tells Gardener how long it should wait during its shoot reconciliation flow for the <code>Extension/foo</code>&rsquo;s reconciliation to finish.</p><h3 id=deployment-configuration-options>Deployment configuration options</h3><p>The <code>.spec.deployment</code> resource allows to configure a deployment <code>policy</code>.
There are the following policies:</p><ul><li><code>OnDemand</code> (default): Gardener will demand the deployment and deletion of the extension controller to/from seed clusters dynamically. It will automatically determine (based on other resources like <code>Shoot</code>s) whether it is required and decide accordingly.</li><li><code>Always</code>: Gardener will demand the deployment of the extension controller to seed clusters independent of whether it is actually required or not. This might be helpful if you want to add a new component/controller to all seed clusters by default. Another use-case is to minimize the durations until extension controllers get deployed and ready in case you have highly fluctuating seed clusters.</li><li><code>AlwaysExceptNoShoots</code>: Similar to <code>Always</code>, but if the seed does not have any shoots then the extension is not being deployed. It will be deleted from a seed after the last shoot has been removed from it.</li></ul><p>Also, the <code>.spec.deployment.seedSelector</code> allows to specify a label selector for seed clusters.
Only if it matches the labels of a seed then it will be deployed to it.
Please note that a seed selector can only be specified for secondary controllers (<code>primary=false</code> for all <code>.spec.resources[]</code>).</p></div><div class=td-content style=page-break-before:always><h1 id=pg-863811f5b98898fe3fba05a3241b77ae>5.8 - Controlplane</h1><h1 id=contract-controlplane-resource>Contract: <code>ControlPlane</code> resource</h1><p>Most Kubernetes clusters require a <code>cloud-controller-manager</code> or CSI drivers in order to work properly.
Before introducing the <code>ControlPlane</code> extension resource Gardener was having several different Helm charts for the <code>cloud-controller-manager</code> deployments for the various providers.
Now, Gardener commissions an external, provider-specific controller to take over this task.</p><h2 id=which-control-plane-resources-are-required>Which control plane resources are required?</h2><p>As mentioned in the <a href=/docs/gardener/extensions/controlplane-webhooks/>controlplane customization webhooks</a> document Gardener shall not deploy any <code>cloud-controller-manager</code> or any other provider-specific component.
Instead, it creates a <code>ControlPlane</code> CRD that should be picked up by provider extensions.
Its purpose is to trigger the deployment of such provider-specific components in the shoot namespace in the seed cluster.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: ControlPlane
metadata:
  name: control-plane
  namespace: shoot--foo--bar
spec:
  type: openstack
  region: europe-west1
  secretRef:
    name: cloudprovider
    namespace: shoot--foo--bar
  providerConfig:
    apiVersion: openstack.provider.extensions.gardener.cloud/v1alpha1
    kind: ControlPlaneConfig
    loadBalancerProvider: provider
    zone: eu-1a
    cloudControllerManager:
      featureGates:
        CustomResourceValidation: <span style=color:#00f>true</span>
  infrastructureProviderStatus:
    apiVersion: openstack.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureStatus
    networks:
      floatingPool:
        id: vpc-1234
      subnets:
      - purpose: nodes
        id: subnetid
</code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used for the shoot cluster.
However, the most important section is the <code>.spec.providerConfig</code> and the <code>.spec.infrastructureProviderStatus</code>.
The first one contains an embedded declaration of the provider specific configuration for the control plane (that cannot be known by Gardener itself).
You are responsible for designing how this configuration looks like.
Gardener does not evaluate it but just copies this part from what has been provided by the end-user in the <code>Shoot</code> resource.
The second one contains the output of the <a href=/docs/gardener/extensions/infrastructure/><code>Infrastructure</code> resource</a> (that might be relevant for the CCM config).</p><p>In order to support a new control plane provider you need to write a controller that watches all <code>ControlPlane</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the Alicloud provider.</p><p>The control plane controller as part of the <code>ControlPlane</code> reconciliation, often deploys resources (e.g. pods/deployments) into the Shoot namespace in the <code>Seed</code> as part of its <code>ControlPlane</code> reconciliation loop.
Because the namespace contains <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>network policies</a> that per default <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic>deny all ingress and egress traffic</a>,
the pods may need to have proper labels matching to the selectors of the network policies in order to allow the required network traffic.
Otherwise, they won&rsquo;t be allowed to talk to certain other components (e.g., the kube-apiserver of the shoot).
Please <a href=https://github.com/gardener/gardener/tree/master/docs/development/seed_network_policies.md>see this document</a> for more information.</p><h2 id=non-provider-specific-information-required-for-infrastructure-creation>Non-provider specific information required for infrastructure creation</h2><p>Most providers might require further information that is not provider specific but already part of the shoot resource.
One example for this is the <a href=https://github.com/gardener/gardener-extension-provider-gcp/tree/master/pkg/controller/controlplane>GCP control plane controller</a> which needs the Kubernetes version of the shoot cluster (because it already uses the in-tree Kubernetes cloud-controller-manager).
As Gardener cannot know which information is required by providers it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>Infrastructure</code> resource itself.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_controlplane.go><code>ControlPlane</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-alicloud/tree/master/pkg/controller/controlplane>Exemplary implementation for the Alicloud provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3a3deb3218151c4ac388e35f40184d2a>5.9 - Controlplane Exposure</h1><h1 id=contract-controlplane-resource-with-purpose-exposure>Contract: <code>ControlPlane</code> resource with purpose <code>exposure</code></h1><p>Some Kubernetes clusters require an additional deployments required by the seed cloud provider in order to work properly, e.g. AWS Load Balancer Readvertiser.
Before using ControlPlane resources with purpose <code>exposure</code> Gardener was having different Helm charts for the deployments for the various providers.
Now, Gardener commissions an external, provider-specific controller to take over this task.</p><h2 id=which-control-plane-resources-are-required>Which control plane resources are required?</h2><p>As mentioned in the <a href=/docs/gardener/extensions/controlplane/>controlplane</a> document Gardener shall not deploy any other provider-specific component.
Instead, it creates a <code>ControlPlane</code> CRD with purpose <code>exposure</code> that should be picked up by provider extensions.
Its purpose is to trigger the deployment of such provider-specific components in the shoot namespace in the seed cluster that are needed to expose the kube-apiserver.</p><p>The shoot cluster&rsquo;s kube-apiserver are exposed via a <code>Service</code> of type <code>LoadBalancer</code> from the shoot provider (you may run the control plane of an Azure shoot in a GCP seed) it&rsquo;s the seed provider extension controller that should act on the <code>ControlPlane</code> resources with purpose <code>exposure</code>.</p><p>If <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>SNI</a> is enabled, then the <code>Service</code> from above is of type <code>ClusterIP</code> and Gardner will not create <code>ControlPlane</code> resources with purpose <code>exposure</code>.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: ControlPlane
metadata:
  name: control-plane-exposure
  namespace: shoot--foo--bar
spec:
  type: aws
  purpose: exposure
  region: europe-west1
  secretRef:
    name: cloudprovider
    namespace: shoot--foo--bar
</code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used for the shoot cluster.
It is most likely not needed, however, still added for some potential corner cases.
If you don&rsquo;t need it then just ignore it.
The <code>.spec.region</code> contains the region of the seed cluster.</p><p>In order to support a control plane provider with purpose <code>exposure</code> you need to write a controller or expand the existing <a href=/docs/gardener/extensions/controlplane/>controlplane controller</a> that watches all <code>ControlPlane</code>s with <code>.spec.type=&lt;my-provider-name></code> and purpose <code>exposure</code>.
You can take a look at the below referenced example implementation for the AWS provider.</p><h2 id=non-provider-specific-information-required-for-infrastructure-creation>Non-provider specific information required for infrastructure creation</h2><p>Most providers might require further information that is not provider specific but already part of the shoot resource.
As Gardener cannot know which information is required by providers it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_controlplane.go><code>ControlPlane</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/controlplane>Exemplary implementation for the AWS provider</a></li><li><a href=https://github.com/gardener/aws-lb-readvertiser>AWS Load Balancer Readvertiser</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b8aa124fe8bedbc5e039bbe785060c38>5.10 - Controlplane Webhooks</h1><h1 id=controlplane-customization-webhooks>Controlplane customization webhooks</h1><p>Gardener creates the Shoot controlplane in several steps of the Shoot flow. At different point of this flow, it:</p><ul><li>deploys standard controlplane components such as kube-apiserver, kube-controller-manager, and kube-scheduler by creating the corresponding deployments, services, and other resources in the Shoot namespace.</li><li>initiates the deployment of custom controlplane components by <a href=/docs/gardener/extensions/controlplane/>ControlPlane controllers</a> by creating a <code>ControlPlane</code> resource in the Shoot namespace.</li></ul><p>In order to apply any provider-specific changes to the configuration provided by Gardener for the standard controlplane components, cloud extension providers can install mutating admission webhooks for the resources created by Gardener in the Shoot namespace.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-cloud-provider>What needs to be implemented to support a new cloud provider?</h2><p>In order to support a new cloud provider you should install &ldquo;controlplane&rdquo; mutating webhooks for any of the following resources:</p><ul><li>Deployment with name <code>kube-apiserver</code>, <code>kube-controller-manager</code>, or <code>kube-scheduler</code></li><li>Service with name <code>kube-apiserver</code></li><li><code>OperatingSystemConfig</code> with any name and purpose <code>reconcile</code></li></ul><p>See <a href=#contract-specification>Contract Specification</a> for more details on the contract that Gardener and webhooks should adhere to regarding the content of the above resources.</p><p>You can install 3 different kinds of controlplane webhooks:</p><ul><li><code>Shoot</code>, or <code>controlplane</code> webhooks apply changes needed by the Shoot cloud provider, for example the <code>--cloud-provider</code> command line flag of <code>kube-apiserver</code> and <code>kube-controller-manager</code>. Such webhooks should only operate on Shoot namespaces labeled with <code>shoot.gardener.cloud/provider=&lt;provider></code>.</li><li><code>Seed</code>, or <code>controlplaneexposure</code> webhooks apply changes needed by the Seed cloud provider, for example annotations on the <code>kube-apiserver</code> service to ensure cloud-specific load balancers are correctly provisioned for a service of type <code>LoadBalancer</code>. Such webhooks should only operate on Shoot namespaces labeled with <code>seed.gardener.cloud/provider=&lt;provider></code>.</li></ul><p>The labels <code>shoot.gardener.cloud/provider</code> and <code>shoot.gardener.cloud/provider</code> are added by Gardener when it creates the Shoot namespace.</p><h2 id=contract-specification>Contract Specification</h2><p>This section specifies the contract that Gardener and webhooks should adhere to in order to ensure smooth interoperability. Note that this contract can&rsquo;t be specified formally and is therefore easy to violate, especially by Gardener. The Gardener team will nevertheless do its best to adhere to this contract in the future and to ensure via additional measures (tests, validations) that it&rsquo;s not unintentionally broken. If it needs to be changed intentionally, this can only happen after proper communication has taken place to ensure that the affected provider webhooks could be adapted to work with the new version of the contract.</p><p><strong>Note:</strong> The contract described below may not necessarily be what Gardener does currently (as of May 2019). Rather, it reflects the target state after changes for <a href=/docs/gardener/extensions/overview/>Gardener extensibility</a> have been introduced.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>To deploy kube-apiserver, Gardener <strong>shall</strong> create a deployment and a service both named <code>kube-apiserver</code> in the Shoot namespace. They can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>The pod template of the <code>kube-apiserver</code> deployment <strong>shall</strong> contain a container named <code>kube-apiserver</code>.</p><p>The <code>command</code> field of the <code>kube-apiserver</code> container <strong>shall</strong> contain the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver command line</a>. It <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li>admission plugins (<code>--enable-admission-plugins</code>, <code>--disable-admission-plugins</code>)</li><li>secure communications (<code>--etcd-cafile</code>, <code>--etcd-certfile</code>, <code>--etcd-keyfile</code>, &mldr;)</li><li>audit log (<code>--audit-log-*</code>)</li><li>ports (<code>--insecure-port</code>, <code>--secure-port</code>)</li></ul><p>The kube-apiserver command line <strong>shall not</strong> contain any provider-specific flags, such as:</p><ul><li><code>--cloud-provider</code></li><li><code>--cloud-config</code></li></ul><p>These flags can be added by webhooks if needed.</p><p>The <code>kube-apiserver</code> command line <strong>may</strong> contain a number of additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-apiserver behavior for the specific provider. Among the flags to be considered are:</p><ul><li><code>--endpoint-reconciler-type</code></li><li><code>--advertise-address</code></li><li><code>--feature-gates</code></li></ul><p>Gardener <strong>may</strong> use <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>SNI</a> to expose the apiserver (<code>APIServerSNI</code> feature gate). In this case, Gardener <strong>shall</strong> label the <code>kube-apiserver</code>&rsquo;s <code>Deployment</code> with <code>core.gardener.cloud/apiserver-exposure: gardener-managed</code> label and expects that the <code>--endpoint-reconciler-type</code> and <code>--advertise-address</code> flags are not modified.</p><p>The <code>--enable-admission-plugins</code> flag <strong>may</strong> contain admission plugins that are not compatible with CSI plugins such as <code>PersistentVolumeLabel</code>. Webhooks should therefore ensure that such admission plugins are either explicitly enabled (if CSI plugins are not used) or disabled (otherwise).</p><p>The <code>env</code> field of the <code>kube-apiserver</code> container <strong>shall not</strong> contain any provider-specific environment variables (so it will be empty). If any provider-specific environment variables are needed, they should be added by webhooks.</p><p>The <code>volumes</code> field of the pod template of the <code>kube-apiserver</code> deployment, and respectively the <code>volumeMounts</code> field of the <code>kube-apiserver</code> container <strong>shall not</strong> contain any provider-specific <code>Secret</code> or <code>ConfigMap</code> resources. If such resources should be mounted as volumes, this should be done by webhooks.</p><p>The <code>kube-apiserver</code> <code>Service</code> <strong>may</strong> be of type <code>LoadBalancer</code>, but <strong>shall not</strong> contain any provider-specific annotations that may be needed to actually provision a load balancer resource in the Seed provider&rsquo;s cloud. If any such annotations are needed, they should be added by webhooks (typically <code>controlplaneexposure</code> webhooks).</p><p>The <code>kube-apiserver</code> <code>Service</code> <strong>shall</strong> be of type <code>ClusterIP</code>, if Gardener is using <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>SNI</a> to expose the apiserver (<code>APIServerSNI</code> feature gate). In this case, Gardener <strong>shall</strong> label this <code>Service</code> with <code>core.gardener.cloud/apiserver-exposure: gardener-managed</code> label and expects that no mutations happen.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>To deploy kube-controller-manager, Gardener <strong>shall</strong> create a deployment named <code>kube-controller-manager</code> in the Shoot namespace. It can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>The pod template of the <code>kube-controller-manager</code> deployment <strong>shall</strong> contain a container named <code>kube-controller-manager</code>.</p><p>The <code>command</code> field of the <code>kube-controller-manager</code> container <strong>shall</strong> contain the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager command line</a>. It <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li><code>--kubeconfig</code>, <code>--authentication-kubeconfig</code>, <code>--authorization-kubeconfig</code></li><li><code>--leader-elect</code></li><li>secure communications (<code>--tls-cert-file</code>, <code>--tls-private-key-file</code>, &mldr;)</li><li>cluster CIDR and identity (<code>--cluster-cidr</code>, <code>--cluster-name</code>)</li><li>sync settings (<code>--concurrent-deployment-syncs</code>, <code>--concurrent-replicaset-syncs</code>)</li><li>horizontal pod autoscaler (<code>--horizontal-pod-autoscaler-*</code>)</li><li>ports (<code>--port</code>, <code>--secure-port</code>)</li></ul><p>The kube-controller-manager command line <strong>shall not</strong> contain any provider-specific flags, such as:</p><ul><li><code>--cloud-provider</code></li><li><code>--cloud-config</code></li><li><code>--configure-cloud-routes</code></li><li><code>--external-cloud-volume-plugin</code></li></ul><p>These flags can be added by webhooks if needed.</p><p>The kube-controller-manager command line <strong>may</strong> contain a number of additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-controller-manager behavior for the specific provider. Among the flags to be considered are:</p><ul><li><code>--feature-gates</code></li></ul><p>The <code>env</code> field of the <code>kube-controller-manager</code> container <strong>shall not</strong> contain any provider-specific environment variables (so it will be empty). If any provider-specific environment variables are needed, they should be added by webhooks.</p><p>The <code>volumes</code> field of the pod template of the <code>kube-controller-manager</code> deployment, and respectively the <code>volumeMounts</code> field of the <code>kube-controller-manager</code> container <strong>shall not</strong> contain any provider-specific <code>Secret</code> or <code>ConfigMap</code> resources. If such resources should be mounted as volumes, this should be done by webhooks.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>To deploy kube-scheduler, Gardener <strong>shall</strong> create a deployment named <code>kube-scheduler</code> in the Shoot namespace. It can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>The pod template of the <code>kube-scheduler</code> deployment <strong>shall</strong> contain a container named <code>kube-scheduler</code>.</p><p>The <code>command</code> field of the <code>kube-scheduler</code> container <strong>shall</strong> contain the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler command line</a>. It <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li><code>--config</code></li><li><code>--authentication-kubeconfig</code>, <code>--authorization-kubeconfig</code></li><li>secure communications (<code>--tls-cert-file</code>, <code>--tls-private-key-file</code>, &mldr;)</li><li>ports (<code>--port</code>, <code>--secure-port</code>)</li></ul><p>The kube-scheduler command line <strong>may</strong> contain additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-controller-manager behavior for the specific provider. Among the flags to be considered are:</p><ul><li><code>--feature-gates</code></li></ul><p>The kube-scheduler command line can&rsquo;t contain provider-specific flags, and it makes no sense to specify provider-specific environment variables or mount provider-specific <code>Secret</code> or <code>ConfigMap</code> resources as volumes.</p><h3 id=etcd-main-and-etcd-events>etcd-main and etcd-events</h3><p>To deploy etcd, Gardener <strong>shall</strong> create 2 <a href=https://github.com/gardener/etcd-druid/blob/1d427e9167adac1476d1847c0e265c2c09d6bc62/config/samples/druid_v1alpha1_etcd.yaml>Etcd</a> named <code>etcd-main</code> and <code>etcd-events</code> in the Shoot namespace. They can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>Gardener <strong>shall</strong> configure the <code>Etcd</code> resource completely to set up an etcd cluster which uses the default storage class of the seed cluster.</p><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p>Gardener <strong>shall not</strong> deploy a cloud-controller-manager. If it is needed, it should be added by a <a href=/docs/gardener/extensions/controlplane/><code>ControlPlane</code> controller</a></p><h3 id=csi-controllers>CSI controllers</h3><p>Gardener <strong>shall not</strong> deploy a CSI controller. If it is needed, it should be added by a <a href=/docs/gardener/extensions/controlplane/><code>ControlPlane</code> controller</a></p><h3 id=kubelet>kubelet</h3><p>To specify the kubelet configuration, Gardener <strong>shall</strong> create a <a href=/docs/gardener/extensions/operatingsystemconfig/><code>OperatingSystemConfig</code> resource</a> with any name and purpose <code>reconcile</code> in the Shoot namespace. It can therefore also be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener. Gardener <strong>may</strong> write multiple such resources with different <code>type</code> to the same Shoot namespaces if multiple OSs are used.</p><p>The OSC resource <strong>shall</strong> contain a unit named <code>kubelet.service</code>, containing the corresponding systemd unit configuration file. The <code>[Service]</code> section of this file <strong>shall</strong> contain a single <code>ExecStart</code> option having the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/>kubelet command line</a> as its value.</p><p>The OSC resource <strong>shall</strong> contain a file with path <code>/var/lib/kubelet/config/kubelet</code>, which contains a <code>KubeletConfiguration</code> resource in YAML format. Most of the flags that can be specified in the kubelet command line can alternatively be specified as options in this configuration as well.</p><p>The kubelet command line <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li><code>--config</code></li><li><code>--bootstrap-kubeconfig</code>, <code>--kubeconfig</code></li><li><code>--network-plugin</code> (and, if it equals <code>cni</code>, also <code>--cni-bin-dir</code> and <code>--cni-conf-dir</code>)</li><li><code>--node-labels</code></li></ul><p>The kubelet command line <strong>shall not</strong> contain any provider-specific flags, such as:</p><ul><li><code>--cloud-provider</code></li><li><code>--cloud-config</code></li><li><code>--provider-id</code></li></ul><p>These flags can be added by webhooks if needed.</p><p>The kubelet command line / configuration <strong>may</strong> contain a number of additional provider-independent flags / options. In general, webhooks should ignore these unless they are known to interfere with the desired kubelet behavior for the specific provider. Among the flags / options to be considered are:</p><ul><li><code>--enable-controller-attach-detach</code> (<code>enableControllerAttachDetach</code>) - should be set to <code>true</code> if CSI plugins are used, but in general can also be ignored since its default value is also <code>true</code>, and this should work both with and without CSI plugins.</li><li><code>--feature-gates</code> (<code>featureGates</code>) - should contain a list of specific feature gates if CSI plugins are used. If CSI plugins are not used, the corresponding feature gates can be ignored since enabling them should not harm in any way.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-719af9bdc56f6cf5b7e123daddb6f6a4>5.11 - Conventions</h1><h1 id=general-conventions>General conventions</h1><p>All the extensions that are registered to Gardener are deployed to the seed clusters, on which they are required (also see <a href=/docs/gardener/extensions/controllerregistration/>ControllerRegistration</a>).</p><p>Some of these extensions might need to create global resources in the seed (e.g., <code>ClusterRole</code>s), i.e., it&rsquo;s important to have a naming scheme to avoid conflicts as it cannot be checked or validated upfront that two extensions don&rsquo;t use the same names.</p><p>Consequently, this page should help answering some general questions that might come up when it comes to developing an extension.</p><h2 id=is-there-a-naming-scheme-for-global-resources>Is there a naming scheme for (global) resources?</h2><p>As there is no formal process to validate non-existence of conflicts between two extensions please follow these naming schemes when creating resources (especially, when creating global resources, but it&rsquo;s in general a good idea for most created resources):</p><p><em>The resource name should be prefixed with <code>extensions.gardener.cloud:&lt;extension-type>-&lt;extension-name>:&lt;resource-name></code></em>, for example:</p><ul><li><code>extensions.gardener.cloud:provider-aws:machine-controller-manager</code></li><li><code>extensions.gardener.cloud:extension-certificate-service:cert-broker</code></li></ul><h2 id=how-to-create-resources-in-the-shoot-cluster>How to create resources in the shoot cluster?</h2><p>Some extensions might not only create resources in the seed cluster itself but also in the shoot cluster. Usually, every extension comes with a <code>ServiceAccount</code> and the required RBAC permissions when it gets installed to the seed.
However, there are no credentials for the shoot for every extension.</p><p>Gardener creates a kubeconfig for itself that it uses to interact with the shoot cluster.
This kubeconfig is stored as a <code>Secret</code> with name <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/core/v1beta1/constants/types_constants.go><code>gardener</code></a> in the shoot namespace.
Extension controllers may use this kubeconfig to interact with the shoot cluster if desired (it has full administrator privileges and no further RBAC rules are required).
Instead, they could also create their own kubeconfig for every shoot (which, of course, is better for auditing reasons, but not yet enforced at this point in time).</p><p>If you need to deploy a non-DaemonSet resource you need to ensure that it only runs on nodes that are allowed to host system components and extensions.
To do that you need to configure a <code>nodeSelector</code> as following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>nodeSelector:
 worker.gardener.cloud/system-components: <span style=color:#a31515>&#34;true&#34;</span>
</code></pre></div><h2 id=how-to-create-certificates-for-the-shoot-cluster>How to create certificates for the shoot cluster?</h2><p>Gardener creates several certificate authorities (CA) that are used to create server certificates for various components.
For example, the shoot&rsquo;s etcd has its own CA, the kube-aggregator has its own CA as well, and both are different to the actual cluster&rsquo;s CA.</p><p>Extensions should do the same and generate dedicated CAs for their components (e.g. for signing a server certificate for cloud-controller-manager). They should not depend on the CA secrets managed by gardenlet.
You can take a look at the <a href=/docs/gardener/development/secrets_management/>Secrets Management document</a> for more details on how this can be achieved.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e378f2a8255d95d82baa75cd98a3b43b>5.12 - Dns</h1><h1 id=contract-dnsprovider-and-dnsentry-resources>Contract: <code>DNSProvider</code> and <code>DNSEntry</code> resources</h1><p>Every shoot cluster requires external DNS records that are publicly resolvable.
The management of these DNS records requires provider-specific knowledge which is to be developed outside of the Gardener&rsquo;s core repository.</p><h2 id=what-does-gardener-create-dns-records-for>What does Gardener create DNS records for?</h2><h3 id=internal-domain-name>Internal domain name</h3><p>Every shoot cluster&rsquo;s kube-apiserver running in the seed is exposed via a load balancer that has a public endpoint (IP or hostname).
This endpoint is used by end-users and also by system components (that are running in another network, e.g., the kubelet or kube-proxy) to talk to the cluster.
In order to be robust against changes of this endpoint (e.g., caused due to re-creation of the load balancer or move of the control plane to another seed cluster) Gardener creates a so-called <em>internal domain name</em> for every shoot cluster.
The <em>internal domain name</em> is a publicly resolvable DNS record that points to the load balancer of the kube-apiserver.
Gardener uses this domain name in the kubeconfigs of all system components (instead of writing the load balancer endpoint directly into it.
This way Gardener does not need to recreate all the kubeconfigs if the endpoint changes - it just needs to update the DNS record.</p><h3 id=external-domain-name>External domain name</h3><p>The internal domain name is not configurable by end-users directly but dictated by the Gardener administrator.
However, end-users usually prefer to have another DNS name, maybe even using their own domain sometimes to access their Kubernetes clusters.
Gardener supports that by creating another DNS record, named <em>external domain name</em>, that actually points to the <em>internal domain name</em>.
The kubeconfig handed out to end-users does contain this <em>external domain name</em>, i.e., users can access their clusters with the DNS name they like to.</p><p>As not every end-user has an own domain it is possible for Gardener administrators to configure so-called <em>default domains</em>.
If configured, shoots that do not specify a domain explicitly get an <em>external domain name</em> based on a default domain (unless explicitly stated that this shoot should not get an external domain name (<code>.spec.dns.provider=unmanaged</code>).</p><h3 id=domain-name-for-ingress-deprecated>Domain name for ingress (deprecated)</h3><p>Gardener allows to deploy a <code>nginx-ingress-controller</code> into a shoot cluster (deprecated).
This controller is exposed via a public load balancer (again, either IP or hostname).
Gardener creates a wildcard DNS record pointing to this load balancer.
<code>Ingress</code> resources can later use this wildcard DNS record to expose underlying applications.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-dns-provider>What needs to be implemented to support a new DNS provider?</h2><p>As part of the shoot flow Gardener will create two special resources in the seed cluster that need to be reconciled by an extension controller.
The first resource (<code>DNSProvider</code>) is a declaration of a DNS provider (e.g., <code>aws-route53</code>, <code>google-clouddns</code>, &mldr;) with a reference to a <code>Secret</code> object that contains the provider-specific credentials in order to talk to the provider&rsquo;s API.
It also allows to specify two lists of domains that shall be allowed or disallowed to be used for DNS entries:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: Secret
metadata:
  name: aws-credentials
  namespace: default
type: Opaque
data:
  <span style=color:green># aws-route53 specific credentials here</span>
---
apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSProvider
metadata:
  name: my-aws-account
  namespace: default
spec:
  type: aws-route53
  secretRef:
    name: aws-credentials
  domains:
    include:
    - dev.my-fancy-domain.com
    exclude:
    - staging.my-fancy-domain.com
    - prod.my-fancy-domain.com
</code></pre></div><p>When reconciling this resource the DNS controller has to read information about available DNS zones to figure out which domains can actually be supported by the provided credentials.
Based on the constraints given in the <code>DNSProvider</code> resources <code>.spec.domains.{include|exclude}</code> fields it shall later only allow certain DNS entries.
Gardener waits until the <code>status</code> indicates that the registration went well:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSProvider
...
status:
  state: Ready
  message: everything ok
</code></pre></div><p>Other possible states are <code>Pending</code>, <code>Error</code>, and <code>Invalid</code>.
The DNS controller may provide an explanation of the <code>.status.state</code> in the <code>.status.message</code> field.</p><p>Now Gardener may create <code>DNSEntry</code> objects that represent the ask to create an actual external DNS record:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSEntry
metadata:
  name: dns
  namespace: default
spec:
  dnsName: apiserver.cluster1.dev.my-fancy-domain.com
  ttl: 600
  targets:
  - 8.8.8.8
</code></pre></div><p>It has to be automatically determined whether the to-be-created DNS record is of type <code>A</code> or <code>CNAME</code>.
The spec shall also allow the creation of <code>TXT</code> records, e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSEntry
metadata:
  name: dns
  namespace: default
spec:
  dnsName: data.apiserver.cluster1.dev.my-fancy-domain.com
  ttl: 120
  text: |<span style=color:#a31515>
</span><span style=color:#a31515>    </span>    content for the DNS TXT record
</code></pre></div><p>The <code>status</code> section of this resource looks similar like the <code>DNSProvider</code>&rsquo;s.
Gardener is (as of today) only evaluating the <code>.status.state</code> and <code>.status.message</code> fields.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/external-dns-management/tree/master/pkg/apis/dns/v1alpha1><code>DNSProvider</code> and <code>DNSEntry</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/external-dns-management>external-dns-management project in Gardener&rsquo;s GitHub organization</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b0bf831ee5197821c0717de33be3996>5.13 - Dnsrecor</h1><h1 id=contract-dnsrecord-resources>Contract: <code>DNSRecord</code> resources</h1><p>Every shoot cluster requires external DNS records that are publicly resolvable.
The management of these DNS records requires provider-specific knowledge which is to be developed outside the Gardener&rsquo;s core repository.</p><p>Currently, Gardener uses <a href=/docs/gardener/extensions/dns/><code>DNSProvider</code> and <code>DNSEntry</code> resources</a>. However, this introduces undesired coupling of Gardener to a controller that does not adhere to the Gardener extension contracts. Because of this, we plan to stop using <code>DNSProvider</code> and <code>DNSEntry</code> resources for Gardener DNS records in the future and use the <code>DNSRecord</code> resources described here instead.</p><h2 id=what-does-gardener-create-dns-records-for>What does Gardener create DNS records for?</h2><h3 id=internal-domain-name>Internal domain name</h3><p>Every shoot cluster&rsquo;s kube-apiserver running in the seed is exposed via a load balancer that has a public endpoint (IP or hostname).
This endpoint is used by end-users and also by system components (that are running in another network, e.g., the kubelet or kube-proxy) to talk to the cluster.
In order to be robust against changes of this endpoint (e.g., caused due to re-creation of the load balancer or move of the DNS record to another seed cluster) Gardener creates a so-called <em>internal domain name</em> for every shoot cluster.
The <em>internal domain name</em> is a publicly resolvable DNS record that points to the load balancer of the kube-apiserver.
Gardener uses this domain name in the kubeconfigs of all system components, instead of using directly the load balancer endpoint.
This way Gardener does not need to recreate all kubeconfigs if the endpoint changes - it just needs to update the DNS record.</p><h3 id=external-domain-name>External domain name</h3><p>The internal domain name is not configurable by end-users directly but configured by the Gardener administrator.
However, end-users usually prefer to have another DNS name, maybe even using their own domain sometimes to access their Kubernetes clusters.
Gardener supports that by creating another DNS record, named <em>external domain name</em>, that actually points to the <em>internal domain name</em>.
The kubeconfig handed out to end-users does contain this <em>external domain name</em>, i.e., users can access their clusters with the DNS name they like to.</p><p>As not every end-user has an own domain it is possible for Gardener administrators to configure so-called <em>default domains</em>.
If configured, shoots that do not specify a domain explicitly get an <em>external domain name</em> based on a default domain (unless explicitly stated that this shoot should not get an external domain name (<code>.spec.dns.provider=unmanaged</code>).</p><h3 id=ingress-domain-name-deprecated>Ingress domain name (deprecated)</h3><p>Gardener allows to deploy a <code>nginx-ingress-controller</code> into a shoot cluster (deprecated).
This controller is exposed via a public load balancer (again, either IP or hostname).
Gardener creates a wildcard DNS record pointing to this load balancer.
<code>Ingress</code> resources can later use this wildcard DNS record to expose underlying applications.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-dns-provider>What needs to be implemented to support a new DNS provider?</h2><p>As part of the shoot flow Gardener will create a number of <code>DNSRecord</code> resources in the seed cluster (one for each of the DNS records mentioned above) that need to be reconciled by an extension controller.
This resource contains the following information:</p><ul><li>The DNS provider type (e.g., <code>aws-route53</code>, <code>google-clouddns</code>, &mldr;)</li><li>A reference to a <code>Secret</code> object that contains the provider-specific credentials used to communicate with the provider&rsquo;s API.</li><li>The fully qualified domain name (FQDN) of the DNS record, e.g. &ldquo;api.&lt;shoot domain>&rdquo;.</li><li>The DNS record type, one of <code>A</code>, <code>CNAME</code>, or <code>TXT</code>.</li><li>The DNS record values, that is a list of IP addresses for A records, a single hostname for CNAME records, or a list of texts for TXT records.</li></ul><p>Optionally, the <code>DNSRecord</code> resource may contain also the following information:</p><ul><li>The region of the DNS record. If not specified, the region specified in the referenced <code>Secret</code> shall be used. If that is also not specified, the extension controller shall use a certain default region.</li><li>The DNS hosted zone of the DNS record. If not specified, it shall be determined automatically by the extension controller by getting all hosted zones of the account and searching for the longest zone name that is a suffix of the fully qualified domain name (FQDN) mentioned above.</li><li>The TTL of the DNS record in seconds. If not specified, it shall be set by the extension controller to 120.</li></ul><p><strong>Example <code>DNSRecord</code></strong>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: Secret
metadata:
  name: dnsrecord-bar-external
  namespace: shoot--foo--bar
type: Opaque
data:
  <span style=color:green># aws-route53 specific credentials here</span>
---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: DNSRecord
metadata:
  name: dnsrecord-external
  namespace: default
spec:
  type: aws-route53
  secretRef:
    name: dnsrecord-bar-external
    namespace: shoot--foo--bar
<span style=color:green># region: eu-west-1</span>
<span style=color:green># zone: ZFOO</span>
  name: api.bar.foo.my-fancy-domain.com
  recordType: A
  values:
  - 1.2.3.4
<span style=color:green># ttl: 600</span>
</code></pre></div><p>In order to support a new DNS record provider you need to write a controller that watches all <code>DNSRecord</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the AWS route53 provider.</p><h2 id=key-names-in-secrets-containing-provider-specific-credentials>Key names in secrets containing provider-specific credentials</h2><p>For compatibility with existing setups, extension controllers shall support two different namings of keys in secrets containing provider-specific credentials:</p><ul><li>The naming used by the <a href=https://github.com/gardener/external-dns-management>external-dns-management DNS controller</a>. For example on AWS, the key names are <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, and <code>AWS_REGION</code>.</li><li>The naming used by other provider-specific extension controllers, e.g. for <a href=/docs/gardener/extensions/infrastructure/>infrastructure</a>. For example on AWS, the key names are <code>accessKeyId</code>, <code>secretAccessKey</code>, and <code>region</code>.</li></ul><h2 id=avoiding-reading-the-dns-hosted-zones>Avoiding reading the DNS hosted zones</h2><p>If the DNS hosted zone is not specified in the <code>DNSRecord</code> resource, during the first reconciliation the extension controller shall determine the correct DNS hosted zone for the specified FQDN and write it to the status of the resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: DNSRecord
metadata:
  name: dnsrecord-external
  namespace: shoot--foo--bar
spec:
  ...
status:
  lastOperation: ...
  zone: ZFOO
</code></pre></div><p>On subsequent reconciliations, the extension controller shall use the zone from the status and avoid reading the DNS hosted zones from the provider.
If the <code>DNSRecord</code> resource specifies a zone in <code>.spec.zone</code> and the extension controller has written a value to <code>.status.zone</code>, the first one shall be considered with higher priority by the extension controller.</p><h2 id=non-provider-specific-information-required-for-dns-record-creation>Non-provider specific information required for DNS record creation</h2><p>Some providers might require further information that is not provider specific but already part of the shoot resource.
As Gardener cannot know which information is required by providers it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>DNSRecord</code> resource itself.</p><h2 id=using-dnsrecord-instead-of-dnsprovider-and-dnsentry-resources>Using <code>DNSRecord</code> instead of <code>DNSProvider</code> and <code>DNSEntry</code> resources</h2><p>Currently, Gardener will create <code>DNSRecord</code> resources only if the feature gate <code>UseDNSRecords</code> is enabled on <code>gardener-apiserver</code>, <code>gardener-controller-manager</code>, and <code>gardenlet</code> (it should be enabled on all three of them for the feature to work properly).
If this feature gate is enabled, all three DNS records mentioned above (internal, external, and ingress) will be managed via <code>DNSRecords</code> and not <code>DNSProvider</code> / <code>DNSEntry</code>.
<code>DNSProvider</code> resources will still be created for all providers listed in <code>spec.dns.providers</code>, including the one marked as <code>primary: true</code>.
These providers can be used for <code>DNSEntry</code> resources needed by workloads deployed on the shoot cluster.</p><p>If the feature gate is disabled, Gardener will not create any <code>DNSRecord</code> resources and use <code>DNSProvider</code> / <code>DNSEntry</code> resources for its DNS records.
The feature gate was introduced in <code>v1.27</code> and was in <code>Alpha</code> stage (disabled by default) until <code>v1.38</code> (including). With <code>v1.39</code> the feature gate is graduated to <code>Beta</code> and it is enabled by default.</p><p>In order to successfully reconcile a shoot with the feature gate enabled, extension controllers for <code>DNSRecord</code> resources for types used in the default, internal and custom domain secrets should be registered via <code>ControllerRegistration</code> resources.</p><h3 id=support-for-dnsrecord-resources-in-the-provider-extensions>Support for <code>DNSRecord</code> resources in the provider extensions</h3><p>The following table contains information about the provider extension version that adds support for <code>DNSRecord</code> resources:</p><table><thead><tr><th>Extension</th><th>Version</th></tr></thead><tbody><tr><td>provider-alicloud</td><td><code>v1.26.0</code></td></tr><tr><td>provider-aws</td><td><code>v1.27.0</code></td></tr><tr><td>provider-azure</td><td><code>v1.21.0</code></td></tr><tr><td>provider-gcp</td><td><code>v1.18.0</code></td></tr><tr><td>provider-openstack</td><td><code>v1.21.0</code></td></tr><tr><td>provider-vsphere</td><td>N/A</td></tr><tr><td>provider-equinix-metal</td><td>N/A</td></tr><tr><td>provider-kubevirt</td><td>N/A</td></tr><tr><td>provider-openshift</td><td>N/A</td></tr></tbody></table><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_dnsrecord.go><code>DNSRecord</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/dnsrecord>Sample implementation for the AWS route53 provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8d41cfc635f0777d1f5003241ea79535>5.14 - Extension</h1><h1 id=contract-extension-resource>Contract: <code>Extension</code> resource</h1><p>Gardener defines common procedures which must be passed to create a functioning shoot cluster. Well known steps are represented by special resources like <code>Infrastructure</code>, <code>OperatingSystemConfig</code> or <code>DNS</code>. These resources are typically reconciled by dedicated controllers setting up the infrastructure on the hyperscaler or managing DNS entries, etc..</p><p>But, some requirements don&rsquo;t match with those special resources or don&rsquo;t depend on being proceeded at a specific step in the creation / deletion flow of the shoot. They require a more generic hook. Therefore, Gardener offers the <code>Extension</code> resource.</p><h2 id=what-is-required-to-register-and-support-an-extension-type>What is required to register and support an Extension type?</h2><p>Gardener creates one <code>Extension</code> resource per registered extension type in <code>ControllerRegistration</code> per shoot.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: ControllerRegistration
metadata:
  name: extension-example
spec:
  resources:
  - kind: Extension
    type: example
    globallyEnabled: <span style=color:#00f>true</span>
</code></pre></div><p>If <code>spec.resources[].globallyEnabled</code> is <code>true</code> then the <code>Extension</code> resources of the given <code>type</code> is created for every shoot cluster. Set to <code>false</code>, the <code>Extension</code> resource is only created if configured in the <code>Shoot</code> manifest.</p><p>The <code>Extension</code> resources are created in the shoot namespace of the seed cluster.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Extension
metadata:
  name: example
  namespace: shoot--foo--bar
spec:
  type: example
  providerConfig: {}
</code></pre></div><p>Your controller needs to reconcile <code>extensions.extensions.gardener.cloud</code>. Since there can exist multiple <code>Extension</code> resources per shoot, each one holds a <code>spec.type</code> field to let controllers check their responsibility (similar to all other extension resources of Gardener).</p><h2 id=providerconfig>ProviderConfig</h2><p>It is possible to provide data in the <code>Shoot</code> resource which is copied to <code>spec.providerConfig</code> of the <code>Extension</code> resource.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: bar
  namespace: garden-foo
spec:
  extensions:
  - type: example
    providerConfig:
      foo: bar
...
</code></pre></div><p>results in</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Extension
metadata:
  name: example
  namespace: shoot--foo--bar
spec:
  type: example
  providerConfig:
    foo: bar
</code></pre></div><h2 id=shoot-reconciliation-flow-and-extension-status>Shoot reconciliation flow and Extension status</h2><p>Gardener creates Extension resources as part of the Shoot reconciliation. Moreover, it is guaranteed that the <a href=/docs/gardener/extensions/cluster/>Cluster</a> resource exists before the <code>Extension</code> resource is created.</p><p>For an <code>Extension</code> controller it is crucial to maintain the <code>Extension</code>&rsquo;s status correctly. At the end Gardener checks the status of each <code>Extension</code> and only reports a successful shoot reconciliation if the state of the last operation is <code>Succeeded</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: Extension
metadata:
  generation: 1
  name: example
  namespace: shoot--foo--bar
spec:
  type: example
status:
  lastOperation:
    state: Succeeded
  observedGeneration: 1
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-079331a6be1955be3c4c16acf0c583c1>5.15 - Healthcheck Library</h1><h1 id=health-check-library>Health Check Library</h1><h2 id=goal>Goal</h2><p>Typically an extension reconciles a specific resource (Custom Resource Definitions (CRDs)) and creates/modifies resources in the cluster (via helm, managed resources, kubectl, &mldr;).
We call these API Objects &lsquo;dependent objects&rsquo; - as they are bound to the lifecycle of the extension.</p><p>The goal of this library is to enable extensions to setup health checks for their &lsquo;dependent objects&rsquo; with minimal effort.</p><h2 id=usage>Usage</h2><p>The library provides a generic controller with the ability to register any resource that satisfies the <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types.go>extension object interface</a>.
An example is <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_worker.go>the <code>Worker</code> CRD</a>.</p><p>Health check functions for commonly used dependent objects can be reused and registered with the controller, such as:</p><ul><li>Deployment</li><li>DaemonSet</li><li>StatefulSet</li><li>ManagedResource (Gardener specific)</li></ul><p>See below example <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/pkg/controller/healthcheck/add.go>taken from the provider-aws</a>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>health.DefaultRegisterExtensionForHealthCheck(
               aws.Type,
               extensionsv1alpha1.SchemeGroupVersion.WithKind(extensionsv1alpha1.WorkerResource),
               <span style=color:#00f>func</span>() runtime.Object { <span style=color:#00f>return</span> &amp;extensionsv1alpha1.Worker{} },
               mgr, <span style=color:green>// controller runtime manager
</span><span style=color:green></span>               opts, <span style=color:green>// options for the health check controller
</span><span style=color:green></span>               <span style=color:#00f>nil</span>, <span style=color:green>// custom predicates
</span><span style=color:green></span>               <span style=color:#00f>map</span>[extensionshealthcheckcontroller.HealthCheck]<span style=color:#2b91af>string</span>{
                       general.CheckManagedResource(genericactuator.McmShootResourceName): string(gardencorev1beta1.ShootSystemComponentsHealthy),
                       general.CheckSeedDeployment(aws.MachineControllerManagerName):      string(gardencorev1beta1.ShootEveryNodeReady),
                       worker.SufficientNodesAvailable():                                  string(gardencorev1beta1.ShootEveryNodeReady),
               })
</code></pre></div><p>This creates a health check controller that reconciles the <code>extensions.gardener.cloud/v1alpha1.Worker</code> resource with the spec.type &lsquo;aws&rsquo;.
Three health check functions are registered that are executed during reconciliation.
Each health check is mapped to a single <code>HealthConditionType</code> that results in conditions with the same <code>condition.type</code> (see below).
To contribute to the Shoot&rsquo;s health, the following can be used: <code>SystemComponentsHealthy</code>, <code>EveryNodeReady</code>, <code>ControlPlaneHealthy</code>.
The Gardener/Gardenlet checks each extension for conditions matching these types.
However extensions are free to choose any <code>HealthConditionType</code>.
More information <a href=/docs/gardener/extensions/shoot-health-status-conditions/>can be found here</a>.</p><p>A health check has to <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/healthcheck/actuator.go>satisfy below interface</a>.
You can find implementation examples <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/healthcheck/general>here</a>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>type</span> HealthCheck <span style=color:#00f>interface</span> {
    <span style=color:green>// Check is the function that executes the actual health check
</span><span style=color:green></span>    Check(context.Context, types.NamespacedName) (*SingleCheckResult, <span style=color:#2b91af>error</span>)
    <span style=color:green>// InjectSeedClient injects the seed client
</span><span style=color:green></span>    InjectSeedClient(client.Client)
    <span style=color:green>// InjectShootClient injects the shoot client
</span><span style=color:green></span>    InjectShootClient(client.Client)
    <span style=color:green>// SetLoggerSuffix injects the logger
</span><span style=color:green></span>    SetLoggerSuffix(<span style=color:#2b91af>string</span>, <span style=color:#2b91af>string</span>)
    <span style=color:green>// DeepCopy clones the healthCheck
</span><span style=color:green></span>    DeepCopy() HealthCheck
}
</code></pre></div><p>The health check controller regularly (default: <code>30s</code>) reconciles the extension resource and executes the registered health checks for the dependent objects.
As a result, the controller writes condition(s) to the status of the extension containing the health check result.
In our example, two checks are mapped to <code>ShootEveryNodeReady</code> and one to <code>ShootSystemComponentsHealthy</code>, leading to conditions with two distinct <code>HealthConditionTypes</code> (condition.type)</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>status:
  conditions:
    - lastTransitionTime: <span style=color:#a31515>&#34;20XX-10-28T08:17:21Z&#34;</span>
      lastUpdateTime: <span style=color:#a31515>&#34;20XX-11-28T08:17:21Z&#34;</span>
      message: (1/1) Health checks successful
      reason: HealthCheckSuccessful
      status: <span style=color:#a31515>&#34;True&#34;</span>
      type: SystemComponentsHealthy
    - lastTransitionTime: <span style=color:#a31515>&#34;20XX-10-28T08:17:21Z&#34;</span>
      lastUpdateTime: <span style=color:#a31515>&#34;20XX-11-28T08:17:21Z&#34;</span>
      message: (2/2) Health checks successful
      reason: HealthCheckSuccessful
      status: <span style=color:#a31515>&#34;True&#34;</span>
      type: EveryNodeReady
</code></pre></div><p>Please note that there are four statuses: <code>True</code>, <code>False</code>, <code>Unknown</code>, and <code>Progressing</code>.</p><ul><li><code>True</code> should be used for successful health checks.</li><li><code>False</code> should be used for unsuccessful/failing health checks.</li><li><code>Unknown</code> should be used when there was an error trying to determine the health status.</li><li><code>Progressing</code> should be used to indicate that the health status did not succeed but for expected reasons (e.g., a cluster scale up/down could make the standard health check fail because something is wrong with the <code>Machines</code>, however, it&rsquo;s actually an expected situation and known to be completed within a few minutes.)</li></ul><p>Health checks that report <code>Progressing</code> should also provide a timeout after which this &ldquo;progressing situation&rdquo; is expected to be completed.
The health check library will automatically transition the status to <code>False</code> if the timeout was exceeded.</p><h2 id=additional-considerations>Additional Considerations</h2><p>It is up to the extension to decide how to conduct health checks, though it is recommended to make use of the build-in health check functionality of <code>managed-resources</code> for trivial checks.
By <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/worker/genericactuator/machine_controller_manager.go>deploying the depending resources via managed resources</a>, the <a href=https://github.com/gardener/gardener-resource-manager>gardener resource manager</a> conducts basic checks for different API objects out-of-the-box (e.g <code>Deployments</code>, <code>DaemonSets</code>, &mldr;) - and writes health conditions.
In turn, the library contains a health check function to gather the health information from managed resources.</p><p>More sophisticated health checks should be implemented by the extension controller itself (implementing the <code>HealthCheck</code> interface).</p></div><div class=td-content style=page-break-before:always><h1 id=pg-21a79d22424671ff092806dd096f0b8e>5.16 - Infrastructure</h1><h1 id=contract-infrastructure-resource>Contract: <code>Infrastructure</code> resource</h1><p>Every Kubernetes cluster requires some low-level infrastructure to be setup in order to work properly.
Examples for that are networks, routing entries, security groups, IAM roles, etc.
Before introducing the <code>Infrastructure</code> extension resource Gardener was using Terraform in order to create and manage these provider-specific resources (e.g., see <a href=https://github.com/gardener/gardener/tree/0.20.0/charts/seed-terraformer/charts/aws-infra>here</a>).
Now, Gardener commissions an external, provider-specific controller to take over this task.</p><h2 id=which-infrastructure-resources-are-required>Which infrastructure resources are required?</h2><p>Unfortunately, there is no general answer to this question as it is highly provider specific.
Consider the above mentioned resources, i.e. VPC, subnets, route tables, security groups, IAM roles, SSH key pairs.
Most of the resources are required in order to create VMs (the shoot cluster worker nodes), load balancers, and volumes.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--foo--bar
spec:
  type: azure
  region: eu-west-1
  secretRef:
    name: cloudprovider
    namespace: shoot--foo--bar
  providerConfig:
    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureConfig
    resourceGroup:
      name: mygroup
    networks:
      vnet: <span style=color:green># specify either &#39;name&#39; or &#39;cidr&#39;</span>
      <span style=color:green># name: my-vnet</span>
        cidr: 10.250.0.0/16
      workers: 10.250.0.0/19
</code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed resources.
However, the most important section is the <code>.spec.providerConfig</code>.
It contains an embedded declaration of the provider specific configuration for the infrastructure (that cannot be known by Gardener itself).
You are responsible for designing how this configuration looks like.
Gardener does not evaluate it but just copies this part from what has been provided by the end-user in the <code>Shoot</code> resource.</p><p>After your controller has created the required resources in your provider&rsquo;s infrastructure it needs to generate an output that can be used by other controllers in subsequent steps.
An example for that is the <code>Worker</code> extension resource controller.
It is responsible for creating virtual machines (shoot worker nodes) in this prepared infrastructure.
Everything that it needs to know in order to do that (e.g., the network IDs, security group names, etc. (again: provider-specific)) needs to be provided as output in the <code>Infrastructure</code> resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--foo--bar
spec:
  ...
status:
  lastOperation: ...
  providerStatus:
    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureStatus
    resourceGroup:
      name: mygroup
    networks:
      vnet:
        name: my-vnet
      subnets:
      - purpose: nodes
        name: my-subnet
    availabilitySets:
    - purpose: nodes
      id: av-set-id
      name: av-set-name
    routeTables:
    - purpose: nodes
      name: route-table-name
    securityGroups:
    - purpose: nodes
      name: sec-group-name
</code></pre></div><p>In order to support a new infrastructure provider you need to write a controller that watches all <code>Infrastructure</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the Azure provider.</p><h2 id=dynamic-nodes-network-for-shoot-clusters>Dynamic nodes network for shoot clusters</h2><p>Some environments do not allow end-users to statically define a CIDR for the network that shall be used for the shoot worker nodes.
In these cases it is possible for the extension controllers to dynamically provision a network for the nodes (as part of their reconciliation loops), and to provide the CIDR in the <code>status</code> of the <code>Infrastructure</code> resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--foo--bar
spec:
  ...
status:
  lastOperation: ...
  providerStatus: ...
  nodesCIDR: 10.250.0.0/16
</code></pre></div><p>Gardener will pick this <code>nodesCIDR</code> and use it to configure the VPN components to establish network connectivity between the control plane and the worker nodes.
If the <code>Shoot</code> resource already specifies a nodes CIDR in <code>.spec.networking.nodes</code> and the extension controller provides also a value in <code>.status.nodesCIDR</code> in the <code>Infrastructure</code> resource then the latter one will always be considered with higher priority by Gardener.</p><h2 id=non-provider-specific-information-required-for-infrastructure-creation>Non-provider specific information required for infrastructure creation</h2><p>Some providers might require further information that is not provider specific but already part of the shoot resource.
One example for this is the <a href=https://github.com/gardener/gardener-extension-provider-gcp/tree/master/pkg/controller/infrastructure>GCP infrastructure controller</a> which needs the pod and the service network of the cluster in order to prepare and configure the infrastructure correctly.
As Gardener cannot know which information is required by providers it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>Infrastructure</code> resource itself.</p><h2 id=implementation-details>Implementation details</h2><h3 id=actuator-interface><code>Actuator</code> interface</h3><p>Most existing infrastructure controller implementations follow a common pattern where a generic <code>Reconciler</code> delegates to <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go>an <code>Actuator</code> interface</a> that contains the methods <code>Reconcile</code>, <code>Delete</code>, <code>Migrate</code>, and <code>Restore</code>. These methods are called by the generic <code>Reconciler</code> for the respective operations, and should be implemented by the extension according to the contract described here and the <a href=/docs/gardener/extensions/migration/>migration guidelines</a>.</p><h3 id=configvalidator-interface><code>ConfigValidator</code> interface</h3><p>For infrastructure controllers, the generic <code>Reconciler</code> also delegates to <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/configvalidator.go>a <code>ConfigValidator</code> interface</a> that contains a single <code>Validate</code> method. This method is called by the generic <code>Reconciler</code> at the beginning of every reconciliation, and can be implemented by the extension to validate the <code>.spec.providerConfig</code> part of the <code>Infrastructure</code> resource with the respective cloud provider, typically the existence and validity of cloud provider resources such as AWS VPCs or GCP Cloud NAT IPs.</p><p>The <code>Validate</code> method returns a list of errors. If this list is non-empty, the generic <code>Reconciler</code> will fail with an error. This error will have the error code <code>ERR_CONFIGURATION_PROBLEM</code>, unless there is at least one error in the list that has its <code>ErrorType</code> field set to <code>field.ErrorTypeInternal</code>.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_infrastructure.go><code>Infrastructure</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/infrastructure>Sample implementation for the Azure provider</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure/configvalidator.go>Sample ConfigValidator implementation</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-95017ccbee8525055e43da8a42034f57>5.17 - Logging And Monitoring</h1><h1 id=logging-and-monitoring-for-extensions>Logging and Monitoring for Extensions</h1><p>Gardener provides an integrated logging and monitoring stack for alerting, monitoring and troubleshooting of its managed components by operators or end users. For further information how to make use of it in these roles, refer to the corresponding guides for <a href=https://github.com/gardener/logging/tree/master/docs/usage/README.md>exploring logs</a> and for <a href=https://grafana.com/docs/grafana/latest/getting-started/getting-started/#all-users>monitoring with Grafana</a>.</p><p>The components that constitute the logging and monitoring stack are managed by Gardener. By default, it deploys <a href=https://prometheus.io/>Prometheus</a>, <a href=https://prometheus.io/docs/alerting/latest/alertmanager/>Alertmanager</a> and <a href=https://grafana.com/>Grafana</a> into the <code>garden</code> namespace of all seed clusters. If the <code>Logging</code> <a href=/docs/gardener/deployment/feature_gates/>feature gate</a> in the <code>gardenlet</code> configuration is enabled, it will deploy <a href=https://fluentbit.io/>fluent-bit</a> and <a href=https://grafana.com/oss/loki/>Loki</a> in the <code>garden</code> namespace too.</p><p>Each shoot namespace hosts managed logging and monitoring components. As part of the shoot reconciliation flow, Gardener deploys a shoot-specific Prometheus, Grafana and, if configured, an Alertmanager into the shoot namespace, next to the other control plane components. If the <code>Logging</code> feature gate is enabled and the <a href=/docs/gardener/usage/shoot_purposes/#behavioral-differences>shoot purpose</a> is not <code>testing</code>, it deploys a shoot-specific Loki in the shoot namespace too.</p><p>The logging and monitoring stack is extensible by configuration. Gardener extensions can take advantage of that and contribute configurations encoded in <code>ConfigMap</code>s for their own, specific dashboards, alerts, log parsers and other supported assets and integrate with it. As with other Gardener resources, they will be continuously reconciled.</p><p>This guide is about the roles and extensibility options of the logging and monitoring stack components, and how to integrate extensions with:</p><ul><li><a href=#monitoring>Monitoring</a></li><li><a href=#logging>Logging</a></li></ul><h2 id=monitoring>Monitoring</h2><p>The central Prometheus instance in the <code>garden</code> namespace fetches metrics and data from all seed cluster nodes and all seed cluster pods.
It uses the <a href=https://prometheus.io/docs/prometheus/latest/federation/>federation</a> concept to allow the shoot-specific instances to scrape only the metrics for the pods of the control plane they are responsible for.
This mechanism allows to scrape the metrics for the nodes/pods once for the whole cluster, and to have them distributed afterwards.</p><p>The shoot-specific metrics are then made available to operators and users in the shoot Grafana, using the shoot Prometheus as data source.</p><p>Extension controllers might deploy components as part of their reconciliation next to the shoot&rsquo;s control plane.
Examples for this would be a cloud-controller-manager or CSI controller deployments. Extensions that want to have their managed control plane components integrated with monitoring can contribute their per-shoot configuration for scraping Prometheus metrics, Alertmanager alerts or Grafana dashboards.</p><h3 id=extensions-monitoring-integration>Extensions monitoring integration</h3><p>Before deploying the shoot-specific Prometheus instance, Gardener will read all <code>ConfigMap</code>s in the shoot namespace, which are labeled with <code>extensions.gardener.cloud/configuration=monitoring</code>.
Such <code>ConfigMap</code>s may contain four fields in their <code>data</code>:</p><ul><li><code>scrape_config</code>: This field contains Prometheus scrape configuration for the component(s) and metrics that shall be scraped.</li><li><code>alerting_rules</code>: This field contains Alertmanager rules for alerts that shall be raised.</li><li>(deprecated)<code>dashboard_operators</code>: This field contains a Grafana dashboard in JSON that is only relevant for Gardener operators.</li><li>(deprecated)<code>dashboard_users</code>: This field contains a Grafana dashboard in JSON that is only relevant for Gardener users (shoot owners).</li></ul><p><strong>Example:</strong> A <code>ControlPlane</code> controller deploying a <code>cloud-controller-manager</code> into the shoot namespace wants to integrate monitoring configuration for scraping metrics, alerting rules, dashboards and logging configuration for exposing logs to the end users.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ConfigMap
metadata:
  name: extension-controlplane-monitoring-ccm
  namespace: shoot--project--name
  labels:
    extensions.gardener.cloud/configuration: monitoring
data:
  scrape_config: |<span style=color:#a31515>
</span><span style=color:#a31515>    - job_name: cloud-controller-manager
</span><span style=color:#a31515>      scheme: https
</span><span style=color:#a31515>      tls_config:
</span><span style=color:#a31515>        insecure_skip_verify: true
</span><span style=color:#a31515>      authorization:
</span><span style=color:#a31515>        type: Bearer
</span><span style=color:#a31515>        credentials_file: /var/run/secrets/gardener.cloud/shoot/token/token
</span><span style=color:#a31515>      honor_labels: false
</span><span style=color:#a31515>      kubernetes_sd_configs:
</span><span style=color:#a31515>      - role: endpoints
</span><span style=color:#a31515>        namespaces:
</span><span style=color:#a31515>          names: [shoot--project--name]
</span><span style=color:#a31515>      relabel_configs:
</span><span style=color:#a31515>      - source_labels:
</span><span style=color:#a31515>        - __meta_kubernetes_service_name
</span><span style=color:#a31515>        - __meta_kubernetes_endpoint_port_name
</span><span style=color:#a31515>        action: keep
</span><span style=color:#a31515>        regex: cloud-controller-manager;metrics
</span><span style=color:#a31515>      # common metrics
</span><span style=color:#a31515>      - action: labelmap
</span><span style=color:#a31515>        regex: __meta_kubernetes_service_label_(.+)
</span><span style=color:#a31515>      - source_labels: [ __meta_kubernetes_pod_name ]
</span><span style=color:#a31515>        target_label: pod
</span><span style=color:#a31515>      metric_relabel_configs:
</span><span style=color:#a31515>      - process_max_fds
</span><span style=color:#a31515>      - process_open_fds</span>    

  alerting_rules: |<span style=color:#a31515>
</span><span style=color:#a31515>    cloud-controller-manager.rules.yaml: |
</span><span style=color:#a31515>      groups:
</span><span style=color:#a31515>      - name: cloud-controller-manager.rules
</span><span style=color:#a31515>        rules:
</span><span style=color:#a31515>        - alert: CloudControllerManagerDown
</span><span style=color:#a31515>          expr: absent(up{job=&#34;cloud-controller-manager&#34;} == 1)
</span><span style=color:#a31515>          for: 15m
</span><span style=color:#a31515>          labels:
</span><span style=color:#a31515>            service: cloud-controller-manager
</span><span style=color:#a31515>            severity: critical
</span><span style=color:#a31515>            type: seed
</span><span style=color:#a31515>            visibility: all
</span><span style=color:#a31515>          annotations:
</span><span style=color:#a31515>            description: All infrastructure specific operations cannot be completed (e.g. creating load balancers or persistent volumes).
</span><span style=color:#a31515>            summary: Cloud controller manager is down.</span>    
</code></pre></div><h2 id=logging>Logging</h2><p>In Kubernetes clusters, container logs are non-persistent and do not survive stopped and destroyed containers. Gardener addresses this problem for the components hosted in a seed cluster, by introducing its own managed logging solution. It is integrated with the Gardener monitoring stack to have all troubleshooting context in one place.</p><p><img src=/__resources/logging-architecture_c8dc32.png alt="&ldquo;Cluster Logging Topology&rdquo;" title="Cluster Logging Topology"></p><p>Gardener logging consists of components in three roles - log collectors and forwarders, log persistency and exploration/consumption interfaces. All of them live in the seed clusters in multiple instances:</p><ul><li>Logs are persisted by Loki instances deployed as StatefulSets - one per shoot namespace, if the <code>Logging</code> feature gate is enabled and the <a href=/docs/gardener/usage/shoot_purposes/#behavioral-differences>shoot purpose</a> is not <code>testing</code>, and one in the <code>garden</code> namespace. The shoot instances store logs from the control plane components hosted there. The <code>garden</code> Loki instance is responsible for logs from the rest of the seed namespaces - <code>kube-system</code>, <code>garden</code> <code>extension-*</code> and others.</li><li>Fluent-bit DaemonSets deployed on each seed node collect logs from it. A custom plugin takes care to distribute the collected log messages to the Loki instances that they are intended for. This allows to fetch the logs once for the whole cluster, and to distribute them afterwards.</li><li>Grafana is the UI component used to explore monitoring and log data together for easier troubleshooting and in context. Grafana instances are configured to use the coresponding Loki instances, sharing the same namespace, as data providers. There is one Grafana Deployment in the <code>garden</code> namespace and two Deployments per shoot namespace (one exposed to the end users and one for the operators).</li></ul><p>Logs can be produced from various sources, such as containers or systemd, and in different formats. The fluent-bit design supports configurable <a href=https://docs.fluentbit.io/manual/concepts/data-pipeline>data pipeline</a> to address that problem. Gardener provides such <a href=https://github.com/gardener/gardener/blob/master/charts/seed-bootstrap/charts/fluent-bit/templates/fluent-bit-configmap.yaml>configuration</a> for logs produced by all its core managed components as a <code>ConfigMap</code>. Extensions can contribute their own, specific configurations as <code>ConfigMap</code>s too. See for example the <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/charts/gardener-extension-provider-aws/templates/configmap-logging.yaml>logging configuration</a> for the Gardener AWS provider extension. The Gardener reconciliation loop watches such resources and updates the fluent-bit agents dynamically.</p><h4 id=fluent-bit-log-parsers-and-filters>Fluent-bit log parsers and filters</h4><p>To integrate with Gardener logging, extensions can and <em>should</em> specify how fluent-bit will handle the logs produced by the managed components that they contribute to Gardener. Normally, that would require to configure a <em>parser</em> for the specific logging format, if none of the available is applicable, and a <em>filter</em> defining how to apply it. For a complete reference for the configuration options, refer to fluent-bit&rsquo;s <a href=https://docs.fluentbit.io/manual/>documentation</a>.</p><p><strong>Note:</strong> At the moment only <em>parser</em> and <em>filter</em> configurations are supported.</p><p>To contribute its own configuration to the fluent-bit agents data pipelines, an extension must provide it as a <code>ConfigMap</code> labeled <code>extensions.gardener.cloud/configuration=logging</code> and deployed in the seed&rsquo;s <code>garden</code> namespace. Unlike the monitoring stack, where configurations are deployed per shoot, here a <em>single</em> configuration <code>ConfigMap</code> is sufficient and it applies to all fluent-bit agents in the seed. Its <code>data</code> field can have the following properties:</p><ul><li><code>filter-kubernetes.conf</code> - configuration for data pipeline <a href=https://docs.fluentbit.io/manual/concepts/data-pipeline/filter>filters</a></li><li><code>parser.conf</code> - configuration for data pipeline <a href=https://docs.fluentbit.io/manual/concepts/data-pipeline/parser>parsers</a></li></ul><p><strong>Note:</strong> Take care to provide the correct data pipeline elements in the coresponding data field and not to mix them.</p><p><strong>Example:</strong> Logging configuration for provider-specific (OpenStack) worker controller deploying a <code>machine-controller-manager</code> component into a shoot namespace that reuses the <code>kubeapiserverParser</code> defined in <a href=https://github.com/gardener/gardener/blob/master/charts/seed-bootstrap/charts/fluent-bit/templates/fluent-bit-configmap.yaml#L304-L309>fluent-bit-configmap.yaml</a> to parse the component logs</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ConfigMap
metadata:
  name: gardener-extension-provider-openstack-logging-config
  namespace: garden
  labels:
    extensions.gardener.cloud/configuration: logging
data:
  filter-kubernetes.conf: |<span style=color:#a31515>
</span><span style=color:#a31515>    [FILTER]
</span><span style=color:#a31515>        Name                parser
</span><span style=color:#a31515>        Match               kubernetes.machine-controller-manager*openstack-machine-controller-manager*
</span><span style=color:#a31515>        Key_Name            log
</span><span style=color:#a31515>        Parser              kubeapiserverParser
</span><span style=color:#a31515>        Reserve_Data        True</span>    
</code></pre></div><h5 id=how-to-expose-logs-to-the-users>How to expose logs to the users</h5><p>To expose logs from extension components to the users, the extension owners have to specify a <code>modify</code> filter which will add <code>__gardener_multitenant_id__=operator;user</code> entry to the log record. This entry contains all of the tenants, which have to receive this log. The tenants are semicolon separated. This specific dedicated entry will be extracted and removed from the log in the <code>gardener fluent-bit-to-loki</code> output plugin and added to the label set of that log. Then it will be parsed and removed from the label set. Any whitespace will be truncated during the parsing. The extension components logs can be found in <code>Controlplane Logs Dashboard</code> Grafana dashboard.</p><p><strong>Example:</strong> In this example we configure fluent-bit when it finds a log with field <code>tag</code>, which match the <code>Condition</code>, to add <code>__gardener_multitenant_id__=operator;user</code> into the log record.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ConfigMap
metadata:
  name: gardener-extension-provider-aws-logging-config
  namespace: garden
  labels:
    extensions.gardener.cloud/configuration: logging
data:
  filter-kubernetes.conf: |<span style=color:#a31515>
</span><span style=color:#a31515>    [FILTER]
</span><span style=color:#a31515>        Name          modify
</span><span style=color:#a31515>        Match         kubernetes.*
</span><span style=color:#a31515>        Condition     Key_value_matches tag ^kubernetes\.var\.log\.containers\.(cloud-controller-manager-.+?_.+?_aws-cloud-controller-manager|csi-driver-controller-.+?_.+?_aws-csi)_.+?
</span><span style=color:#a31515>        Add           __gardener_multitenant_id__ operator;user</span>    
</code></pre></div><p>In this case we have predefined filter which copies the log&rsquo;s tag into the log record under the <code>tag</code> field. The tag consists of the container logs directories path, plus <code>&lt;pod_name>_&lt;shoot_controlplane_namespace>_&lt;container_name>_&lt;container_id></code>, so here we say:</p><blockquote><p>When you see a record from pod <code>cloud-controller-manager</code> and some of the <code>aws-cloud-controller-manager</code>, <code>csi-driver-controller</code> or <code>aws-csi</code> containers add <code>__gardener_multitenant_id__</code> key with <code>operator;user</code> value into the log record.</p></blockquote><p>Further details how to define parsers and use them with examples can be found in the following <a href=/docs/gardener/development/log_parsers/>guide</a>.</p><h4 id=grafana>Grafana</h4><p>The three types of Grafana instances found in a seed cluster are configured to expose logs of different origin in their dashboards:</p><ul><li>Garden Grafana dashboards expose logs from non-shoot namespaces of the seed clusters<ul><li><a href=https://github.com/gardener/gardener/blob/master/charts/seed-bootstrap/dashboards/pod-logs.json>Pod Logs</a></li><li><a href=https://github.com/gardener/gardener/blob/master/charts/seed-bootstrap/dashboards/extensions-dashboard.json>Extensions</a></li><li><a href=https://github.com/gardener/gardener/blob/master/charts/seed-bootstrap/dashboards/systemd-logs.json>Systemd Logs</a></li></ul></li><li>Shoot User Grafana dashboards expose a subset of the logs shown to operators<ul><li>Kube Apiserver</li><li>Kube Controller Manager</li><li>Kube Scheduler</li><li>Cluster Autoscaler</li><li>VPA components</li></ul></li><li>Shoot Operator Grafana dashboards expose logs from the shoot cluster namespace where they belong<ul><li>All user&rsquo;s dashboards</li><li><a href=https://github.com/gardener/gardener/blob/master/charts/seed-monitoring/charts/grafana/dashboards/operators/kubernetes-pods-dashboard.json>Kubernetes Pods</a></li></ul></li></ul><p>If the type of logs exposed in the Grafana instances needs to be changed, it is necessary to update the coresponding instance dashboard configurations.</p><h2 id=tips>Tips</h2><ul><li>Be careful to match exactly the log names that you need for a particular parser in your filters configuration. The regular expression you will supply will match names in the form <code>kubernetes.pod_name.&lt;metadata>.container_name</code>. If there are extensions with the same container and pod names, they will all match the same parser in a filter. That may be a desired effect, if they all share the same log format. But it will be a problem if they don&rsquo;t. To solve it, either the pod or container names must be unique, and the regular expression in the filter has to match that unique pattern. A recommended approach is to prefix containers with the extension name and tune the regular expression to match it. For example, using <code>myextension-container</code> as container name, and a regular expression <code>kubernetes.mypod.*myextension-container</code> will guarantee match of the right log name. Make sure that the regular expression does not match more than you expect. For example, <code>kubernetes.systemd.*systemd.*</code> will match both <code>systemd-service</code> and <code>systemd-monitor-service</code>. You will want to be as specific as possible.</li><li>It&rsquo;s a good idea to put the logging configuration into the Helm chart that also deploys the extension <em>controller</em>, while the monitoring configuration can be part of the Helm chart/deployment routine that deploys the <em>component</em> managed by the controller.</li></ul><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/issues/1351>GitHub issue describing the concept</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-gcp/blob/master/charts/internal/seed-controlplane/charts/cloud-controller-manager/templates/configmap-observability.yaml>Exemplary implementation (monitoring) for the GCP provider</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-openstack/blob/master/charts/gardener-extension-provider-openstack/templates/configmap-logging.yaml>Exemplary implementation (logging) for the OpenStack provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-107acf6f6b69c9ac1c403a4f60e455d7>5.18 - Managedresources</h1><h1 id=deploy-resources-to-the-shoot-cluster>Deploy resources to the Shoot cluster</h1><p>We have introduced a component called <a href=/docs/gardener/concepts/resource-manager/><code>gardener-resource-manager</code></a> that is deployed as part of every shoot control plane in the seed.
One of its tasks is to manage CRDs, so called <code>ManagedResource</code>s.
Managed resources contain Kubernetes resources that shall be created, reconciled, updated, and deleted by the gardener-resource-manager.</p><p>Extension controllers may create these <code>ManagedResource</code>s in the shoot namespace if they need to create any resource in the shoot cluster itself, for example RBAC roles (or anything else).</p><h2 id=where-can-i-find-more-examples-and-more-information-how-to-use-managedresources>Where can I find more examples and more information how to use <code>ManagedResource</code>s?</h2><p>Please take a look at the <a href=/docs/gardener/concepts/resource-manager/>respective documentation</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fb6f6dc9c480f0bfbe05fce71647dcf7>5.19 - Migration</h1><h1 id=control-plane-migration>Control Plane Migration</h1><p><em>Control Plane Migration</em> is a new Gardener feature that has been recently implemented as proposed in <a href=/docs/gardener/proposals/07-shoot-control-plane-migration/>GEP-7 Shoot Control Plane Migration</a>. It should be properly supported by all extensions controllers. This document outlines some important points that extension maintainers should keep in mind to properly support migration in their extensions.</p><h2 id=overall-principles>Overall Principles</h2><p>The following principles should always be upheld:</p><ul><li>All state maintained by the extension that is external from the seed cluster, for example infrastructure resources in a cloud provider, DNS entries, etc., should be kept during the migration. No such state should be deleted and then recreated, as this might cause disruption in the availability of the shoot cluster.</li><li>All Kubernetes resources maintained by the extension in the shoot cluster itself should also be kept during the migration. No such resources should be deleted and then recreated.</li></ul><h2 id=migrate-and-restore-operations>Migrate and Restore Operations</h2><p>Two new operations have been introduced in Gardener. They can be specified as values of the <code>gardener.cloud/operation</code> annotation on an extension resource to indicate that an operation different from a normal <code>reconcile</code> should be performed by the corresponding extension controller:</p><ul><li>The <code>migrate</code> operation is used to ask the extension controller in the source seed to stop reconciling extension resources (in case they are requeued due to errors) and perform cleanup activities, if such are required. These cleanup activities might involve removing finalizers on resources in the shoot namespace that have been previously created by the extension controller and deleting them without actually deleting any resources external to the seed cluster.</li><li>The <code>restore</code> operation is used to ask extension controller in the destination seed to restore any state saved in the extension resource <code>status</code>, before performing the actual reconciliation.</li></ul><p>Unlike the <a href=/docs/gardener/extensions/reconcile-trigger/>reconcile operation</a>, extension controllers must remove the <code>gardener.cloud/operation</code> annotation at the end of a successful reconciliation when the current operation is <code>migrate</code> or <code>restore</code>, not at the beginning of a reconciliation.</p><h2 id=cleaning-up-source-seed-resources>Cleaning-up Source Seed Resources</h2><p>All resources in the source seed that have been created by an extension controller, for example secrets, config maps, <a href=/docs/gardener/extensions/managedresources/>managed resources</a>, etc. should be properly cleaned up by the extension controller when the current operation is <code>migrate</code>. As mentioned above, such resources should be deleted without actually deleting any resources external to the seed cluster.</p><p>For many custom resources, for example MCM resources, the above requirement means in practice that any finalizers should be removed before deleting the resource, in addition to ensuring that the resource deletion is not reconciled by its respective controller if there is no finalizer. For managed resources, the above requirement means in practice that the <code>spec.keepObjects</code> field should be set to <code>true</code> before deleting the extension resource.</p><p>Here it is assumed that any resources that contain state needed by the extension controller can be safely deleted, since any such state has been saved as described in <a href=#saving-and-restoring-extension-states>Saving and Restoring Extension States</a> at the end of the last successful reconciliation.</p><h2 id=saving-and-restoring-extension-states>Saving and Restoring Extension States</h2><p>Some extension controllers create and maintain their own state when reconciling extension resources. For example, most infrastructure controllers use Terraform and maintain the terraform state in a special config map in the shoot namespace. This state must be properly migrated to the new seed cluster during control plane migration, so that subsequent reconciliations in the new seed could find and use it appropriately.</p><p>All extension controllers that require such state migration must save their state in the <code>status.state</code> field of their extension resource at the end of a successful reconciliation. They must also restore their state from that same field upon reconciling an extension resource when the current operation is <code>restore</code>, as specified by the <code>gardener.cloud/operation</code> annotation, before performing the actual reconciliation.</p><p>As an example, an infrastructure controller that uses Terraform must save the terraform state in the <code>status.state</code> field of the <code>Infrastructure</code> resource. An <code>Infrastructure</code> resource with a properly saved state might look as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--foo--bar
spec:
  type: azure
  region: eu-west-1
  secretRef:
    name: cloudprovider
    namespace: shoot--foo--bar
  providerConfig:
    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureConfig
    resourceGroup:
      name: mygroup
    ...
status:
  state: |<span style=color:#a31515>
</span><span style=color:#a31515>    {
</span><span style=color:#a31515>      &#34;version&#34;: 3,
</span><span style=color:#a31515>      &#34;terraform_version&#34;: &#34;0.11.14&#34;,
</span><span style=color:#a31515>      &#34;serial&#34;: 2,
</span><span style=color:#a31515>      &#34;lineage&#34;: &#34;3a1e2faa-e7b6-f5f0-5043-368dd8ea6c10&#34;,
</span><span style=color:#a31515>      ...
</span><span style=color:#a31515>    }</span>    
</code></pre></div><p>Extension controllers that do not use a saved state and therefore do not require state migration could leave the <code>status.state</code> field as <code>nil</code> at the end of a successful reconciliation, and just perform a normal reconciliation when the current operation is <code>restore</code>.</p><p>In addition, extension controllers that use <a href=/docs/gardener/extensions/referenced-resources/>referenced resources</a> (usually secrets) must also make sure that these resources are added to the <code>status.resources</code> field of their extension resource at the end of a successful reconciliation, so they could be properly migrated by Gardener to the destination seed.</p><h2 id=implementation-details>Implementation Details</h2><h3 id=migrate-and-restore-actuator-methods>Migrate and Restore Actuator Methods</h3><p>Most extension controller implementations follow a common pattern where a generic <code>Reconciler</code> implementation delegates to an <code>Actuator</code> interface that contains the methods <code>Reconcile</code> and <code>Delete</code>, provided by the extension. The two new methods <code>Migrate</code> and <code>Restore</code> have been added to all such <code>Actuator</code> interfaces, see <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go>the infrastructure <code>Actuator</code> interface</a> as an example. These methods are called by the generic reconcilers for the <a href=#migrate-and-restore-operations>migrate and restore operations</a> respectively, and should be implemented by the extension according to the above guidelines.</p><h3 id=extension-controllers-based-on-generic-actuators>Extension Controllers Based on Generic Actuators</h3><p>In practice, the implementation of many extension controllers (for example, the controlplane and worker controllers in most provider extensions) are based on a <em>generic <code>Actuator</code> implementation</em> that only delegates to extension methods for behavior that is truly provider specific. In all such cases, the <code>Migrate</code> and <code>Restore</code> methods have already been implemented properly in the generic actuators and there is nothing more to do in the extension itself.</p><p>In some rare cases, extension controllers based on a generic actuator might still introduce a custom <code>Actuator</code> implementation to override some of the generic actuator methods in order to enhance or change their behavior in a certain way. In such cases, the <code>Migrate</code> and <code>Restore</code> methods might need to be overridden as well, see the <a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/controlplane>Azure controlplane controller</a> as an example.</p><h3 id=extension-controllers-not-based-on-generic-actuators>Extension Controllers Not Based on Generic Actuators</h3><p>The implementation of some extension controllers (for example, the infrastructure controllers in all provider extensions) are not based on a generic <code>Actuator</code> implementation. Such extension controllers must always provide a proper implementation of the <code>Migrate</code> and <code>Restore</code> methods according to the above guidelines, see the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure>AWS infrastructure controller</a> as an example. In practice this might result in code duplication between the different extensions, since the <code>Migrate</code> and <code>Restore</code> code is usually not provider or OS-specific.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6abc753b67fb6ebd6b625067c168bcb1>5.20 - Network</h1><h1 id=gardener-network-extension>Gardener Network Extension</h1><p>Gardener is an open-source project that provides a nested user model. Basically, there are two types of services provided by Gardener to its users:</p><ul><li>Managed: end-users only request a Kubernetes cluster (Clusters-as-a-Service)</li><li>Hosted: operators utilize Gardener to provide their own managed version of Kubernetes (Cluster-Provisioner-as-a-service)</li></ul><p>Whether an operator or an end-user, it makes sense to provide choice. For example, for an end-user it might make sense to
choose a network-plugin that would support enforcing network policies (some plugins does not come with network-policy support by default).
For operators however, choice only matters for delegation purposes i.e., when providing an own managed-service, it becomes important to also provide choice over which network-plugins to use.</p><p>Furthermore, Gardener provisions clusters on different cloud-providers with different networking requirements. For example, Azure does not support Calico Networking [1], this leads to the introduction of manual exceptions in static add-on charts which is error prone and can lead to failures during upgrades.</p><p>Finally, every provider is different, and thus the network always needs to adapt to the infrastructure needs to provide better performance. Consistency does not necessarily lie in the implementation but in the interface.</p><h2 id=motivation>Motivation</h2><p>Prior to the <code>Network Extensibility</code> concept, Gardener followed a mono network-plugin support model (i.e., Calico). Although this seemed to be the easier approach, it did not completely reflect the real use-case.
The goal of the Gardener Network Extensions is to support different network plugins, therefore, the specification for the network resource won&rsquo;t be fixed and will be customized based on the underlying network plugin.</p><p>To do so, a <code>ProviderConfig</code> field in the spec will be provided where each plugin will define. Below is an example for how to deploy Calico as the cluster network plugin.</p><h2 id=the-network-extensions-resource>The Network Extensions Resource</h2><p>Here is what a typical <code>Network</code> resource would look-like:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Network
metadata:
  name: my-network
spec:
  podCIDR: 100.244.0.0/16
  serviceCIDR: 100.32.0.0/13
  type: calico
  providerConfig:
    apiVersion: calico.networking.extensions.gardener.cloud/v1alpha1
    kind: NetworkConfig
    backend: bird
    ipam:
      cidr: usePodCIDR
      type: host-local
</code></pre></div><p>The above resources is divided into two parts (more information can be found <a href=/docs/extensions/network-extensions/gardener-extension-networking-calico/docs/usage-as-end-user/>here</a>):</p><ul><li>global configuration (e.g., podCIDR, serviceCIDR, and type)</li><li>provider specific config (e.g., for calico we can choose to configure a <code>bird</code> backend)</li></ul><blockquote><p><strong>Note</strong>: certain cloud-provider extensions might have webhooks that would modify the network-resource to fit into their network specific context. As previously mentioned, Azure does not support IPIP, as a result, the <a href=https://github.com/gardener/gardener-extension-provider-azure>Azure provider extension</a> implements a <a href=https://github.com/gardener/gardener-extension-provider-azure/blob/master/pkg/webhook/network/mutate.go>webhook</a> to mutate the backend and set it to <code>None</code> instead of <code>bird</code>.</p></blockquote><h2 id=supporting-a-new-network-extension-provider>Supporting a new Network Extension Provider</h2><p>To add support for another networking provider (e.g., weave, Cilium, Flannel, etc.) a network extension controller needs to be implemented which would optionally have its own custom configuration specified in the <code>spec.providerConfig</code> in the <code>Network</code> resource. For example, if support for a network plugin named <code>gardenet</code> is required, the following <code>Network</code> resource would be created:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Network
metadata:
  name: my-network
spec:
  podCIDR: 100.244.0.0/16
  serviceCIDR: 100.32.0.0/13
  type: gardenet
  providerConfig:
    apiVersion: gardenet.networking.extensions.gardener.cloud/v1alpha1
    kind: NetworkConfig
    gardenetCustomConfigField: &lt;value&gt;
    ipam:
      cidr: usePodCIDR
      type: host-local
</code></pre></div><p>Once applied, the presumably implemented <code>Gardenet</code> extension controller, would pick the configuration up, parse the <code>providerConfig</code> and create the necessary resources in the shoot.</p><p>For additional reference, please have a look at the <a href=https://github.com/gardener/gardener-extension-networking-calico>networking-calico</a> provider extension, which provides more information on how to configure the necessary charts as well as the actuators required to reconcile networking inside the <code>Shoot</code> cluster to the desired state.</p><h2 id=supporting-kube-proxy-less-service-routing>Supporting <code>kube-proxy</code> less Service Routing</h2><p>Some networking extensions support service routing without the <code>kube-proxy</code> component. This is why Gardener supports disabling of <code>kube-proxy</code> for service routing by setting <code>.spec.kubernetes.kubeproxy.enabled</code> to <code>false</code> in the <code>Shoot</code> specification. The implicit contract of the flag is: If <code>kube-proxy</code> is disabled then the networking extension is responsible for the service routing.
The networking extensions need to handle this twofold:</p><ol><li>During the reconciliation of the networking resources, the extension needs to check whether <code>kube-proxy</code> takes care of the service routing or the networking extension itself should handle it. In case the networking extension should be responsible according to <code>.spec.kubernetes.kubeproxy.enabled</code> (but is unable to perform the service routing) it should raise an error during the reconciliation. If the networking extension should handle the service routing it may reconfigure itself accordingly.</li><li>(optional) In case the networking extension does not support taking over the service routing (in some scenarios), it is recommended to also provide a validating admission webhook to reject corresponding changes early on. The validation may take the current operating mode of the networking extension into consideration.</li></ol><h2 id=references>References</h2><p>[1] <a href=https://docs.projectcalico.org/v3.0/reference/public-cloud/azure>Azure support for Calico Networking</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d758265b318aa3c4194c99f8fe8e2760>5.21 - Operatingsystemconfig</h1><h1 id=contract-operatingsystemconfig-resource>Contract: <code>OperatingSystemConfig</code> resource</h1><p>Gardener uses the machine API and leverages the functionalities of the <a href=https://github.com/gardener/machine-controller-manager>machine-controller-manager</a> (MCM) in order to manage the worker nodes of a shoot cluster.
The machine-controller-manager itself simply takes a reference to an OS-image and (optionally) some user-data (a script or configuration that is executed when a VM is bootstrapped), and forwards both to the provider&rsquo;s API when creating VMs.
MCM does not have any restrictions regarding supported operating systems as it does not modify or influence the machine&rsquo;s configuration in any way - it just creates/deletes machines with the provided metadata.</p><p>Consequently, Gardener needs to provide this information when interacting with the machine-controller-manager.
This means that basically every operating system is possible to be used as long as there is some implementation that generates the OS-specific configuration in order to provision/bootstrap the machines.</p><p>⚠️ Currently, there are a few requirements:</p><ol><li>The operating system must have built-in <a href=https://www.docker.com/>Docker</a> support.</li><li>The operating system must have <a href=https://www.freedesktop.org/wiki/Software/systemd/>systemd</a> support.</li><li>The operating system must have <a href=https://www.gnu.org/software/wget/><code>wget</code></a> pre-installed.</li><li>The operating system must have <a href=https://stedolan.github.io/jq/><code>jq</code></a> pre-installed.</li></ol><p>The reasons for that will become evident later.</p><h2 id=what-does-the-user-data-bootstrapping-the-machines-contain>What does the user-data bootstrapping the machines contain?</h2><p>Gardener installs a few components onto every worker machine in order to allow it to join the shoot cluster.
There is the <code>kubelet</code> process, some scripts for continuously checking the health of <code>kubelet</code> and <code>docker</code>, but also configuration for log rotation, CA certificates, etc.
The complete configuration you can find <a href=https://github.com/gardener/gardener/tree/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/original/components>here</a>. We are calling this the &ldquo;original&rdquo; user-data.</p><h2 id=how-does-gardener-bootstrap-the-machines>How does Gardener bootstrap the machines?</h2><p>Usually, you would submit all the components you want to install onto the machine as part of the user-data during creation time.
However, some providers do have a size limitation (like ~16KB) for that user-data.
That&rsquo;s why we do not send the &ldquo;original&rdquo; user-data to the machine-controller-manager (who forwards it then to the provider&rsquo;s API).
Instead, we only send a small script that downloads the &ldquo;original&rdquo; data and applies it on the machine directly.
This way we can extend the &ldquo;original&rdquo; user-data without any size restrictions - plus we can modify it without the necessity of re-creating the machine (because we run a script that downloads and updates it continuously).</p><p>The high-level flow is as follows:</p><ol><li><p>For every worker pool <code>X</code> in the <code>Shoot</code> specification, Gardener creates a <code>Secret</code> named <code>cloud-config-&lt;X></code> in the <code>kube-system</code> namespace of the shoot cluster. The secret contains the &ldquo;original&rdquo; user-data.</p></li><li><p>Gardener generates a kubeconfig with minimal permissions just allowing reading these secrets. It is used by the <code>downloader</code> script later.</p></li><li><p>Gardener provides the <code>downloader</code> script, the kubeconfig, and the machine image stated in the <code>Shoot</code> specification to the machine-controller-manager.</p></li><li><p>Based on this information the machine-controller-manager creates the VM.</p></li><li><p>After the VM has been provisioned the <code>downloader</code> script starts and fetches the appropriate <code>Secret</code> for its worker pool (containing the &ldquo;original&rdquo; user-data) and applies it.</p></li></ol><h3 id=detailed-bootstrap-flow-with-a-worker-generated-bootstrap-token>Detailed bootstrap flow with a worker generated bootstrap-token</h3><p>With gardener v1.23 a file with the content <code>&lt;&lt;BOOTSTRAP_TOKEN>></code> is added to the <code>cloud-config-&lt;worker-group>-downloader</code> <code>OperatingSystemConfig</code> (part of step 2 in the graphic below).
Via the OS extension the new file (with its content in clear-text) gets passed to the corresponding <code>Worker</code> resource.</p><p>The <code>Worker</code> controller has to guarantee that:</p><ul><li>a bootstrap token is created.</li><li>the <code>&lt;&lt;BOOTSTRAP_TOKEN>></code> in the user data is replaced by the generated token.
One implementation of that is depicted in the picture where the machine-controller-manager creates a temporary token and replaces the placeholder.</li></ul><p>As part of the user-data the bootstrap-token is placed on the newly created VM under a defined path.
The cloud-config-script will then refer to the file path of the added bootstrap token in the kubelet-bootstrap script.</p><p><img src=/__resources/bootstrap_token_c9a050.png alt="Bootstrap flow with shortlived bootstrapTokens"></p><h3 id=compatibility-matrix-for-node-bootstrap-token>Compatibility matrix for node bootstrap-token</h3><p>With Gardener v1.23, we replaced the long-valid bootstrap-token shared between nodes with a short-lived token unique for each node, ref: <a href=https://github.com/gardener/gardener/issues/3898>#3898</a>.</p><p>❗ When updating to Gardener version >=1.35 the old bootstrap-token will be removed. You are required to update your extensions to the following versions when updating Gardener:</p><table><thead><tr><th>Extension</th><th>Version</th><th>Release Date</th><th>Pull Request</th></tr></thead><tbody><tr><td>os-gardenlinux</td><td>v0.9.0</td><td>2 Jul</td><td><a href=https://github.com/gardener/gardener-extension-os-gardenlinux/pull/29>https://github.com/gardener/gardener-extension-os-gardenlinux/pull/29</a></td></tr><tr><td>os-suse-chost</td><td>v1.11.0</td><td>2 Jul</td><td><a href=https://github.com/gardener/gardener-extension-os-suse-chost/pull/41>https://github.com/gardener/gardener-extension-os-suse-chost/pull/41</a></td></tr><tr><td>os-ubuntu</td><td>v1.11.0</td><td>2 Jul</td><td><a href=https://github.com/gardener/gardener-extension-os-ubuntu/pull/42>https://github.com/gardener/gardener-extension-os-ubuntu/pull/42</a></td></tr><tr><td>os-flatcar</td><td>v1.7.0</td><td>2 Jul</td><td><a href=https://github.com/gardener/gardener-extension-os-coreos/pull/24>https://github.com/gardener/gardener-extension-os-coreos/pull/24</a></td></tr><tr><td>infrastructure-provider using Machine Controller Manager</td><td>varies</td><td>~ end of 2019</td><td><a href=https://github.com/gardener/machine-controller-manager/pull/351>https://github.com/gardener/machine-controller-manager/pull/351</a></td></tr></tbody></table><p>⚠️ If you run a provider extension that does not use Machine Controller Manager (MCM) you need to implement the functionality of creating a temporary bootstrap-token before updating your Gardener version to v1.35 or higher.
All provider extensions maintained in <a href=https://github.com/gardener/>https://github.com/gardener/</a> use MCM.</p><h2 id=how-does-gardener-update-the-user-data-on-already-existing-machines>How does Gardener update the user-data on already existing machines?</h2><p>With ongoing development and new releases of Gardener some new components could be required to get installed onto every shoot worker VM, or existing components need to be changed.
Gardener achieves that by simply updating the user-data inside the <code>Secret</code>s mentioned above (step 1).
The <code>downloader</code> script is continuously (every 30s) reading the secret&rsquo;s content (which might include an updated user-data) and storing it onto the disk.
In order to re-apply the (new) downloaded data the secrets do not only contain the &ldquo;original&rdquo; user-data but also another short script (called &ldquo;execution&rdquo; script).
This script checks whether the downloaded user-data differs from the one previously applied - and if required - re-applies it.
After that it uses <code>systemctl</code> to restart the installed <code>systemd</code> units.</p><p>With the help of the execution script Gardener can centrally control how machines are updated without the need of OS providers to (re-)implement that logic.
However, as stated in the mentioned requirements above, the execution script assumes existence of Docker and <code>systemd</code>.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-operating-system>What needs to be implemented to support a new operating system?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: OperatingSystemConfig
metadata:
  name: pool-01-original
  namespace: default
spec:
  type: &lt;my-operating-system&gt;
  purpose: reconcile
  reloadConfigFilePath: /var/lib/cloud-config-downloader/cloud-config
  units:
  - name: docker.service
    dropIns:
    - name: 10-docker-opts.conf
      content: |<span style=color:#a31515>
</span><span style=color:#a31515>        [Service]
</span><span style=color:#a31515>        Environment=&#34;DOCKER_OPTS=--log-opt max-size=60m --log-opt max-file=3&#34;</span>        
  - name: docker-monitor.service
    command: start
    enable: <span style=color:#00f>true</span>
    content: |<span style=color:#a31515>
</span><span style=color:#a31515>      [Unit]
</span><span style=color:#a31515>      Description=Docker-monitor daemon
</span><span style=color:#a31515>      After=kubelet.service
</span><span style=color:#a31515>      [Install]
</span><span style=color:#a31515>      WantedBy=multi-user.target
</span><span style=color:#a31515>      [Service]
</span><span style=color:#a31515>      Restart=always
</span><span style=color:#a31515>      EnvironmentFile=/etc/environment
</span><span style=color:#a31515>      ExecStart=/opt/bin/health-monitor docker</span>      
  files:
  - path: /var/lib/kubelet/ca.crt
    permissions: 0644
    encoding: b64
    content:
      secretRef:
        name: default-token-5dtjz
        dataKey: token
  - path: /etc/sysctl.d/99-k8s-general.conf
    permissions: 0644
    content:
      inline:
        data: |<span style=color:#a31515>
</span><span style=color:#a31515>          # A higher vm.max_map_count is great for elasticsearch, mongo, or other mmap users
</span><span style=color:#a31515>          # See https://github.com/kubernetes/kops/issues/1340
</span><span style=color:#a31515>          vm.max_map_count = 135217728</span>          
</code></pre></div><p>In order to support a new operating system you need to write a controller that watches all <code>OperatingSystemConfig</code>s with <code>.spec.type=&lt;my-operating-system></code>.
For those it shall generate a configuration blob that fits to your operating system.
For example, a CoreOS controller might generate a <a href=https://coreos.com/os/docs/latest/cloud-config.html>CoreOS cloud-config</a> or <a href=https://coreos.com/ignition/docs/latest/what-is-ignition.html>Ignition</a>, SLES might generate <a href=https://cloudinit.readthedocs.io/en/latest/>cloud-init</a>, and others might simply generate a bash script translating the <code>.spec.units</code> into <code>systemd</code> units, and <code>.spec.files</code> into real files on the disk.</p><p><code>OperatingSystemConfig</code>s can have two purposes which can be used (or ignored) by the extension controllers: either <code>provision</code> or <code>reconcile</code>.</p><ul><li>The <code>provision</code> purpose is used by Gardener for the user-data that it later passes to the machine-controller-manager (and then to the provider&rsquo;s API) when creating new VMs. It contains the <code>downloader</code> unit.</li><li>The <code>reconcile</code> purpose contains the &ldquo;original&rdquo; user-data (that is then stored in <code>Secret</code>s in the shoot&rsquo;s <code>kube-system</code> namespace (see step 1). This is downloaded and applies late (see step 5).</li></ul><p>As described above, the &ldquo;original&rdquo; user-data must be re-applicable to allow in-place updates.
The way how this is done is specific to the generated operating system config (e.g., for CoreOS cloud-init the command is <code>/usr/bin/coreos-cloudinit --from-file=&lt;path></code>, whereas SLES would run <code>cloud-init --file &lt;path> single -n write_files --frequency=once</code>).
Consequently, besides the generated OS config, the extension controller must also provide a command for re-application an updated version of the user-data.
As visible in the mentioned examples the command requires a path to the user-data file.
Gardener will provide the path to the file in the <code>OperatingSystemConfig</code>s <code>.spec.reloadConfigFilePath</code> field (only if <code>.spec.purpose=reconcile</code>).
As soon as Gardener detects that the user data has changed it will reload the systemd daemon and restart all the units provided in the <code>.status.units[]</code> list (see below example). The same logic applies during the very first application of the whole configuration.</p><p>After generation extension controllers are asked to store their OS config inside a <code>Secret</code> (as it might contain confidential data) in the same namespace.
The secret&rsquo;s <code>.data</code> could look like this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: osc-result-pool-01-original
  namespace: default
  ownerReferences:
  - apiVersion: extensions.gardener.cloud/v1alpha1
    blockOwnerDeletion: <span style=color:#00f>true</span>
    controller: <span style=color:#00f>true</span>
    kind: OperatingSystemConfig
    name: pool-01-original
    uid: 99c0c5ca-19b9-11e9-9ebd-d67077b40f82
data:
  cloud_config: base64(generated-user-data)
</code></pre></div><p>Finally, the secret&rsquo;s metadata, the OS-specific command to re-apply the configuration, and the list of <code>systemd</code> units that shall be considered to be restarted if an updated version of the user-data is re-applied must be provided in the <code>OperatingSystemConfig</code>&rsquo;s <code>.status</code> field:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>...
status:
  cloudConfig:
    secretRef:
      name: osc-result-pool-01-original
      namespace: default
  command: /usr/bin/coreos-cloudinit --from-file=/var/lib/cloud-config-downloader/cloud-config
  lastOperation:
    description: Successfully generated cloud config
    lastUpdateTime: <span style=color:#a31515>&#34;2019-01-23T07:45:23Z&#34;</span>
    progress: 100
    state: Succeeded
    type: Reconcile
  observedGeneration: 5
  units:
  - docker-monitor.service
</code></pre></div><p>(The <code>.status.command</code> field is optional and must only be provided if <code>.spec.reloadConfigFilePath</code> exists).</p><p>Once the <code>.status</code> indicates that the extension controller finished reconciling Gardener will continue with the next step of the shoot reconciliation flow.</p><h2 id=cri-support>CRI Support</h2><p>Gardener supports specifying Container Runtime Interface (CRI) configuration in the <code>OperatingSystemConfig</code> resource. If the <code>.spec.cri</code> section exists then the <code>name</code> property is mandatory. The only supported values for <code>cri.name</code> at the moment are: <code>containerd</code> and <code>docker</code>, which uses the in-tree dockershim.
For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: OperatingSystemConfig
metadata:
  name: pool-01-original
  namespace: default
spec:
  type: &lt;my-operating-system&gt;
  purpose: reconcile
  reloadConfigFilePath: /var/lib/cloud-config-downloader/cloud-config
  cri:
    name: containerd
...
</code></pre></div><p>To support ContainerD, an OS extension must :</p><ol><li>The operating system must have built-in <a href=https://containerd.io/>ContainerD</a> and the <a href=https://github.com/projectatomic/containerd/blob/master/docs/cli.md/>Client CLI</a></li><li>ContainerD must listen on its default socket path: <code>unix:///run/containerd/containerd.sock</code></li><li>ContainerD must be configured to work with the default configuration file in: <code>/etc/containerd/config.toml</code> (Created by Gardener).</li></ol><p>If CRI configurations are not supported it is recommended create a validating webhook running in the garden cluster that prevents specifying the <code>.spec.providers.workers[].cri</code> section in the <code>Shoot</code> objects.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_operatingsystemconfig.go><code>OperatingSystemConfig</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/downloader/templates/scripts/download-cloud-config.tpl.sh><code>downloader</code> script</a> (fetching the &ldquo;original&rdquo; user-data and the execution script)</li><li><a href=https://github.com/gardener/gardener/tree/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/original/components>Original user-data templates</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/executor/templates/scripts/execute-cloud-config.tpl.sh>Execution script</a> (applying the &ldquo;original&rdquo; user-data)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5809410418b357cb13756988bdf0a8b8>5.22 - Overview</h1><h1 id=extensibility-overview>Extensibility overview</h1><p>Initially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself.
But as the project grew, it got more and more difficult to add new providers and maintain the existing code base.
As a consequence and in order to become agile and flexible again, we proposed <a href=/docs/gardener/proposals/01-extensibility/>GEP-1</a> (Gardener Enhancement Proposal).
The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with <a href=https://github.com/kubernetes/enhancements/issues/88>out-of-tree cloud providers</a> or with <a href=https://github.com/kubernetes/community/pull/1258>CSI volume plugins</a>).</p><h2 id=basic-concepts>Basic concepts</h2><p>Gardener keeps running in the &ldquo;garden cluster&rdquo; and implements the core logic of shoot cluster reconciliation/deletion.
Extensions are Kubernetes controllers themselves (like Gardener) and run in the seed clusters.
As usual, we try to use Kubernetes wherever applicable.
We rely on Kubernetes extension concepts in order to enable extensibility for Gardener.
The main ideas of GEP-1 are the following:</p><ol><li><p>During the shoot reconciliation process Gardener will write CRDs into the seed cluster that are watched and managed by the extension controllers. They will reconcile (based on the <code>.spec</code>) and report whether everything went well or errors occurred in the CRD&rsquo;s <code>.status</code> field.</p></li><li><p>Gardener keeps deploying the provider-independent control plane components (etcd, kube-apiserver, etc.). However, some of these components might still need little customization by providers, e.g., additional configuration, flags, etc. In this case, the extension controllers register webhooks in order to manipulate the manifests.</p></li></ol><p><strong>Example 1</strong>:</p><p>Gardener creates a new AWS shoot cluster and requires the preparation of infrastructure in order to proceed (networks, security groups, etc.).
It writes the following CRD into the seed cluster:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--core--aws-01
spec:
  type: aws
  providerConfig:
    apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureConfig
    networks:
      vpc:
        cidr: 10.250.0.0/16
      internal:
      - 10.250.112.0/22
      public:
      - 10.250.96.0/22
      workers:
      - 10.250.0.0/19
    zones:
    - eu-west-1a
  dns:
    apiserver: api.aws-01.core.example.com
  region: eu-west-1
  secretRef:
    name: my-aws-credentials
  sshPublicKey: |<span style=color:#a31515>
</span><span style=color:#a31515>    </span>    base64(key)
</code></pre></div><p>Please note that the <code>.spec.providerConfig</code> is a raw blob and not evaluated or known in any way by Gardener.
Instead, it was specified by the user (in the <code>Shoot</code> resource) and just &ldquo;forwarded&rdquo; to the extension controller.
Only the AWS controller understands this configuration and will now start provisioning/reconciling the infrastructure.
It reports in the <code>.status</code> field the result:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
  providerStatus:
    apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureStatus
    vpc:
      id: vpc-1234
      subnets:
      - id: subnet-acbd1234
        name: workers
        zone: eu-west-1
      securityGroups:
      - id: sg-xyz12345
        name: workers
    iam:
      nodesRoleARN: &lt;some-arn&gt;
      instanceProfileName: foo
    ec2:
      keyName: bar
</code></pre></div><p>Gardener waits until the <code>.status.lastOperation</code>/<code>.status.lastError</code> indicates that the operation reached a final state and either continuous with the next step or stops and reports the potential error.
The extension-specific output in <code>.status.providerStatus</code> is - similar to <code>.spec.providerConfig</code> - not evaluated and simply forwarded to CRDs in subsequent steps.</p><p><strong>Example 2</strong>:</p><p>Gardener deploys the control plane components into the seed cluster, e.g. the <code>kube-controller-manager</code> deployment with the following flags:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: apps/v1
kind: Deployment
...
spec:
  template:
    spec:
      containers:
      - command:
        - /usr/local/bin/kube-controller-manager
        - --allocate-node-cidrs=true
        - --attach-detach-reconcile-sync-period=1m0s
        - --controllers=*,bootstrapsigner,tokencleaner
        - --cluster-cidr=100.96.0.0/11
        - --cluster-name=shoot--core--aws-01
        - --cluster-signing-cert-file=/srv/kubernetes/ca/ca.crt
        - --cluster-signing-key-file=/srv/kubernetes/ca/ca.key
        - --concurrent-deployment-syncs=10
        - --concurrent-replicaset-syncs=10
...
</code></pre></div><p>The AWS controller requires some additional flags in order to make the cluster functional.
It needs to provide a Kubernetes cloud-config and also some cloud-specific flags.
Consequently, it registers a <code>MutatingWebhookConfiguration</code> on <code>Deployment</code>s and adds these flags to the container:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>        - --cloud-provider=external
        - --external-cloud-volume-plugin=aws
        - --cloud-config=/etc/kubernetes/cloudprovider/cloudprovider.conf
</code></pre></div><p>Of course, it would have needed to create a <code>ConfigMap</code> containing the cloud config and to add the proper <code>volume</code> and <code>volumeMounts</code> to the manifest as well.</p><p>(Please note for this special example: The Kubernetes community is also working on making the <code>kube-controller-manager</code> provider-independent.
However, there will most probably be still components other than the <code>kube-controller-manager</code> which need to be adapted by extensions.)</p><p>If you are interested in writing an extension, or generally in digging deeper to find out the nitty-gritty details of the extension concepts please read <a href=/docs/gardener/proposals/01-extensibility/>GEP-1</a>.
We are truly looking forward to your feedback!</p><h2 id=current-status>Current status</h2><p>Meanwhile, the out-of-tree extension architecture of Gardener is in place and has been productively validated. We are tracking all internal and external extensions of Gardener in the repo: <a href=https://github.com/gardener/gardener/tree/master/extensions#known-extension-implementations>Gardener Extensions Library</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d20ec57f1c788e4c86ed68fe624544eb>5.23 - Project Roles</h1><h1 id=extending-project-roles>Extending project roles</h1><p>The <code>Project</code> resource allows to specify a list of roles for every member (<code>.spec.members[*].roles</code>).
There are a few standard roles defined by Gardener itself.
Please consult <a href=/docs/gardener/usage/projects/>this document</a> for further information.</p><p>However, extension controllers running in the garden cluster may also create <code>CustomResourceDefinition</code>s that project members might be able to CRUD.
For this purpose Gardener also allows to specify extension roles.</p><p>An extension role is prefixed with <code>extension:</code>, e.g.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Project
metadata:
  name: dev
spec:
  members:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: alice.doe@example.com
    role: admin
    roles:
    - owner
    - extension:foo
</code></pre></div><p>The project controller will, for every extension role, create a <code>ClusterRole</code> with name <code>name: gardener.cloud:extension:project:&lt;projectName>:&lt;roleName></code>, i.e., for above example: <code>name: gardener.cloud:extension:project:dev:foo</code>.
This <code>ClusterRole</code> aggregates other <code>ClusterRole</code>s that are labeled with <code>rbac.gardener.cloud/aggregate-to-extension-role=foo</code> which might be created by extension controllers.</p><p>Extension that might want to contribute to the core <code>admin</code> or <code>viewer</code> roles can use the labels <code>rbac.gardener.cloud/aggregate-to-project-member=true</code> or <code>rbac.gardener.cloud/aggregate-to-project-viewer=true</code>, respectively.</p><p>Please note that the names of the extension roles are restricted to 20 characters!</p><p>Moreover, the project controller will also create a corresponding <code>RoleBinding</code> with the same name in the project namespace.
It will automatically assign all members that are assigned to this extension role.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-45f5e5c8792c123831d7123647c5db0c>5.24 - Provider Local</h1><h1 id=local-provider-extension>Local Provider Extension</h1><p>The &ldquo;local provider&rdquo; extension is used to allow the usage of seed and shoot clusters which run entirely locally without any real infrastructure or cloud provider involved.
It implements Gardener&rsquo;s extension contract (<a href=/docs/gardener/proposals/01-extensibility/>GEP-1</a>) and thus comprises several controllers and webhooks acting on resources in seed and shoot clusters.</p><p>The code is maintained in <a href=https://github.com/gardener/gardener/tree/master/pkg/provider-local><code>pkg/provider-local</code></a>.</p><h2 id=motivation>Motivation</h2><p>The motivation for maintaining such extension is the following:</p><ul><li>🛡 Output Qualification: Run fast and cost-efficient end-to-end tests, locally and in CI systems (increased confidence ⛑ before merging pull requests)</li><li>⚙️ Development Experience: Develop Gardener entirely on a local machine without any external resources involved (improved costs 💰 and productivity 🚀)</li><li>🤝 Open Source: Quick and easy setup for a first evaluation of Gardener and a good basis for first contributions</li></ul><h2 id=current-limitations>Current Limitations</h2><p>The following enlists the current limitations of the implementation.
Please note that all of them are no technical limitations/blockers but simply advanced scenarios that we haven&rsquo;t had invested yet into.</p><ol><li><p>Shoot clusters can only have one node when <code>.spec.networking.type=local</code>.</p><p><em>We use <a href=https://github.com/kubernetes-sigs/kind/blob/main/images/kindnetd/README.md>kindnetd</a> as CNI plugin in shoot clusters and didn&rsquo;t invest into making it work with multiple worker nodes.</em></p></li><li><p><code>NetworkPolicy</code>s are not effective.</p><p><em><code>kindnetd</code> does not ship any controller for Kubernetes <code>NetworkPolicy</code>s, hence, they are not effective. Typically, the same applies for the local seed cluster unless a different CNI plugin is pro-actively installed.</em></p></li><li><p>Shoot clusters don&rsquo;t support persistent storage.</p><p><em>We don&rsquo;t install any CSI plugin into the shoot cluster yet, hence, there is no persistent storage for shoot clusters.</em></p></li><li><p>No support for ETCD backups.</p><p><em>We have not yet implemented the <a href=/docs/gardener/extensions/backupbucket/><code>BackupBucket</code></a>/<a href=/docs/gardener/extensions/backupentry/><code>BackupEntry</code></a> extension API, hence, there is no support for ETCD backups.</em></p></li><li><p>No owner TXT <code>DNSRecord</code>s (hence, no <a href=/docs/gardener/proposals/17-shoot-control-plane-migration-bad-case/>&ldquo;bad-case&rdquo; control plane migration</a>).</p><p><em>In order to realize DNS (see <a href=#implementation-details>Implementation Details</a> section below), the <code>/etc/hosts</code> file is manipulated. This does not work for TXT records. In the future, we could look into using <a href=https://coredns.io/>CoreDNS</a> instead.</em></p></li><li><p>No load balancers for Shoot clusters.</p><p><em>We have not yet developed a <code>cloud-controller-manager</code> which could reconcile load balancer <code>Service</code>s in the shoot cluster. Hence, when the gardenlet&rsquo;s <code>ReversedVPN</code> feature gate is disabled then the <code>kube-system/vpn-shoot</code> <code>Service</code> must be manually patched (with <code>{"status": {"loadBalancer": {"ingress": [{"hostname": "vpn-shoot"}]}}}</code>) to make the reconciliation work.</em></p></li><li><p>Only one shoot cluster possible when gardenlet&rsquo;s <code>APIServerSNI</code> feature gate is disabled.</p><p><em>When <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/><code>APIServerSNI</code></a> is disabled then gardenlet uses load balancer <code>Service</code>s in order to expose the shoot clusters' <code>kube-apiserver</code>s. Typically, local Kubernetes clusters don&rsquo;t support this. In this case, the local extension uses the host IP to expose the <code>kube-apiserver</code>, however, this can only be done once.</em></p></li><li><p>Dependency-Watchdog cannot be enabled.</p><p><em>The <code>dependency-watchdog</code> needs to be able to resolve the shoot cluster&rsquo;s DNS names. It is not yet able to do so, hence, it cannot be enabled.</em></p></li><li><p><code>Ingress</code>es exposed in the seed cluster are not reachable.</p><p><em>There is no DNS resolution for the domains used for <code>Ingress</code>es in the seed cluster yet, hence, they are not reachable. Consequently, the <a href=/docs/gardener/deployment/configuring_logging/#enable-logs-from-the-shoots-node-systemd-services>shoot node logging</a> feature does not work end-to-end.</em></p></li></ol><h2 id=implementation-details>Implementation Details</h2><p>This section contains information about how the respective controllers and webhooks are implemented and what their purpose is.</p><h3 id=bootstrapping>Bootstrapping</h3><p>The Helm chart of the <code>provider-local</code> extension defined in its <a href=/docs/gardener/extensions/controllerregistration/><code>ControllerDeployment</code></a> contains a special deployment for a <a href=https://coredns.io/>CoreDNS</a> instance in a <code>gardener-extension-provider-local-coredns</code> namespace in the seed cluster.</p><p>This CoreDNS instance is responsible for enabling the components running in the shoot clusters to be able to resolve the DNS names when they communicate with their <code>kube-apiserver</code>s.</p><p>It contains static configuration to resolve the DNS names based on <code>local.gardener.cloud</code> to either the <code>istio-ingressgateway.istio-ingress.svc</code> or the <code>kube-apiserver.&lt;shoot-namespace>.svc</code> addresses (depending on whether the <code>--apiserver-sni-enabled</code> flag is set to <code>true</code> or <code>false</code>).</p><h3 id=controllers>Controllers</h3><p>There are controllers for all resources in the <code>extensions.gardener.cloud/v1alpha1</code> API group except for <code>BackupBucket</code> and <code>BackupEntry</code>s.</p><h4 id=controlplane><code>ControlPlane</code></h4><p>This controller is not deploying anything since we haven&rsquo;t invested yet into a <code>cloud-controller-manager</code> or CSI solution.
For the latter, we could probably use the <a href=https://github.com/rancher/local-path-provisioner>local-path-provisioner</a>.</p><h4 id=dnsrecord><code>DNSRecord</code></h4><p>This controller manipulates the <code>/etc/hosts</code> file and adds a new line for each <code>DNSRecord</code> it observes.
This enables accessing the shoot clusters from the respective machine, however, it also requires to run the extension with elevated privileges (<code>sudo</code>).</p><p>The <code>/etc/hosts</code> would be extended as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text># Begin of gardener-extension-provider-local section
10.84.23.24 api.local.local.external.local.gardener.cloud
10.84.23.24 api.local.local.internal.local.gardener.cloud
...
# End of gardener-extension-provider-local section
</code></pre></div><h4 id=infrastructure><code>Infrastructure</code></h4><p>This controller generates a <code>NetworkPolicy</code> which allows the control plane pods (like <code>kube-apiserver</code>) to communicate with the worker machine pods (see <a href=#worker><code>Worker</code> section</a>)).</p><p>In addition, it creates a <code>Service</code> named <code>vpn-shoot</code> which is only used in case the gardenlet&rsquo;s <code>ReversedVPN</code> feature gate is disabled.
This <code>Service</code> enables the <code>vpn-seed</code> containers in the <code>kube-apiserver</code> pods in the seed cluster to communicate with the <code>vpn-shoot</code> pod running in the shoot cluster.</p><h4 id=network><code>Network</code></h4><p>This controller deploys a <code>ManagedResource</code> which contains the <a href=https://github.com/kubernetes-sigs/kind/blob/main/images/kindnetd/README.md>kindnetd</a> <code>DaemonSet</code> which is used as CNI in the shoot clusters.</p><h4 id=operatingsystemconfig><code>OperatingSystemConfig</code></h4><p>This controller leverages the standard <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/operatingsystemconfig/oscommon><code>oscommon</code> library</a> in order to render a simple cloud-init template which can later be executed by the shoot worker nodes.</p><p>The shoot worker nodes are <code>Pod</code>s with a container based on the <code>kindest/node</code> image. This is maintained in <a href=https://github.com/gardener/machine-controller-manager-provider-local/tree/master/node>https://github.com/gardener/machine-controller-manager-provider-local/tree/master/node</a> and has a special <code>run-userdata</code> systemd service which executes the cloud-init generated earlier by the <code>OperatingSystemConfig</code> controller.</p><h4 id=worker><code>Worker</code></h4><p>This controller leverages the standard <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker/genericactuator>generic <code>Worker</code> actuator</a> in order to deploy the <a href=https://github.com/gardener/machine-controller-manager><code>machine-controller-manager</code></a> as well as the <a href=https://github.com/gardener/machine-controller-manager-provider-local><code>machine-controller-manager-provider-local</code></a>.</p><p>Additionally, it generates the <a href=https://github.com/gardener/machine-controller-manager-provider-local/blob/master/kubernetes/machine-class.yaml><code>MachineClass</code>es</a> and the <code>MachineDeployment</code>s based on the specification of the <code>Worker</code> resources.</p><h4 id=dnsprovider><code>DNSProvider</code></h4><p>Due to legacy reasons, the gardenlet still creates <code>DNSProvider</code> resources part of the <a href=https://github.com/gardener/external-dns-management/><code>dns.gardener.cloud/v1alpha1</code> API group</a>.
Since those are only needed in conjunction with the <a href=https://github.com/gardener/gardener-extension-shoot-dns-service><code>shoot-dns-service</code> extension</a> and have no relevance for the local provider, it just sets their <code>status.state=Ready</code> to please the expectations.
In the future, this controller can be dropped when the gardenlet no longer creates such <code>DNSProvider</code>s.</p><h4 id=service><code>Service</code></h4><p>This controller reconciles the <code>istio-ingress/istio-ingressgateway</code> <code>Service</code> in the seed cluster if the <code>--apiserver-sni-enabled</code> flag is set to <code>true</code> (default).
Otherwise, it reconciles the <code>kube-apiserver</code> <code>Service</code> in the shoot namespaces in the seed cluster.</p><p>All such <code>Service</code>s are of type <code>LoadBalancer</code>.
Since the local Kubernetes clusters used as seed typically don&rsquo;t support such services, this controller sets the <code>.status.ingress.loadBalancer.ip[0]</code> to the IP of the host.</p><h4 id=node><code>Node</code></h4><p>This controller reconciles the <code>Node</code>s of <a href=https://kind.sigs.k8s.io/>kind</a> clusters.
Typically, the <code>.status.{capacity,allocatable}</code> values are determined by the resources configured for the Docker daemon (see for example <a href=https://docs.docker.com/desktop/mac/#resources>this</a> for Mac).
Since many of the <code>Pod</code>s deployed by Gardener have quite high <code>.spec.resources.{requests,limits}</code>, the kind <code>Node</code>s easily get filled up and only a few <code>Pod</code>s can be scheduled (even if they barely consume any of their reserved resources).
In order to improve the user experience, the controller submits an empty patch which triggers the &ldquo;Node webhook&rdquo; (see below section) in case the <code>.status.{capacity,allocatable}</code> values are not high enough.
The webhook will increase the capacity of the <code>Node</code>s to allow all <code>Pod</code>s to be scheduled.</p><h4 id=health-checks>Health Checks</h4><p>The health check controller leverages the <a href=/docs/gardener/extensions/healthcheck-library/>health check library</a> in order to</p><ul><li>check the health of the <code>ManagedResource/extension-controlplane-shoot-webhooks</code> and populate the <code>SystemComponentsHealthy</code> condition in the <code>ControlPlane</code> resource.</li><li>check the health of the <code>ManagedResource/extension-networking-local</code> and populate the <code>SystemComponentsHealthy</code> condition in the <code>Network</code> resource.</li><li>check the health of the <code>ManagedResource/extension-worker-mcm-shoot</code> and populate the <code>SystemComponentsHealthy</code> condition in the <code>Worker</code> resource.</li><li>check the health of the <code>Deployment/machine-controller-manager</code> and populate the <code>ControlPlaneHealthy</code> condition in the <code>Worker</code> resource.</li><li>check the health of the <code>Node</code>s and populate the <code>EveryNodeReady</code> condition in the <code>Worker</code> resource.</li></ul><h3 id=webhooks>Webhooks</h3><h4 id=control-plane>Control Plane</h4><p>This webhook reacts on the <code>OperatingSystemConfig</code> containing the configuration of the kubelet and sets the <code>failSwapOn</code> to <code>false</code> (independent of what is configured in the <code>Shoot</code> spec) (<a href=https://github.com/kubernetes-sigs/kind/blob/b6bc112522651d98c81823df56b7afa511459a3b/site/content/docs/design/node-image.md#design>ref</a>).</p><h4 id=control-plane-exposure>Control Plane Exposure</h4><p>This webhook reacts on the <code>kube-apiserver</code> <code>Service</code> in shoot namespaces in the seed in case the gardenlet&rsquo;s <code>APIServerSNI</code> feature gate is disabled.
It sets the <code>nodePort</code> to <code>30443</code> to enable communication from the host (this requires a port mapping to work when creating the local cluster).</p><h4 id=machine-pod>Machine Pod</h4><p>This webhook reacts on <code>Pod</code>s created when the <code>machine-controller-manager</code> reconciles <code>Machine</code>s.
It sets the <code>.spec.dnsPolicy=None</code> and <code>.spec.dnsConfig.nameServers</code> to the cluster IP of the <code>coredns</code> <code>Service</code> created in the <code>gardener-extension-provider-local-coredns</code> namespaces (see the <a href=#bootstrapping>Bootstrapping section</a> for more details).</p><h4 id=node-1>Node</h4><p>This webhook reacts on <a href=https://kind.sigs.k8s.io/>kind</a> <code>Node</code>s and sets the <code>.status.{allocatable,capacity}.cpu="100"</code> and <code>.status.{allocatable,capacity}.memory="100Gi"</code> fields.
See also the above section about the &ldquo;Node controller&rdquo; for more information.</p><h4 id=shoot>Shoot</h4><p>This webhook reacts on the <code>ConfigMap</code> used by the <code>kube-proxy</code> and sets the <code>maxPerCore</code> field to <code>0</code> since other values don&rsquo;t work well in conjunction with the <code>kindest/node</code> image which is used as base for the shoot worker machine pods (<a href=https://github.com/kubernetes-sigs/kind/blob/fa7d86470f4c0e924fc4c2e767ec8491c45f4304/pkg/cluster/internal/kubeadm/config.go#L283-L285>ref</a>).</p><h2 id=future-work>Future Work</h2><p>Future work could mostly focus on resolving above listed <a href=#limitations>limitations</a>, i.e.,</p><ul><li>Add storage support for shoot clusters.</li><li>Implement a <code>cloud-controller-manager</code> and deploy it via the <a href=#controlplane><code>ControlPlane</code> controller</a>.</li><li>Implement support for <code>BackupBucket</code> and <code>BackupEntry</code>s to enable ETCD backups for shoot clusters (based on the support for local disks in <a href=https://github.com/gardener/etcd-backup-restore><code>etcd-backup-restore</code></a>).</li><li>Switch from <code>kindnetd</code> to a different CNI plugin which supports <code>NetworkPolicy</code>s.</li><li>Properly implement <code>.spec.machineTypes</code> in the <code>CloudProfile</code>s (i.e., configure <code>.spec.resources</code> properly for the created shoot worker machine pods).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-874f35cd0bbeb8acb3c1033b641e3d43>5.25 - Reconcile Trigger</h1><h1 id=reconcile-trigger>Reconcile trigger</h1><p>Gardener dictates the time of reconciliation for resources of the API group <code>extensions.gardener.cloud</code>.
It does that by annotating the respected resource with <code>gardener.cloud/operation=reconcile</code>.
Extension controllers shall react to this annotation and start reconciling the resource.
They have to remove this annotation as soon as they begin with their reconcile operation and maintain the <code>status</code> of the extension resource accordingly.</p><p>The reason for this behaviour is that it is possible to configure Gardener to reconcile only in the shoots' maintenance time windows.
In order to avoid that extension controllers reconcile outside of the shoot&rsquo;s maintenance time window we have introduced this contract.
This way extension controllers don&rsquo;t need to care about when the shoot maintenance time window happens.
Gardener keeps control and decides when the shoot shall be reconciled/updated.</p><p>Our <a href=https://github.com/gardener/gardener/blob/master/extensions>extension controller library</a> provides all the required utilities to conveniently implement this behaviour.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-df45cc83f21d97b2fdcceee7d9127056>5.26 - Referenced Resources</h1><h1 id=referenced-resources>Referenced Resources</h1><p>The Shoot resource can include a list of resources (usually secrets) that can be referenced by name in extension <code>providerConfig</code> and other Shoot sections, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>kind: Shoot
apiVersion: core.gardener.cloud/v1beta1
metadata:
  name: crazy-botany
  namespace: garden-dev
  ...
spec:
  ...
  extensions:
  - type: foobar
    providerConfig:
      apiVersion: foobar.extensions.gardener.cloud/v1alpha1
      kind: FooBarConfig
      foo: bar
      secretRef: foobar-secret
  resources:
  - name: foobar-secret
    resourceRef:
      apiVersion: v1
      kind: Secret
      name: my-foobar-secret
</code></pre></div><p>Gardener expects to find these referenced resources in the project namespace (e.g. <code>garden-dev</code>) and will copy them to the Shoot namespace in the Seed cluster when reconciling a Shoot, adding a prefix to their names to avoid naming collisions with Gardener&rsquo;s own resources.</p><p>Extension controllers can resolve the references to these resources by accessing the Shoot via the <code>Cluster</code> resource. To properly read a referenced resources, extension controllers should use the utility function <code>GetObjectByReference</code> from the <code>extensions/pkg/controller</code> package, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>    ...
    ref = &amp;autoscalingv1.CrossVersionObjectReference{
        APIVersion: <span style=color:#a31515>&#34;v1&#34;</span>,
        Kind:       <span style=color:#a31515>&#34;Secret&#34;</span>,
        Name:       <span style=color:#a31515>&#34;foo&#34;</span>,
    }
    secret := &amp;corev1.Secret{}
    <span style=color:#00f>if</span> err := controller.GetObjectByReference(ctx, client, ref, <span style=color:#a31515>&#34;shoot--test--foo&#34;</span>, secret); err != <span style=color:#00f>nil</span> {
        <span style=color:#00f>return</span> err
    }
    <span style=color:green>// Use secret
</span><span style=color:green></span>    ...
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0a10283207035fd65241bff1e92982ef>5.27 - Shoot Health Status Conditions</h1><h1 id=contributing-to-shoot-health-status-conditions>Contributing to shoot health status conditions</h1><p>Gardener checks regularly (every minute by default) the health status of all shoot clusters.
It categorizes its checks into four different types:</p><ul><li><code>APIServerAvailable</code>: This type indicates whether the shoot&rsquo;s kube-apiserver is available or not.</li><li><code>ControlPlaneHealthy</code>: This type indicates whether all the control plane components deployed to the shoot&rsquo;s namespace in the seed do exist and are running fine.</li><li><code>EveryNodeReady</code>: This type indicates whether all <code>Node</code>s and all <code>Machine</code> objects report healthiness.</li><li><code>SystemComponentsHealthy</code>: This type indicates whether all system components deployed to the <code>kube-system</code> namespace in the shoot do exist and are running fine.</li></ul><p>Every <code>Shoot</code> resource has a <code>status.conditions[]</code> list that contains the mentioned types, together with a <code>status</code> (<code>True</code>/<code>False</code>) and a descriptive message/explanation of the <code>status</code>.</p><p>Most extension controllers are deploying components and resources as part of their reconciliation flows into the seed or shoot cluster.
A prominent example for this is the <code>ControlPlane</code> controller that usually deploys a cloud-controller-manager or CSI controllers as part of the shoot control plane.
Now that the extensions deploy resources into the cluster, especially resources that are essential for the functionality of the cluster, they might want to contribute to Gardener&rsquo;s checks mentioned above.</p><h2 id=what-can-extensions-do-to-contribute-to-gardeners-health-checks>What can extensions do to contribute to Gardener&rsquo;s health checks?</h2><p>Every extension resource in Gardener&rsquo;s <code>extensions.gardener.cloud/v1alpha1</code> API group also has a <code>status.conditions[]</code> list (like the <code>Shoot</code>).
Extension controllers can write conditions to the resource they are acting on and use a type that also exist in the shoot&rsquo;s conditions.
One exception is that <code>APIServerAvailable</code> can&rsquo;t be used as the Gardener clearly can identify the status of this condition and it doesn&rsquo;t make sense for extensions to try to contribute/modify it.</p><p>As an example for the <code>ControlPlane</code> controller let&rsquo;s take a look at the following resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: ControlPlane
metadata:
  name: control-plane
  namespace: shoot--foo--bar
spec:
  ...
status:
  conditions:
  - type: ControlPlaneHealthy
    status: <span style=color:#a31515>&#34;False&#34;</span>
    reason: DeploymentUnhealthy
    message: &#39;Deployment cloud-controller-manager is unhealthy: condition &#34;Available&#34; has
      invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
      does not have minimum availability.&#39;
    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:44:27Z&#34;</span>
  - type: ConfigComputedSuccessfully
    status: <span style=color:#a31515>&#34;True&#34;</span>
    reason: ConfigCreated
    message: The cloud-provider-config has been successfully computed.
    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:43:27Z&#34;</span>
</code></pre></div><p>The extension controller has declared in its extension resource that one of the deployments it is responsible for is unhealthy.
Also, it has written a second condition using a type that is unknown by Gardener.</p><p>Gardener will pick the list of conditions and recognize that the there is one with a type <code>ControlPlaneHealthy</code>.
It will merge it with its own <code>ControlPlaneHealthy</code> condition and report it back to the <code>Shoot</code>&rsquo;s status:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  labels:
    shoot.gardener.cloud/status: unhealthy
  name: some-shoot
  namespace: garden-core
spec:
status:
  conditions:
  - type: APIServerAvailable
    status: <span style=color:#a31515>&#34;True&#34;</span>
    reason: HealthzRequestSucceeded
    message: API server /healthz endpoint responded with success status code. [response_time:31ms]
    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-23T08:26:52Z&#34;</span>
    lastTransitionTime: <span style=color:#a31515>&#34;2014-05-25T12:45:13Z&#34;</span>
  - type: ControlPlaneHealthy
    status: <span style=color:#a31515>&#34;False&#34;</span>
    reason: ControlPlaneUnhealthyReport
    message: &#39;Deployment cloud-controller-manager is unhealthy: condition &#34;Available&#34; has
      invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
      does not have minimum availability.&#39;
    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:45:13Z&#34;</span>
    lastTransitionTime: <span style=color:#a31515>&#34;2014-05-25T12:45:13Z&#34;</span>
  ...
</code></pre></div><p>Hence, the only duty extensions have is to maintain the health status of their components in the extension resource they are managing.
This can be accomplished using the <a href=/docs/gardener/extensions/healthcheck-library/>health check library for extensions</a>.</p><h2 id=error-codes>Error Codes</h2><p>The Gardener API includes some well-defined error codes, e.g., <code>ERR_INFRA_UNAUTHORIZED</code>, <code>ERR_INFRA_DEPENDENCIES</code>, etc.
Extension may set these error codes in the <code>.status.conditions[].codes[]</code> list in case it makes sense.
Gardener will pick them up and will similarly merge them into the <code>.status.conditions[].codes[]</code> list in the <code>Shoot</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>status:
  conditions:
  - type: ControlPlaneHealthy
    status: <span style=color:#a31515>&#34;False&#34;</span>
    reason: DeploymentUnhealthy
    message: &#39;Deployment cloud-controller-manager is unhealthy: condition &#34;Available&#34; has
      invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
      does not have minimum availability.&#39;
    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:44:27Z&#34;</span>
    codes:
    - ERR_INFRA_UNAUTHORIZED 
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-a2e99bb1eae354d266924368862541f8>5.28 - Shoot Maintenance</h1><h1 id=shoot-maintenance>Shoot maintenance</h1><p>There is a general <a href=/docs/gardener/usage/shoot_maintenance/>document about shoot maintenance</a> that you might want to read.
Here, we describe how you can influence certain operations that happen during a shoot maintenance.</p><h2 id=restart-control-plane-controllers>Restart Control Plane Controllers</h2><p>As outlined in above linked document, Gardener offers to restart certain control plane controllers running in the seed during a shoot maintenance.</p><p>Extension controllers can extend the amount of pods being affected by these restarts.
If your Gardener extension manages pods of a shoot&rsquo;s control plane (shoot namespace in seed) and it could potentially profit from a regular restart please consider labeling it with <code>maintenance.gardener.cloud/restart=true</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-be099eb6107ce0525e229d5cfa5bf30b>5.29 - Shoot Webhooks</h1><h1 id=shoot-resource-customization-webhooks>Shoot resource customization webhooks</h1><p>Gardener deploys several components/resources into the shoot cluster.
Some of these resources are essential (like the <code>kube-proxy</code>), others are optional addons (like the <code>kubernetes-dashboard</code> or the <code>nginx-ingress-controller</code>).
In either case, some provider extensions might need to mutate these resources and inject provider-specific bits into it.</p><h2 id=whats-the-approach-to-implement-such-mutations>What&rsquo;s the approach to implement such mutations?</h2><p>Similar to how <a href=/docs/gardener/extensions/controlplane-webhooks/>control plane components in the seed</a> are modified we are using <code>MutatingWebhookConfiguration</code>s to achieve the same for resources in the shoot.
Both, the provider extension and the kube-apiserver of the shoot cluster are running in the same seed.
Consequently, the kube-apiserver can talk cluster-internally to the provider extension webhook which makes such operations even faster.</p><h2 id=how-is-the-mutatingwebhookconfiguration-object-created-in-the-shoot>How is the <code>MutatingWebhookConfiguration</code> object created in the shoot?</h2><p>The preferred approach is to use a <code>ManagedResource</code> (see also <a href=/docs/gardener/extensions/managedresources/>this document</a>) in the seed cluster.
This way the <code>gardener-resource-manager</code> ensures that end-users cannot delete/modify the webhook configuration.
The provider extension doesn&rsquo;t need to care about the same.</p><h2 id=what-else-is-needed>What else is needed?</h2><p>The shoot&rsquo;s kube-apiserver must be allowed to talk to the provider extension.
To achieve this you need to create a <code>NetworkPolicy</code> in the shoot namespace.
Our <a href=https://github.com/gardener/gardener/blob/master/extensions>extension controller library</a> provides easy-to-use utilities and hooks to implement such a webhook.
Please find an exemplary implementation <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/webhook/shoot>here</a> and <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/566fe4dd588c93821bc9d22c452203867457c930/cmd/gardener-extension-provider-aws/app/app.go#L170-L174>here</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-aa66bdf689454ea90b099d33515cef79>5.30 - Worker</h1><h1 id=contract-worker-resource>Contract: <code>Worker</code> resource</h1><p>While the control plane of a shoot cluster is living in the seed and deployed as native Kubernetes workload, the worker nodes of the shoot clusters are normal virtual machines (VMs) in the end-users infrastructure account.
The Gardener project features a sub-project called <a href=https://github.com/gardener/machine-controller-manager>machine-controller-manager</a>.
This controller is extending the Kubernetes API using custom resource definitions to represent actual VMs as <code>Machine</code> objects inside a Kubernetes system.
This approach unlocks the possibility to manage virtual machines in the Kubernetes style and benefit from all its design principles.</p><h2 id=what-is-the-machine-controller-manager-exactly-doing>What is the machine-controller-manager exactly doing?</h2><p>Generally, there are provider-specific <code>MachineClass</code> objects (<code>AWSMachineClass</code>, <code>AzureMachineClass</code>, etc.; similar to <code>StorageClass</code>), and <code>MachineDeployment</code>, <code>MachineSet</code>, and <code>Machine</code> objects (similar to <code>Deployment</code>, <code>ReplicaSet</code>, and <code>Pod</code>).
A machine class describes <strong>where</strong> and <strong>how</strong> to create virtual machines (in which networks, region, availability zone, SSH key, user-data for bootstrapping, etc.) while a <code>Machine</code> results in an actual virtual machine.
You can read up <a href=https://github.com/gardener/machine-controller-manager>more information</a> in the machine-controller-manager&rsquo;s <a href=https://github.com/gardener/machine-controller-manager>repository</a>.</p><p>Before the introduction of the <code>Worker</code> extension resource Gardener was deploying the machine-controller-manager, the machine classes, and the machine deployments itself.
Now, Gardener commissions an external, provider-specific controller to take over these tasks.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-worker-provider>What needs to be implemented to support a new worker provider?</h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Worker
metadata:
  name: bar
  namespace: shoot--foo--bar
spec:
  type: azure
  region: eu-west-1
  secretRef:
    name: cloudprovider
    namespace: shoot--foo--bar
  infrastructureProviderStatus:
    apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureStatus
    ec2:
      keyName: shoot--foo--bar-ssh-publickey
    iam:
      instanceProfiles:
      - name: shoot--foo--bar-nodes
        purpose: nodes
      roles:
      - arn: arn:aws:iam::0123456789:role/shoot--foo--bar-nodes
        purpose: nodes
    vpc:
      id: vpc-0123456789
      securityGroups:
      - id: sg-1234567890
        purpose: nodes
      subnets:
      - id: subnet-01234
        purpose: nodes
        zone: eu-west-1b
      - id: subnet-56789
        purpose: public
        zone: eu-west-1b
      - id: subnet-0123a
        purpose: nodes
        zone: eu-west-1c
      - id: subnet-5678a
        purpose: public
        zone: eu-west-1c
  pools:
  - name: cpu-worker
    minimum: 3
    maximum: 5
    maxSurge: 1
    maxUnavailable: 0
    machineType: m4.large
    machineImage:
      name: coreos
      version: 1967.5.0
    nodeTemplate:
      capacity:
        cpu: 2
        gpu: 0
        memory: 8Gi
    userData: c29tZSBkYXRhIHRvIGJvb3RzdHJhcCB0aGUgVk0K
    volume:
      size: 20Gi
      type: gp2
    zones:
    - eu-west-1b
    - eu-west-1c
    machineControllerManager:
      drainTimeout: 10m
      healthTimeout: 10m
      creationTimeout: 10m
      maxEvictRetries: 30
      nodeConditions:
      - ReadonlyFilesystem
      - DiskPressure
      - KernelDeadlock
</code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed virtual machines.
Also, as you can see, Gardener copies the output of the infrastructure creation (<code>.spec.infrastructureProviderStatus</code>), see <a href=/docs/gardener/extensions/infrastructure/><code>Infrastructure</code> resource</a>, into the <code>.spec</code>.</p><p>In the <code>.spec.pools[]</code> field the desired worker pools are listed.
In the above example, one pool with machine type <code>m4.large</code> and <code>min=3</code>, <code>max=5</code> machines shall be spread over two availability zones (<code>eu-west-1b</code>, <code>eu-west-1c</code>).
This information together with the infrastructure status must be used to determine the proper configuration for the machine classes.</p><p>The <code>spec.pools[].nodeTemplate.capacity</code> field contains the resource information of the machine like <code>cpu</code>, <code>gpu</code> and <code>memory</code>. This info is used by Cluster Autoscaler to generate <code>nodeTemplate</code> during scaling the <code>nodeGroup</code> from zero.</p><p>The <code>spec.pools[].machineControllerManager</code> field allows to configure the settings for machine-controller-manager component. Providers must populate these settings on worker-pool to the related <a href=https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/machine_objects/machine-deployment.yaml#L30-L34>fields</a> in MachineDeployment.</p><p>When seeing such a resource your controller must make sure that it deploys the machine-controller-manager next to the control plane in the seed cluster.
After that, it must compute the desired machine classes and the desired machine deployments.
Typically, one class maps to one deployment, and one class/deployment is created per availability zone.
Following this convention, the created resource would look like this:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: shoot--foo--bar-cpu-worker-z1-3db65
  namespace: shoot--foo--bar
  labels:
    gardener.cloud/purpose: machineclass
type: Opaque
data:
  providerAccessKeyId: eW91ci1hd3MtYWNjZXNzLWtleS1pZAo=
  providerSecretAccessKey: eW91ci1hd3Mtc2VjcmV0LWFjY2Vzcy1rZXkK
  userData: c29tZSBkYXRhIHRvIGJvb3RzdHJhcCB0aGUgVk0K
---
apiVersion: machine.sapcloud.io/v1alpha1
kind: AWSMachineClass
metadata:
  name: shoot--foo--bar-cpu-worker-z1-3db65
  namespace: shoot--foo--bar
spec:
  ami: ami-0123456789 <span style=color:green># Your controller must map the stated version to the provider specific machine image information, in the AWS case the AMI.</span>
  blockDevices:
  - ebs:
      volumeSize: 20
      volumeType: gp2
  iam:
    name: shoot--foo--bar-nodes
  keyName: shoot--foo--bar-ssh-publickey
  machineType: m4.large
  networkInterfaces:
  - securityGroupIDs:
    - sg-1234567890
    subnetID: subnet-01234
  region: eu-west-1
  secretRef:
    name: shoot--foo--bar-cpu-worker-z1-3db65
    namespace: shoot--foo--bar
  tags:
    kubernetes.io/cluster/shoot--foo--bar: <span style=color:#a31515>&#34;1&#34;</span>
    kubernetes.io/role/node: <span style=color:#a31515>&#34;1&#34;</span>
---
apiVersion: machine.sapcloud.io/v1alpha1
kind: MachineDeployment
metadata:
  name: shoot--foo--bar-cpu-worker-z1
  namespace: shoot--foo--bar
spec:
  replicas: 2
  selector:
    matchLabels:
      name: shoot--foo--bar-cpu-worker-z1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        name: shoot--foo--bar-cpu-worker-z1
    spec:
      class:
        kind: AWSMachineClass
        name: shoot--foo--bar-cpu-worker-z1-3db65
</code></pre></div><p>for the first availability zone <code>eu-west-1b</code>, and</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: shoot--foo--bar-cpu-worker-z2-5z6as
  namespace: shoot--foo--bar
  labels:
    gardener.cloud/purpose: machineclass
type: Opaque
data:
  providerAccessKeyId: eW91ci1hd3MtYWNjZXNzLWtleS1pZAo=
  providerSecretAccessKey: eW91ci1hd3Mtc2VjcmV0LWFjY2Vzcy1rZXkK
  userData: c29tZSBkYXRhIHRvIGJvb3RzdHJhcCB0aGUgVk0K
---
apiVersion: machine.sapcloud.io/v1alpha1
kind: AWSMachineClass
metadata:
  name: shoot--foo--bar-cpu-worker-z2-5z6as
  namespace: shoot--foo--bar
spec:
  ami: ami-0123456789 <span style=color:green># Your controller must map the stated version to the provider specific machine image information, in the AWS case the AMI.</span>
  blockDevices:
  - ebs:
      volumeSize: 20
      volumeType: gp2
  iam:
    name: shoot--foo--bar-nodes
  keyName: shoot--foo--bar-ssh-publickey
  machineType: m4.large
  networkInterfaces:
  - securityGroupIDs:
    - sg-1234567890
    subnetID: subnet-0123a
  region: eu-west-1
  secretRef:
    name: shoot--foo--bar-cpu-worker-z2-5z6as
    namespace: shoot--foo--bar
  tags:
    kubernetes.io/cluster/shoot--foo--bar: <span style=color:#a31515>&#34;1&#34;</span>
    kubernetes.io/role/node: <span style=color:#a31515>&#34;1&#34;</span>
---
apiVersion: machine.sapcloud.io/v1alpha1
kind: MachineDeployment
metadata:
  name: shoot--foo--bar-cpu-worker-z1
  namespace: shoot--foo--bar
spec:
  replicas: 1
  selector:
    matchLabels:
      name: shoot--foo--bar-cpu-worker-z1
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    metadata:
      labels:
        name: shoot--foo--bar-cpu-worker-z1
    spec:
      class:
        kind: AWSMachineClass
        name: shoot--foo--bar-cpu-worker-z2-5z6as
</code></pre></div><p>for the second availability zone <code>eu-west-1c</code>.</p><p>Another convention is the 5-letter hash at the end of the machine class names.
Most controllers compute a checksum out of the specification of the machine class.
This helps to trigger a rolling update of the worker nodes if, for example, the machine image version changes.
In this case, a new checksum will be generated which results in the creation of a new machine class.
The <code>MachineDeployment</code>&rsquo;s machine class reference (<code>.spec.template.spec.class.name</code>) is updated which triggers the rolling update process in the machine-controller-manager.
However, all of this is only a convention that eases writing the controller, but you can do it completely differently if you desire - as long as you make sure that the described behaviours are implemented correctly.</p><p>After the machine classes and machine deployments have been created the machine-controller-manager will start talking to the provider&rsquo;s IaaS API and create the virtual machines.
Gardener makes sure that the content of the <code>userData</code> field that is used to bootstrap the machines contain the required configuration for installation of the kubelet and registering the VM as worker node in the shoot cluster.
The <code>Worker</code> extension controller shall wait until all the created <code>MachineDeployment</code>s indicate healthiness/readiness before it ends the control loop.</p><h2 id=does-gardener-need-some-information-that-must-be-returned-back>Does Gardener need some information that must be returned back?</h2><p>Another important benefit of the machine-controller-manager&rsquo;s design principles (extending the Kubernetes API using CRDs) is that the <a href=https://github.com/gardener/autoscaler>cluster-autoscaler</a> can be used <strong>without</strong> any provider-specific implementation.
We have forked the <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler>upstream Kubernetes community&rsquo;s cluster-autoscaler</a> and extended it so that it understands the machine API.
Definitely, we will merge it back into the community&rsquo;s versions once it has been adapted properly.</p><p>Our cluster-autoscaler only needs to know the minimum and maximum number of replicas <strong>per</strong> <code>MachineDeployment</code> and is ready to act without that it needs to talk to the provider APIs (it just modifies the <code>.spec.replicas</code> field in the <code>MachineDeployment</code> object).
Gardener deploys this autoscaler if there is at least one worker pool that specifies <code>max>min</code>.
In order to know how it needs to configure it, the provider-specific <code>Worker</code> extension controller must expose which <code>MachineDeployment</code>s it had created and how the <code>min</code>/<code>max</code> numbers should look like.</p><p>Consequently, your controller should write this information into the <code>Worker</code> resource&rsquo;s <code>.status.machineDeployments</code> field:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Worker
metadata:
  name: worker
  namespace: shoot--foo--bar
spec:
  ...
status:
  lastOperation: ...
  machineDeployments:
  - name: shoot--foo--bar-cpu-worker-z1
    minimum: 2
    maximum: 3
  - name: shoot--foo--bar-cpu-worker-z2
    minimum: 1
    maximum: 2
</code></pre></div><p>In order to support a new worker provider you need to write a controller that watches all <code>Worker</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the AWS provider.</p><h2 id=that-sounds-like-a-lot-that-needs-to-be-done-can-you-help-me>That sounds like a lot that needs to be done, can you help me?</h2><p>All of the described behaviour is mostly the same for every provider.
The only difference is maybe the version/configuration of the machine-controller-manager, and the machine class specification itself.
You can take a look at our <a href=https://github.com/gardener/gardener/blob/master/extensions>extension library</a>, especially the <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker>worker controller</a> part where you will find a lot of utilities that you can use.
Also, using the library you only need to implement your provider specifics - all the things that can be handled generically can be taken for free and do not need to be re-implemented.
Take a look at the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/worker>AWS worker controller</a> for finding an example.</p><h2 id=non-provider-specific-information-required-for-worker-creation>Non-provider specific information required for worker creation</h2><p>All the providers require further information that is not provider specific but already part of the shoot resource.
One example for such information is whether the shoot is hibernated or not.
In this case all the virtual machines should be deleted/terminated, and after that the machine controller-manager should be scaled down.
You can take a look at the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/worker>AWS worker controller</a> to see how it reads this information and how it is used.
As Gardener cannot know which information is required by providers it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>Worker</code> resource itself.</p><h2 id=references-and-additional-resources>References and additional resources</h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_worker.go><code>Worker</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener/blob/master/extensions>Extension controller library</a></li><li><a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker>Generic worker controller</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/worker>Exemplary implementation for the AWS provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-62245990be65d8c8a7f72ab7834620e9>6 - Monitoring</h1><h1 id=monitoring>Monitoring</h1><h2 id=roles-of-the-different-prometheus-instances>Roles of the different Prometheus instances</h2><p><img src=/__resources/monitoring_06c124.png alt=monitoring></p><h3 id=prometheus>Prometheus</h3><p>Deployed in the <code>garden</code> namespace. Important scrape targets:</p><ul><li>cadvisor</li><li>node-exporter</li><li>kube-state-metrics</li></ul><p><strong>Purpose</strong>: Acts as a cache for other Prometheus instances. The metrics are kept for a short amount of time (~2 hours) due to the high cardinality. For example if another Prometheus needs access to cadvisor metrics it will query this Prometheus instead of the cadvisor. This also reduces load on the kubelets and API Server.</p><p>Some of the high cardinality metrics are aggregated with recording rules. These <em>pre-aggregated</em> metrics are scraped by the <a href=#aggregate-prometheus>Aggregate Prometheus</a>.</p><p>This Prometheus is not used for alerting.</p><h3 id=aggregate-prometheus>Aggregate Prometheus</h3><p>Deployed in the <code>garden</code> namespace. Important scrape targets:</p><ul><li>other prometheus instances</li><li>logging components</li></ul><p><strong>Purpose</strong>: Store pre-aggregated data from <a href=#prometheus>prometheus</a> and <a href=#shoot-prometheus>shoot prometheus</a>. An ingress exposes this Prometheus allowing it to be scraped from another cluster.</p><h3 id=seed-prometheus>Seed Prometheus</h3><p>Deployed in the <code>garden</code> namespace. Important scrape targets:</p><ul><li>pods in extension namespaces annotated with:</li></ul><pre><code>prometheus.io/scrape=true
prometheus.io/port=&lt;port&gt;
</code></pre><ul><li>cadvisor metrics from pods in the garden and extension namespaces</li></ul><p><strong>Purpose</strong>: Entrypoint for operators when debugging issues with extensions or other garden components.</p><h3 id=shoot-prometheus>Shoot Prometheus</h3><p>Deployed in the shoot control plane namespace. Important scrape targets:</p><ul><li>control plane components</li><li>shoot nodes (node-exporter)</li><li>blackbox-exporter used to measure <a href=/docs/gardener/monitoring/connectivity/>connectivity</a></li></ul><p><strong>Purpose</strong>: Monitor all relevant components belonging to a shoot cluster managed by Gardener. Shoot owners can view the metrics in Grafana dashboards and receive <a href=/docs/gardener/monitoring/user_alerts/>alerts</a> based on these metrics. Gardener operators will receive a different set of <a href=/docs/gardener/monitoring/operator_alerts/>alerts</a>. For alerting internals refer to <a href=/docs/gardener/monitoring/alerting/>this</a> document.</p><h2 id=collect-all-shoot-prometheus-with-remote-write>Collect all Shoot Prometheus with remote write</h2><p>An optional collection of all Shoot Prometheus metrics to a central prometheus (or cortex) instance is possible with the <code>monitoring.shoot</code> setting in <code>GardenletConfiguration</code>:</p><pre><code>monitoring:
  shoot:
    remoteWrite:
      url: https://remoteWriteUrl # remote write URL
      keep:# metrics that should be forwarded to the external write endpoint. If empty all metrics get forwarded
      - kube_pod_container_info
      queueConfig: | # queue_config of prometheus remote write as multiline string
        max_shards: 100
        batch_send_deadline: 20s
        min_backoff: 500ms
        max_backoff: 60s
    externalLabels: # add additional labels to metrics to identify it on the central instance
      additional: label
</code></pre><p>If basic auth is needed it can be set via secret in garden namespace (Gardener API Server). <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-remote-write.yaml>Example secret</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-954b7364e06db9899aa6264a5b0a9e91>6.1 - Alerting</h1><h1 id=alerting>Alerting</h1><p>Gardener uses <a href=https://prometheus.io/>Prometheus</a> to gather metrics from each component. A Prometheus is deployed in each shoot control plane (on the seed) which is responsible for gathering control plane and cluster metrics. Prometheus can be configured to fire alerts based on these metrics and send them to an <a href=https://prometheus.io/docs/alerting/alertmanager/>alertmanager</a>. The alertmanager is responsible for sending the alerts to users and operators. This document describes how to setup alerting for:</p><ul><li><a href=#Alerting-for-Users>end-users/stakeholders/customers</a></li><li><a href=#Alerting-for-Operators>operators/administrators</a></li></ul><h1 id=alerting-for-users>Alerting for Users</h1><p>To receive email alerts as a user set the following values in the shoot spec:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  monitoring:
    alerting:
      emailReceivers:
      - john.doe@example.com
</code></pre></div><p><code>emailReceivers</code> is a list of emails that will receive alerts if something is wrong with the shoot cluster. A list of alerts for users can be found <a href=/docs/gardener/monitoring/user_alerts/>here</a>.</p><h1 id=alerting-for-operators>Alerting for Operators</h1><p>Currently, Gardener supports two options for alerting:</p><ul><li><a href=#Email-Alerting>Email Alerting</a></li><li><a href=#External-Alertmanager>Sending Alerts to an external alertmanager</a></li></ul><p>A list of operator alerts can be found <a href=/docs/gardener/monitoring/operator_alerts/>here</a>.</p><h2 id=email-alerting>Email Alerting</h2><p>Gardener provides the option to deploy an alertmanager into each seed. This alertmanager is responsible for sending out alerts to operators for each shoot cluster in the seed. Only email alerts are supported by the alertmanager managed by Gardener. This is configurable by setting the Gardener controller manager configuration values <code>alerting</code>. See <a href=/docs/gardener/usage/configuration/>this</a> on how to configure the Gardener&rsquo;s SMTP secret. If the values are set, a secret with the label <code>gardener.cloud/role: alerting</code> will be created in the garden namespace of the garden cluster. This secret will be used by each alertmanager in each seed.</p><h2 id=external-alertmanager>External Alertmanager</h2><p>The alertmanager supports different kinds of <a href=https://prometheus.io/docs/alerting/configuration/>alerting configurations</a>. The alertmanager provided by Gardener only supports email alerts. If email is not sufficient, then alerts can be sent to an external alertmanager. Prometheus will send alerts to a URL and then alerts will be handled by the external alertmanager. This external alertmanager is operated and configured by the operator (i.e. Gardener does not configure or deploy this alertmanager). To configure sending alerts to an external alertmanager, create a secret in the virtual garden cluster in the garden namespace with the label: <code>gardener.cloud/role: alerting</code>. This secret needs to contain a URL to the external alertmanager and information regarding authentication. Supported authentication types are:</p><ul><li>No Authentication (none)</li><li>Basic Authentication (basic)</li><li>Mutual TLS (certificate)</li></ul><h3 id=remote-alertmanager-examples>Remote Alertmanager Examples</h3><p>Note: the <code>url</code> value cannot be prepended with <code>http</code> or <code>https</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green># No Authentication</span>
apiVersion: v1
kind: Secret
metadata:
  labels:
    gardener.cloud/role: alerting
  name: alerting-auth
  namespace: garden
data:
  <span style=color:green># No Authentication</span>
  auth_type: base64(none)
  url: base64(external.alertmanager.foo)

  <span style=color:green># Basic Auth</span>
  auth_type: base64(basic)
  url: base64(extenal.alertmanager.foo)
  username: base64(admin)
  password: base64(password)

  <span style=color:green># Mutual TLS</span>
  auth_type: base64(certificate)
  url: base64(external.alertmanager.foo)
  ca.crt: base64(ca)
  tls.crt: base64(certificate)
  tls.key: base64(key)
  insecure_skip_verify: base64(false)

  <span style=color:green># Email Alerts (internal alertmanager)</span>
  auth_type: base64(smtp)
  auth_identity: base64(internal.alertmanager.auth_identity)
  auth_password: base64(internal.alertmanager.auth_password)
  auth_username: base64(internal.alertmanager.auth_username)
  from: base64(internal.alertmanager.from)
  smarthost: base64(internal.alertmanager.smarthost)
  to: base64(internal.alertmanager.to)
type: Opaque
</code></pre></div><h3 id=configuring-your-external-alertmanager>Configuring your External Alertmanager</h3><p>Please refer to the <a href=https://prometheus.io/docs/alerting/alertmanager/>alertmanager</a> documentation on how to configure an alertmanager.</p><p>We recommend you use at least the following inhibition rules in your alertmanager configuration to prevent excessive alerts:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>inhibit_rules:
<span style=color:green># Apply inhibition if the alert name is the same.</span>
- source_match:
    severity: critical
  target_match:
    severity: warning
  equal: [<span style=color:#a31515>&#39;alertname&#39;</span>, <span style=color:#a31515>&#39;service&#39;</span>, <span style=color:#a31515>&#39;cluster&#39;</span>]

<span style=color:green># Stop all alerts for type=shoot if there are VPN problems.</span>
- source_match:
    service: vpn
  target_match_re:
    type: shoot
  equal: [<span style=color:#a31515>&#39;type&#39;</span>, <span style=color:#a31515>&#39;cluster&#39;</span>]

<span style=color:green># Stop warning and critical alerts if there is a blocker</span>
- source_match:
    severity: blocker
  target_match_re:
    severity: ^(critical|warning)$
  equal: [<span style=color:#a31515>&#39;cluster&#39;</span>]

<span style=color:green># If the API server is down inhibit no worker nodes alert. No worker nodes depends on kube-state-metrics which depends on the API server.</span>
- source_match:
    service: kube-apiserver
  target_match_re:
    service: nodes
  equal: [<span style=color:#a31515>&#39;cluster&#39;</span>]

<span style=color:green># If API server is down inhibit kube-state-metrics alerts.</span>
- source_match:
    service: kube-apiserver
  target_match_re:
    severity: info
  equal: [<span style=color:#a31515>&#39;cluster&#39;</span>]

<span style=color:green># No Worker nodes depends on kube-state-metrics. Inhibit no worker nodes if kube-state-metrics is down.</span>
- source_match:
    service: kube-state-metrics-shoot
  target_match_re:
    service: nodes
  equal: [<span style=color:#a31515>&#39;cluster&#39;</span>]
</code></pre></div><p>Below is a graph visualizing the inhibition rules:</p><p><img src=/__resources/alertInhibitionGraph_ceaef0.png alt=inhibitionGraph></p></div><div class=td-content style=page-break-before:always><h1 id=pg-7c33abee93181fcc22c3692c1a9c8f2a>6.2 - Connectivity</h1><h1 id=connectivity>Connectivity</h1><h2 id=shoot-connectivity>Shoot Connectivity</h2><p>We measure the connectivity from the shoot to the API Server. This is done via the <code>blackbox exporter</code> which is deployed in the shoot&rsquo;s <code>kube-system</code> namespace. Prometheus will scrape the <code>blackbox exporter</code> and then the exporter will try to access the API Server. Metrics are exposed if the connection was successful or not. This can be seen in the dashboard <code>Kubernetes Control Plane Status</code> dashboard under the <code>API Server Connectivity</code> panel. The <code>shoot</code> line represents the connectivity from the shoot.</p><p><img src=/__resources/panel_393a41.png alt=image></p><h2 id=seed-connectivity>Seed Connectivity</h2><p>In addition to the shoot connectivity, we also measure the seed connectivity. This means trying to reach the API Server from the seed via the external fully qualified domain name of the API server. The connectivity is also displayed in the above panel as the <code>seed</code> line. Both <code>seed</code> and <code>shoot</code> connectivity are shown below.</p><p><img src=/__resources/connectivity_b79584.png alt=image></p></div><div class=td-content style=page-break-before:always><h1 id=pg-52cd1f12c4a525b9382c2ae0184ec4c3>6.3 - Operator Alerts</h1><h1 id=operator-alerts>Operator Alerts</h1><table><thead><tr><th>Alertname</th><th>Severity</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>ApiServerUnreachableViaKubernetesService</td><td>critical</td><td>shoot</td><td><code>The Api server has been unreachable for 3 minutes via the kubernetes service in the shoot.</code></td></tr><tr><td>KubeletTooManyOpenFileDescriptorsSeed</td><td>critical</td><td>seed</td><td><code>Seed-kubelet ({{ $labels.kubernetes_io_hostname }}) is using {{ $value }}% of the available file/socket descriptors. Kubelet could be under heavy load.</code></td></tr><tr><td>KubePersistentVolumeUsageCritical</td><td>critical</td><td>seed</td><td><code>The PersistentVolume claimed by {{ $labels.persistentvolumeclaim }} is only {{ printf "%0.2f" $value }}% free.</code></td></tr><tr><td>KubePersistentVolumeFullInFourDays</td><td>warning</td><td>seed</td><td><code>Based on recent sampling, the PersistentVolume claimed by {{ $labels.persistentvolumeclaim }} is expected to fill up within four days. Currently {{ printf "%0.2f" $value }}% is available.</code></td></tr><tr><td>KubePodPendingControlPlane</td><td>warning</td><td>seed</td><td><code>Pod {{ $labels.pod }} is stuck in "Pending" state for more than 30 minutes.</code></td></tr><tr><td>KubePodNotReadyControlPlane</td><td>warning</td><td></td><td><code>Pod {{ $labels.pod }} is not ready for more than 30 minutes.</code></td></tr><tr><td>KubeStateMetricsShootDown</td><td>info</td><td>seed</td><td><code>There are no running kube-state-metric pods for the shoot cluster. No kubernetes resource metrics can be scraped.</code></td></tr><tr><td>KubeStateMetricsSeedDown</td><td>critical</td><td>seed</td><td><code>There are no running kube-state-metric pods for the seed cluster. No kubernetes resource metrics can be scraped.</code></td></tr><tr><td>NoWorkerNodes</td><td>blocker</td><td></td><td><code>There are no worker nodes in the cluster or all of the worker nodes in the cluster are not schedulable.</code></td></tr><tr><td>PrometheusCantScrape</td><td>warning</td><td>seed</td><td><code>Prometheus failed to scrape metrics. Instance {{ $labels.instance }}, job {{ $labels.job }}.</code></td></tr><tr><td>PrometheusConfigurationFailure</td><td>warning</td><td>seed</td><td><code>Latest Prometheus configuration is broken and Prometheus is using the previous one.</code></td></tr><tr><td>VPNProbeAPIServerProxyFailed</td><td>critical</td><td>shoot</td><td><code>The API Server proxy functionality is not working. Probably the vpn connection from an API Server pod to the vpn-shoot endpoint on the Shoot workers does not work.</code></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4bd3553c7141772a5c5be0814ce3145b>6.4 - Profiling</h1><h1 id=profiling-gardener-components>Profiling Gardener Components</h1><p>Similar to Kubernetes, Gardener components support profiling using <a href=https://golang.org/doc/diagnostics#profiling>standard Go tools</a> for analyzing CPU and memory usage by different code sections and more.
This document shows how to enable and use profiling handlers with Gardener components.</p><p>Enabling profiling handlers and the ports on which they are exposed differs between components.
However, once the handlers are enabled, they provide profiles via the same HTTP endpoint paths, from which you can retrieve them via <code>curl</code>/<code>wget</code> or directly using <code>go tool pprof</code>.
(You might need to use <code>kubectl port-forward</code> in order to access HTTP endpoints of Gardener components running in clusters.)</p><p>For example (gardener-controller-manager):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl http://localhost:2718/debug/pprof/heap &gt; /tmp/heap-controller-manager
$ go tool pprof /tmp/heap-controller-manager
Type: inuse_space
Time: Sep 3, 2021 at 10:05am (CEST)
Entering interactive mode (type <span style=color:#a31515>&#34;help&#34;</span> <span style=color:#00f>for</span> commands, <span style=color:#a31515>&#34;o&#34;</span> <span style=color:#00f>for</span> options)
(pprof)
</code></pre></div><p>or</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go tool pprof http://localhost:2718/debug/pprof/heap
Fetching profile over HTTP from http://localhost:2718/debug/pprof/heap
Saved profile in /Users/timebertt/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.008.pb.gz
Type: inuse_space
Time: Sep 3, 2021 at 10:05am (CEST)
Entering interactive mode (type <span style=color:#a31515>&#34;help&#34;</span> <span style=color:#00f>for</span> commands, <span style=color:#a31515>&#34;o&#34;</span> <span style=color:#00f>for</span> options)
(pprof)
</code></pre></div><h2 id=gardener-apiserver>gardener-apiserver</h2><p>gardener-apiserver provides the same flags as kube-apiserver for enabling profiling handlers (enabled by default):</p><pre><code>--contention-profiling    Enable lock contention profiling, if profiling is enabled
--profiling               Enable profiling via web interface host:port/debug/pprof/ (default true)
</code></pre><p>The handlers are served on the same port as the API endpoints (configured via <code>--secure-port</code>).
This means, you will also have to authenticate against the API server according to the configured authentication and authorization policy.</p><p>For example, in the <a href=/docs/gardener/development/local_setup/>local-setup</a> you can use:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -k --cert ./hack/local-development/local-garden/certificates/certs/default-admin.crt --key ./hack/local-development/local-garden/certificates/keys/default-admin.key https://localhost:8443/debug/pprof/heap &gt; /tmp/heap-apiserver
$ go tool pprof /tmp/heap-apiserver
</code></pre></div><h2 id=gardener-controller-manager-gardenlet>gardener-controller-manager, gardenlet</h2><p>gardener-controller-manager and gardenlet allow enabling profiling handlers via their respective component configs (currently disabled by default):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardenlet.config.gardener.cloud/v1alpha1
kind: GardenletConfiguration
<span style=color:green># ...</span>
server:
  https:
    port: 2720
debugging:
  enableProfiling: <span style=color:#00f>true</span>
  enableContentionProfiling: <span style=color:#00f>true</span>
</code></pre></div><p>The handlers are served on the same port as configured in <code>server.http(s).port</code> via HTTP or HTTPS respectively.</p><p>For example (gardenlet with HTTPS configured):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl -k https://localhost:2720/debug/pprof/heap &gt; /tmp/heap-gardenlet
$ go tool pprof /tmp/heap-gardenlet
</code></pre></div><h2 id=gardener-admission-controller-gardener-scheduler>gardener-admission-controller, gardener-scheduler</h2><p>gardener-admission-controller and gardener-scheduler also allow enabling profiling handlers via their respective component configs (currently disabled by default):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: admissioncontroller.config.gardener.cloud/v1alpha1
kind: AdmissionControllerConfiguration
<span style=color:green># ...</span>
server:
  metrics:
    port: 2723
debugging:
  enableProfiling: <span style=color:#00f>true</span>
  enableContentionProfiling: <span style=color:#00f>true</span>
</code></pre></div><p>However, the handlers are served on the same port as configured in <code>server.metrics.port</code> via HTTP.</p><p>For example (gardener-admission-controller):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ curl http://localhost:2723/debug/pprof/heap &gt; /tmp/heap-admission-controller
$ go tool pprof /tmp/heap-admission-controller
</code></pre></div><h2 id=gardener-seed-admission-controller>gardener-seed-admission-controller</h2><p>gardener-seed-admission-controller doesn&rsquo;t support profiling yet. See <a href=https://github.com/gardener/gardener/issues/4567>gardener/gardener#4567</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e5728941ab1558f050d903ea1fc6ece4>6.5 - User Alerts</h1><h1 id=user-alerts>User Alerts</h1><table><thead><tr><th>Alertname</th><th>Severity</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>ApiServerUnreachableViaKubernetesService</td><td>critical</td><td>shoot</td><td><code>The Api server has been unreachable for 3 minutes via the kubernetes service in the shoot.</code></td></tr><tr><td>KubeKubeletNodeDown</td><td>warning</td><td>shoot</td><td><code>The kubelet {{ $labels.instance }} has been unavailable/unreachable for more than 1 hour. Workloads on the affected node may not be schedulable.</code></td></tr><tr><td>KubeletTooManyOpenFileDescriptorsShoot</td><td>warning</td><td>shoot</td><td><code>Shoot-kubelet ({{ $labels.kubernetes_io_hostname }}) is using {{ $value }}% of the available file/socket descriptors. Kubelet could be under heavy load.</code></td></tr><tr><td>KubeletTooManyOpenFileDescriptorsShoot</td><td>critical</td><td>shoot</td><td><code>Shoot-kubelet ({{ $labels.kubernetes_io_hostname }}) is using {{ $value }}% of the available file/socket descriptors. Kubelet could be under heavy load.</code></td></tr><tr><td>KubePodPendingShoot</td><td>warning</td><td>shoot</td><td><code>Pod {{ $labels.pod }} is stuck in "Pending" state for more than 1 hour.</code></td></tr><tr><td>KubePodNotReadyShoot</td><td>warning</td><td>shoot</td><td><code>Pod {{ $labels.pod }} is not ready for more than 1 hour.</code></td></tr><tr><td>NoWorkerNodes</td><td>blocker</td><td></td><td><code>There are no worker nodes in the cluster or all of the worker nodes in the cluster are not schedulable.</code></td></tr><tr><td>NodeExporterDown</td><td>warning</td><td>shoot</td><td><code>The NodeExporter has been down or unreachable from Prometheus for more than 1 hour.</code></td></tr><tr><td>K8SNodeOutOfDisk</td><td>critical</td><td>shoot</td><td><code>Node {{ $labels.node }} has run out of disk space.</code></td></tr><tr><td>K8SNodeMemoryPressure</td><td>warning</td><td>shoot</td><td><code>Node {{ $labels.node }} is under memory pressure.</code></td></tr><tr><td>K8SNodeDiskPressure</td><td>warning</td><td>shoot</td><td><code>Node {{ $labels.node }} is under disk pressure</code></td></tr><tr><td>VMRootfsFull</td><td>critical</td><td>shoot</td><td><code>Root filesystem device on instance {{ $labels.instance }} is almost full.</code></td></tr><tr><td>VMConntrackTableFull</td><td>critical</td><td>shoot</td><td><code>The nf_conntrack table is {{ $value }}% full.</code></td></tr><tr><td>VPNProbeAPIServerProxyFailed</td><td>critical</td><td>shoot</td><td><code>The API Server proxy functionality is not working. Probably the vpn connection from an API Server pod to the vpn-shoot endpoint on the Shoot workers does not work.</code></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-3d1846d329d412578f082b9a8f919eb2>7 - Proposals</h1><h1 id=gardener-enhancement-proposal-gep>Gardener Enhancement Proposal (GEP)</h1><p>Changes to the Gardener code base are often incorporated directly via pull requests which either themselves contain a description about the motivation and scope of a change or a linked GitHub issue does.</p><p>If a perspective feature has a bigger extent, requires the involvement of several parties or more discussion is needed before the actual implementation can be started, you may consider filing a pull request with a Gardener Enhancement Proposal (GEP) first.</p><p>GEPs are a measure to propose a change or to add a feature to Gardener, help you to describe the change(s) conceptionally, and to list the steps that are necessary to reach this goal. It helps the Gardener maintainers as well as the community to understand the motivation and scope around your proposed change(s) and encourages their contribution to discussions and future pull requests. If you are familiar with the Kubernetes community, GEPs are analogue to Kubernetes Enhancement Proposals (<a href=https://github.com/kubernetes/enhancements/tree/master/keps>KEPs</a>).</p><h2 id=reasons-for-a-gep>Reasons for a GEP</h2><p>You may consider filing a GEP for the following reasons:</p><ul><li>A Gardener architectural change is intended / necessary</li><li>Major changes to the Gardener code base</li><li>A phased implementation approach is expected because of the widespread scope of the change</li><li>Your proposed changes may be controversial</li></ul><p>We encourage you to take a look at already merged <a href=https://github.com/gardener/gardener/tree/master/docs/proposals>GEPs</a> since they give you a sense of what a typical GEP comprises.</p><h2 id=before-creating-a-gep>Before creating a GEP</h2><p>Before starting your work and creating a GEP, please take some time to familiarize yourself with our
general <a href=https://gardener.cloud/docs/contribute/>Gardener Contribution Guidelines</a>.</p><p>It is recommended to discuss and outline the motivation of your prospective GEP as a draft with the community before you take the investment of creating the actual GEP. This early briefing supports the understanding for the broad community and leads to a fast feedback for your proposal from the respective experts in the community.
An appropriate format for this may be the regular <a href=https://gardener.cloud/docs/contribute/#bi-weekly-meetings>Gardener community meetings</a>.</p><h2 id=how-to-file-a-gep>How to file a GEP</h2><p>GEPs should be created as Markdown <code>.md</code> files and are submitted through a GitHub pull request to their current home in <a href=https://github.com/gardener/gardener/tree/master/docs/proposals>docs/proposals</a>. Please use the provided <a href=/docs/gardener/proposals/00-template/>template</a> or follow the structure of existing <a href=https://github.com/gardener/gardener/tree/master/docs/proposals>GEPs</a> which makes reviewing easier and faster. Additionally, please link the new GEP in our documentation <a href=https://github.com/gardener/gardener/blob/master/docs/README.md#Proposals>index</a>.</p><p>If not already done, please present your GEP in the <a href=https://gardener.cloud/docs/contribute/#bi-weekly-meetings>regular community meetings</a> to brief the community about your proposal (we strive for personal communication :) ). Also consider that this may be an important step to raise awareness and understanding for everyone involved.</p><p>The GEP template contains a small set of metadata, which is helpful for keeping track of the enhancement
in general and especially of who is responsible for implementing and reviewing PRs that are part of
the enhancement.</p><h3 id=main-reviewers>Main Reviewers</h3><p>Apart from general metadata, the GEP should name at least one &ldquo;main reviewer&rdquo;.
You can find a main reviewer for your GEP either when discussing the proposal in the community meeting, by asking in our
<a href=https://gardener.cloud/docs/contribute/#slack-channel>Slack Channel</a> or at latest during the GEP PR review.
New GEPs should only be accepted once at least one main reviewer is nominated/assigned.</p><p>The main reviewers are charged with the following tasks:</p><ul><li>familiarizing themselves with the details of the proposal</li><li>reviewing the GEP PR itself and any further updates to the document</li><li>discussing design details and clarifying implementation questions with the author before and after
the proposal was accepted</li><li>reviewing PRs related to the GEP in-depth</li></ul><p>Other community members are of course also welcome to help the GEP author, review his work and raise
general concerns with the enhancement. Nevertheless, the main reviewers are supposed to focus on more
in-depth reviews and accompaning the whole GEP process end-to-end, which helps with getting more
high-quality reviews and faster feedback cycles instead of having more people looking at the process
with lower priority and less focus.</p><h2 id=gep-process>GEP Process</h2><ol><li>Pre-discussions about GEP (if necessary)</li><li>Find a main reviewer for your enhancement</li><li>GEP is filed through GitHub PR</li><li>Presentation in Gardener community meeting (if possible)</li><li>Review of GEP from maintainers/community</li><li>GEP is merged if accepted</li><li>Implementation of GEP</li><li>Consider keeping GEP up-to-date in case implementation differs essentially</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-a871ba89d724217f0cabd24297c97c72>7.1 - 01 Extensibility</h1><h1 id=gardener-extensibility-and-extraction-of-cloud-specificos-specific-knowledge-308httpsgithubcomgardenergardenerissues308-262httpsgithubcomgardenergardenerissues262>Gardener extensibility and extraction of cloud-specific/OS-specific knowledge (<a href=https://github.com/gardener/gardener/issues/308>#308</a>, <a href=https://github.com/gardener/gardener/issues/262>#262</a>)</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#table-of-contents>Table of Contents</a></li><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a><ul><li><a href=#modification-of-existing-cloudprofile-and-shoot-resources>Modification of existing <code>CloudProfile</code> and <code>Shoot</code> resources</a><ul><li><a href=#cloudprofiles>CloudProfiles</a></li><li><a href=#shoots>Shoots</a></li></ul></li><li><a href=#crd-definitions-and-workflow-adaptation>CRD definitions and workflow adaptation</a><ul><li><a href=#custom-resource-definitions>Custom resource definitions</a><ul><li><a href=#dns-records>DNS records</a></li><li><a href=#infrastructure-provisioning>Infrastructure provisioning</a></li><li><a href=#backup-infrastructure-provisioning>Backup infrastructure provisioning</a></li><li><a href=#cloud-config-user-data-for-bootstrapping-machines>Cloud config (user-data) for bootstrapping machines</a></li><li><a href=#worker-pools-definition>Worker pools definition</a></li><li><a href=#generic-resources>Generic resources</a></li></ul></li><li><a href=#shoot-state>Shoot state</a></li><li><a href=#shoot-health-checksconditions>Shoot health checks/conditions</a></li><li><a href=#reconciliation-flow>Reconciliation flow</a></li><li><a href=#deletion-flow>Deletion flow</a></li></ul></li><li><a href=#gardenlet>Gardenlet</a></li><li><a href=#shoot-control-plane-movementmigration>Shoot control plane movement/migration</a></li></ul></li><li><a href=#registration-of-external-controllers-at-gardener>Registration of external controllers at Gardener</a></li><li><a href=#other-cloud-specific-parts>Other cloud-specific parts</a><ul><li><a href=#defaulting-and-validation-admission-plugins>Defaulting and validation admission plugins</a></li><li><a href=#dns-hosted-zone-admission-plugin>DNS Hosted Zone admission plugin</a></li><li><a href=#shoot-quota-admission-plugin>Shoot Quota admission plugin</a></li><li><a href=#shoot-maintenance-controller>Shoot maintenance controller</a></li></ul></li><li><a href=#alternatives>Alternatives</a></li></ul><h2 id=summary>Summary</h2><p>Gardener has evolved to a large compound of packages containing lots of highly specific knowledge which makes it very hard to extend (supporting a new cloud provider, new OS, &mldr;, or behave differently depending on the underlying infrastructure).</p><p>This proposal aims to move out the cloud-specific implementations (called &ldquo;(cloud) botanists&rdquo;) and the OS-specifics into dedicated controllers, and simultaneously to allow deviation from the standard Gardener deployment.</p><h2 id=motivation>Motivation</h2><p>Currently, it is too hard to support additional cloud providers or operation systems/distributions as everything must be done in-tree which might affect the implementation of other cloud providers as well.
The various conditions and branches make the code hard to maintain and hard to test.
Every change must be done centrally, requires to completely rebuild Gardener, and cannot be deployed individually. Similar to the motivation for Kubernetes to extract their cloud-specifics into dedicated cloud-controller-managers or to extract the container/storage/network/&mldr; specifics into CRI/CSI/CNI/&mldr;, we aim to do the same right now.</p><h3 id=goals>Goals</h3><ul><li>Gardener does not contain any cloud-specific knowledge anymore but defines a clear contract allowing external controllers (botanists) to support different environments (AWS, Azure, GCP, &mldr;).</li><li>Gardener does not contain any operation system-specific knowledge anymore but defines a clear contract allowing external controllers to support different operation systems/distributions (CoreOS, SLES, Ubuntu, &mldr;).</li><li>It shall become much easier to move control planes of Shoot clusters between Seed clusters (<a href=https://github.com/gardener/gardener/issues/232>#232</a>) which is a necessary requirement of an automated setup for the Gardener Ring (<a href=https://github.com/gardener/gardener/issues/233>#233</a>).</li></ul><h3 id=non-goals>Non-Goals</h3><ul><li>We want to also factor out the specific knowledge of the addon deployments (nginx-ingress, kubernetes-dashboard, &mldr;), but we already have dedicated projects/issues for that: <a href=https://github.com/gardener/bouquet>https://github.com/gardener/bouquet</a> and <a href=https://github.com/gardener/gardener/issues/246>#246</a>. We will keep the addons in-tree as part of this proposal and tackle their extraction separately.</li><li>We do not want to make the Gardener a plain workflow engine that just executes a given template (which indeed would allow to be generic, open, and extensible in their highest forms but which would end-up in building a &ldquo;programming/scripting language&rdquo; inside a serialization format (YAML/JSON/&mldr;)). Rather, we want to have well-defined contracts and APIs, keeping Gardener responsible for the clusters management.</li></ul><h2 id=proposal>Proposal</h2><p>Gardener heavily relies on and implements Kubernetes principles, and its ultimate strategy is to use Kubernetes wherever applicable.
The extension concept in Kubernetes is based on (next to others) <code>CustomResourceDefinition</code>s, <code>ValidatingWebhookConfiguration</code>s and <code>MutatingWebhookConfiguration</code>s, and <code>InitializerConfiguration</code>s.
Consequently, Gardener&rsquo;s extensibility concept relies on these mechanisms.</p><p>Instead of implementing all aspects directly in Gardener it will deploy some CRDs to the Seed cluster which will be watched by dedicated controllers (also running in the Seed clusters), each one implementing one aspect of cluster management. This way one complex strongly coupled Gardener implementation covering all infrastructures is decomposed into a set of loosely coupled controllers implementing aspects of APIs defined by Gardener.
Gardener will just wait until the controllers report that they are done (or have faced an error) in the CRD&rsquo;s <code>.status</code> field instead of doing the respective tasks itself.
We will have one specific CRD for every specific operation (e.g., DNS, infrastructure provisioning, machine cloud config generation, &mldr;).
However, there are also parts inside Gardener which can be handled generically (not by cloud botanists) because they are the same or very similar for all the environments.
One example of those is the deployment of a <code>Namespace</code> in the Seed which will run the Shoot&rsquo;s control plane
Another one is the deployment of a <code>Service</code> for the Shoot&rsquo;s kube-apiserver.
In case a cloud botanist needs to cooperate and react on those operations it should register a <code>ValidatingWebhookConfiguration</code>, a <code>MutatingWebhookConfiguration</code>, or a <code>InitializerConfiguration</code>.
With this approach it can validate, modify, or react on any resource created by Gardener to make it cloud infrastructure specific.</p><p>The web hooks should be registered with <code>failurePolicy=Fail</code> to ensure that a request made by Gardener fails if the respective web hook is not available.</p><h3 id=modification-of-existing-cloudprofile-and-shoot-resources>Modification of existing <code>CloudProfile</code> and <code>Shoot</code> resources</h3><p>We will introduce the new API group <code>gardener.cloud</code>:</p><h4 id=cloudprofiles>CloudProfiles</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: gardener.cloud/v1alpha1
kind: CloudProfile
metadata:
  name: aws
spec:
  type: aws
<span style=color:green># caBundle: |</span>
<span style=color:green>#   -----BEGIN CERTIFICATE-----</span>
<span style=color:green>#   ...</span>
<span style=color:green>#   -----END CERTIFICATE-----</span>
  dnsProviders:
  - type: aws-route53
  - type: unmanaged
  kubernetes:
    versions:
    - 1.12.1
    - 1.11.0
    - 1.10.5
  machineTypes:
  - name: m4.large
    cpu: <span style=color:#a31515>&#34;2&#34;</span>
    gpu: <span style=color:#a31515>&#34;0&#34;</span>
    memory: 8Gi
  <span style=color:green># storage: 20Gi   # optional (not needed in every environment, may only be specified if no volumeTypes have been specified)</span>
  ...
  volumeTypes:      <span style=color:green># optional (not needed in every environment, may only be specified if no machineType has a `storage` field)</span>
  - name: gp2
    class: standard
  - name: io1
    class: premium
  providerConfig:
    apiVersion: aws.cloud.gardener.cloud/v1alpha1
    kind: CloudProfileConfig
    constraints:
      minimumVolumeSize: 20Gi
      machineImages:
      - name: coreos
        regions:
        - name: eu-west-1
          ami: ami-32d1474b
        - name: us-east-1
          ami: ami-e582d29f
      zones:
      - region: eu-west-1
        zones:
        - name: eu-west-1a
          unavailableMachineTypes: <span style=color:green># list of machine types defined above that are not available in this zone</span>
          - name: m4.large
          unavailableVolumeTypes:  <span style=color:green># list of volume types defined above that are not available in this zone</span>
          - name: gp2
        - name: eu-west-1b
        - name: eu-west-1c
</code></pre></div><h4 id=shoots>Shoots</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardener.cloud/v1alpha1
kind: Shoot
metadata:
  name: johndoe-aws
  namespace: garden-dev
spec:
  cloudProfileName: aws
  secretBindingName: core-aws
  cloud:
    type: aws
    region: eu-west-1
    providerConfig:
      apiVersion: aws.cloud.gardener.cloud/v1alpha1
      kind: InfrastructureConfig
      networks:
        vpc: <span style=color:green># specify either &#39;id&#39; or &#39;cidr&#39;</span>
        <span style=color:green># id: vpc-123456</span>
          cidr: 10.250.0.0/16
        internal:
        - 10.250.112.0/22
        public:
        - 10.250.96.0/22
        workers:
        - 10.250.0.0/19
      zones:
      - eu-west-1a
    workerPools:
    - name: pool-01
    <span style=color:green># Taints, labels, and annotations are not yet implemented. This requires interaction with the machine-controller-manager, see</span>
    <span style=color:green># https://github.com/gardener/machine-controller-manager/issues/174. It is only mentioned here as future proposal.</span>
    <span style=color:green># taints:</span>
    <span style=color:green># - key: foo</span>
    <span style=color:green>#   value: bar</span>
    <span style=color:green>#   effect: PreferNoSchedule</span>
    <span style=color:green># labels:</span>
    <span style=color:green># - key: bar</span>
    <span style=color:green>#   value: baz</span>
    <span style=color:green># annotations:</span>
    <span style=color:green># - key: foo</span>
    <span style=color:green>#   value: hugo</span>
      machineType: m4.large
      volume: <span style=color:green># optional, not needed in every environment, may only be specified if the referenced CloudProfile contains the volumeTypes field</span>
        type: gp2
        size: 20Gi
      providerConfig:
        apiVersion: aws.cloud.gardener.cloud/v1alpha1
        kind: WorkerPoolConfig
        machineImage:
          name: coreos
          ami: ami-d0dcef3
        zones:
        - eu-west-1a
      minimum: 2
      maximum: 2
      maxSurge: 1
      maxUnavailable: 0
  kubernetes:
    version: 1.11.0
    ...
  dns:
    provider: aws-route53
    domain: johndoe-aws.garden-dev.example.com
  maintenance:
    timeWindow:
      begin: 220000+0100
      end: 230000+0100
    autoUpdate:
      kubernetesVersion: <span style=color:#00f>true</span>
  backup:
    schedule: <span style=color:#a31515>&#34;*/5 * * * *&#34;</span>
    maximum: 7
  addons:
    kube2iam:
      enabled: <span style=color:#00f>false</span>
    kubernetes-dashboard:
      enabled: <span style=color:#00f>true</span>
    cluster-autoscaler:
      enabled: <span style=color:#00f>true</span>
    nginx-ingress:
      enabled: <span style=color:#00f>true</span>
      loadBalancerSourceRanges: []
    kube-lego:
      enabled: <span style=color:#00f>true</span>
      email: john.doe@example.com
</code></pre></div><p>ℹ The specifications for the other cloud providers Gardener already has an implementation for looks similar.</p><h3 id=crd-definitions-and-workflow-adaptation>CRD definitions and workflow adaptation</h3><p>In the following we are outlining the CRD definitions which define the API between Gardener and the dedicated controllers.
After that we will take a look at the current <a href=https://github.com/gardener/gardener/blob/master/pkg/gardenlet/controller/shoot/shoot_control_reconcile.go>reconciliation</a>/<a href=https://github.com/gardener/gardener/blob/master/pkg/gardenlet/controller/shoot/shoot_control_delete.go>deletion</a> flow and describe how it would look like in case we would implement this proposal.</p><h4 id=custom-resource-definitions>Custom resource definitions</h4><p>Every CRD has a <code>.spec.type</code> field containing the respective instance of the dimension the CRD represents, e.g. the cloud provider, the DNS provider or the operation system name.
Moreover, the <code>.status</code> field must contain</p><ul><li><code>observedGeneration</code> (<code>int64</code>), a field indicating on which generation the controller last worked on.</li><li><code>state</code> (<code>*runtime.RawExtension</code>), a field which is not interpreted by Gardener but persisted; it should be treated opaque and only be used by the respective CRD-specific controller (it can store anything it needs to re-construct its own state).</li><li><code>lastError</code> (<code>object</code>), a field which is optional and only present if the last operation ended with an error state.</li><li><code>lastOperation</code> (<code>object</code>), a field which always exists and which indicates what the last operation of the controller was.</li><li><code>conditions</code> (<code>list</code>), a field allowing the controller to report health checks for its area of responsibility.</li></ul><p>Some CRDs might have a <code>.spec.providerConfig</code> or a <code>.status.providerStatus</code> field containing controller-specific information that is treated opaque by Gardener and will only be copied to dependent or depending CRDs.</p><h5 id=dns-records>DNS records</h5><p>Every Shoot needs two DNS records (or three, depending on whether nginx-ingress addon is enabled), one so-called &ldquo;internal&rdquo; record that Gardener uses in the kubeconfigs of the Shoot cluster&rsquo;s system components, and one so-called &ldquo;external&rdquo; record which is used in the kubeconfig provided to the user.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSProvider
metadata:
  name: alicloud
  namespace: default
spec:
  type: alicloud-dns
  secretRef:
    name: alicloud-credentials
  domains:
    include:
    - my.own.domain.com
---
apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSEntry
metadata:
  name: dns
  namespace: default
spec:
  dnsName: dns.my.own.domain.com
  ttl: 600
  targets:
  - 8.8.8.8
status:
  observedGeneration: 4
  state: some-state
  lastError:
    lastUpdateTime: 2018-04-04T07:08:51Z
    description: some-error message
    codes:
    - ERR_UNAUTHORIZED
  lastOperation:
    lastUpdateTime: 2018-04-04T07:24:51Z
    progress: 70
    type: Reconcile
    state: Processing
    description: Currently provisioning ...
  conditions:
  - lastTransitionTime: 2018-07-11T10:18:25Z
    message: DNS record has been created and is available.
    reason: RecordResolvable
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: Available
    propagate: <span style=color:#00f>false</span>
  providerStatus:
    apiVersion: aws.extensions.gardener.cloud/v1alpha1
    kind: DNSStatus
    ...
</code></pre></div><h5 id=infrastructure-provisioning>Infrastructure provisioning</h5><p>The <code>Infrastructure</code> CRD contains the information about VPC, networks, security groups, availability zones, &mldr;, basically, everything that needs to be prepared before an actual VMs/load balancers/&mldr; can be provisioned.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--core--aws-01
spec:
  type: aws
  providerConfig:
    apiVersion: aws.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureConfig
    networks:
      vpc:
        cidr: 10.250.0.0/16
      internal:
      - 10.250.112.0/22
      public:
      - 10.250.96.0/22
      workers:
      - 10.250.0.0/19
    zones:
    - eu-west-1a
  dns:
    apiserver: api.aws-01.core.example.com
  region: eu-west-1
  secretRef:
    name: my-aws-credentials
  sshPublicKey: |<span style=color:#a31515>
</span><span style=color:#a31515>    </span>    base64(key)
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
  providerStatus:
    apiVersion: aws.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureStatus
    vpc:
      id: vpc-1234
      subnets:
      - id: subnet-acbd1234
        name: workers
        zone: eu-west-1
      securityGroups:
      - id: sg-xyz12345
        name: workers
    iam:
      nodesRoleARN: &lt;some-arn&gt;
      instanceProfileName: foo
    ec2:
      keyName: bar
</code></pre></div><h5 id=backup-infrastructure-provisioning>Backup infrastructure provisioning</h5><p>The <code>BackupInfrastructure</code> CRD in the Seeds tells the cloud-specific controller to prepare a blob store bucket/container which can later be used to store etcd backups.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: BackupInfrastructure
metadata:
  name: etcd-backup
  namespace: shoot--core--aws-01
spec:
  type: aws
  region: eu-west-1
  storageContainerName: asdasjndasd-1293912378a-2213
  secretRef:
    name: my-aws-credentials
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
</code></pre></div><h5 id=cloud-config-user-data-for-bootstrapping-machines>Cloud config (user-data) for bootstrapping machines</h5><p>Gardener will continue to keep knowledge about the content of the cloud config scripts, but it will hand over it to the respective OS-specific controller which will generate the specific valid representation.
Gardener creates two <code>MachineCloudConfig</code> CRDs, one for the cloud-config-downloader (which will later flow into the <code>WorkerPool</code> CRD) and one for the real cloud-config (which will be stored as a <code>Secret</code> in the Shoot&rsquo;s <code>kube-system</code> namespace, and downloaded and executed from the cloud-config-downloader on the machines).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: MachineCloudConfig
metadata:
  name: pool-01-downloader
  namespace: shoot--core--aws-01
spec:
  type: CoreOS
  units:
  - name: cloud-config-downloader.service
    command: start
    enable: <span style=color:#00f>true</span>
    content: |<span style=color:#a31515>
</span><span style=color:#a31515>      [Unit]
</span><span style=color:#a31515>      Description=Downloads the original cloud-config from Shoot API Server and executes it
</span><span style=color:#a31515>      After=docker.service docker.socket
</span><span style=color:#a31515>      Wants=docker.socket
</span><span style=color:#a31515>      [Service]
</span><span style=color:#a31515>      Restart=always
</span><span style=color:#a31515>      RestartSec=30
</span><span style=color:#a31515>      EnvironmentFile=/etc/environment
</span><span style=color:#a31515>      ExecStart=/bin/sh /var/lib/cloud-config-downloader/download-cloud-config.sh</span>      
  files:
  - path: /var/lib/cloud-config-downloader/credentials/kubeconfig
    permissions: 0644
    content:
      secretRef:
        name: cloud-config-downloader
        dataKey: kubeconfig
  - path: /var/lib/cloud-config-downloader/download-cloud-config.sh
    permissions: 0644
    content:
      inline:
        encoding: b64
        data: IyEvYmluL2Jhc2ggL...
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
  cloudConfig: | <span style=color:green># base64-encoded</span>
    <span style=color:green>#cloud-config</span>

    coreos:
      update:
        reboot-strategy: <span style=color:#00f>off</span>
      units:
      - name: cloud-config-downloader.service
        command: start
        enable: <span style=color:#00f>true</span>
        content: |<span style=color:#a31515>
</span><span style=color:#a31515>          [Unit]
</span><span style=color:#a31515>          Description=Downloads the original cloud-config from Shoot API Server and execute it
</span><span style=color:#a31515>          After=docker.service docker.socket
</span><span style=color:#a31515>          Wants=docker.socket
</span><span style=color:#a31515>          [Service]
</span><span style=color:#a31515>          Restart=always
</span><span style=color:#a31515>          RestartSec=30
</span><span style=color:#a31515>          ...</span>          
</code></pre></div><p>ℹ The cloud-config-downloader script does not only download the cloud-config initially but at regular intervals, e.g., every <code>30s</code>.
If it sees an updated cloud-config then it applies it again by reloading and restarting all systemd units in order to reflect the changes.
The way how this reloading of the cloud-config happens is OS-specific as well and not known to Gardener anymore, however, it must be part of the script already.
On CoreOS, you have to execute <code>/usr/bin/coreos-cloudinit --from-file=&lt;path></code> whereas on SLES you execute <code>cloud-init --file &lt;path> single -n write_files --frequency=once</code>.
As Gardener doesn&rsquo;t know these commands it will write a placeholder expression instead (e.g., <code>{RELOAD-CLOUD-CONFIG-WITH-PATH:&lt;path>}</code>) and the OS-specific controller is asked to replace it with the proper expression.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: MachineCloudConfig
metadata:
  name: pool-01-original <span style=color:green># stored as secret and downloaded later</span>
  namespace: shoot--core--aws-01
spec:
  type: CoreOS
  units:
  - name: docker.service
    drop-ins:
    - name: 10-docker-opts.conf
      content: |<span style=color:#a31515>
</span><span style=color:#a31515>        [Service]
</span><span style=color:#a31515>        Environment=&#34;DOCKER_OPTS=--log-opt max-size=60m --log-opt max-file=3&#34;</span>        
  - name: docker-monitor.service
    command: start
    enable: <span style=color:#00f>true</span>
    content: |<span style=color:#a31515>
</span><span style=color:#a31515>      [Unit]
</span><span style=color:#a31515>      Description=Docker-monitor daemon
</span><span style=color:#a31515>      After=kubelet.service
</span><span style=color:#a31515>      [Service]
</span><span style=color:#a31515>      Restart=always
</span><span style=color:#a31515>      EnvironmentFile=/etc/environment
</span><span style=color:#a31515>      ExecStart=/opt/bin/health-monitor docker</span>      
  - name: kubelet.service
    command: start
    enable: <span style=color:#00f>true</span>
    content: |<span style=color:#a31515>
</span><span style=color:#a31515>      [Unit]
</span><span style=color:#a31515>      Description=kubelet daemon
</span><span style=color:#a31515>      Documentation=https://kubernetes.io/docs/admin/kubelet
</span><span style=color:#a31515>      After=docker.service
</span><span style=color:#a31515>      Wants=docker.socket rpc-statd.service
</span><span style=color:#a31515>      [Service]
</span><span style=color:#a31515>      Restart=always
</span><span style=color:#a31515>      RestartSec=10
</span><span style=color:#a31515>      EnvironmentFile=/etc/environment
</span><span style=color:#a31515>      ExecStartPre=/bin/docker run --rm -v /opt/bin:/opt/bin:rw k8s.gcr.io/hyperkube:v1.11.2 cp /hyperkube /opt/bin/
</span><span style=color:#a31515>      ExecStartPre=/bin/sh -c &#39;hostnamectl set-hostname $(cat /etc/hostname | cut -d &#39;.&#39; -f 1)&#39;
</span><span style=color:#a31515>      ExecStart=/opt/bin/hyperkube kubelet \
</span><span style=color:#a31515>          --allow-privileged=true \
</span><span style=color:#a31515>          --bootstrap-kubeconfig=/var/lib/kubelet/kubeconfig-bootstrap \
</span><span style=color:#a31515>          ...</span>      
  files:
  - path: /var/lib/kubelet/ca.crt
    permissions: 0644
    content:
      secretRef:
        name: ca-kubelet
        dataKey: ca.crt
  - path: /var/lib/cloud-config-downloader/download-cloud-config.sh
    permissions: 0644
    content:
      inline:
        encoding: b64
        data: IyEvYmluL2Jhc2ggL...
  - path: /etc/sysctl.d/99-k8s-general.conf
    permissions: 0644
    content:
      inline:
        data: |<span style=color:#a31515>
</span><span style=color:#a31515>          vm.max_map_count = 135217728
</span><span style=color:#a31515>          kernel.softlockup_panic = 1
</span><span style=color:#a31515>          kernel.softlockup_all_cpu_backtrace = 1
</span><span style=color:#a31515>          ...</span>          
  - path: /opt/bin/health-monitor
    permissions: 0755
    content:
      inline:
        data: |<span style=color:#a31515>
</span><span style=color:#a31515>          #!/bin/bash
</span><span style=color:#a31515>          set -o nounset
</span><span style=color:#a31515>          set -o pipefail
</span><span style=color:#a31515>
</span><span style=color:#a31515>          function docker_monitoring {
</span><span style=color:#a31515>          ...</span>          
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
  cloudConfig: ...
</code></pre></div><p>Cloud-specific controllers which might need to add another kernel option or another flag to the kubelet, maybe even another file to the disk, can register a <code>MutatingWebhookConfiguration</code> to that resource and modify it upon creation/update.
The task of the <code>MachineCloudConfig</code> controller is to only generate the OS-specific cloud-config based on the <code>.spec</code> field, but not to add or change any logic related to Shoots.</p><h5 id=worker-pools-definition>Worker pools definition</h5><p>For every worker pool defined in the <code>Shoot</code> Gardener will create a <code>WorkerPool</code> CRD which shall be picked up by a cloud-specific controller and be translated to <code>MachineClass</code>es and <code>MachineDeployment</code>s.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: WorkerPool
metadata:
  name: pool-01
  namespace: shoot--core--aws-01
spec:
  cloudConfig: base64(downloader-cloud-config)
  infrastructureProviderStatus:
    apiVersion: aws.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureStatus
    vpc:
      id: vpc-1234
      subnets:
      - id: subnet-acbd1234
        name: workers
        zone: eu-west-1
      securityGroups:
      - id: sg-xyz12345
        name: workers
    iam:
      nodesRoleARN: &lt;some-arn&gt;
      instanceProfileName: foo
    ec2:
      keyName: bar
  providerConfig:
    apiVersion: aws.cloud.gardener.cloud/v1alpha1
    kind: WorkerPoolConfig
    machineImage:
      name: CoreOS
      ami: ami-d0dcef3b
    machineType: m4.large
    volumeType: gp2
    volumeSize: 20Gi
    zones:
    - eu-west-1a
  region: eu-west-1
  secretRef:
    name: my-aws-credentials
  minimum: 2
  maximum: 2
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
</code></pre></div><h5 id=generic-resources>Generic resources</h5><p>Some components are cloud-specific and must be deployed by the cloud-specific botanists.
Others might need to deploy another pod next to the shoot&rsquo;s control plane or must do anything else.
Some of these might be important for a functional cluster (e.g., the cloud-controller-manager, or a CSI plugin in the future), and controllers should be able to report errors back to the user.
Consequently, in order to trigger the controllers to deploy these components Gardener would write a <code>Generic</code> CRD to the Seed to trigger the deployment.
No operation is depending on the status of these resources, however, the entire reconciliation flow is.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Generic
metadata:
  name: cloud-components
  namespace: shoot--core--aws-01
spec:
  type: cloud-components
  secretRef:
    name: my-aws-credentials
  shootSpec:
    ...
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
</code></pre></div><h4 id=shoot-state>Shoot state</h4><p>In order to enable moving the control plane of a Shoot between Seed clusters (e.g., if a Seed cluster is not available anymore or entirely broken) Gardener must store some non-reconstructable state, potentially also the state written by the controllers.
Gardener watches these extension CRDs and copies the <code>.status.state</code> in a <code>ShootState</code> resource into the Garden cluster.
Any observed status change of the respective CRD-controllers must be immediately reflected in the <code>ShootState</code> resource.
The contract between Gardener and those controllers is: <strong>Every controller must be capable of reconstructing its own environment based on both the state it has written before and on the real world&rsquo;s conditions/state.</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: gardener.cloud/v1alpha1
kind: ShootState
metadata:
  name: shoot--core--aws-01
shootRef:
  name: aws-01
  project: core
state:
  secrets:
  - name: ca
    data: ...
  - name: kube-apiserver-cert
    data: ...
  resources:
  - kind: DNS
    name: record-1
    state: &lt;copied-state-of-dns-crd&gt;
  - kind: Infrastructure
    name: networks
    state: &lt;copied-state-of-infrastructure-crd&gt;
  ...
  &lt;other fields required to keep track of&gt;
</code></pre></div><p>We cannot assume that Gardener is always online to observe the most recent states the controllers have written to their resources.
Consequently, the information stored here must not be used as &ldquo;single point of truth&rdquo;, but the controllers must potentially check the real world&rsquo;s status to reconstruct themselves.
However, this must anyway be part of their normal reconciliation logic and is a general best practice for Kubernetes controllers.</p><h4 id=shoot-health-checksconditions>Shoot health checks/conditions</h4><p>Some of the existing conditions already contain specific code which shall be simplified as well.
All of the CRDs described above have a <code>.status.conditions</code> field to which the controllers may write relevant health information of their function area.
Gardener will pick them up and copy them over to the Shoots <code>.status.conditions</code> (only those conditions setting <code>propagate=true</code>).</p><h4 id=reconciliation-flow>Reconciliation flow</h4><p>We are now examining the current Shoot creation/reconciliation flow and describe how it could look like when applying this proposal:</p><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>botanist.DeployNamespace</td><td>Gardener creates the namespace for the Shoot in the Seed cluster.</td></tr><tr><td>botanist.DeployKubeAPIServerService</td><td>Gardener creates a Service of type <code>LoadBalancer</code> in the Seed.<br>AWS Botanist registers a Mutating Webhook and adds its AWS-specific annotation.</td></tr><tr><td>botanist.WaitUntilKubeAPIServerServiceIsReady</td><td>Gardener checks the <code>.status</code> object of the just created <code>Service</code> in the Seed. The contract is that also clouds not supporting load balancers must react on the <code>Service</code> object and modify the <code>.status</code> to correctly reflect the kube-apiserver&rsquo;s ingress IP.</td></tr><tr><td>botanist.DeploySecrets</td><td>Gardener creates the secrets/certificates it needs like it does today, but it provides utility functions that can be adopted by Botanists/other controllers if they need additional certificates/secrets created on their own. (We should also add labels to all secrets)</td></tr><tr><td>botanist.Shoot.Components.DNS.Internal{Provider/Entry}.Deploy</td><td>Gardener creates a DNS-specific CRD in the Seed, and the responsible DNS-controller picks it up and creates a corresponding DNS record (see CRD specification above).</td></tr><tr><td>botanist.Shoot.Components.DNS.External{Provider/Entry}.Deploy</td><td>Gardener creates a DNS-specific CRD in the Seed, and the responsible DNS-controller picks it up and creates a corresponding DNS record: (see CRD specification above).</td></tr><tr><td>shootCloudBotanist.DeployInfrastructure</td><td>Gardener creates a Infrastructure-specific CRD in the Seed, and the responsible Botanist picks it up and does its job: (see CRD above).</td></tr><tr><td>botanist.DeployBackupInfrastructure</td><td>Gardener creates a <code>BackupInfrastructure</code> resource in the Garden cluster.<br>(The BackupInfrastructure controller creates a BackupInfrastructure-specific CRD in the Seed, and the responsible Botanist picks it up and does its job: (see CRD above).)</td></tr><tr><td>botanist.WaitUntilBackupInfrastructureReconciled</td><td>Gardener checks the <code>.status</code> object of the just created <code>BackupInfrastructure</code> resource.</td></tr><tr><td>hybridBotanist.DeployETCD</td><td>Gardener does only deploy the etcd <code>StatefulSet</code> without backup-restore sidecar at all.<br>The cloud-specific Botanist registers a Mutating Webhook and adds the backup-restore sidecar, and it also creates the <code>Secret</code> needed by the backup-restore sidecar.</td></tr><tr><td>botanist.WaitUntilEtcdReady</td><td>Gardener checks the <code>.status</code> object of the etcd <code>Statefulset</code> and waits until readiness is indicated.</td></tr><tr><td>hybridBotanist.DeployCloudProviderConfig</td><td>Gardener does not execute this anymore because it doesn&rsquo;t know anything about cloud-specific configuration.</td></tr><tr><td>hybridBotanist.DeployKubeAPIServer</td><td>Gardener does only deploy the kube-apiserver <code>Deployment</code> without any cloud-specific flags/configuration.<br>The cloud-specific Botanist registers a Mutating Webhook and adds whatever is needed for the kube-apiserver to run in its cloud environment.</td></tr><tr><td>hybridBotanist.DeployKubeControllerManager</td><td>Gardener does only deploy the kube-controller-manager <code>Deployment</code> without any cloud-specific flags/configuration.<br>The cloud-specific Botanist registers a Mutating Webhook and adds whatever is needed for the kube-controller-manager to run in its cloud environment (e.g., the cloud-config).</td></tr><tr><td>hybridBotanist.DeployKubeScheduler</td><td>Gardener does only deploy the kube-scheduler <code>Deployment</code> without any cloud-specific flags/configuration.<br>The cloud-specific Botanist registers a Mutating Webhook and adds whatever is needed for the kube-scheduler to run in its cloud environment.</td></tr><tr><td>hybridBotanist.DeployCloudControllerManager</td><td>Gardener does not execute this anymore because it doesn&rsquo;t know anything about cloud-specific configuration. The Botanists would be responsible to deploy their own cloud-controller-manager now.<br>They would watch for the kube-apiserver Deployment to exist, and as soon as it does, they deploy the CCM.<br>(Side note: The Botanist would also be responsible to deploy further controllers needed for this cloud environment, e.g. F5-controllers or CSI plugins).</td></tr><tr><td>botanist.WaitUntilKubeAPIServerReady</td><td>Gardener checks the <code>.status</code> object of the kube-apiserver <code>Deployment</code> and waits until readiness is indicated.</td></tr><tr><td>botanist.InitializeShootClients</td><td>Unchanged; Gardener creates a Kubernetes client for the Shoot cluster.</td></tr><tr><td>botanist.DeployMachineControllerManager</td><td>Deleted, Gardener does no longer deploy MCM itself. See below.</td></tr><tr><td>hybridBotanist.ReconcileMachines</td><td>Gardener creates a <code>Worker</code> CRD in the Seed, and the responsible <code>Worker</code> controller picks it up and does its job (see CRD above). It also deploys the machine-controller-manager.<br>Gardener waits until the status indicates that the controller is done.</td></tr><tr><td>hybridBotanist.DeployKubeAddonManager</td><td>This function also computes the CoreOS cloud-config (because the secret storing it is managed by the kube-addon-manager).<br>Gardener would deploy the CloudConfig-specific CRD in the Seed, and the responsible OS controller picks it up and does its job (see CRD above).<br>The Botanists which would have to modify something would register a Webhook for this CloudConfig-specific resource and apply their changes.<br>The rest is mostly unchanged, Gardener generates the manifests for the addons and deploys the kube-addon-manager into the Seed.<br>AWS Botanist registers a Webhook for nginx-ingress.<br>Azure Botanist registers a Webhook for calico.<br>Gardener will no longer deploy the <code>StorageClass</code>es. Instead, the Botanists wait until the kube-apiserver is available and deploy them.<br><br>In the long term we want to get rid of optional addons inside the Gardener core and implement a sophisticated addon concept (see <a href=https://github.com/gardener/gardener/issues/246>#246</a>).</td></tr><tr><td>shootCloudBotanist.DeployKube2IAMResources</td><td>This function would be removed (currently Gardener would execute a Terraform job creating the IAM roles specified in the Shoot manifest). We cannot keep this behavior, the user would be responsible to create the needed IAM roles on its own.</td></tr><tr><td>botanist.Shoot.Components.Nginx.DNSEtnry</td><td>Gardener creates a DNS-specific CRD in the Seed, and the responsible DNS-controller picks it up and creates a corresponding DNS record (see CRD specification above).</td></tr><tr><td>botanist.WaitUntilVPNConnectionExists</td><td>Unchanged, Gardener checks that it is possible to port-forward to a Shoot pod.</td></tr><tr><td>seedCloudBotanist.ApplyCreateHook</td><td>This function would be removed (actually, only the AWS Botanist implements it).<br>AWS Botanist deploys the aws-lb-readvertiser once the API Server is deployed and updates the ELB health check protocol one the load balancer pointing to the API server is created.</td></tr><tr><td>botanist.DeploySeedMonitoring</td><td>Unchanged, Gardener deploys the monitoring stack into the Seed.</td></tr><tr><td>botanist.DeployClusterAutoscaler</td><td>Unchanged, Gardener deploys the cluster-autoscaler into the Seed.</td></tr></tbody></table><p>ℹ We can easily lift the contract later and allow dynamic network plugins or not using the VPN solution at all.
We could also introduce a dedicated <code>ControlPlane</code> CRD and leave the complete responsibility of deploying kube-apiserver, kube-controller-manager, etc. to other controllers (if we need it at some point in time).</p><h4 id=deletion-flow>Deletion flow</h4><p>We are now examining the current Shoot deletion flow and describe shortly how it could look like when applying this proposal:</p><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>botanist.DeploySecrets</td><td>This is just refreshing the cloud provider secret in the Shoot namespace in the Seed (in case the user has changed it before triggering the deletion). This function would stay as it is.</td></tr><tr><td>hybridBotanist.RefreshMachineClassSecrets</td><td>This function would disappear.<br>Worker Pool controller needs to watch the referenced secret and update the generated MachineClassSecrets immediately.</td></tr><tr><td>hybridBotanist.RefreshCloudProviderConfig</td><td>This function would disappear. Botanist needs to watch the referenced secret and update the generated cloud-provider-config immediately.</td></tr><tr><td>botanist.RefreshCloudControllerManagerChecksums</td><td>See &ldquo;hybridBotanist.RefreshCloudProviderConfig&rdquo;.</td></tr><tr><td>botanist.RefreshKubeControllerManagerChecksums</td><td>See &ldquo;hybridBotanist.RefreshCloudProviderConfig&rdquo;.</td></tr><tr><td>botanist.InitializeShootClients</td><td>Unchanged; Gardener creates a Kubernetes client for the Shoot cluster.</td></tr><tr><td>botanist.DeleteSeedMonitoring</td><td>Unchanged; Gardener deletes the monitoring stack.</td></tr><tr><td>botanist.DeleteKubeAddonManager</td><td>Unchanged; Gardener deletes the kube-addon-manager.</td></tr><tr><td>botanist.DeleteClusterAutoscaler</td><td>Unchanged; Gardener deletes the cluster-autoscaler.</td></tr><tr><td>botanist.WaitUntilKubeAddonManagerDeleted</td><td>Unchanged; Gardener waits until the kube-addon-manager is deleted.</td></tr><tr><td>botanist.CleanCustomResourceDefinitions</td><td>Unchanged, Gardener cleans the CRDs in the Shoot.</td></tr><tr><td>botanist.CleanKubernetesResources</td><td>Unchanged, Gardener cleans all remaining Kubernetes resources in the Shoot.</td></tr><tr><td>hybridBotanist.DestroyMachines</td><td>Gardener deletes the WorkerPool-specific CRD in the Seed, and the responsible WorkerPool-controller picks it up and does its job.<br>Gardener waits until the CRD is deleted.</td></tr><tr><td>shootCloudBotanist.DestroyKube2IAMResources</td><td>This function would disappear (currently Gardener would execute a Terraform job deleting the IAM roles specified in the <code>Shoot</code> manifest). We cannot keep this behavior, the user would be responsible to delete the needed IAM roles on its own.</td></tr><tr><td>shootCloudBotanist.DestroyInfrastructure</td><td>Gardener deletes the Infrastructure-specific CRD in the Seed, and the responsible Botanist picks it up and does its job.<br>Gardener waits until the CRD is deleted.</td></tr><tr><td>botanist.Shoot.Components.DNS.External{Provider/Entry}.Destroy</td><td>Gardener deletes the DNS-specific CRD in the Seed, and the responsible DNS-controller picks it up and does its job.<br>Gardener waits until the CRD is deleted.</td></tr><tr><td>botanist.DeleteKubeAPIServer</td><td>Unchanged; Gardener deletes the kube-apiserver.</td></tr><tr><td>botanist.DeleteBackupInfrastructure</td><td>Unchanged; Gardener deletes the <code>BackupInfrastructure</code> object in the Garden cluster.<br>(The BackupInfrastructure controller deletes the BackupInfrastructure-specific CRD in the Seed, and the responsible Botanist picks it up and does its job.<br>The BackupInfrastructure controller waits until the CRD is deleted.)</td></tr><tr><td>botanist.Shoot.Components.DNS.Internal{Provider/Entry}.Destroy</td><td>Gardener deletes the DNS-specific CRD in the Seed, and the responsible DNS-controller picks it up and does its job.<br>Gardener waits until the CRD is deleted.</td></tr><tr><td>botanist.DeleteNamespace</td><td>Unchanged; Gardener deletes the Shoot namespace in the Seed cluster.</td></tr><tr><td>botanist.WaitUntilSeedNamespaceDeleted</td><td>Unchanged; Gardener waits until the Shoot namespace in the Seed has been deleted.</td></tr><tr><td>botanist.DeleteGardenSecrets</td><td>Unchanged; Gardener deletes the kubeconfig/ssh-keypair <code>Secret</code> in the project namespace in the Garden.</td></tr></tbody></table><h3 id=gardenlet>Gardenlet</h3><p>One part of the whole extensibility work will also to further split Gardener itself.
Inspired from Kubernetes itself we plan to move the <code>Shoot</code> reconciliation/deletion controller loops as well as the <code>BackupInfrastructure</code> reconciliation/deletion controller loops into a dedicated &ldquo;gardenlet&rdquo; component that will run in the Seed cluster.
With that, it can talk locally to the responsible kube-apiserver and we do no longer need to perform every operation out of the Garden cluster.
This approach will also help us with scalability, performance, maintainability, testability in general.</p><p>This architectural change implies that the Kubernetes API server of the Garden cluster must be exposed publicly (or at least be reachable by the registered Seeds). The Gardener controller-manager will remain and will keep its <code>CloudProfile</code>, <code>SecretBinding</code>, <code>Quota</code>, <code>Project</code>, and <code>Seed</code> controller loops. One part of the seed controller could be to deploy the &ldquo;gardenlet&rdquo; into the Seeds, however, this would require network connectivity to the Seed cluster.</p><h3 id=shoot-control-plane-movementmigration>Shoot control plane movement/migration</h3><p>Automatically moving control planes is difficult with the current implementation as some resources created in the old Seed must be moved to the new one. However, some of them are not under Gardener&rsquo;s control (e.g., <code>Machine</code> resources). Moreover, the old control plane must be deactivated somehow to ensure that not two controllers work on the same things (e.g., virtual machines) from different environments.</p><p>Gardener does not only deploy a DNS controller into the Seeds but also into its own Garden cluster.
For every Shoot cluster, Gardener commissions it to create a DNS <code>TXT</code> record containing the name of the Seed responsible for the Shoot (holding the control plane), e.g.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>dig -t txt aws-01.core.garden.example.com

...
;; ANSWER SECTION:
aws-01.core.garden.example.com. 120 IN	TXT <span style=color:#a31515>&#34;Seed=seed-01&#34;</span>
...
</code></pre></div><p>Gardener always keeps the DNS record up-to-date based on which Seed is responsible.</p><p>In the above CRD examples one object in the <code>.spec</code> section was omitted as it is needed to get Shoot control plane movement/migration working (the field is only explained now in this section and not before; it was omitted on purpose to support focusing on the relevant specifications first).
Every CRD also has the following section in its <code>.spec</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>leadership:
  record: aws-01.core.garden.example.com
  value: seed-01
  leaseSeconds: 60
</code></pre></div><p>Before every operation the CRD-controllers check this DNS record (based on the <code>.spec.leadership.leaseSeconds</code> configuration) and verify that its result is equal to the <code>.spec.leadership.value</code> field.
If both match they know that they should act on the resource, otherwise they stop doing anything.</p><p>ℹ We will provide an easy-to-use framework for the controllers containing all of these features out-of-the-box in order to allow the developers to focus on writing the actual controller logic.</p><p>When a Seed control plane move is triggered, the <code>.spec.cloud.seed</code> field of the respective <code>Shoot</code> is changed.
Gardener will change the respective DNS record&rsquo;s value (<code>aws-01.core.garden.example.com</code>) to contain the new Seed name.
After that it will wait <code>2*60s</code> to be sure that all controllers have observed the change.
Then it starts reconciling and applying the CRDs together with a preset <code>.status.state</code> into the new Seed (based on its last observations which were stored in the respective <code>ShootState</code> object stored in the Garden cluster).
The controllers are - as per contract - asked to reconstruct their own environment based on the <code>.status.state</code> they have written before and the real world&rsquo;s status.
Apart from that, the normal reconciliation flow gets executed.</p><p>Gardener stores the list of Seeds that were responsible for hosting a Shoots control plane at some time in the Shoots <code>.status.seeds</code> list so that it knows which Seeds must be cleaned up (i.e., where the control plane must be deleted because it has been moved).
Once cleaned up, the Seed&rsquo;s name will be removed from that list.</p><h3 id=backupinfrastructure-migration>BackupInfrastructure migration</h3><p>One part of the reconciliation flow above is the provisioning of the infrastructure for the Shoot&rsquo;s etcd backups (usually, this is a blob store bucket/container).
Gardener already uses a separate <code>BackupInfrastructure</code> resource that is written into the Garden cluster and picked up by a dedicated <code>BackupInfrastructure</code> controller (bundled into the Gardener controller manager).
This dedicated resource exists mainly for the reason to allow keeping backups for a certain &ldquo;grace period&rdquo; even after the Shoot deletion itself:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardener.cloud/v1alpha1
kind: BackupInfrastructure
metadata:
  name: aws-01-bucket
  namespace: garden-core
spec:
  seed: seed-01
  shootUID: uuid-of-shoot
</code></pre></div><p>The actual provisioning is executed in a corresponding Seed cluster as Gardener can only assume network connectivity to the underlying cloud environment in the Seed.
We would like to keep the created artifacts in the Seed (e.g., Terraform state) near to the control plane.
Consequently, when Gardener moves a control plane, it will update the <code>.spec.seed</code> field of the <code>BackupInfrastructure</code> resource as well.
With the exact same logic described above the <code>BackupInfrastructure</code> controller inside the Gardener will move to the new Seed.</p><h2 id=registration-of-external-controllers-at-gardener>Registration of external controllers at Gardener</h2><p>We want to have a dynamic registration process, i.e. we don&rsquo;t want to hard-code any information about which controllers shall be deployed.
The ideal solution would be to not even requiring a restart of Gardener when a new controller registers.</p><p>Every controller is registered by a <code>ControllerRegistration</code> resource that introduces every controller together with its supported resources (dimension (<code>kind</code>) and shape (<code>type</code>) combination) to Gardener:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardener.cloud/v1alpha1
kind: ControllerRegistration
metadata:
  name: dns-aws-route53
spec:
  resources:
  - kind: DNS
    type: aws-route53
<span style=color:green># deployment:</span>
<span style=color:green>#   type: helm</span>
<span style=color:green>#   providerConfig:</span>
<span style=color:green>#     chart.tgz: base64(helm-chart)</span>
<span style=color:green>#     values.yaml: |</span>
<span style=color:green>#       foo: bar</span>
</code></pre></div><p>Every <code>.kind</code>/<code>.type</code> combination may only exist once in the system.</p><p>When a <code>Shoot</code> shall be reconciled Gardener can identify based on the referenced <code>Seed</code> and the content of the <code>Shoot</code> specification which controllers are needed in the respective Seed cluster.
It will demand the operators in the Garden cluster to deploy the controllers they are responsible for to a specific Seed.
This kind of communication happens via CRDs as well:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardener.cloud/v1alpha1
kind: ControllerInstallation
metadata:
  name: dns-aws-route53
spec:
  registrationRef:
    name: dns-aws-route53
  seedRef:
    name: seed-01
status:
  conditions:
  - lastTransitionTime: 2018-08-07T15:09:23Z
    message: The controller has been successfully deployed to the seed.
    reason: ControllerDeployed
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: Available
</code></pre></div><p>The default scenario is that every controller is gets deployed by a dedicated operator that knows how to handle its lifecycle operations like deployment, update, upgrade, deletion.
This operator watches <code>ControllerInstallation</code> resources and reacts on those it is responsible for (that it has created earlier).
Gardener is responsible for writing the <code>.spec</code> field, the operator is responsible for providing information in the <code>.status</code> indicating whether the controller was successfully deployed and is ready to be used.
Gardener will be also able to ask for deletion of controllers from Seeds when they are not needed there anymore by deleting the corresponding <code>ControllerInstallation</code> object.</p><p>ℹ The provided easy-to-use framework for the controllers will also contain these needed features to implement corresponding operators.</p><p>For most cases the controller deployment is very simple (just deploying it into the seed with some static configuration).
In these cases it would produce unnecessary effort to ask for providing another component (the operator) that deploys the controller.
To simplify this situation Gardener will be able to react on <code>ControllerInstallation</code>s specifying <code>.spec.registration.deployment.type=helm</code>.
The controller would be registered with the <code>ControllerRegistration</code> resources that would contain a Helm chart with all resources needed to deploy this controller into a seed (plus some static values).
Gardener would render the Helm chart and deploy the resources into the seed.
It will not react if <code>.spec.registration.deployment.type!=helm</code> which allows to also use any other deployment mechanism. Controllers that are getting deployed by operators would not specify the <code>.spec.deployment</code> section in the <code>ControllerRegistration</code> at all.</p><p>ℹ Any controller requiring dynamic configuration values (e.g., based on the cloud provider or the region of the seed) must be installed with the operator approach.</p><h2 id=other-cloud-specific-parts>Other cloud-specific parts</h2><p>The Gardener API server has a few admission controllers that contain cloud-specific code as well. We have to replace these parts as well.</p><h3 id=defaulting-and-validation-admission-plugins>Defaulting and validation admission plugins</h3><p>Right now, the admission controllers inside the Gardener API server do perform a lot of validation and defaulting of fields in the Shoot specification.
The cloud-specific parts of these admission controllers will be replaced by mutating admission webhooks that will get called instead.
As we will have a dedicated operator running in the Garden cluster anyway it will also get the responsibility to register this webhook if it needs to validate/default parts of the Shoot specification.</p><p>Example: The <code>.spec.cloud.workerPools[*].providerConfig.machineImage</code> field in the new Shoot manifest mentioned above could be omitted by the user and would get defaulted by the cloud-specific operator.</p><h3 id=dns-hosted-zone-admission-plugin>DNS Hosted Zone admission plugin</h3><p>For the same reasons the existing DNS Hosted Zone admission plugin will be removed from the Gardener core and moved into the responsibility of the respective DNS-specific operators running in the Garden cluster.</p><h3 id=shoot-quota-admission-plugin>Shoot Quota admission plugin</h3><p>The Shoot quota admission plugin validates create or update requests on Shoots and checks that the specified machine/storage configuration is defined as per referenced <code>Quota</code> objects.
The cloud-specifics in this controller are no longer needed as the <code>CloudProfile</code> and the <code>Shoot</code> resource have been adapted:
The machine/storage configuration is no longer in cloud-specific sections but hard-wired fields in the general <code>Shoot</code> specification (see example resources above).
The quota admission plugin will be simplified and remains in the Gardener core.</p><h3 id=shoot-maintenance-controller>Shoot maintenance controller</h3><p>Every Shoot cluster can define a maintenance time window in which Gardener will update the Kubernetes patch version (if enabled) and the used machine image version in the Shoot resource.
While the Kubernetes version is not part of the <code>providerConfig</code> section in the <code>CloudProfile</code> resource, the <code>machineImage</code> field is, and thus Gardener can&rsquo;t understand it any longer.
In the future Gardener has to rely on the cloud-specific operator (probably the same doing the defaulting/validation mentioned before) to update this field.
In the maintenance time window the maintenance controller will update the Kubernetes patch version (if enabled) and add a <code>trigger.gardener.cloud=maintenance</code> annotation in the Shoot resource.
The already registered mutating web hook will call the operator who has to remove this annotation and update the <code>machineImage</code> in the <code>.spec.cloud.workerPools[*].providerConfig</code> sections.</p><h2 id=alternatives>Alternatives</h2><ul><li>Alternative to DNS approach for Shoot control plane movement/migration: We have thought about rotating the credentials when a move is triggered which would make all controllers ineffective immediately. However, one problem with this is that we require IAM privileges for the users infrastructure account which might be not desired. Another, more complicated problem is that we cannot assume API access in order to create technical users for all cloud environments that might be supported.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b5f9b425f9c9a3fa5345982414974ca5>7.2 - 02 Backupinfra</h1><h1 id=backup-infrastructure-crd-and-controller-redesign>Backup Infrastructure CRD and Controller Redesign</h1><h2 id=goal>Goal</h2><ul><li>As an operator, I would like to efficiently use the backup bucket for multiple clusters, thereby limiting the total number of buckets required.</li><li>As an operator, I would like to use different cloud provider for backup bucket provisioning other than cloud provider used for seed infrastructure.</li><li>Have seed independent backups, so that we can easily migrate a shoot from one seed to another.</li><li>Execute the backup operations (including bucket creation and deletion) from a seed, because network connectivity may only be ensured from the seeds (not necessarily from the garden cluster).</li><li>Preserve the garden cluster as source of truth (no information is missing in the garden cluster to reconstruct the state of the backups even if seed and shoots are lost completely).</li><li>Do not violate the infrastructure limits in regards to blob store limits/quotas.</li></ul><h2 id=motivation>Motivation</h2><p>Currently, every shoot cluster has its own etcd backup bucket with a centrally configured retention period. With the growing number of clusters, we are soon running out of the <a href=https://gist.github.com/swapnilgm/5c4d5506811e63c32ab3d73c4171d30f>quota limits of buckets on the cloud provider</a>. Moreover, even if the clusters are deleted, the backup buckets do exist, for a configured period of retention. Hence, there is need of minimizing the total count of buckets.</p><p>In addition, currently we use seed infrastructure credentials to provision the bucket for etcd backups. This results in binding backup bucket provider to seed infrastructure provider.</p><h2 id=terminology>Terminology</h2><ul><li><strong>Bucket</strong> : It is equivalent to s3 bucket, abs container, gcs bucket, swift container, alicloud bucket</li><li><strong>Object</strong> : It is equivalent s3 object, abs blob, gcs object, swift object, alicloud object, snapshot/backup of etcd on object store.</li><li><strong>Directory</strong> : As such there is no concept of directory in object store but usually the use directory as <code>/</code> separate common prefix for set of objects. Alternatively they use term folder for same.</li><li><strong>deletionGracePeriod</strong>: This means grace period or retention period for which backups will be persisted post deletion of shoot.</li></ul><h2 id=current-spec>Current Spec:</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-YAML data-lang=YAML><span style=color:green>#BackupInfra spec</span>
Kind: BackupInfrastructure
Spec:
    seed: seedName
    shootUID : shoot.status.uid
</code></pre></div><h2 id=current-naming-conventions>Current naming conventions</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>SeedNamespace :</td><td>Shoot&ndash;projectname&ndash;shootname</td></tr><tr><td>seed:</td><td>seedname</td></tr><tr><td>ShootUID :</td><td>shoot.status.UID</td></tr><tr><td>BackupInfraname:</td><td>seednamespce+sha(uid)[:5]</td></tr><tr><td>Backup-bucket-name:</td><td>BackupInfraName</td></tr><tr><td>BackupNamespace:</td><td>backup&ndash;BackupInfraName</td></tr></tbody></table><h2 id=proposal>Proposal</h2><p>Considering <a href=/docs/gardener/proposals/01-extensibility/#backup-infrastructure-provisioning>Gardener extension proposal</a> in mind, the backup infrastructure controller can be divided in two parts. There will be basically four backup infrastructure related CRD&rsquo;s. Two on the garden apiserver. And two on the seed cluster. Before going into to workflow, let&rsquo;s just first have look at the CRD.</p><h3 id=crd-on-garden-cluster>CRD on Garden cluster</h3><p>Just to give brief before going into the details, we will be sticking to the fact that Garden apiserver is always source of truth. Since backupInfra will be maintained post deletion of shoot, the info regarding this should always come from garden apiserver, we will continue to have BackupInfra resource on garden apiserver with some modifications.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: garden.cloud/v1alpha1
kind: BackupBucket
metadata:
  name: packet-region1-uid[:5]
  <span style=color:green># No namespace needed. This will be cluster scope resource.</span>
  ownerReferences:
  - kind: CloudProfile
    name: packet
spec:
  provider: aws
  region: eu-west-1
  secretRef: <span style=color:green># Required for root</span>
    name: backup-operator-aws
    namespace: garden
status:
  lastOperation: ...
  observedGeneration: ...
  seed: ...
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: garden.cloud/v1alpha1
kind: BackupEntry
metadata:
  name: shoot--dev--example--3ef42 <span style=color:green># Naming convention explained before</span>
  namespace: garden-dev
  ownerReferences:
  - apiVersion: core.gardener.cloud/v1beta1
    blockOwnerDeletion: <span style=color:#00f>false</span>
    controller: <span style=color:#00f>true</span>
    kind: Shoot
    name: example
    uid: 19a9538b-5058-11e9-b5a6-5e696cab3bc8
spec:
  shootUID: 19a9538b-5058-11e9-b5a6-5e696cab3bc8 <span style=color:green># Just for reference to find back associated shoot.</span>
  <span style=color:green># Following section comes from cloudProfile or seed yaml based on granularity decision.</span>
  bucketName: packet-region1-uid[:5]
status:
  lastOperation: ...
  observedGeneration: ...
  seed: ...
</code></pre></div><h3 id=crd-on-seed-cluster>CRD on Seed cluster</h3><p>Considering the extension proposal, we want individual component to be handled by controller inside seed cluster. We will have Backup related resource in registered seed cluster as well.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: BackupBucket
metadata:
  name: packet-random[:5]
  <span style=color:green># No namespace need. This will be cluster scope resource</span>
spec:
  type: aws
  region: eu-west-1
  secretRef:
    name: backup-operator-aws
    namespace: backup-garden
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
</code></pre></div><p>There are two points for introducing BackupEntry resource.</p><ol><li>Cloud provider specific code goes completely in seed cluster.</li><li>Network issue is also handled by moving deletion part to backup-extension-controller in seed cluster.</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: BackupEntry
metadata:
  name: shoot--dev--example--3ef42 <span style=color:green># Naming convention explained later</span>
  <span style=color:green># No namespace need. This will be cluster scope resource</span>
spec:
  type: aws
  region: eu-west-1
  secretRef: <span style=color:green># Required for root</span>
    name: backup-operator-aws
    namespace: backup-garden
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
</code></pre></div><h3 id=workflow>Workflow</h3><ul><li>Gardener administrator will configure the cloudProfile with backup infra credentials and provider config as follows.</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green># CloudProfile.yaml:</span>
Spec:
    backup:
        provider: aws
        region: eu-west-1
        secretRef:
            name: backup-operator-aws
            namespace: garden
</code></pre></div><p>Here CloudProfileController will interpret this spec as follows:</p><ul><li>If <code>spec.backup</code> is nil<ul><li>No backup for any shoot.</li></ul></li><li>If <code>spec.backup.region</code> is not nil,<ul><li>Then respect it, i.e. use the provider and unique region field mentioned there for BackupBucket.</li><li>Here Preferably, <code>spec.backup.region</code> field will be unique, since for cross provider, it doesn’t make much sense. Since region name will be different for different providers.</li></ul></li><li>Otherwise, spec.backup.region is nil then,<ul><li>If same provider case i.e. spec.backup.provider = spec.(type-of-provider) or nil,<ul><li>Then, for each region from <code>spec.(type-of-provider).constraints.regions</code> create a <code>BackupBucket</code> instance. This can be done lazily i.e. create <code>BackupBucket</code> instance for region only if some seed actually spawned in the region has been registered. This will avoid creating IaaS bucket even if no seed is registered in that region, but region is listed in <code>cloudprofile</code>.</li><li>Shoot controller will choose backup container as per the seed region. (With shoot control plane migration also, seed’s availability zone might change but the region will be remaining same as per current scope.)</li></ul></li><li>Otherwise cross provider case i.e. spec.backup.provider != spec.(type-of-provider)<ul><li>Report validation error: Since, for example, we can’t expect <code>spec.backup.provider</code> = <code>aws</code> to support region in, <code>spec.packet.constraint.region</code>. Where type-of-provider is <code>packet</code></li></ul></li></ul></li></ul><p>Following diagram represent overall flow in details:</p><p><img src=/__resources/02-backupinfra-provisioning-sequence-diagram_c08a3e.svg alt=sequence-diagram></p><h4 id=reconciliation>Reconciliation</h4><p>Reconciliation on backup entry in seed cluster mostly comes in picture at the time of deletion. But we can add initialization steps like creation of <a href=#terminology>directory</a> specific to shoot in backup bucket. We can simply create BackupEntry at the time of shoot deletion as well.</p><h4 id=deletion>Deletion</h4><ul><li>On shoot deletion, the BackupEntry instance i.e. shoot specific instance will get deletion timestamp because of ownerReference.</li><li>If <code>deletionGracePeriod</code> configured in GCM component configuration is expired, BackupInfrastructure Controller will delete the backup folder associated with it from backup object store.</li><li>Finally, it will remove the <code>finalizer</code> from backupEntry instance.</li></ul><h3 id=alternative>Alternative</h3><p><img src=/__resources/02-backupinfra-provisioning-with-deletion-job_e51f05.svg alt=sequence-diagram></p><h2 id=discussion-points--variations>Discussion points / variations</h2><h3 id=manual-vs-dynamic-bucket-creation>Manual vs dynamic bucket creation</h3><ul><li><p>As per limit observed on different cloud providers, we can have single bucket for backups on one cloud providers. So, we could avoid the little complexity introduced in above approach by pre-provisioning buckets as a part of landscape setup. But there won&rsquo;t be anybody to detect bucket existence and its reconciliation. Ideally this should be avoided.</p></li><li><p>Another thing we can have is, we can let administrator register the pool of root backup infra resource and let the controller schedule backup on one of this.</p></li><li><p>One more variation here could be to create bucket dynamically per hash of shoot UID.</p></li></ul><h3 id=sdk-vs-terraform>SDK vs Terraform</h3><p>Initial reason for going for terraform script is its stability and the provided parallelism/concurrency in resource creation. For backup infrastructure, Terraform scripts are very minimal right now. Its simply have bucket creation script. With shared bucket logic, if possible we might want to isolate access at <a href=#terminology>directory</a> level but again its additional one call. So, we will prefer switching to SDK for all object store operations.</p><h3 id=limiting-the-number-of-shoots-per-bucket>Limiting the number of shoots per bucket</h3><p>Again as per limit observed on different cloud providers, we can have single bucket for backups on one cloud providers. But if we want to limit the number of shoots associated with bucket, we can have central map of configuration in <code>gardener-controller-component-configuration.yaml</code>.
Where we will mark supported count of shoots per cloud provider. Most probable space could be,
<code>controller.backupInfrastructures.quota</code>. If limit is reached we can create new <code>BucketBucket</code> instance.</p><p>e.g.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: controllermanager.config.gardener.cloud/v1alpha1
kind: ControllerManagerConfiguration
controllers:
  backupInfrastructure:
    quota:
      - provider: aws
        limit: 100 <span style=color:green># Number mentioned here are random, just for example purpose.</span>
      - provider: azure
        limit: 80
      - provider: openstack
        limit: 100
      ...
</code></pre></div><h2 id=backward-compatibility>Backward compatibility</h2><h3 id=migration>Migration</h3><ul><li>Create shoot specific folder.</li><li>Transfer old objects.</li><li>Create manifest of objects on new bucket<ul><li>Each entry will have status: None,Copied, NotFound.</li><li>Copy objects one by one.</li></ul></li><li>Scale down etcd-main with old config. ⚠️ Cluster down time</li><li>Copy remaining objects</li><li>Scale up etcd-main with new config.</li><li>Destroy Old bucket and old backup namespace. It can be immediate or preferably <strong>lazy</strong> deletion.</li></ul><p><img src=/__resources/02-backupinfra-migration_a671d5.svg alt=backup-migration-sequence-diagram></p><h3 id=legacy-mode-alternative>Legacy Mode alternative</h3><ul><li>If Backup namespace present in seed cluster, then follow the legacy approach.</li><li>i.e. reconcile creation/existence of shoot specific bucket and backup namespace.</li><li>If backup namespace is not created, use shared bucket.</li><li><strong>Limitation</strong> Never know when the existing cluster will be deleted, and hence, it might be little difficult to maintain with next release of gardener. This might look simple and straight-forward for now but may become pain point in future, if in worst case, because of some new use cases or refactoring, we have to change the design again. Also, even after multiple garden release we won&rsquo;t be able to remove deprecated existing BackupInfrastructure CRD</li></ul><h3 id=references>References</h3><ul><li><a href=/docs/gardener/proposals/01-extensibility/#backup-infrastructure-provisioning>Gardener extension proposal</a></li><li><a href=https://gist.github.com/swapnilgm/5c4d5506811e63c32ab3d73c4171d30f>Cloud providers object store limit comparison</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7f676322b31081c2c8e84da2b175e0a4>7.3 - 03 Networking Extensibility</h1><h1 id=network-extensibility>Network Extensibility</h1><p>Currently Gardener follows a mono network-plugin support model (i.e., Calico). Although this can seem to be the more stable approach, it does not completely reflect the real use-case. This proposal brings forth an effort to add an extra level of customizability to Gardener networking.</p><h2 id=motivation>Motivation</h2><p>Gardener is an open-source project that provides a nested user model. Basically, there are two types of services provided by Gardener to its users:</p><ul><li><strong>Managed</strong>: users only request a Kubernetes cluster (Clusters-as-a-Service)</li><li><strong>Hosted</strong>: users utilize Gardener to provide their own managed version of Kubernetes (Cluster-Provisioner-as-a-service)</li></ul><p>For the first set of users, the choice of network plugin might not be so important, however, for the second class of users (i.e., Hosted) it is important to be able to customize networking based on their needs.</p><p>Furthermore, Gardener provisions clusters on different cloud-providers with different networking requirements. For example, Azure does not support Calico Networking [1], this leads to the introduction of manual exceptions in static add-on charts which is error prune and can lead to failures during upgrades.</p><p>Finally, every provider is different, and thus the network always needs to adapt to the infrastructure needs to provider better performance. Consistency does not necessarily lie in the implementation but in the interface.</p><h2 id=gardener-network-extension>Gardener Network Extension</h2><p>The goal of the Gardener Network Extensions is to support different network plugin, therefore, the specification for the network resource won&rsquo;t be fixed and will be customized based on the underlying network plugin. To do so, a <code>NetworkConfig</code> field in the spec will be provided where each plugin will define. Below is an example for deploy Calico as the cluster network plugin.</p><h3 id=long-term-spec>Long Term Spec</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Network
metadata:
  name: calico-network
  namespace: shoot--core--test-01
spec:
  type: calico
  clusterCIDR: 192.168.0.0/24
  serviceCIDR:  10.96.0.0/24
  providerConfig:
    apiVersion: calico.extensions.gardener.cloud/v1alpha1
    kind: NetworkConfig
    ipam:
      type: host-local
      cidr: usePodCIDR
    backend: bird
    typha:
      enabled: <span style=color:#00f>true</span>
status:
  observedGeneration: ...
  state: ...
  lastError: ..
  lastOperation: ...
  providerStatus:
    apiVersion: calico.extensions.gardener.cloud/v1alpha1
    kind: NetworkStatus
    components:
      kubeControllers: <span style=color:#00f>true</span>
      calicoNodes: <span style=color:#00f>true</span>
    connectivityTests:
      pods: <span style=color:#00f>true</span>
      services: <span style=color:#00f>true</span>
    networkModules:
      arp_proxy: <span style=color:#00f>true</span>
    config:
      clusterCIDR: 192.168.0.0/24
      serviceCIDR:  10.96.0.0/24
      ipam:
        type: host-local
        cidr: usePodCIDR
</code></pre></div><h3 id=first-implementation-short-term>First Implementation (Short Term)</h3><p>As an initial implementation the network plugin type will be specified by the user e.g., Calico (without further configuration in the provider spec). This will then be used to generate
the <code>Network</code> resource in the seed. The Network operator will pick it up, and apply the configuration based on the <code>spec.cloudProvider</code> specified directly to the shoot or via the
Gardener resource manager (still in the works).</p><p>The <code>cloudProvider</code> field in the spec is just an initial catalyst but not meant to be stay long-term. In the future, the network provider configuration will be customized to match the best
needs of the infrastructure.</p><p>Here is how the simplified initial spec would look like:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: extensions.gardener.cloud/v1alpha1
kind: Network
metadata:
  name: calico-network
  namespace: shoot--core--test-01
spec:
  type: calico
  cloudProvider: {aws,azure,...}
status:
  observedGeneration: 2
  lastOperation: ...
  lastError: ...
</code></pre></div><h2 id=functionality>Functionality</h2><p>The network resource need to be created early-on during cluster provisioning. Once created, the Network operator residing in every seed will create all the necessary networking resources and apply them to the shoot cluster.</p><p>The status of the Network resource should reflect the health of the networking components as well as additional tests if required.</p><h2 id=references>References</h2><p>[1] <a href=https://docs.projectcalico.org/v3.0/reference/public-cloud/azure>Azure support for Calico Networking</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-6972c06e5d67dfd5b9bac676e2a230c2>7.4 - 04 New Core Gardener Cloud Apis</h1><h1 id=new-coregardenercloudv1beta1-apis-required-to-extract-cloud-specificos-specific-knowledge-out-of-gardener-core>New <code>core.gardener.cloud/v1beta1</code> APIs required to extract cloud-specific/OS-specific knowledge out of Gardener core</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#table-of-contents>Table of Contents</a></li><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a><ul><li><a href=#cloudprofile-resource><code>CloudProfile</code> resource</a></li><li><a href=#seed-resource><code>Seed</code> resource</a></li><li><a href=#project-resource><code>Project</code> resource</a></li><li><a href=#secretbinding-resource><code>SecretBinding</code> resource</a></li><li><a href=#quota-resource><code>Quota</code> resource</a></li><li><a href=#backupbucket-resource><code>BackupBucket</code> resource</a></li><li><a href=#backupentry-resource><code>BackupEntry</code> resource</a></li><li><a href=#shoot-resource><code>Shoot</code> resource</a></li><li><a href=#plant-resource><code>Plant</code> resource</a></li></ul></li></ul><h2 id=summary>Summary</h2><p>In <a href=/docs/gardener/proposals/01-extensibility/>GEP-1</a> we have proposed how to (re-)design Gardener to allow providers maintaining their provider-specific knowledge out of the core tree.
Meanwhile, we have progressed a lot and are about to remove the <a href=https://github.com/gardener/gardener/blob/de75a5bfcbedd16ba341ace0eb58be2a87049dcb/pkg/operation/cloudbotanist/types.go><code>CloudBotanist</code> interface</a> entirely.
The only missing aspect that will allow providers to really maintain their code out of the core is to design new APIs.</p><p>This proposal describes how the new <code>Shoot</code>, <code>Seed</code> etc. APIs will be re-designed to cope with the changes made with extensibility.
We already have the new <code>core.gardener.cloud/v1beta1</code> API group that will be the new default soon.</p><h2 id=motivation>Motivation</h2><p>We want to allow providers to individually maintain their specific knowledge without the necessity to touch the Gardener core code.
In order to achieve the same, we have to provide proper APIs.</p><h3 id=goals>Goals</h3><ul><li>Provide proper APIs to allow providers maintaining their code outside of the core codebase.</li><li>Do not complicate the APIs for end-users such that they can easily create, delete, and maintain shoot clusters.</li></ul><h3 id=non-goals>Non-Goals</h3><ul><li>Let&rsquo;s try to not split everything up into too many different resources. Instead, let&rsquo;s try to keep all relevant information in the same resources when possible/appropriate.</li></ul><h2 id=proposal>Proposal</h2><p>In GEP-1 we already have proposed a first version for new <code>CloudProfile</code> and <code>Shoot</code> resources.
In order to deprecate the existing/old <code>garden.sapcloud.io/v1beta1</code> API group (and remove it, eventually) we should move all existing resources to the new <code>core.gardener.cloud/v1beta1</code> API group.</p><h3 id=cloudprofile-resource><code>CloudProfile</code> resource</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: CloudProfile
metadata:
  name: cloudprofile1
spec:
  type: &lt;some-provider-name&gt; <span style=color:green># {aws,azure,gcp,...}</span>
<span style=color:green># Optional list of labels on `Seed` resources that marks those seeds whose shoots may use this provider profile.</span>
<span style=color:green># An empty list means that all seeds of the same provider type are supported.</span>
<span style=color:green># This is useful for environments that are of the same type (like openstack) but may have different &#34;instances&#34;/landscapes.</span>
<span style=color:green># seedSelector:</span>
<span style=color:green>#   matchLabels:</span>
<span style=color:green>#     foo: bar</span>
  kubernetes:
    versions:
    - version: 1.12.1
    - version: 1.11.0
    - version: 1.10.6
    - version: 1.10.5
      expirationDate: 2020-04-05T01:02:03Z <span style=color:green># optional</span>
  machineImages:
  - name: coreos
    versions:
    - version: 2023.5.0
    - version: 1967.5.0
      expirationDate: 2020-04-05T08:00:00Z
  - name: ubuntu
    versions:
    - version: 18.04.201906170
  machineTypes:
  - name: m5.large
    cpu: <span style=color:#a31515>&#34;2&#34;</span>
    gpu: <span style=color:#a31515>&#34;0&#34;</span>
    memory: 8Gi
  <span style=color:green># storage: 20Gi # optional (not needed in every environment, may only be specified if no volumeTypes have been specified)</span>
    usable: <span style=color:#00f>true</span>
  volumeTypes: <span style=color:green># optional (not needed in every environment, may only be specified if no machineType has a `storage` field)</span>
  - name: gp2
    class: standard
  - name: io1
    class: premium
  regions:
  - name: europe-central-1
    zones: <span style=color:green># optional (not needed in every environment)</span>
    - name: europe-central-1a
    - name: europe-central-1b
    - name: europe-central-1c
    <span style=color:green># unavailableMachineTypes: # optional, list of machine types defined above that are not available in this zone</span>
    <span style=color:green># - m5.large</span>
    <span style=color:green># unavailableVolumeTypes: # optional, list of volume types defined above that are not available in this zone</span>
    <span style=color:green># - io1</span>
<span style=color:green># CA bundle that will be installed onto every shoot machine that is using this provider profile.</span>
<span style=color:green># caBundle: |</span>
<span style=color:green>#   -----BEGIN CERTIFICATE-----</span>
<span style=color:green>#   ...</span>
<span style=color:green>#   -----END CERTIFICATE-----</span>
  providerConfig:
    &lt;some-provider-specific-cloudprofile-config&gt;
    <span style=color:green># We don&#39;t have concrete examples for every existing provider yet, but these are the proposals:</span>
    <span style=color:green>#</span>
    <span style=color:green># Example for Alicloud:</span>
    <span style=color:green>#</span>
    <span style=color:green># apiVersion: alicloud.provider.extensions.gardener.cloud/v1alpha1</span>
    <span style=color:green># kind: CloudProfileConfig</span>
    <span style=color:green># machineImages:</span>
    <span style=color:green># - name: coreos</span>
    <span style=color:green>#   version: 2023.5.0</span>
    <span style=color:green>#   id: coreos_2023_4_0_64_30G_alibase_20190319.vhd</span>
    <span style=color:green>#</span>
    <span style=color:green>#</span>
    <span style=color:green># Example for AWS:</span>
    <span style=color:green>#</span>
    <span style=color:green># apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1</span>
    <span style=color:green># kind: CloudProfileConfig</span>
    <span style=color:green># machineImages:</span>
    <span style=color:green># - name: coreos</span>
    <span style=color:green>#   version: 1967.5.0</span>
    <span style=color:green>#   regions:</span>
    <span style=color:green>#   - name: europe-central-1</span>
    <span style=color:green>#     ami: ami-0f46c2ed46d8157aa</span>
    <span style=color:green>#</span>
    <span style=color:green>#</span>
    <span style=color:green># Example for Azure:</span>
    <span style=color:green>#</span>
    <span style=color:green># apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1</span>
    <span style=color:green># kind: CloudProfileConfig</span>
    <span style=color:green># machineImages:</span>
    <span style=color:green># - name: coreos</span>
    <span style=color:green>#   version: 1967.5.0</span>
    <span style=color:green>#   publisher: CoreOS</span>
    <span style=color:green>#   offer: CoreOS</span>
    <span style=color:green>#   sku: Stable</span>
    <span style=color:green># countFaultDomains:</span>
    <span style=color:green># - region: westeurope</span>
    <span style=color:green>#   count: 2</span>
    <span style=color:green># countUpdateDomains:</span>
    <span style=color:green># - region: westeurope</span>
    <span style=color:green>#   count: 5</span>
    <span style=color:green>#</span>
    <span style=color:green>#</span>
    <span style=color:green># Example for GCP:</span>
    <span style=color:green>#</span>
    <span style=color:green># apiVersion: gcp.provider.extensions.gardener.cloud/v1alpha1</span>
    <span style=color:green># kind: CloudProfileConfig</span>
    <span style=color:green># machineImages:</span>
    <span style=color:green># - name: coreos</span>
    <span style=color:green>#   version: 2023.5.0</span>
    <span style=color:green>#   image: projects/coreos-cloud/global/images/coreos-stable-2023-5-0-v20190312</span>
    <span style=color:green>#</span>
    <span style=color:green>#</span>
    <span style=color:green># Example for OpenStack:</span>
    <span style=color:green>#</span>
    <span style=color:green># apiVersion: openstack.provider.extensions.gardener.cloud/v1alpha1</span>
    <span style=color:green># kind: CloudProfileConfig</span>
    <span style=color:green># machineImages:</span>
    <span style=color:green># - name: coreos</span>
    <span style=color:green>#   version: 2023.5.0</span>
    <span style=color:green>#   image: coreos-2023.5.0</span>
    <span style=color:green># keyStoneURL: https://url-to-keystone/v3/</span>
    <span style=color:green># dnsServers:</span>
    <span style=color:green># - 10.10.10.10</span>
    <span style=color:green># - 10.10.10.11</span>
    <span style=color:green># dhcpDomain: foo.bar</span>
    <span style=color:green># requestTimeout: 30s</span>
    <span style=color:green># constraints:</span>
    <span style=color:green>#   loadBalancerProviders:</span>
    <span style=color:green>#   - name: haproxy</span>
    <span style=color:green>#   floatingPools:</span>
    <span style=color:green>#   - name: fip1</span>
    <span style=color:green>#     loadBalancerClasses:</span>
    <span style=color:green>#     - name: class1</span>
    <span style=color:green>#       floatingSubnetID: 04eed401-f85f-4610-8041-c4835c4beea6</span>
    <span style=color:green>#       floatingNetworkID: 23949a30-1cdd-4732-ba47-d03ced950acc</span>
    <span style=color:green>#       subnetID: ac46c204-9d0d-4a4c-a90d-afefe40cfc35</span>
    <span style=color:green>#</span>
    <span style=color:green>#</span>
    <span style=color:green># Example for Packet:</span>
    <span style=color:green>#</span>
    <span style=color:green># apiVersion: packet.provider.extensions.gardener.cloud/v1alpha1</span>
    <span style=color:green># kind: CloudProfileConfig</span>
    <span style=color:green># machineImages:</span>
    <span style=color:green># - name: coreos</span>
    <span style=color:green>#   version: 2079.3.0</span>
    <span style=color:green>#   id: d61c3912-8422-4daf-835e-854efa0062e4</span>
</code></pre></div><h3 id=seed-resource><code>Seed</code> resource</h3><p>Special note: The proposal contains fields that are not yet existing in the current <code>garden.sapcloud.io/v1beta1.Seed</code> resource, but they should be implemented (open issues that require them are linked).</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: seed-secret
  namespace: garden
type: Opaque
data:
  kubeconfig: base64(kubeconfig-for-seed-cluster)

---
apiVersion: v1
kind: Secret
metadata:
  name: backup-secret
  namespace: garden
type: Opaque
data:
  <span style=color:green># &lt;some-provider-specific data keys&gt;</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-alicloud/blob/master/example/30-backupbucket.yaml#L9-L11</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-infrastructure.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-azure/blob/master/example/30-backupbucket.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-gcp/blob/master/example/30-backupbucket.yaml#L9</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-openstack/blob/master/example/30-backupbucket.yaml#L9-L13</span>

---
apiVersion: core.gardener.cloud/v1beta1
kind: Seed
metadata:
  name: seed1
spec:
  provider:
    type: &lt;some-provider-name&gt; <span style=color:green># {aws,azure,gcp,...}</span>
    region: europe-central-1
  secretRef:
    name: seed-secret
    namespace: garden
  <span style=color:green># Motivation for DNS section: https://github.com/gardener/gardener/issues/201.</span>
  dns:
    provider: &lt;some-provider-name&gt; <span style=color:green># {aws-route53, google-clouddns, ...}</span>
    secretName: my-dns-secret <span style=color:green># must be in `garden` namespace</span>
    ingressDomain: seed1.dev.example.com
  volume: <span style=color:green># optional (introduced to get rid of `persistentvolume.garden.sapcloud.io/minimumSize` and `persistentvolume.garden.sapcloud.io/provider` annotations)</span>
    minimumSize: 20Gi
    providers:
    - name: foo
      purpose: etcd-main
  networks: <span style=color:green># Seed and Shoot networks must be disjunct</span>
    nodes: 10.240.0.0/16
    pods: 10.241.128.0/17
    services: 10.241.0.0/17
  <span style=color:green># Shoot default networks, see also https://github.com/gardener/gardener/issues/895.</span>
  <span style=color:green># shootDefaults:</span>
  <span style=color:green>#   pods: 100.96.0.0/11</span>
  <span style=color:green>#   services: 100.64.0.0/13</span>
  taints:
  - key: seed.gardener.cloud/protected
  - key: seed.gardener.cloud/invisible
  blockCIDRs:
  - 169.254.169.254/32
  backup: <span style=color:green># See https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md.</span>
    type: &lt;some-provider-name&gt; <span style=color:green># {aws,azure,gcp,...}</span>
  <span style=color:green># region: eu-west-1</span>
    secretRef:
      name: backup-secret
      namespace: garden
status:
  conditions:
  - lastTransitionTime: <span style=color:#a31515>&#34;2020-07-14T19:16:42Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2020-07-14T19:18:17Z&#34;</span>
    message: all checks passed
    reason: Passed
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: Available
  gardener:
    id: 4c9832b3823ee6784064877d3eb10c189fc26e98a1286c0d8a5bc82169ed702c
    name: gardener-controller-manager-7fhn9ikan73n-7jhka
    version: 1.0.0
  observedGeneration: 1
</code></pre></div><h3 id=project-resource><code>Project</code> resource</h3><p>Special note: The <code>members</code> and <code>viewers</code> field of the <code>garden.sapcloud.io/v1beta1.Project</code> resource will be merged together into one <code>members</code> field.
Every member will have a role that is either <code>admin</code> or <code>viewer</code>.
This will allow us to add new roles without changing the API.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Project
metadata:
  name: example
spec:
  description: Example project
  members:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: john.doe@example.com
    role: admin
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: joe.doe@example.com
    role: viewer
  namespace: garden-example
  owner:
    apiGroup: rbac.authorization.k8s.io
    kind: User
    name: john.doe@example.com
  purpose: Example project
status:
  observedGeneration: 1
  phase: Ready
</code></pre></div><h3 id=secretbinding-resource><code>SecretBinding</code> resource</h3><p>Special note: No modifications needed compared to the current <code>garden.sapcloud.io/v1beta1.SecretBinding</code> resource.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: secret1
  namespace: garden-core
type: Opaque
data:
  <span style=color:green># &lt;some-provider-specific data keys&gt;</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-alicloud/blob/master/example/30-infrastructure.yaml#L14-L15</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-infrastructure.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-azure/blob/master/example/30-infrastructure.yaml#L14-L17</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-gcp/blob/master/example/30-infrastructure.yaml#L14</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-openstack/blob/master/example/30-infrastructure.yaml#L15-L18</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-packet/blob/master/example/30-infrastructure.yaml#L14-L15</span>
  <span style=color:green>#</span>
  <span style=color:green># If you use your own domain (not the default domain of your landscape) then you have to add additional keys to this secret.</span>
  <span style=color:green># The reason is that the DNS management is not part of the Gardener core code base but externalized, hence, it might use other</span>
  <span style=color:green># key names than Gardener itself.</span>
  <span style=color:green># The actual values here depend on the DNS extension that is installed to your landscape.</span>
  <span style=color:green># For example, check out https://github.com/gardener/external-dns-management and find a lot of example secret manifests here:</span>
  <span style=color:green># https://github.com/gardener/external-dns-management/tree/master/examples</span>

---
apiVersion: core.gardener.cloud/v1beta1
kind: SecretBinding
metadata:
  name: secretbinding1
  namespace: garden-core
secretRef:
  name: secret1
<span style=color:green># namespace: namespace-other-than-&#39;garden-core&#39; // optional</span>
quotas: []
<span style=color:green># - name: quota-1</span>
<span style=color:green># # namespace: namespace-other-than-&#39;garden-core&#39; // optional</span>
</code></pre></div><h3 id=quota-resource><code>Quota</code> resource</h3><p>Special note: No modifications needed compared to the current <code>garden.sapcloud.io/v1beta1.Quota</code> resource.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Quota
metadata:
  name: trial-quota
  namespace: garden-trial
spec:
  scope:
    apiGroup: core.gardener.cloud
    kind: Project
<span style=color:green># clusterLifetimeDays: 14</span>
  metrics:
    cpu: <span style=color:#a31515>&#34;200&#34;</span>
    gpu: <span style=color:#a31515>&#34;20&#34;</span>
    memory: 4000Gi
    storage.standard: 8000Gi
    storage.premium: 2000Gi
    loadbalancer: <span style=color:#a31515>&#34;100&#34;</span>
</code></pre></div><h3 id=backupbucket-resource><code>BackupBucket</code> resource</h3><p>Special note: This new resource is cluster-scoped.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green># See also: https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md.</span>

apiVersion: v1
kind: Secret
metadata:
  name: backup-operator-provider
  namespace: backup-garden
type: Opaque
data:
  <span style=color:green># &lt;some-provider-specific data keys&gt;</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-alicloud/blob/master/example/30-backupbucket.yaml#L9-L11</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-backupbucket.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-azure/blob/master/example/30-backupbucket.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-gcp/blob/master/example/30-backupbucket.yaml#L9</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-openstack/blob/master/example/30-backupbucket.yaml#L9-L13</span>

---
apiVersion: core.gardener.cloud/v1beta1
kind: BackupBucket
metadata:
  name: &lt;seed-provider-type&gt;-&lt;region&gt;-&lt;seed-uid&gt;
  ownerReferences:
  - kind: Seed
    name: seed1
spec:
  provider:
    type: &lt;some-provider-name&gt; <span style=color:green># {aws,azure,gcp,...}</span>
    region: europe-central-1
  seed: seed1
  secretRef:
    name: backup-operator-provider
    namespace: backup-garden
status:
  lastOperation:
    description: Backup bucket has been successfully reconciled.
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:34:27Z&#39;</span>
    progress: 100
    state: Succeeded
    type: Reconcile
  observedGeneration: 1
</code></pre></div><h3 id=backupentry-resource><code>BackupEntry</code> resource</h3><p>Special note: This new resource is cluster-scoped.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green># See also: https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md.</span>

apiVersion: v1
kind: Secret
metadata:
  name: backup-operator-provider
  namespace: backup-garden
type: Opaque
data:
  <span style=color:green># &lt;some-provider-specific data keys&gt;</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-alicloud/blob/master/example/30-backupbucket.yaml#L9-L11</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-backupbucket.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-azure/blob/master/example/30-backupbucket.yaml#L9-L10</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-gcp/blob/master/example/30-backupbucket.yaml#L9</span>
  <span style=color:green># https://github.com/gardener/gardener-extension-provider-openstack/blob/master/example/30-backupbucket.yaml#L9-L13</span>

---
apiVersion: core.gardener.cloud/v1beta1
kind: BackupEntry
metadata:
  name: shoot--core--crazy-botany--3ef42
  namespace: garden-core
  ownerReferences:
  - apiVersion: core.gardener.cloud/v1beta1
    blockOwnerDeletion: <span style=color:#00f>false</span>
    controller: <span style=color:#00f>true</span>
    kind: Shoot
    name: crazy-botany
    uid: 19a9538b-5058-11e9-b5a6-5e696cab3bc8
spec:
  bucketName: cloudprofile1-random[:5]
  seed: seed1
status:
  lastOperation:
    description: Backup entry has been successfully reconciled.
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:34:27Z&#39;</span>
    progress: 100
    state: Succeeded
    type: Reconcile
  observedGeneration: 1
</code></pre></div><h3 id=shoot-resource><code>Shoot</code> resource</h3><p>Special notes:</p><ul><li><code>kubelet</code> configuration in the worker pools may override the default <code>.spec.kubernetes.kubelet</code> configuration (that applies for all worker pools if not overridden).</li><li>Moved remaining control plane configuration to new <code>.spec.provider.controlplane</code> section.</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: crazy-botany
  namespace: garden-core
spec:
  secretBindingName: secretbinding1
  cloudProfileName: cloudprofile1
  region: europe-central-1
<span style=color:green># seedName: seed1</span>
  provider:
    type: &lt;some-provider-name&gt; <span style=color:green># {aws,azure,gcp,...}</span>
    infrastructureConfig:
      &lt;some-provider-specific-infrastructure-config&gt;
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-alicloud/blob/master/example/30-infrastructure.yaml#L56-L64</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-infrastructure.yaml#L43-L53</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-azure/blob/master/example/30-infrastructure.yaml#L63-L71</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-gcp/blob/master/example/30-infrastructure.yaml#L53-L57</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-openstack/blob/master/example/30-infrastructure.yaml#L56-L64</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-packet/blob/master/example/30-infrastructure.yaml#L48-L49</span>
    controlPlaneConfig:
      &lt;some-provider-specific-controlplane-config&gt;
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-alicloud/blob/master/example/30-controlplane.yaml#L60-L65</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-aws/blob/master/example/30-controlplane.yaml#L60-L64</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-azure/blob/master/example/30-controlplane.yaml#L61-L66</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-gcp/blob/master/example/30-controlplane.yaml#L59-L64</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-openstack/blob/master/example/30-controlplane.yaml#L64-L70</span>
      <span style=color:green># https://github.com/gardener/gardener-extension-provider-packet/blob/master/example/30-controlplane.yaml#L60-L61</span>
    workers:
    - name: cpu-worker
      minimum: 3
      maximum: 5
    <span style=color:green># maxSurge: 1</span>
    <span style=color:green># maxUnavailable: 0</span>
      machine:
        type: m5.large
        image:
          name: &lt;some-os-name&gt;
          version: &lt;some-os-version&gt;
        <span style=color:green># providerConfig:</span>
        <span style=color:green>#   &lt;some-os-specific-configuration&gt;</span>
      volume:
        type: gp2
        size: 20Gi
    <span style=color:green># providerConfig:</span>
    <span style=color:green>#   &lt;some-provider-specific-worker-config&gt;</span>
    <span style=color:green># labels:</span>
    <span style=color:green>#   key: value</span>
    <span style=color:green># annotations:</span>
    <span style=color:green>#   key: value</span>
    <span style=color:green># taints: # See also https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/</span>
    <span style=color:green># - key: foo</span>
    <span style=color:green>#   value: bar</span>
    <span style=color:green>#   effect: NoSchedule</span>
    <span style=color:green># caBundle: &lt;some-ca-bundle-to-be-installed-to-all-nodes-in-this-pool&gt;</span>
    <span style=color:green># kubernetes:</span>
    <span style=color:green>#   kubelet:</span>
    <span style=color:green>#     cpuCFSQuota: true</span>
    <span style=color:green>#     cpuManagerPolicy: none</span>
    <span style=color:green>#     podPidsLimit: 10</span>
    <span style=color:green>#     featureGates:</span>
    <span style=color:green>#       SomeKubernetesFeature: true</span>
    <span style=color:green># zones: # optional, only relevant if the provider supports availability zones</span>
    <span style=color:green># - europe-central-1a</span>
    <span style=color:green># - europe-central-1b</span>
  kubernetes:
    version: 1.15.1
  <span style=color:green># allowPrivilegedContainers: true # &#39;true&#39; means that all authenticated users can use the &#34;gardener.privileged&#34; PodSecurityPolicy, allowing full unrestricted access to Pod features.</span>
  <span style=color:green># kubeAPIServer:</span>
  <span style=color:green>#   featureGates:</span>
  <span style=color:green>#     SomeKubernetesFeature: true</span>
  <span style=color:green>#   runtimeConfig:</span>
  <span style=color:green>#     scheduling.k8s.io/v1alpha1: true</span>
  <span style=color:green>#   oidcConfig:</span>
  <span style=color:green>#     caBundle: |</span>
  <span style=color:green>#       -----BEGIN CERTIFICATE-----</span>
  <span style=color:green>#       Li4u</span>
  <span style=color:green>#       -----END CERTIFICATE-----</span>
  <span style=color:green>#     clientID: client-id</span>
  <span style=color:green>#     groupsClaim: groups-claim</span>
  <span style=color:green>#     groupsPrefix: groups-prefix</span>
  <span style=color:green>#     issuerURL: https://identity.example.com</span>
  <span style=color:green>#     usernameClaim: username-claim</span>
  <span style=color:green>#     usernamePrefix: username-prefix</span>
  <span style=color:green>#     signingAlgs: RS256,some-other-algorithm</span>
  <span style=color:green>#-#-# only usable with Kubernetes &gt;= 1.11</span>
  <span style=color:green>#     requiredClaims:</span>
  <span style=color:green>#       key: value</span>
  <span style=color:green>#   admissionPlugins:</span>
  <span style=color:green>#   - name: PodNodeSelector</span>
  <span style=color:green>#     config: |</span>
  <span style=color:green>#       podNodeSelectorPluginConfig:</span>
  <span style=color:green>#         clusterDefaultNodeSelector: &lt;node-selectors-labels&gt;</span>
  <span style=color:green>#         namespace1: &lt;node-selectors-labels&gt;</span>
  <span style=color:green>#         namespace2: &lt;node-selectors-labels&gt;</span>
  <span style=color:green>#   auditConfig:</span>
  <span style=color:green>#     auditPolicy:</span>
  <span style=color:green>#       configMapRef:</span>
  <span style=color:green>#         name: auditpolicy</span>
  <span style=color:green># kubeControllerManager:</span>
  <span style=color:green>#   featureGates:</span>
  <span style=color:green>#     SomeKubernetesFeature: true</span>
  <span style=color:green>#   horizontalPodAutoscaler:</span>
  <span style=color:green>#     syncPeriod: 30s</span>
  <span style=color:green>#     tolerance: 0.1</span>
  <span style=color:green>#-#-# only usable with Kubernetes &lt; 1.12</span>
  <span style=color:green>#     downscaleDelay: 15m0s</span>
  <span style=color:green>#     upscaleDelay: 1m0s</span>
  <span style=color:green>#-#-# only usable with Kubernetes &gt;= 1.12</span>
  <span style=color:green>#     downscaleStabilization: 5m0s</span>
  <span style=color:green>#     initialReadinessDelay: 30s</span>
  <span style=color:green>#     cpuInitializationPeriod: 5m0s</span>
  <span style=color:green># kubeScheduler:</span>
  <span style=color:green>#   featureGates:</span>
  <span style=color:green>#     SomeKubernetesFeature: true</span>
  <span style=color:green># kubeProxy:</span>
  <span style=color:green>#   featureGates:</span>
  <span style=color:green>#     SomeKubernetesFeature: true</span>
  <span style=color:green>#   mode: IPVS</span>
  <span style=color:green># kubelet:</span>
  <span style=color:green>#   cpuCFSQuota: true</span>
  <span style=color:green>#   cpuManagerPolicy: none</span>
  <span style=color:green>#   podPidsLimit: 10</span>
  <span style=color:green>#   featureGates:</span>
  <span style=color:green>#     SomeKubernetesFeature: true</span>
  <span style=color:green># clusterAutoscaler:</span>
  <span style=color:green>#   scaleDownUtilizationThreshold: 0.5</span>
  <span style=color:green>#   scaleDownUnneededTime: 30m</span>
  <span style=color:green>#   scaleDownDelayAfterAdd: 60m</span>
  <span style=color:green>#   scaleDownDelayAfterFailure: 10m</span>
  <span style=color:green>#   scaleDownDelayAfterDelete: 10s</span>
  <span style=color:green>#   scanInterval: 10s</span>
  dns:
    <span style=color:green># When the shoot shall use a cluster domain no domain and no providers need to be provided - Gardener will</span>
    <span style=color:green># automatically compute a correct domain.</span>
    domain: crazy-botany.core.my-custom-domain.com
    providers:
    - type: aws-route53
      secretName: my-custom-domain-secret
      domains:
        include:
        - my-custom-domain.com
        - my-other-custom-domain.com
        exclude:
        - yet-another-custom-domain.com
      zones:
        include:
        - zone-id-1
        exclude:
        - zone-id-2
  extensions:
  - type: foobar
  <span style=color:green># providerConfig:</span>
  <span style=color:green>#   apiVersion: foobar.extensions.gardener.cloud/v1alpha1</span>
  <span style=color:green>#   kind: FooBarConfiguration</span>
  <span style=color:green>#   foo: bar</span>
  networking:
    type: calico
    pods: 100.96.0.0/11
    services: 100.64.0.0/13
    nodes: 10.250.0.0/16
  <span style=color:green># providerConfig:</span>
  <span style=color:green>#   apiVersion: calico.extensions.gardener.cloud/v1alpha1</span>
  <span style=color:green>#   kind: NetworkConfig</span>
  <span style=color:green>#   ipam:</span>
  <span style=color:green>#     type: host-local</span>
  <span style=color:green>#     cidr: usePodCIDR</span>
  <span style=color:green>#   backend: bird</span>
  <span style=color:green>#   typha:</span>
  <span style=color:green>#     enabled: true</span>
  <span style=color:green># See also: https://github.com/gardener/gardener/blob/master/docs/proposals/03-networking.md</span>
  maintenance:
    timeWindow:
      begin: 220000+0100
      end: 230000+0100
    autoUpdate:
      kubernetesVersion: <span style=color:#00f>true</span>
      machineImageVersion: <span style=color:#00f>true</span>
<span style=color:green># hibernation:</span>
<span style=color:green>#   enabled: false</span>
<span style=color:green>#   schedules:</span>
<span style=color:green>#   - start: &#34;0 20 * * *&#34; # Start hibernation every day at 8PM</span>
<span style=color:green>#     end: &#34;0 6 * * *&#34;    # Stop hibernation every day at 6AM</span>
<span style=color:green>#     location: &#34;America/Los_Angeles&#34; # Specify a location for the cron to run in</span>
  addons:
    nginx-ingress:
      enabled: <span style=color:#00f>false</span>
    <span style=color:green># loadBalancerSourceRanges: []</span>
    kubernetes-dashboard:
      enabled: <span style=color:#00f>true</span>
    <span style=color:green># authenticationMode: basic # allowed values: basic,token</span>
status:
  conditions:
  - type: APIServerAvailable
    status: <span style=color:#a31515>&#39;True&#39;</span>
    lastTransitionTime: <span style=color:#a31515>&#39;2020-01-30T10:38:15Z&#39;</span>
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:35:21Z&#39;</span>
    reason: HealthzRequestFailed
    message: API server /healthz endpoint responded with success status code. [response_time:3ms]
  - type: ControlPlaneHealthy
    status: <span style=color:#a31515>&#39;True&#39;</span>
    lastTransitionTime: <span style=color:#a31515>&#39;2020-04-02T05:18:58Z&#39;</span>
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:35:21Z&#39;</span>
    reason: ControlPlaneRunning
    message: All control plane components are healthy.
  - type: EveryNodeReady
    status: <span style=color:#a31515>&#39;True&#39;</span>
    lastTransitionTime: <span style=color:#a31515>&#39;2020-04-01T16:27:21Z&#39;</span>
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:35:21Z&#39;</span>
    reason: EveryNodeReady
    message: Every node registered to the cluster is ready.
  - type: SystemComponentsHealthy
    status: <span style=color:#a31515>&#39;True&#39;</span>
    lastTransitionTime: <span style=color:#a31515>&#39;2020-04-03T18:26:28Z&#39;</span>
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:35:21Z&#39;</span>
    reason: SystemComponentsRunning
    message: All system components are healthy.
  gardener:
    id: 4c9832b3823ee6784064877d3eb10c189fc26e98a1286c0d8a5bc82169ed702c
    name: gardener-controller-manager-7fhn9ikan73n-7jhka
    version: 1.0.0
  lastOperation:
    description: Shoot cluster state has been successfully reconciled.
    lastUpdateTime: <span style=color:#a31515>&#39;2020-04-13T14:34:27Z&#39;</span>
    progress: 100
    state: Succeeded
    type: Reconcile
  observedGeneration: 1
  seed: seed1
  hibernated: <span style=color:#00f>false</span>
  technicalID: shoot--core--crazy-botany
  uid: d8608cfa-2856-11e8-8fdc-0a580af181af
</code></pre></div><h3 id=plant-resource><code>Plant</code> resource</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  name: crazy-plant-secret
  namespace: garden-core
type: Opaque
data:
  kubeconfig: base64(kubeconfig-for-plant-cluster)

---
apiVersion: core.gardener.cloud/v1beta1
kind: Plant
metadata:
  name: crazy-plant
  namespace: garden-core
spec:
  secretRef:
    name: crazy-plant-secret
  endpoints:
  - name: Cluster GitHub repository
    purpose: management
    url: https://github.com/my-org/my-cluster-repo
  - name: GKE cluster page
    purpose: management
    url: https://console.cloud.google.com/kubernetes/clusters/details/europe-west1-b/plant?project=my-project&amp;authuser=1&amp;tab=details
status:
  clusterInfo:
    provider:
      type: gce
      region: europe-west4-c
    kubernetes:
      version: v1.11.10-gke.5
  conditions:
  - lastTransitionTime: <span style=color:#a31515>&#34;2020-03-01T11:31:37Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2020-04-14T18:00:29Z&#34;</span>
    message: API server /healthz endpoint responded with success status code. [response_time:8ms]
    reason: HealthzRequestFailed
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: APIServerAvailable
  - lastTransitionTime: <span style=color:#a31515>&#34;2020-04-01T06:26:56Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2020-04-14T18:00:29Z&#34;</span>
    message: Every node registered to the cluster is ready.
    reason: EveryNodeReady
    status: <span style=color:#a31515>&#34;True&#34;</span>
    type: EveryNodeReady
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-d76ec792a311963802e5b8c02ff3c5d5>7.5 - 05 Versioning Policy</h1><h1 id=gardener-versioning-policy>Gardener Versioning Policy</h1><p>Please refer to <a href=/docs/gardener/usage/shoot_versions/>this document</a> for the documentation of the implementation of this GEP.</p><h2 id=goal>Goal</h2><ul><li>As a Garden operator I would like to define a clear Kubernetes version policy, which informs my users about deprecated or expired Kubernetes versions.</li><li>As an user of Gardener, I would like to get information which Kubernetes version is supported for how long. I want to be able to get this information via API (cloudprofile) and also in the Dashboard.</li></ul><h2 id=motivation>Motivation</h2><p>The Kubernetes community releases <strong>minor</strong> versions roughly every three months and usually maintains <strong>three minor</strong> versions (the actual and the last two) with bug fixes and security updates. Patch releases are done more frequently. Operators of Gardener should be able to define their own Kubernetes version policy. This GEP suggests the possibility for operators to classify Kubernetes versions, while they are going through their &ldquo;maintenance life-cycle&rdquo;.</p><h2 id=kubernetes-version-classifications>Kubernetes Version Classifications</h2><p>An operator should be able to classify Kubernetes versions differently while they go through their &ldquo;maintenance life-cycle&rdquo;, starting with <strong>preview</strong>, <strong>supported</strong>, <strong>deprecated</strong>, and finally <strong>expired</strong>. This information should be programmatically available in the <code>cloudprofiles</code> of the Garden cluster as well as in the Dashboard. Please also note, that Gardener keeps the control plane and the workers on the same Kubernetes version.</p><p>For further explanation of the possible classifications, we assume that an operator wants to support four minor versions e.g. v1.16, v1.15, v1.14 and v1.13.</p><ul><li><p><strong>preview:</strong> After a fresh release of a new Kubernetes <strong>minor</strong> version (e.g. v1.17.0) the operator could tag it as <em>preview</em> until he has gained sufficient experience. It will not become the default in the Gardener Dashboard until he promotes that minor version to <em>supported</em>, which could happen a few weeks later with the first patch version.</p></li><li><p><strong>supported:</strong> The operator would tag the latest Kubernetes patch versions of the actual (if not still in <em>preview</em>) and the last three minor Kubernetes versions as <em>supported</em> (e.g. v1.16.1, v1.15.4, v1.14.9 and v1.13.12). The latest of these becomes the default in the Gardener Dashboard (e.g. v1.16.1).</p></li><li><p><strong>deprecated:</strong> The operator could decide, that he generally wants to classify every version that is not the latest patch version as <em>deprecated</em> and flag this versions accordingly (e.g. v1.16.0 and older, v1.15.3 and older, 1.14.8 and older as well as v1.13.11 and older). He could also tag all versions (latest or not) of every Kubernetes minor release that is neither the actual nor one of the last three minor Kubernetes versions as <em>deprecated</em>, too (e.g. v1.12.x and older). Deprecated versions will eventually expire (i.e., removed).</p></li><li><p><strong>expired:</strong> This state is a <em>logical</em> state only. It doesn&rsquo;t have to be maintained in the <code>cloudprofile</code>. All cluster versions whose <code>expirationDate</code> as defined in the <code>cloudprofile</code> is expired, are automatically in this <em>logical</em> state. After that date has passed, users cannot create new clusters with that version anymore and any cluster that is on that version will be forcefully migrated in its next maintenance time window, even if the owner has opted out of automatic cluster updates! The forceful update will pick the latest patch version of the current minor Kubernetes version. If the cluster was already on that latest patch version and the latest patch version is also expired, it will continue with latest patch version of the <strong>next minor Kubernetes version</strong>, so <strong>it will result in an update of a minor Kubernetes version, which is potentially harmful to your workload, so you should avoid that/plan ahead!</strong> If that&rsquo;s expired as well, the update process repeats until a non-expired Kubernetes version is reached, so <strong>depending on the circumstances described above, it can happen that the cluster receives multiple consecutive minor Kubernetes version updates!</strong></p></li></ul><p>To fulfill his specific versioning policy, the Garden operator should be able to classify his versions as well set the expiration date in the <code>cloudprofiles</code>. The user should see this classifiers as well as the expiration date in the dashboard.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-65e79b644bcfac2ee0ea485728885ad7>7.6 - 06 Etcd Drui</h1><h1 id=integrating-etcd-druid-with-gardener>Integrating etcd-druid with Gardener</h1><p>Etcd is currently deployed by garden-controller-manager as a Statefulset. The sidecar container spec contains details pertaining to cloud-provider object-store which is injected into the statefulset via a mutable webhook running as part of the gardener extension <a href=/docs/gardener/extensions/controlplane-webhooks/#what-needs-to-be-implemented-to-support-a-new-cloud-provider>story</a>. This approach restricts the operations on etcd such as scale-up and upgrade. Etcd-druid will eliminate the need to hijack statefulset creation to add cloudprovider details. It has been designed to provide an intricate control over the procedure of deploying and maintaining etcd. The roadmap for etcd-druid can be found <a href=https://github.com/gardener/etcd-druid/issues/2>here</a>.</p><p>This document explains how Gardener deploys etcd and what resources it creates for etcd-druid to deploy an etcd cluster.</p><h2 id=resources-required-by-etcd-druid-created-by-gardener>Resources required by etcd-druid (created by Gardener)</h2><ul><li>Secret containing credentials to access backup bucket in Cloud provider object store.</li><li>TLS server and client secrets for etcd and backup-sidecar</li><li>Etcd CRD resource that contains parameters pertaining to etcd, backup-sidecar and cloud-provider object store.</li></ul><p>When an etcd resource is created in the cluster, the druid acts on it by creating an etcd statefulset, a service and a configmap containing etcd bootstrap script. The secrets containing the infrastructure credentials and the TLS certificates are mounted as volumes. If no secret/information regarding backups is stated then etcd data backups are not taken. Only data corruption checks are performed prior to starting etcd.</p><p>Garden-controller-manager, being cloud agnostic, deploys the etcd resource. This will not contain any cloud-specific information other than the cloud-provider. The extension controller that contains the cloud specific implementation to create the backup bucket will create it if needed and create a secret containing the credentials to access the bucket. The etcd backup secret name should be exposed in the BackupEntry status. Then, Gardener can read it and write it into the ETCD resource. The secret will have to be made available in the namespace the etcd statefulset will be deployed. If etcd and backup-sidecar communicates over TLS then the CA certificates, server and client certificates, and keys will also have to be made available in the namespace as well. The etcd resource will have reference to these aforementioned secrets. etcd-druid will deploy the statefulset only if the secrets are available.</p><h2 id=workflow>Workflow</h2><ul><li>etcd-druid will be deployed and etcd CRD will be created as part of the seed bootstrap.</li><li>Garden-controller-manager creates backupBucket extension resource. Extension controller creates the backup bucket associated with the seed.</li><li>Garden-controller-manager creates backupentry associated with each shoot in the seed namespace.</li><li>Garden-controller-manager creates etcd resource with secretRefs and etcd information populated appropriately.</li><li>etcd-druid acts on the etcd resource; druid creates the statefulset, the service and the configmap.</li></ul><p><img src=/__resources/druid_integration_539d05.png alt=etcd-druid></p></div><div class=td-content style=page-break-before:always><h1 id=pg-8da6d960cda1d76486946f507800f02b>7.7 - 07 Shoot Control Plane Migration</h1><h1 id=shoot-control-plane-migration>Shoot Control Plane Migration</h1><h2 id=motivation>Motivation</h2><p>Currently moving the control plane of a shoot cluster can only be done manually and requires deep knowledge of how exactly to transfer the resources and state from one seed to another. This can make it slow and prone to errors.</p><p>Automatic migration can be very useful in a couple of scenarios:</p><ul><li>Seed goes down and can&rsquo;t be repaired (fast enough or at all) and it&rsquo;s control planes need to be brought to another seed</li><li>Seed needs to be changed, but this operation requires the recreation of the seed (e.g. turn a single-AZ seed into a multi-AZ seed)</li><li>Seeds need to be rebalanced</li><li>New seeds become available in a region closer to/in the region of the workers and the control plane should be moved there to improve latency</li><li>Gardener ring, which is a self-supporting setup/underlay for a highly available (usually cross-region) Gardener deployment</li></ul><h2 id=goals>Goals</h2><ul><li>Provide a mechanism to migrate the control plane of a shoot cluster from one seed to another</li><li>The mechanism should support migration from a seed which is no longer reachable (Disaster Recovery)</li><li>The shoot cluster nodes are preserved and continue to run the workload, but will talk to the new control plane after the migration completes</li><li>Extension controllers implement a mechanism which allows them to store their state or to be restored from an already existing state on a different seed cluster.</li><li>The already existing shoot reconciliation flow is reused for migration with minimum changes</li></ul><h2 id=terminology>Terminology</h2><p><strong>Source Seed</strong> is the seed which currently hosts the control plane of a Shoot Cluster</p><p><strong>Destination Seed</strong> is the seed to which the control plane is being migrated</p><h2 id=resources-and-controller-state-which-have-to-be-migrated-between-two-seeds>Resources and controller state which have to be migrated between two seeds:</h2><p><strong>Note:</strong> The following lists are just FYI and are meant to show the current resources which need to be moved to the <strong>Destination Seed</strong></p><h3 id=secrets>Secrets</h3><p>Gardener has preconfigured lists of needed secrets which are generated when a shoot is created and deployed in the seed. Following is a minimum set of secrets which must be migrated to the <strong>Destination Seed</strong>. Other secrets can be regenerated from them.</p><ul><li>ca</li><li>ca-front-proxy</li><li>static-token</li><li>ca-kubelet</li><li>ca-metrics-server</li><li>etcd-encryption-secret</li><li>kube-aggregator</li><li>kube-apiserver-basic-auth</li><li>kube-apiserver</li><li>service-account-key</li><li>ssh-keypair</li></ul><h3 id=custom-resources-and-state-of-extension-controllers>Custom Resources and state of extension controllers</h3><p>Gardenlet deploys custom resources in the <strong>Source Seed</strong> cluster during shoot reconciliation which are reconciled by extension controllers. The state of these controllers and any additional resources they create is independent of the gardenlet and must also be migrated to the <strong>Destination Seed</strong>. Following is a list of custom resources, and the state which is generated by them that has to be migrated.</p><ul><li><strong>BackupBucket</strong>: nothing relevant for migration</li><li><strong>BackupEntry</strong>: nothing relevant for migration</li><li><strong>ControlPlane</strong>: nothing relevant for migration</li><li><strong>DNSProvider</strong>/DNSEntry: nothing relevant for migration</li><li><strong>Extensions</strong>: migration of state needs to be handled individually</li><li><strong>Infrastructure</strong>: terraform state</li><li><strong>Network</strong>: nothing relevant for migration</li><li><strong>OperatingSystemConfig</strong>: nothing relevant for migration</li><li><strong>Worker</strong>: Machine-Controller-Manager related objects: machineclasses, machinedeployments, machinesets, machines</li></ul><p>This list depends on the currently installed extensions and can change in the future</p><h2 id=proposal>Proposal</h2><h3 id=custom-resource-on-the-garden-cluster>Custom Resource on the garden cluster</h3><p>The Garden cluster has a new Custom Resource which is stored in the project namespace of the Shoot called <code>ShootState</code>. It contains all the required data described above so that the control plane can be recreated on the <strong>Destination Seed</strong>.</p><p>This data is separated into two sections. The first is generated by the gardenlet and then either used to generate new resources (e.g secrets) or is directly deployed to the Shoot&rsquo;s control plane on the <strong>Destination Seed</strong>.</p><p>The second is generated by the extension controllers in the seed.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1alpha1
kind: ShootState
metadata:
  name: my-shoot
  namespace: garden-core
  ownerReference:
    apiVersion: core.gardener.cloud/v1beta1
    blockOwnerDeletion: <span style=color:#00f>true</span>
    controller: <span style=color:#00f>true</span>
    kind: Shoot
    name: my-shoot
    uid: ...
  finalizers:
  - gardener
gardenlet:
  secrets:
  - name: ca
    data:
      ca.crt: ...
      ca.key: ...
  - name: ssh-keypair
    data:
      id_rsa: ...
  - name:
...
extensions:
- kind: Infrastructure
  state: ... (Terraform state)
- kind: ControlPlane
  purpose: normal
  state: ... (Certificates generated by the extension)
- kind: Worker
  state: ... (Machine objects)
</code></pre></div><p>The state data is saved as a <code>runtime.RawExtension</code> type, which can be encoded/decoded by the corresponding extension controller.</p><p>There can be sensitive data in the <code>ShootState</code> which has to be hidden from the end-users. Hence, it will be recommended to provide an etcd encryption configuration to the Gardener API server in order to encrypt the <code>ShootState</code> resource.</p><h4 id=size-limitations>Size limitations</h4><p>There are limits on the size of the request bodies sent to the kubernetes API server when creating or updating resources: by default ETCD can only accept request bodies which do not exceed 1.5 MiB (this can be configured with the <code>--max-request-bytes</code> flag); the kubernetes API Server has a request body limit of 3 MiB which cannot be set from the outside (with a command line flag); the gRPC configuration used by the API server to talk to ETCD has a limit of 2 MiB per request body which cannot be configured from the outside; and <code>watch</code> requests have a 16 MiB limit on the buffer used to stream resources.</p><p>This means that if <code>ShootState</code> is bigger than 1.5 MiB, the ETCD max request bytes will have to be increased. However, there is still an upper limit of 2 MiB imposed by the gRPC configuration.</p><p>If <code>ShootState</code> exceeds this size limitation it must make use of configmap/secret references to store the state of extension controllers. This is an implementation detail of Gardener and can be done at a later time if necessary as extensions will not be affected.</p><p>Splitting the <code>ShootState</code> into multiple resources could have a positive benefit on performance as the Gardener API Server and Gardener Controller Manager would handle multiple small resources instead of one big resource.</p><h3 id=gardener-extensions-changes>Gardener extensions changes</h3><p>All extension controllers which require state migration must save their state in a new <code>status.state</code> field and act on an annotation <code>gardener.cloud/operation=restore</code> in the respective Custom Resources which should trigger a restoration operation instead of reconciliation. A restoration operation means that the extension has to restore its state in the Shoot&rsquo;s namespace on the <strong>Destination Seed</strong> from the <code>status.state</code> field.</p><p>As an example: the <code>Infrastructure</code> resource must save the terraform state.</p><pre><code>apiVersion: extensions.gardener.cloud/v1alpha1
kind: Infrastructure
metadata:
  name: infrastructure
  namespace: shoot--foo--bar
spec:
  type: azure
  region: eu-west-1
  secretRef:
    name: cloudprovider
    namespace: shoot--foo--bar
  providerConfig:
    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
    kind: InfrastructureConfig
    resourceGroup:
      name: mygroup
    networks:
      vnet: # specify either 'name' or 'cidr'
      # name: my-vnet
        cidr: 10.250.0.0/16
      workers: 10.250.0.0/19
status:
  state: |
      {
          &quot;version&quot;: 3,
          &quot;terraform_version&quot;: &quot;0.11.14&quot;,
          &quot;serial&quot;: 2,
          &quot;lineage&quot;: &quot;3a1e2faa-e7b6-f5f0-5043-368dd8ea6c10&quot;,
          &quot;modules&quot;: [
              {
              }
          ]
          ...
      }
</code></pre><p>Extensions which do not require state migration should set <code>status.state=nil</code> in their Custom Resources and trigger a normal reconciliation operation if the CR contains the <code>core.gardener.cloud/operation=restore</code> annotation.</p><p>Similar to the contract for the <a href=/docs/gardener/extensions/reconcile-trigger/>reconcile operation</a>, the extension controller has to remove the <code>restore</code> annotation after the restoration operation has finished.</p><p>An additional annotation <code>gardener.cloud/operation=migrate</code> is added to the Custom Resources. It is used to tell the extension controllers in the <strong>Source Seed</strong> that they must stop reconciling resources (in case they are requeued due to errors) and should perform cleanup activities in the Shoot&rsquo;s control plane. These cleanup activities involve removing the finalizers on Custom Resources and deleting them without actually deleting any infrastructure resources.</p><p><strong>Note:</strong> The same size limitations from the previous section are relevant here as well.</p><h3 id=shoot-reconciliation-flow-changes>Shoot reconciliation flow changes</h3><p>The only data which must be stored in the <code>ShootState</code> by the gardenlet is secrets (e.g ca for the API server). Therefore the <code>botanist.DeploySecrets</code> step is changed. It is split into two functions which take a list of secrets that have to be generated.</p><ul><li><code>botanist.GenerateSecretState</code> Generates certificate authorities and other secrets which have to be persisted in the ShootState and must not be regenerated on the <strong>Destination Seed</strong>.</li><li><code>botanist.DeploySecrets</code> Takes secret data from the <code>ShootState</code>, generates new ones (e.g. client tls certificates from the saved certificate authorities) and deploys everything in the Shoot&rsquo;s control plane on the <strong>Destination Seed</strong></li></ul><h3 id=shootstate-synchronization-controller>ShootState synchronization controller</h3><p>The ShootState synchronization controller will become part of the gardenlet. It syncs the state of extension custom resources from the shoot namespace to the garden cluster and updates the corresponding <code>spec.extension.state</code> field in the <code>ShootState</code> resource. The controller can <code>watch</code> Custom Resources used by the extensions and update the <code>ShootState</code> only when changes occur.</p><h3 id=migration-workflow>Migration workflow</h3><ol><li>Starting migration<ul><li>Migration can only be started after a Shoot cluster has been successfully created so that the <code>status.seed</code> field in the <code>Shoot</code> resource has been set</li><li>The <code>Shoot</code> resource&rsquo;s field <code>spec.seedName="new-seed"</code> is edited to hold the name of the <strong>Destination Seed</strong> and reconciliation is automatically triggered</li><li>The Garden Controller Manager checks if the equality between <code>spec.seedName</code> and <code>status.seed</code>, detects that they are different and triggers migration.</li></ul></li><li>The Garden Controller Manager waits for the <strong>Destination Seed</strong> to be ready</li><li>Shoot&rsquo;s API server is stopped</li><li>Backup the Shoot&rsquo;s ETCD.</li><li>Extension resources in the <strong>Source Seed</strong> are annotated with <code>gardener.cloud/operation=migrate</code></li><li>Scale Down the Shoot&rsquo;s control plane in the <strong>Source Seed</strong>.</li><li>The gardenlet in the <strong>Destination Seed</strong> fetches the state of extension resources from the <code>ShootState</code> resource in the garden cluster.</li><li>Normal reconciliation flow is resumed in the <strong>Destination Seed</strong>. Extension resources are annotated with <code>gardener.cloud/operation=restore</code> to instruct the extension controllers to reconstruct their state.</li><li>The Shoot&rsquo;s namespace in <strong>Source Seed</strong> is deleted.</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-537ccca03886037e9fbdfd4d0c15d1a0>7.8 - 08 Shoot Apiserver Via Sni</h1><h1 id=sni-passthrough-proxy-for-kube-apiservers>SNI Passthrough proxy for kube-apiservers</h1><p>This GEP tackles the problem that today a single <code>LoadBalancer</code> is needed for every single Shoot cluster&rsquo;s control plane.</p><h2 id=background>Background</h2><p>When the control plane of a Shoot cluster is provisioned, a dedicated LoadBalancer is created for it. It keeps the entire flow quite easy - the apiserver Pods are running and they are accessible via that LoadBalancer. It&rsquo;s hostnames / IP addresses are used for DNS records like <code>api.&lt;external-domain></code> and <code>api.&lt;shoot>.&lt;project>.&lt;internal-domain></code>. While this solution is simple it comes with several issues.</p><h2 id=motivation>Motivation</h2><p>There are several problems with the current setup.</p><ul><li>IaaS provider costs. For example <code>ClassicLoadBalancer</code> on AWS costs at minimum 17 USD / month.</li><li>Quotas can limit the amount of LoadBalancers you can get per account / project, limiting the number of clusters you can host under a single account.</li><li>Lack of support for better loadbalancing <a href=https://www.envoyproxy.io/docs/envoy/v1.10.0/intro/arch_overview/load_balancing/load_balancers#supported-load-balancers>algorithms than round-robin</a>.</li><li>Slow cluster provisioning time - depending on the provider a LoadBalancer provisioning could take quite a while.</li><li>Lower downtime when workload is shuffled in the clusters as the LoadBalancer is Kubernetes-aware.</li></ul><h2 id=goals>Goals</h2><ul><li>Only one LoadBalancer is used for all Shoot cluster API servers running in a Seed cluster.</li><li>Out-of-cluster (end-user / robot) communication to the API server is still possible.</li><li>In-cluster communication via the kubernetes master service (IPv4/v6 ClusterIP and the <code>kubernetes.default.svc.cluster.local</code>) is possible.</li><li>Client TLS authentication works without intermediate TLS termination (TLS is terminated by <code>kube-apiserver</code>).</li><li>Solution should be cloud-agnostic.</li></ul><h2 id=proposal>Proposal</h2><h3 id=seed-cluster>Seed cluster</h3><p>To solve the problem of having multiple <code>kube-apiservers</code> behind a single LoadBalancer, an intermediate proxy must be placed between the Cloud-Provider&rsquo;s LoadBalancer and <code>kube-apiservers</code>. This proxy is going to choose the Shoot API Server with the help of Server Name Indication. From <a href=https://en.wikipedia.org/wiki/Server_Name_Indication>wikipedia</a>:</p><blockquote><p>Server Name Indication (SNI) is an extension to the Transport Layer Security (TLS) computer networking protocol by which a client indicates which hostname it is attempting to connect to at the start of the handshaking process. This allows a server to present multiple certificates on the same IP address and TCP port number and hence allows multiple secure (HTTPS) websites (or any other service over TLS) to be served by the same IP address without requiring all those sites to use the same certificate. It is the conceptual equivalent to HTTP/1.1 name-based virtual hosting, but for HTTPS.</p></blockquote><p>A rough diagram of the flow of data:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>+-------------------------------+
|                               |
|           Network LB          | (accessible from clients)
|                               |
|                               |
+-------------+-------+---------+                       +------------------+
              |       |                                 |                  |
              |       |            proxy + lb           | Shoot API Server |
              |       |    +-------------+-------------&gt;+                  |
              |       |    |                            | Cluster A        |
              |       |    |                            |                  |
              |       |    |                            +------------------+
              |       |    |
     +----------------v----+--+
     |        |               |
   +-+--------v----------+    |                         +------------------+
   |                     |    |                         |                  |
   |                     |    |       proxy + lb        | Shoot API Server |
   |        Proxy        |    +-------------+----------&gt;+                  |
   |                     |    |                         | Cluster B        |
   |                     |    |                         |                  |
   |                     +----+                         +------------------+
   +----------------+----+
                    |
                    |
                    |                                   +------------------+
                    |                                   |                  |
                    |             proxy + lb            | Shoot API Server |
                    +-------------------+--------------&gt;+                  |
                                                        | Cluster C        |
                                                        |                  |
                                                        +------------------+
</code></pre></div><p>Sequentially:</p><ol><li>client requests <code>Shoot Cluster A</code> and sets the <code>Server Name</code> in the TLS handshake to <code>api.shoot-a.foo.bar</code>.</li><li>this packet goes through the Network LB and it&rsquo;s forwarded to the Proxy server. (this loadbalancer should be a simple Layer-4 TCP proxy)</li><li>the proxy server reads the packet and see that client requests <code>api.shoot-a.foo.bar</code>.</li><li>based on its configuration, it maps <code>api.shoot-a.foo.bar</code> to <code>Shoot API Server Cluster A</code>.</li><li>it acts as TCP proxy and simply send the data <code>Shoot API Server Cluster A</code>.</li></ol><p>There are multiple OSS proxies for this case:</p><ul><li>nginx</li><li>HAProxy</li><li>Envoy</li><li>traefik</li><li><a href=https://github.com/linkerd/linkerd2-proxy>linkerd2-proxy</a></li></ul><p>To ease integration it should:</p><ul><li>be configurable via Kubernetes resources</li><li>not require restarting when configuration changes</li><li>be fast and with little overhead</li></ul><p>All things considered, <a href=http://envoyproxy.io/>Envoy proxy</a> is the most fitting solution as it provides all the features Gardener would like (no process reload being the most important one + battle tested in production by various companies).</p><p>While building a custom control plane for Envoy is <a href=https://github.com/envoyproxy/go-control-plane>quite simple</a>, an already established solution might be the better path forward. <a href=https://istio.io/docs/concepts/traffic-management/#pilot-and-envoy>Istio&rsquo;s Pilot</a> is one of the most feature-complete Envoy control plane solutions as it offers a way to configure edge ingress traffic for Envoy via <a href=https://istio.io/docs/reference/config/networking/v1alpha3/gateway/>Gateway</a> and <a href=https://istio.io/docs/reference/config/networking/v1alpha3/virtual-service/>VirtualService</a>.</p><p>The resources which needs to be created per Shoot clusters are the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: kube-apiserver-gateway
  namespace: &lt;shoot-namespace&gt;
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 443
      name: tls
      protocol: TLS
    tls:
      mode: PASSTHROUGH
    hosts:
    - api.&lt;external-domain&gt;
    - api.&lt;shoot&gt;.&lt;project&gt;.&lt;internal-domain&gt;
</code></pre></div><p>and correct <code>VirtualService</code> pointing to the correct API server:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: kube-apiserver
  namespace: &lt;shoot-namespace&gt;
spec:
  hosts:
  - api.&lt;external-domain&gt;
  - api.&lt;shoot&gt;.&lt;project&gt;.&lt;internal-domain&gt;
  gateways:
  - kube-apiserver-gateway
  tls:
  - match:
    - port: 443
      sniHosts:
      - api.&lt;external-domain&gt;
      - api.&lt;shoot&gt;.&lt;project&gt;.&lt;internal-domain&gt;
    route:
    - destination:
        host: kube-apiserver.&lt;shoot-namespace&gt;.svc.cluster.local
        port:
          number: 443
</code></pre></div><p>The resources above configures Envoy to forward the raw TLS data (without termination) to the Shoot <code>kube-apiserver</code>.</p><p>Updated diagram:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>+-------------------------------+
|                               |
|           Network LB          | (accessible from clients)
|                               |
|                               |
+-------------+-------+---------+                       +------------------+
              |       |                                 |                  |
              |       |            proxy + lb           | Shoot API Server |
              |       |    +-------------+-------------&gt;+                  |
              |       |    |                            | Cluster A        |
              |       |    |                            |                  |
              |       |    |                            +------------------+
              |       |    |
     +----------------v----+--+
     |        |               |
   +-+--------v----------+    |                         +------------------+
   |                     |    |                         |                  |
   |                     |    |       proxy + lb        | Shoot API Server |
   |    Envoy Proxy      |    +-------------+----------&gt;+                  |
   | (ingress Gateway)   |    |                         | Cluster B        |
   |                     |    |                         |                  |
   |                     +----+                         +------------------+
   +-----+----------+----+
         |          |
         |          |
         |          |                                   +------------------+
         |          |                                   |                  |
         |          |             proxy + lb            | Shoot API Server |
         |          +-------------------+--------------&gt;+                  |
         |   get                                        | Cluster C        |
         | configuration                                |                  |
         |                                              +------------------+
         |
         v                                                  Configure
      +--+--------------+         +---------------------+   via Istio
      |                 |         |                     |   Custom Resources
      |     Pilot       +--------&gt;+   Seed API Server   +&lt;------------------+
      |                 |         |                     |
      |                 |         |                     |
      +-----------------+         +---------------------+
</code></pre></div><p>In this case the <code>internal</code> and <code>external</code> <code>DNSEntries</code> should be changed to the Network LoadBalancer&rsquo;s IP.</p><h3 id=in-cluster-communication-to-the-apiserver>In-cluster communication to the apiserver</h3><p>In Kubernetes the API server is discoverable via the master service (<code>kubernetes</code> in <code>default</code> namespace). Today, this service can only be of type <code>ClusterIP</code> - making in-cluster communication to the API server impossible due to:</p><ul><li>the client doesn&rsquo;t set the <code>Server Name</code> in the TLS handshake, if it attempts to talk to an IP address. In this case, the TLS handshake reaches the Envoy IngressGateway proxy, but it&rsquo;s rejected by it.</li><li>Kubernetes services can be of type <code>ExternalName</code>, but the master service is not supported by <a href=https://github.com/gardener/gardener/issues/1135#issuecomment-505317932>kubelet</a>.<ul><li>even if this is fixed in future Kubernetes versions, this problem still exists for older versions where this functionality is not available.</li></ul></li></ul><p>Another issue occurs when the client tries to talk to the apiserver via the in-cluster DNS. For all Shoot API servers <code>kubernetes.default.svc.cluster.local</code> is the same and when a client tries to connect to that API server using that server name. This makes distinction between different in-cluster Shoot clients impossible by the Envoy IngressGateway.</p><p>To mitigate this problem an additional proxy must be deployed on every single Node. It does not terminate TLS and sends the traffic to the correct Shoot API Server. This is achieved by:</p><ul><li>the apiserver master service reconciler is started and pointing to the <code>kube-apiserver</code>&rsquo;s Cluster IP in the Seed cluster (e.g. <code>--advertise-address=10.1.2.3</code>).</li><li>the proxy runs in the host network of the <code>Node</code>.</li><li>the proxy has a sidecar container which:<ul><li>creates a dummy network interface and assigns the <code>10.1.2.3</code> to it.</li><li>removes connection tracking (conntrack) if iptables/nftables is enabled as the IP address is local to the <code>Node</code>.</li></ul></li><li>the proxy listens on the <code>10.1.2.3</code> and using the <a href=http://www.haproxy.org/download/2.0/doc/proxy-protocol.txt>PROXY protocol</a> it sends the data stream to the Envoy ingress gateway (EIGW).</li><li>EIGW listens for PROXY protocol on a dedicated <code>8443</code> port. EIGW reads the destination IP + port from the PROXY protocol and forwards traffic to the correct upstream apiserver.</li></ul><p>The sidecar is a standalone component. It&rsquo;s possible to transparently change the proxy implementation without any modifications to the sidecar. The simplified flow looks like:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>+------------------+                    +----------------+
| Shoot API Server |       TCP          |   Envoy IGW    |
|                  +&lt;-------------------+ PROXY listener |
| Cluster A        |                    |     :8443      |
+------------------+                    +-+--------------+
                                          ^
                                          |
                                          |
                                          |
                                          |
+-----------------------------------------------------------+
                                          |   Single Node in
                                          |   the Shoot cluster
                                          |
                                          | PROXY Protocol
                                          |
                                          |
                                          |
 +---------------------+       +----------+----------+
 |  Pod talking to     |       |                     |
 |  the kubernetes     |       |       Proxy         |
 |  service            +------&gt;+  No TLS termination |
 |                     |       |                     |
 +---------------------+       +---------------------+
</code></pre></div><p>Multiple OSS solutions can be used:</p><ul><li>haproxy</li><li>nginx</li></ul><p>To add a PROXY lister with Istio several resources must be created - a dedicated <code>Gateway</code>, dummy <code>VirtualService</code> and <code>EnvoyFilter</code> which adds listener filter (<code>envoy.listener.proxy_protocol</code>) on <code>8443</code> port:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: blackhole
  namespace: istio-system
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 8443
      name: tcp
      protocol: TCP
    hosts:
    - <span style=color:#a31515>&#34;*&#34;</span>

---

apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: blackhole
  namespace: istio-system
spec:
  hosts:
  - blackhole.local
  gateways:
  - blackhole
  tcp:
  - match:
    - port: 8443
    route:
    - destination:
        host: localhost
        port:
          number: 9999 <span style=color:green># any dummy port will work</span>

---

apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: proxy-protocol
  namespace: istio-system
spec:
  workloadSelector:
    labels:
      istio: ingressgateway
  configPatches:
  - applyTo: LISTENER
    match:
      context: ANY
      listener:
        portNumber: 8443
        name: 0.0.0.0_8443
    patch:
      operation: MERGE
      value:
        listener_filters:
        - name: envoy.filters.listener.proxy_protocol
</code></pre></div><p>For each individual <code>Shoot</code> cluster, a dedicated <a href=https://www.envoyproxy.io/docs/envoy/v1.13.0/api-v2/api/v2/listener/listener_components.proto#listener-filterchainmatch>FilterChainMatch</a> is added. It ensures that only Shoot API servers can receive traffic from this listener:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: &lt;shoot-namespace&gt;
  namespace: istio-system
spec:
  workloadSelector:
    labels:
      istio: ingressgateway
  configPatches:
  - applyTo: FILTER_CHAIN
    match:
      context: ANY
      listener:
        portNumber: 8443
        name: 0.0.0.0_8443
    patch:
      operation: ADD
      value:
        filters:
        - name: envoy.filters.network.tcp_proxy
          typed_config:
            &#34;@type&#34;: type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
            stat_prefix: outbound|443||kube-apiserver.&lt;shoot-namespace&gt;.svc.cluster.local
            cluster: outbound|443||kube-apiserver.&lt;shoot-namespace&gt;.svc.cluster.local
        filter_chain_match:
          destination_port: 443
          prefix_ranges:
          - address_prefix: 10.1.2.3 <span style=color:green># kube-apiserver&#39;s cluster-ip</span>
            prefix_len: 32
</code></pre></div><blockquote><p>Note: this additional <code>EnvoyFilter</code> can be removed when Istio supports full <a href=https://istio.io/docs/reference/config/networking/virtual-service/#L4MatchAttributes>L4 matching</a>.</p></blockquote><p>A nginx proxy client in the Shoot cluster on every node could have the following configuration:</p><pre><code class=language-conf data-lang=conf>error_log /dev/stdout;
stream {
    server {
        listen 10.1.2.3:443;
        proxy_pass api.&lt;external-domain&gt;:8443;
        proxy_protocol on;

        proxy_protocol_timeout 5s;
        resolver_timeout 5s;
        proxy_connect_timeout 5s;
    }
}

events { }
</code></pre><h3 id=in-cluster-communication-to-the-apiserver-when-exernalname-is-supported>In-cluster communication to the apiserver when ExernalName is supported</h3><p>Even if in future versions of Kubernetes, the master service of type <code>ExternalName</code> is supported, we still have the problem that in-cluster workload can talk to the server via DNS. For this to work we still need the above mentioned proxy (this time listening on another IP address <code>10.0.0.2</code>). An additional change to CoreDNS would be needed:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>default.svc.cluster.local.:8053 {
    file kubernetes.default.svc.cluster.local
}

.:8053 {
    errors
    health
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        upstream
        fallthrough in-addr.arpa ip6.arpa
    }
    prometheus :9153
    forward . /etc/resolv.conf
    cache 30
    loop
    reload
    loadbalance
}
</code></pre></div><p>The content of the <code>kubernetes.default.svc.cluster.local</code> is going to be:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ORIGIN default.svc.cluster.local.

@	30 IN	SOA local. local. (
        2017042745 ; serial
        1209600    ; refresh (2 hours)
        1209600    ; retry (1 hour)
        1209600    ; expire (2 weeks)
        30         ; minimum (1 hour)
        )

  30 IN NS local.

kubernetes     IN A     10.0.0.2
</code></pre></div><p>So when a client requests <code>kubernetes.default.svc.cluster.local</code>, it&rsquo;ll be send to the proxy listening on that IP address.</p><h2 id=future-work>Future work</h2><p>While out of scope of this GEP, several things can be improved:</p><ul><li>Make the sidecar work with eBPF and environments where iptables/nftables are not enabled.</li></ul><h2 id=references>References</h2><ul><li><a href=https://github.com/gardener/gardener/issues/1135>https://github.com/gardener/gardener/issues/1135</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7581ec6f70a5cf65db6f716b423048e5>7.9 - 09 Test Framework</h1><h1 id=gardener-integration-test-framework>Gardener integration test framework</h1><h2 id=motivation>Motivation</h2><p>As we want to improve our code coverage in the next months we will need a simple and easy to use test framework.
The current testframework already contains a lot of general test functions that ease the work for writing new tests.
However there are multiple disadvantages with the current structure of the tests and the testframework:</p><ol><li>Every new test is an own testsuite and therefore needs its own <code>TestDef</code> (<a href=https://github.com/gardener/gardener/tree/master/.test-defs>https://github.com/gardener/gardener/tree/master/.test-defs</a>). With this approach there will be hundreds of test definitions, growing with every new test (or at least new test suite).
But in most cases new tests do not need their own special <code>TestDef</code>: it&rsquo;s just the wrong scope for the testmachinery and will result in unnecessary complex testruns and configurations. In addition it would result in additional maintenance for a huge number of <code>TestDefs</code>.</li><li>The testsuites currently have their own specific interface/configuration that they need in order to be executed correctly (see <a href=https://github.com/gardener/gardener/blob/master/.test-defs/ShootKubernetesUpdateTest.yaml#L14>K8s Update test</a>).
Consequently the configuration has to be defined in the testruns which result in one step per test with their very own configuration which means that the testmachinery cannot simply select testdefinitions by label.
As the testmachinery cannot make use of its ability to run labeled tests (e.g. run all tests labeled <code>default</code>), the testflow size increases with every new tests and the testruns have to be manually adjusted with every new test.</li><li>The current gardener test framework contains multiple test operations where some are just used for specific tests (e.g. <code>plant_operations</code>) and some are more general (<code>garden_operation</code>). Also the functions offered by the operations vary in their specialization as some are really specific to just one test e.g. shoot test operation with <code>WaitUntilGuestbookAppIsAvailable</code> whereas others are more general like <code>WaitUntilPodIsRunning</code>.<br>This structure makes it hard for developers to find commonly used functions and also hard to integrate as the common framework grows with specialized functions.</li></ol><h2 id=goals>Goals</h2><p>In order to clean the testframework, make it easier for new developers to write tests and easier to add and maintain test execution within the testmachinery, the following goals are defined:</p><ul><li>Have a small number of test suites (gardener, shoots see <a href=#test_flavors>test flavors</a>) to only maintain a fixed number of testdefinitions.</li><li>Use ginkgo test labels (inspired by the k8s e2e tests) to differentiate test behavior, test execution and test importance.</li><li>Use standardized configuration for all tests (differ depending on the test suite) but provide better tooling to dynamically read additional configuration from configuration files like the <code>cloudprofile</code>.</li><li>Clean the testframework to only contain general functionality and keep specific functions inside the tests</li></ul><h2 id=proposal>Proposal</h2><p>The proposed new test framework consists of the following changes to tackle the above described goals.
​</p><h4 id=test-flavors>Test Flavors</h4><p>Reducing the number of test definitions is done by ​combining the current specified test suites into the following 3 general ones:</p><ul><li><em>System test suite</em><ul><li>e.g. create-shoot, delete-shoot, hibernate</li><li>need their own testdef because they have a special meaning in the context of the testmachinery</li></ul></li><li><em>Gardener test suite</em><ul><li>e.g. RBAC, scheduler</li><li>All tests that only need a gardener installation but no shoot cluster</li><li>Possible functions/environment:<ul><li>New project for test suite (copy secret binding, cleanup)?</li></ul></li></ul></li><li><em>Shoot test suite</em><ul><li>e.g. shoot app, network</li><li>Test that require a running shoot</li><li>Possible functions:<ul><li>Namespace per test</li><li>cleanup of ns</li></ul></li></ul></li></ul><p>As inspired by the k8s e2e tests, test labels are used to differentiate the tests by their behavior, their execution and their importance.
Test labels means that tests are described using predefined labels in the test&rsquo;s text (e.g <code>ginkgo.It("[BETA] this is a test")</code>).
With this labeling strategy, it is also possible to see the test properties directly in the code and promoting a test can be done via a pullrequest and will then be automatically recognized by the testmachinery with the next release.</p><p>Using ginkgo focus to only run desired tests and combined testsuites, an example test definition will look like the following.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>kind: TestDefinition
metadata:
  name: gardener-beta-suite
spec:
  description: Test suite that runs all gardener tests that are labeled as beta
  activeDeadlineSeconds: 7200
  labels: [<span style=color:#a31515>&#34;gardener&#34;</span>, <span style=color:#a31515>&#34;beta&#34;</span>]
​
  command: [bash, -c]
  args:
  - &gt;-<span style=color:#a31515>
</span><span style=color:#a31515>    go test -timeout=0 -mod=vendor ./test/integration/suite
</span><span style=color:#a31515>    --v -ginkgo.v -ginkgo.progress -ginkgo.no-color
</span><span style=color:#a31515>    -ginkgo.focus=&#34;[GARDENER] [BETA]&#34;</span>    
</code></pre></div><p>Using this approach, the overall number of testsuites is then reduced to a fixed number (excluding the system steps) of <code>test suites * labelCombinations</code>.</p><h4 id=framework>Framework</h4><p>The new framework will consist of a common framework, a gardener framework (integrating the commom framework) and a shoot framework (integrating the gardener framework).</p><p>All of these frameworks will have their own configuration that is exposed via commandline flags so that for example the shoot test framework can be executed by <code>go test -timeout=0 -mod=vendor ./test/integration/suite --v -ginkgo.v -ginkgo.focus="[SHOOT]" --kubecfg=/path/to/config --shoot-name=xx</code>.</p><p>The available test labels should be declared in the code with predefined values and in a predefined order so that everyone is aware about possible labels and the tests are labeled similarly across all integration tests. This approach is somehow similar to what kubernetes is doing in their e2e test suite but with some more restrictions (compare <a href=https://github.com/kubernetes/kubernetes/blob/master/test/e2e/apps/deployment.go#L84>example k8s e2e test</a>).<br>A possible solution to have consistent labeling would be to define them with every new <code>ginkgo.It</code> definition: <code>f.Beta().Flaky().It("my test")</code> which internally orders them and would produce a ginkgo test with the text : <code>[BETA] [FLAKY] my test</code>.</p><p><strong>General Functions</strong>
The test framework should include some general functions that can and will be reused by every test.
These general functions may include:
​</p><ul><li>Logging</li><li>State Dump</li><li>Detailed test output (status, duration, etc..)</li><li>Cleanup handling per test (<code>It</code>)</li><li>General easy to use functions like <code>WaitUntilDeploymentCompleted</code>, <code>GetLogs</code>, <code>ExecCommand</code>, <code>AvailableCloudprofiles</code>, etc..
​</li></ul><h4 id=example>Example</h4><p>A possible test with the new test framework would look like:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>var</span> _ = ginkgo.Describe(<span style=color:#a31515>&#34;Shoot network testing&#34;</span>, <span style=color:#00f>func</span>() {
  <span style=color:green>// the testframework registers some cleanup handling for a state dump on failure and maybe cleanup of created namespaces
</span><span style=color:green></span>  f := framework.NewShootFramework()
  f.CAfterEach(<span style=color:#00f>func</span>(ctx context.Context) {
    ginkgo.By(<span style=color:#a31515>&#34;cleanup network test daemonset&#34;</span>)
    err := f.ShootClient.Client().Delete(ctx, &amp;appsv1.DaemonSet{ObjectMeta: metav1.ObjectMeta{Name: name, Namespace: namespace}})
    <span style=color:#00f>if</span> err != <span style=color:#00f>nil</span> {
      <span style=color:#00f>if</span> !apierrors.IsNotFound(err) {
        Expect(err).To(HaveOccurred())
      }
    }
  }, FinalizationTimeout)
  f.Release().Default().CIt(<span style=color:#a31515>&#34;should reach all webservers on all nodes&#34;</span>, <span style=color:#00f>func</span>(ctx context.Context) {
    ginkgo.By(<span style=color:#a31515>&#34;Deploy the net test daemon set&#34;</span>)
    templateFilepath := filepath.Join(f.ResourcesDir, <span style=color:#a31515>&#34;templates&#34;</span>, nginxTemplateName)
    err := f.RenderAndDeployTemplate(f.Namespace(), tempalteFilepath)
    Expect(err).ToNot(HaveOccurred())
    err = f.WaitUntilDaemonSetIsRunning(ctx, f.ShootClient.Client(), name, namespace)
    Expect(err).NotTo(HaveOccurred())
    pods := &amp;corev1.PodList{}
    err = f.ShootClient.Client().List(ctx, pods, client.MatchingLabels{<span style=color:#a31515>&#34;app&#34;</span>: <span style=color:#a31515>&#34;net-nginx&#34;</span>})
    Expect(err).NotTo(HaveOccurred())
    <span style=color:green>// check if all webservers can be reached from all nodes
</span><span style=color:green></span>    ginkgo.By(<span style=color:#a31515>&#34;test connectivity to webservers&#34;</span>)
    shootRESTConfig := f.ShootClient.RESTConfig()
    <span style=color:#00f>var</span> res <span style=color:#2b91af>error</span>
    <span style=color:#00f>for</span> _, from := <span style=color:#00f>range</span> pods.Items {
      <span style=color:#00f>for</span> _, to := <span style=color:#00f>range</span> pods.Items {
        <span style=color:green>// test pods
</span><span style=color:green></span>        f.Logger.Infof(<span style=color:#a31515>&#34;%s to %s: %s&#34;</span>, from.GetName(), to.GetName(), data)
      }
    }
    Expect(res).ToNot(HaveOccurred())
  }, NetworkTestTimeout)
})
</code></pre></div><h2 id=future-plans>Future Plans</h2><h4 id=ownership>Ownership</h4><p>When the test coverage is increased and there will be more tests, we will need to track ownership for tests.
At the beginning the ownership will be shared across all maintainers of the residing repository but this is not suitable anymore as tests will grow and get more complex.</p><p>Therefore the test ownership should be tracked via subgroups (in kubernetes this would be a SIG (comp. <a href=https://github.com/kubernetes/kubernetes/blob/master/test/e2e/apps/framework.go#L22>sig apps e2e test</a>)). These subgroup will then be tracked via labels and the members of these groups will then be notified if tests fail.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3769be973f9bb9047a57a60178b9367c>7.10 - 10 Shoot Additional Container Runtimes</h1><h1 id=gardener-extensibility-to-support-shoot-additional-container-runtimes>Gardener extensibility to support shoot additional container runtimes</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a></li><li><a href=#design-details>Design Details</a></li><li><a href=#alternatives>Alternatives</a></li></ul><h2 id=summary>Summary</h2><p>Gardener-managed Kubernetes clusters are sometimes used to run sensitive workloads, which sometimes are comprised of OCI images originating from untrusted sources. Additional use-cases want to leverage economy-of-scale to run workloads for multiple tenants on the same cluster. In some cases, Gardener users want to use operating systems which do not easily support the Docker engine.</p><p>This proposal aims to allow Gardener Shoot clusters to use CRI instead of the legacy Docker API, and to provide extension type for adding CRI shims (like <a href=https://gvisor.dev/>GVisor</a> and <a href=https://katacontainers.io/>Kata Containers</a>) which can be used to add support in Gardener Shoot clusters for these runtimes.</p><h2 id=motivation>Motivation</h2><p>While pods and containers are intended to create isolated areas for concurrently running workloads on nodes, this isolation is not as robust as could be expected. Containers leverage the core Linux CGroup and Namespace features to isolate workloads, and many kernel vulnerabilities have the potential to allow processes to escape from their isolation. Once a process has escaped from its container, any other process running on the same node is compromised. Several projects try to mitigate this problem; for example Kata Containers allow isolating a Kubernetes Pod in a micro-vm, gVisor reduces the kernel attack surface by adding another level of indirection between the actual payload and the real kernel.</p><p>Kubernetes supports running pods using these alternate runtimes via the <a href=https://kubernetes.io/docs/concepts/containers/runtime-class/>RuntimeClass</a> concept, which was promoted to Beta in Kubernetes 1.14. Once Kubernetes is configured to use the Container Runtime Interface to control pods, it becomes possible to leverage CRI and run specific pods using different Runtime Classes. Additionally, configuring Kubernetes to use CRI instead of the legacy Dockershim is <a href=https://events19.linuxfoundation.org/wp-content/uploads/2017/11/How-Container-Runtime-Matters-in-Kubernetes_-OSS-Kunal-Kushwaha.pdf>faster</a>.</p><p>The motivation behind this proposal is to make all of this functionality accessible to Shoot clusters managed by Gardener.</p><h3 id=goals>Goals</h3><ul><li>Gardener must allow to configue its managed clusters with the CRI interface instead of the legacy Dockershim.</li><li>Low-level runtimes like gVisor or Kata Containers are provided as gardener extensions which are (optionally) installed into a landscape by the Gardener operator. There must be no runtime-specific knowledge in the core Gardener code.</li><li>It shall be possible to configure multiple low-level runtimes in Shoot clusters, on the Worker Group level.</li></ul><h2 id=proposal>Proposal</h2><p>Gardener today assumes that all supported operating systems have Docker pre-installed in the base image. Starting with Docker Engine 1.11, Docker itself was <a href=https://www.docker.com/blog/docker-engine-1-11-runc/>refactored</a> and cleaned-up to be based on the <a href=https://containerd.io/>containerd</a> library. The first phase would be to allow the change of the Kubelet configuration as described <a href=https://kubernetes.io/docs/setup/production-environment/container-runtimes/#containerd>here</a> so that Kubernetes would use containerd instead of the default Dockershim. This will be implemented for CoreOS, Ubuntu, and SuSE-CHost.</p><p>We will implement two Gardener extensions, providing gVisor and Kata Containers as options for Gardener landscapes.
The <code>WorkerGroup</code> specification will be extended to allow specifying the CRI name and a list of additional required Runtimes for nodes in that group. For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>workers:
- name: worker-b8jg5
  machineType: m5.large
  volumeType: gp2
  volumeSize: 50Gi
  autoScalerMin: 1
  autoScalerMax: 2
  maxSurge: 1
  cri:
    name: containerd
    containerRuntimes:
    - type: gvisor
    - type: kata-containers
  machineImage:
    name: coreos
    version: 2135.6.0
</code></pre></div><p>Each extension will need to address the following concern:</p><ol><li>Add the low-level runtime binaries to the worker nodes. Each extension should get the runtime binaries from a container.</li><li>Hook the runtime binary into the containerd configuration file, so that the runtime becomes available to containerd.</li><li>Apply a label to each node that allows identifying nodes where the runtime is available.</li><li>Apply the relevant <code>RuntimeClass</code> to the Shoot cluster, to expose the functionality to users.</li><li>Provide a separate binary with a <code>ValidatingWebhook</code> (deployable to the garden cluster) to catch invalid configurations. For example, Kata Containers on AWS requires a <code>machineType</code> of <code>i3.metal</code>, so any <code>Shoot</code> requests with a Kata Containers runtime and a different machine type on AWS should be rejected.</li></ol><h2 id=design-details>Design Details</h2><ol><li><p>Change the nodes container runtime to work with CRI and ContainerD (Only if specified in the Shoot spec):</p><ol><li><p>In order to configure each worker machine in the cluster to work with CRI, the following configurations should be done:</p><ol><li>Add kubelet execution flags:<ol><li>&ndash;container-runtime=remote</li><li>&ndash;container-runtime-endpoint=unix:///run/containerd/containerd.sock</li></ol></li><li>Make sure that default containerd configuration file exist in path /etc/containerd/config.toml.</li></ol></li><li><p>ContainerD and Docker configurations are different for each OS. To make sure the default configurations above works well in each worker machine, each OS extension would be responsible to configure them during the reconciliation of the
OperatingSystemConfig:</p><ol><li>os-ubuntu -<ol><li>Create ContainerD unit Drop-In to execute ContainerD with the default configurations file in path /etc/containerd/config.toml.</li><li>Create the container runtime metadata file with a OS path for binaries installations: /usr/bin.</li></ol></li><li>os-coreos -<ol><li>Create ContainerD unit Drop-In to execute ContainerD with the default configurations file in path /etc/containerd/config.toml.</li><li>Create Docker Drop-In unit to execute Docker with the correct socket path of ContainerD.</li><li>Create the container runtime metadata file with a OS path for binaries installations: /var/bin.</li></ol></li><li>os-suse-chost -<ol><li>Create ContainerD service unit and execute ContainerD with the default configurations file in path /etc/containerd/config.toml.</li><li>Download and install ctr-cli which is not shipped with the current SuSe image.</li><li>Create the container runtime metadata file with a OS path for binaries installations /usr/sbin.</li></ol></li></ol></li><li><p>To rotate the ContainerD (CRI) logs we will activate the kubelet feature flag: CRIContainerLogRotation=true.</p></li><li><p>Docker monitor service will be replaced with equivalent ContainerD monitor service.</p></li></ol></li><li><p>Validate workers additional runtime configurations:</p><ol><li>Disallow additional runtimes with shoots &lt; 1.14</li><li>kata-container validation: Machine type support nested virtualization.</li></ol></li><li><p>Add support for each additional container runtime in the cluster.</p><ol><li><p>In order to install each additional available runtime in the cluster we should:</p><ol><li>Install the runtime binaries in each Worker&rsquo;s pool nodes that specified the runtime support.</li><li>Apply the relevant RuntimeClass to the cluster.</li></ol></li><li><p>The installation above should be done by a new kind of extension: ContainerRuntime resource. For each container runtime type (Kata-container/gvisor) a dedicate extension controller will be created.</p><ol><li><p>A label for each container runtime support will be added to every node that belongs to the worker pool. This should be done similar
to the way labels created today for each node, through kubelet execution parameters (_kubelet.flags: &ndash;node-labels). When creating the OperatingSystemConfig (original) for the worker each container runtime support should be mapped to a label on the node.
For Example:
label: container.runtime.kata-containers=true (shoot.spec.cloud.<iaas>.worker.containerRuntimes.kata-container)
label: container.runtime.gvisor=true (shoot.spec.cloud.<iaas>.worker.containerRuntimes.gvisor)</p></li><li><p>During the Shoot reconciliation (Similar steps to the Extensions today) Gardener will create new ContainerRuntime resource if a container runtime exist in at least one worker spec:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: ContainerRuntime
metadata:
  name: kata-containers-runtime-extention
  namespace: shoot--foo--bar
spec:
  type: kata-containers
</code></pre></div><p>Gardener will wait that all ContainerRuntimes extensions will be reconciled by the appropriate extensions controllers.</p></li><li><p>Each runtime extension controller will be responsible to reconcile it&rsquo;s RuntimeContainer resource type.
rc-kata-containers extension controller will reconcile RuntimeContainer resource from type kata-container and rc-gvisor will reconcile RuntimeContainer resource from gvisor.
Reconciliation process by container runtime extension controllers:</p><ol><li>Runtime extension controller from specific type should apply a chart which responsible for the installation of the runtime container in the cluster:<ol><li>DaemonSet which will run a privileged pod on each node with the label: container.runtime.<type of the resource>:true The pod will be responsible for:<ol><li>Copy the runtime container binaries (From extension package ) to the relevant path in the host OS.</li><li>Add the relevant container runtime plugin section to the containerd configuration file (/etc/containerd/config.toml).</li><li>Restart containerd in the node.</li></ol></li><li>RuntimeClasses in the cluster to support the runtime class. for example:<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: node.k8s.io/v1beta1
kind: RuntimeClass
metadata:
  name: gvisor
handler: runsc
</code></pre></div></li></ol></li><li>Update the status of the relevant RuntimeContainer resource to succeeded.</li></ol></li></ol></li></ol></li></ol><p>&ndash;></p><h2 id=alternatives>Alternatives</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-f79a3d9aaa070750a3943e02881b340a>7.11 - 12 Oidc Webhook Authenticator</h1><h1 id=oidc-webhook-authenticator>OIDC Webhook Authenticator</h1><h2 id=problem>Problem</h2><p>In Kubernetes you can authenticate via several authentication strategies:</p><ul><li>x509 Client Certificates</li><li>Static Token Files</li><li>Bootstrap Tokens</li><li>Static Password File (Basic authentication - deprecated and removed in 1.19)</li><li>Service Account Tokens</li><li>OpenID Connect TOkens</li><li>Webhook Token Authentication</li><li>Authenticating Proxy</li></ul><p>End-users should use <a href=https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens>OpenID Connect (OIDC) Tokens</a> created by OIDC-compatible Identity Provider (IDP) and present <a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>id_token</a> to the Kube APIServer. If the API server is configured to trust the IDP and the token is valid, then the user is authenticated and the <a href=https://github.com/kubernetes/kubernetes/blob/99019502bd6ed038dbd1c444974d5e8c6a8dda19/staging/src/k8s.io/api/authentication/v1/types.go#L100-L117>UserInfo</a> is send to the authorization stack.</p><p>Ideally, operators of the Gardener cluster should be able to authenticate to end-user Shoot clusters with <code>id_token</code> generated by OIDC IDP, but in many cases, end-users might have already configured OIDC for their cluster and more than one OIDC configurations are not allowed.</p><p>Another interesting application of multiple OIDC providers would be per <code>Project</code> OIDC provider where end-users of Gardener can add their own OIDC-compatible IDPs.</p><p>To workaround the one OIDC per Kube APIServer limitation, a new <code>OIDC Webhook Authenticator</code> (OWA) could be implemented.</p><h2 id=goals>Goals</h2><ul><li>Dynamic registrations of OpenID Connect configurations.</li><li>Close as possible to the Kubernetes build-in OIDC Authenticator.</li><li>Build as an optional extension and not required for functional Shoot or Gardener cluster.</li></ul><h2 id=non-goals>Non-goals</h2><ul><li><a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/>Dynamic Authorization</a> is out of scope.</li></ul><h2 id=proposal>Proposal</h2><p>The Kube APIServer can use <a href=https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>Webhook Token Authentication</a> to send a <a href=https://tools.ietf.org/html/rfc6750#section-2.1>Bearer Tokens (id_token)</a> to external webhook for validation:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  &#34;kind&#34;: <span style=color:#a31515>&#34;TokenReview&#34;</span>,
  &#34;spec&#34;: {
    &#34;token&#34;: <span style=color:#a31515>&#34;(BEARERTOKEN)&#34;</span>
  }
}
</code></pre></div><p>Where upon verification, the remote webhook returns the identity of the user (if authentication succeeds):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  &#34;kind&#34;: <span style=color:#a31515>&#34;TokenReview&#34;</span>,
  &#34;status&#34;: {
    &#34;authenticated&#34;: <span style=color:#00f>true</span>,
    &#34;user&#34;: {
      &#34;username&#34;: <span style=color:#a31515>&#34;janedoe@example.com&#34;</span>,
      &#34;uid&#34;: <span style=color:#a31515>&#34;42&#34;</span>,
      &#34;groups&#34;: [
        <span style=color:#a31515>&#34;developers&#34;</span>,
        <span style=color:#a31515>&#34;qa&#34;</span>
      ],
      &#34;extra&#34;: {
        &#34;extrafield1&#34;: [
          <span style=color:#a31515>&#34;extravalue1&#34;</span>,
          <span style=color:#a31515>&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div><h3 id=registration-of-new-openidconnect>Registration of new OpenIDConnect</h3><p>This new OWA can be configured with multiple OIDC providers and the entire flow can look like this:</p><ol><li><p>Admin adds a new <code>OpenIDConnect</code> resource (via CRD) to the cluster.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: authentication.gardener.cloud/v1alpha1
kind: OpenIDConnect
metadata:
  name: foo
spec:
  issuerURL: https://foo.bar
  clientID: some-client-id
  usernameClaim: email
  usernamePrefix: <span style=color:#a31515>&#34;test-&#34;</span>
  groupsClaim: groups
  groupsPrefix: <span style=color:#a31515>&#34;baz-&#34;</span>
  supportedSigningAlgs:
  - RS256
  requiredClaims:
    baz: bar
  caBundle: LS0tLS1CRUdJTiBDRVJU...base64-encoded CA certs for issuerURL.
</code></pre></div></li><li><ol><li>OWA watches for changes on this resource and does <a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC discovery</a>. The <a href=https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse>OIDC provider&rsquo;s configuration</a> has to be accessible under the <code>spec.issuerURL</code> with a <a href=https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig>well-known path (.well-known/openid-configuration)</a>.</li></ol></li><li><p>OWA uses the <code>jwks_uri</code> obtained from the OIDC providers configuration, to fetch the OIDC provider&rsquo;s public keys from that endpoint and stores them in the status of <code>OpenIDConnect</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: authentication.gardener.cloud/v1alpha1
kind: OpenIDConnect
metadata:
  name: foo
spec:
  issuerURL: https://foo.bar
  ...
status:
  keys: f31deA9b... <span style=color:green>#the content of jwks_uri base64-encoded</span>
</code></pre></div></li><li><p>OWA uses those keys, issuer, client_id and other settings to add OIDC authenticator to a in-memory list of <a href="https://pkg.go.dev/k8s.io/apiserver/pkg/authentication/authenticator?tab=doc#Token">Token Authenticators</a>.</p></li></ol><p><img src=/__resources/registration_4bbe69.svg alt="alt text" title="Authentication with OIDC webhook"></p><h3 id=end-user-authentication-via-new-openidconnect-idp>End-user authentication via new OpenIDConnect IDP</h3><p>When a user presents an <code>id_token</code> obtained from a OpenID Connect the flow looks like this:</p><ol><li><p>The user authenticates in Custom IDP.</p></li><li><p><code>id_token</code> is obtained from Custom IDP.</p></li><li><p>The user uses <code>id_token</code> to perform an API call to Kube APIServer.</p></li><li><p>As the <code>id_token</code> is not matched by any build-in or configured authenticators in the Kube APIServer, it is send to OWA for validation.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;TokenReview&#34;: {
    &#34;kind&#34;: <span style=color:#a31515>&#34;TokenReview&#34;</span>,
    &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authentication.k8s.io/v1beta1&#34;</span>,
    &#34;spec&#34;: {
      &#34;token&#34;: <span style=color:#a31515>&#34;ddeewfwef...&#34;</span>
    }
  }
}
</code></pre></div></li><li><p>OWA uses <code>TokenReview</code> to authenticate the calling API server (the Kube APIServer for delegation of authentication and authorization is different from the calling API server).</p><blockquote><p>Example: When a Shoot cluster&rsquo;s API Server is configured to verify tokens by OWA, that API server will be the callee API server. The Seed API server will be used for delegating authentication and authorization.</p></blockquote><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;TokenReview&#34;: {
    &#34;kind&#34;: <span style=color:#a31515>&#34;TokenReview&#34;</span>,
    &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authentication.k8s.io/v1beta1&#34;</span>,
    &#34;spec&#34;: {
      &#34;token&#34;: <span style=color:#a31515>&#34;api-server-token...&#34;</span>
    }
  }
}
</code></pre></div></li><li><p>After the Authentication API server returns the identity of callee API server:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authentication.k8s.io/v1&#34;</span>,
    &#34;kind&#34;: <span style=color:#a31515>&#34;TokenReview&#34;</span>,
    &#34;metadata&#34;: {
        &#34;creationTimestamp&#34;: <span style=color:#00f>null</span>
    },
    &#34;spec&#34;: {
        &#34;token&#34;: <span style=color:#a31515>&#34;eyJhbGciOiJSUzI1NiIsImtpZCI6InJocEdLTXZlYjV1OE5heD...&#34;</span>
    },
    &#34;status&#34;: {
        &#34;authenticated&#34;: <span style=color:#00f>true</span>,
        &#34;user&#34;: {
            &#34;groups&#34;: [
                <span style=color:#a31515>&#34;system:serviceaccounts&#34;</span>,
                <span style=color:#a31515>&#34;system:serviceaccounts:shoot--abcd&#34;</span>,
                <span style=color:#a31515>&#34;system:authenticated&#34;</span>
            ],
            &#34;uid&#34;: <span style=color:#a31515>&#34;14db103e-88bb-4fb3-8efd-ca9bec91c7bf&#34;</span>,
            &#34;username&#34;: <span style=color:#a31515>&#34;system:serviceaccount:shoot--abcd:kube-apiserver&#34;</span>
        }
    }
}
</code></pre></div><p>OWA makes a <code>SubjectAccessReview</code> call to the Authorization API server to ensure that callee API server is allowed to validate tokens:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authorization.k8s.io/v1&#34;</span>,
  &#34;kind&#34;: <span style=color:#a31515>&#34;SubjectAccessReview&#34;</span>,
  &#34;spec&#34;: {
    &#34;groups&#34;: [
      <span style=color:#a31515>&#34;system:serviceaccounts&#34;</span>,
      <span style=color:#a31515>&#34;system:serviceaccounts:shoot--abcd&#34;</span>,
      <span style=color:#a31515>&#34;system:authenticated&#34;</span>
    ],
    &#34;nonResourceAttributes&#34;: {
      &#34;path&#34;: <span style=color:#a31515>&#34;/validate-token&#34;</span>,
      &#34;verb&#34;: <span style=color:#a31515>&#34;post&#34;</span>
    },
    &#34;user&#34;: <span style=color:#a31515>&#34;system:serviceaccount:shoot--abcd:kube-apiserver&#34;</span>
  },
  &#34;status&#34;: {
    &#34;allowed&#34;: <span style=color:#00f>true</span>,
    &#34;reason&#34;: <span style=color:#a31515>&#34;RBAC: allowed by RoleBinding \&#34;kube-apiserver\&#34; of ClusterRole \&#34;kube-apiserver\&#34; to ServiceAccount \&#34;system:serviceaccount:shoot--abcd:kube-apiserver\&#34;&#34;</span>
  }
}
</code></pre></div></li><li><p>OWA then iterates over all registered <code>OpenIDConnect</code> Token authenticators and tries to validate the token.</p></li><li><p>Upon a successful validation it returns the <code>TokeReview</code> with user, groups and extra parameters:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  &#34;TokenReview&#34;: {
    &#34;kind&#34;: <span style=color:#a31515>&#34;TokenReview&#34;</span>,
    &#34;apiVersion&#34;: <span style=color:#a31515>&#34;authentication.k8s.io/v1beta1&#34;</span>,
    &#34;spec&#34;: {
      &#34;token&#34;: <span style=color:#a31515>&#34;ddeewfwef...&#34;</span>
    },
    &#34;status&#34;: {
      &#34;authenticated&#34;: <span style=color:#00f>true</span>,
      &#34;user&#34;: {
        &#34;username&#34;: <span style=color:#a31515>&#34;test-foo@bar.com&#34;</span>,
        &#34;groups&#34;: [
          <span style=color:#a31515>&#34;baz-employee&#34;</span>
        ],
        &#34;extra&#34;: {
          &#34;gardener.cloud/apiserver/groups&#34;: [
            <span style=color:#a31515>&#34;system:serviceaccounts&#34;</span>,
            <span style=color:#a31515>&#34;system:serviceaccounts:shoot--abcd&#34;</span>,
            <span style=color:#a31515>&#34;system:authenticated&#34;</span>
          ],
          &#34;gardener.cloud/apiserver/uid&#34;: [
            <span style=color:#a31515>&#34;system:serviceaccount:shoot--abcd:kube-apiserver&#34;</span>
          ],
          &#34;gardener.cloud/apiserver/username&#34;: [
            <span style=color:#a31515>&#34;system:serviceaccount:shoot--abcd:kube-apiserver&#34;</span>
          ],
          &#34;gardener.cloud/oidc/name&#34;: [
            <span style=color:#a31515>&#34;foo&#34;</span>
          ],
          &#34;gardener.cloud/oidc/uid&#34;: [
            <span style=color:#a31515>&#34;e5062528-e5a4-4b97-ad83-614d015b0979&#34;</span>
          ],
          &#34;gardener.cloud/oidc/resourceVersion&#34;: [
            <span style=color:#a31515>&#34;3355876311&#34;</span>
          ]
        }
      }
    }
  }
}
</code></pre></div><p>It also adds some extra information which can be used by custom authorizers later on:</p><ol><li><code>gardener.cloud/apiserver/groups</code> contains all the groups of the API server which is making the <code>TokenReview</code> request (it&rsquo;s the ServiceAccount of the API Server Pod in this case)</li><li><code>gardener.cloud/apiserver/uid</code> contains the UID of the API server which is making the <code>TokenReview</code> request (it&rsquo;s the ServiceAccount of the API Server Pod in this case)</li><li><code>gardener.cloud/apiserver/username</code> contains the username of the API server which is making the <code>TokenReview</code> request (it&rsquo;s the ServiceAccount of the API Server Pod in this case)</li><li><code>gardener.cloud/oidc/name</code> contains the name of the <code>OpenIDConnect</code> authenticator which was used.</li><li><code>gardener.cloud/oidc/uid</code> contains the <code>metadata.uid</code> of the <code>OpenIDConnect</code> authenticator which was used.</li><li><code>gardener.cloud/oidc/resourceVersion</code> contains the <code>metadata.resourceVersion</code> of the <code>OpenIDConnect</code> authenticator which was used.</li></ol></li><li><p>Kube APIServer proceeds with authorization checks and returns response.</p></li></ol><p>An overview of the flow:</p><p><img src=/__resources/authentication_eac090.svg alt="alt text" title="Authentication with OIDC webhook"></p><h2 id=deployment-for-shoot-clusters>Deployment for Shoot clusters</h2><p>To save cost, a single (multi-replica) deployment of OWA can be deployed in the <code>Seed</code> cluster. All Shoot API Servers are started with</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>--authentication-token-webhook-config-file=/etc/webhook/kubeconfig
</code></pre></div><p>where <code>/etc/webhook/kubeconfig</code> would contain a standard <code>kubeconfig</code>, with using for authentication the Service Account token of the API Server:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Config
clusters:
- name: authenticator
  cluster:
    certificate-authority-data: LS0tLS1CRU...
    server: https://oidc-webhook-authenticator/odic-authenticator-system.svc/validate-token
users:
- name: token
  user:
    tokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
current-context: webhook
contexts:
- context:
    cluster: authenticator
    user: token
  name: webhook
</code></pre></div><p>Depending on the version of the Seed cluster and configuration, <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>Service Account Token Volume projection</a> should be used instead of static ServiceAccount Tokens:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>volumes:
- name: oidc-authenticator-token
  projected:
    sources:
    - serviceAccountToken:
        path: oidc-authenticator-token
        expirationSeconds: 7200
        audience: oidc-authenticator
</code></pre></div><p>OWA is deployed via <code>ControllerRegistration</code>, which deploys the necessary components and inject the necessary shoot kube-apiserver configuration via a <code>MutatingWebhookConfiguration</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3a2b9eef5225b9d23e95c0373526624f>7.12 - 13 Automated Seed Management</h1><h1 id=automated-seed-management>Automated Seed Management</h1><p>Automated seed management involves automating certain aspects of managing seeds in Garden clusters, such as:</p><ul><li><a href=#ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring that the seeds capacity for shoots is not exceeded</a></li><li><a href=#managedseeds>Creating, deleting, and updating seeds declaratively as &ldquo;managed seeds&rdquo;</a></li><li><a href=#managedseedsets>Declaratively managing sets of similar &ldquo;managed seeds&rdquo; as &ldquo;managed seed sets&rdquo; which can be scaled up/down</a></li><li><a href=#auto-scaling-seeds>Auto-scaling seeds upon reaching capacity thresholds</a></li></ul><p>Implementing the above features would involve changes to various existing Gardener components, as well as perhaps introducing new ones. This document describes these features in more detail and proposes a design approach for some of them.</p><p>In Gardener, scheduling shoots onto seeds is quite similar to scheduling pods onto nodes in Kubernetes. Therefore, a guiding principle behind the proposed design approaches is taking advantage of best practices and existing components already used in Kubernetes.</p><h2 id=ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring Seeds Capacity for Shoots Is Not Exceeded</h2><p>Seeds have a practical limit of how many shoots they can accommodate. Exceeding this limit is undesirable as the system performance will be noticeably impacted. Therefore, it is important to ensure that a seed&rsquo;s capacity for shoots is not exceeded by introducing a maximum number of shoots that can be scheduled onto a seed and making sure that it is taken into account by the scheduler.</p><p>An initial discussion of this topic is available in <a href=https://github.com/gardener/gardener/issues/2938>Issue #2938</a>. The proposed solution is based on the following flow:</p><ul><li>The <code>gardenlet</code> is configured with certain <em>resources</em> and their total <em>capacity</em> (and, for certain resources, the amount reserved for Gardener).</li><li>The <code>gardenlet</code> seed controller updates the Seed status with the capacity of each resource and how much of it is actually available to be consumed by shoots, using <code>capacity</code> and <code>allocatable</code> fields that are very similar to the corresponding fields in <a href=https://github.com/kubernetes/api/blob/2c3c141c931c0ab1ce1396c3152c72852b3d37ee/core/v1/types.go#L4582-L4593>the Node status</a>.</li><li>When scheduling shoots, <code>gardener-scheduler</code> is influenced by the remaining capacity of the seed. In the simplest possible implementation, it never schedules shoots onto a seed that has already reached its capacity for a resource needed by the shoot.</li></ul><p>Initially, the only resource considered would be the maximum number of shoots that can be scheduled onto a seed. Later, more resources could be added to make more precise scheduling calculations.</p><p><strong>Note:</strong> Resources could also be requested by shoots, similarly to how pods can request node resources, and the scheduler could then ensure that such requests are taken into account when scheduling shoots onto seeds. However, the user is rarely, if at all, concerned with what resources does a shoot consume from a seed, and this should also be regarded as an implementation detail that could change in the future. Therefore, such resource requests are not included in this GEP.</p><p>In addition, an extensibility plugin framework could be introduced in the future in order to advertise custom resources, including provider-specific resources, so that <code>gardenlet</code> would be able to update the seed status with their capacity and allocatable values, for example load balancers on Azure. Such a concept is not described here in further details as it is sufficiently complex to require a separate GEP.</p><p>Example Seed status with <code>capacity</code> and <code>allocatable</code> fields:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>status:
  capacity:
    shoots: <span style=color:#a31515>&#34;100&#34;</span>
    persistent-volumes: <span style=color:#a31515>&#34;200&#34;</span> <span style=color:green># Built-in resource</span>
    azure.provider.extensions.gardener.cloud/load-balancers: <span style=color:#a31515>&#34;30&#34;</span> <span style=color:green># Custom resource advertised by an Azure-specific plugin</span>
  allocatable:
    shoots: <span style=color:#a31515>&#34;100&#34;</span>
    persistent-volumes: <span style=color:#a31515>&#34;197&#34;</span> <span style=color:green># 3 persistent volumes are reserved for Gardener</span>
    azure.provider.extensions.gardener.cloud/load-balancers: <span style=color:#a31515>&#34;300&#34;</span>
</code></pre></div><h3 id=gardenlet-configuration>Gardenlet Configuration</h3><p>As mentioned above, the total resource capacity for built-in resources such as the number of shoots is specified as part of the <code>gardenlet</code> configuration, not in the Seed spec. The <code>gardenlet</code> configuration itself could be specified in the spec of the newly introduced <a href=#managedseeds>ManagedSeed</a> resource. Here it is assumed that in the future this could become the recommended and most widely used way to manage seeds. If the same <code>gardenlet</code> is responsible for multiple seeds, they would all share the same capacity settings.</p><p>To specify the total resource capacity for built-in resources, as well as the amount of such resources reserved for Gardener, the 2 new fields <code>resources.capacity</code> and <code>resources.reserved</code> are introduced in the <code>GardenletConfiguration</code> resource. The <code>gardenlet</code> seed controller would then initialize the <code>capacity</code> and <code>allocatable</code> fields in the seed status as follows:</p><ul><li>The <code>capacity</code> value is set to the configured <code>resources.capacity</code>.</li><li>The <code>allocatable</code> value is set to the configured <code>resources.capacity</code> minus <code>resources.reserved</code>.</li></ul><p>Example <code>GardenletConfiguration</code> with <code>resources.capacity</code> and <code>resources.reserved</code> field:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>resources:
  capacity:
    shoots: 100
    persistent-volumes: 200
  reserved:
    persistent-volumes: 3
</code></pre></div><h3 id=scheduling-algorithm>Scheduling Algorithm</h3><p>Currently <code>gardener-scheduler</code> uses a simple non-extensible algorithm in order to schedule shoots onto seeds. It goes through the following stages:</p><ul><li>Filter out seeds that don&rsquo;t meet scheduling requirements such as being ready, matching cloud profile and shoot label selectors, matching the shoot provider, and not having taints that are not tolerated by the shoot.</li><li>From the remaining seeds, determine candidates that are considered best based on their region, by using a strategy that can be either &ldquo;same region&rdquo; or &ldquo;minimal distance&rdquo;.</li><li>Among these candidates, choose the one with the least number of shoots.</li></ul><p>This scheduling algorithm should be adapted in order to properly take into account resources capacity and requests. As a first step, during the filtering stage, any seeds that would exceed their capacity for shoots, or their capacity for any resources requested by the shoot, should simply be filtered out and not considered during the next stages.</p><p>Later, the scheduling algorithm could be further enhanced by replacing the step in which the region strategy is applied by a scoring step similar to the one in <a href=https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/>Kubernetes Scheduler</a>. In this scoring step, the scheduler would rank the remaining seeds to choose the most suitable shoot placement. It would assign a score to each seed that survived filtering based on a list of scoring rules. These rules might include for example <code>MinimalDistance</code> and <code>SeedResourcesLeastAllocated</code>, among others. Each rule would produce its own score for the seed, and the overall seed score would be calculated as a weighted sum of all such scores. Finally, the scheduler would assign the shoot to the seed with the highest ranking.</p><h2 id=managedseeds>ManagedSeeds</h2><p>When all or most of the existing seeds are near capacity, new seeds should be created in order to accommodate more shoots. Conversely, sometimes there could be too many seeds for the number of shoots, and so some of the seeds could be deleted to save resources. Currently, the process of creating a new seed involves a number of manual steps, such as creating a new shoot that meets certain criteria, and then registering it as a seed in Gardener. This could be automated to some extent by <a href=/docs/gardener/usage/shooted_seed/>annotating a shoot with the <code>use-as-seed</code> annotation</a>, in order to create a &ldquo;shooted seed&rdquo;. However, adding more than one similar seeds still requires manually creating all needed shoots, annotating them appropriately, and making sure that they are successfully reconciled and registered.</p><p>To create, delete, and update seeds effectively in a declarative way and allow auto-scaling, a &ldquo;creatable seed&rdquo; resource along with a &ldquo;set&rdquo; (and in the future, perhaps also a &ldquo;deployment&rdquo;) of such creatable seeds should be introduced, similar to Kubernetes <code>Pod</code>, <code>ReplicaSet</code>, and <code>Deployment</code> (or to MCM <code>Machine</code>, <code>MachineSet</code>, and <code>MachineDeployment</code>) resources. With such resources (and their respective controllers), creating a new seed based on a template would become as simple as increasing the <code>replicas</code> field in the &ldquo;set&rdquo; resource.</p><p>In <a href=https://github.com/gardener/gardener/issues/2181>Issue #2181</a> it is already proposed that the <code>use-as-seed</code> annotation is replaced by a dedicated <code>ShootedSeed</code> resource. The solution proposed here further elaborates on this idea.</p><h3 id=managedseed-resource>ManagedSeed Resource</h3><p>The <code>ManagedSeed</code> resource is a dedicated custom resource that represents an evolution of the &ldquo;shooted seed&rdquo; and properly replaces the <code>use-as-seed</code> annotation. This resource contains:</p><ul><li>The name of the Shoot that should be registered as a Seed.</li><li>An optional <code>seedTemplate</code> section that contains the Seed spec and parts of the metadata, such as labels and annotations.</li><li>An optional <code>gardenlet</code> section that contains:<ul><li><code>gardenlet</code> deployment parameters, such as the number of replicas, the image, etc.</li><li>The <code>GardenletConfiguration</code> resource that contains controllers configuration, feature gates, and a <code>seedConfig</code> section that contains the <code>Seed</code> spec and parts of its metadata.</li><li>Additional configuration parameters, such as the garden connection bootstrap mechanism (see <a href=/docs/gardener/concepts/gardenlet/#tls-bootstrapping>TLS Bootstrapping</a>), and whether to merge the provided configuration with the configuration of the parent <code>gardenlet</code>.</li></ul></li></ul><p>Either the <code>seedTemplate</code> or the <code>gardenlet</code> section must be specified, but not both:</p><ul><li>If the <code>seedTemplate</code> section is specified, <code>gardenlet</code> is not deployed to the shoot, and a new <code>Seed</code> resource is created based on the template.</li><li>If the <code>gardenlet</code> section is specified, <code>gardenlet</code> is deployed to the shoot, and it registers a new seed upon startup based on the <code>seedConfig</code> section of the <code>GardenletConfiguration</code> resource.</li></ul><p>A ManagedSeed allows fine-tuning the seed and the <code>gardenlet</code> configuration of shooted seeds in order to deviate from the global defaults, e.g. lower the concurrent sync for some of the seed&rsquo;s controllers or enable a feature gate only on certain seeds. Also, it simplifies the deletion protection of such seeds.</p><p>Also, the <code>ManagedSeed</code> resource is a more powerful alternative to the <code>use-as-seed</code> annotation. The implementation of the <code>use-as-seed</code> annotation itself could be refactored to use a <code>ManagedSeed</code> resource extracted from the annotation by a controller.</p><p>Although in this proposal a ManagedSeed is always a &ldquo;shooted seed&rdquo;, that is a Shoot that is registered as a Seed, this idea could be further extended in the future by adding a <code>type</code> field that could be either <code>Shoot</code> (implied in this proposal), or something different. Such an extension would allow to register and manage as Seed a cluster that is not a Shoot, e.g. a GKE cluster.</p><p>Last but not least, ManagedSeeds could be used as the basis for creating and deleting seeds automatically via the <code>ManagedSeedSet</code> resource that is described in <a href=#managedseedsets>ManagedSeedSets</a>.</p><p>Unlike the <code>Seed</code> resource, the <code>ManagedSeed</code> resource is namespaced. If created in the <code>garden</code> namespace, the resulting seed is globally available. If created in a project namespace, the resulting seed can be used as a &ldquo;private seed&rdquo; by shoots in the project, either by being decorated with project-specific taints and labels, or by being of the special <code>PrivateSeed</code> kind that is also namespaced. The concept of private seeds / cloudprofiles is described in <a href=https://github.com/gardener/gardener/issues/2874>Issue #2874</a>. Until this concept is implemented, <code>ManagedSeed</code> resources might need to be restricted to the <code>garden</code> namespace, similarly to how shoots with the <code>use-as-seed</code> annotation currently are.</p><p>Example <code>ManagedSeed</code> resource with a <code>seedTemplate</code> section:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: seedmanagement.gardener.cloud/v1alpha1
kind: ManagedSeed
metadata:
  name: crazy-botany
  namespace: garden
spec:
  shoot:
    name: crazy-botany <span style=color:green># Shoot that should be registered as a Seed</span>
  seedTemplate: <span style=color:green># Seed template, including spec and parts of the metadata</span>
    metadata:
      labels:
        foo: bar
    spec:
      provider:
        type: gcp
        region: europe-west1
      taints:
      - key: seed.gardener.cloud/protected
      ...
</code></pre></div><p>Example <code>ManagedSeed</code> resource with a <code>gardenlet</code> section:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: seedmanagement.gardener.cloud/v1alpha1
kind: ManagedSeed
metadata:
  name: crazy-botany
  namespace: garden
spec:
  shoot:
    name: crazy-botany <span style=color:green># Shoot that should be registered as a Seed</span>
  gardenlet: 
    deployment: <span style=color:green># Gardenlet deployment configuration</span>
      replicaCount: 1
      revisionHistoryLimit: 10
      serviceAccountName: gardenlet
      image:
        repository: eu.gcr.io/gardener-project/gardener/gardenlet
        tag: latest
        pullPolicy: IfNotPresent
      resources:
        ...
      podLabels:
        ...
      podAnnotations: 
        ...
      additionalVolumes:
        ...
      additionalVolumeMounts:
        ...
      env:
        ...
      vpa: <span style=color:#00f>false</span>
    config: <span style=color:green># GardenletConfiguration resource</span>
      apiVersion: gardenlet.config.gardener.cloud/v1alpha1
      kind: GardenletConfiguration
      seedConfig: <span style=color:green># Seed template, including spec and parts of the metadata</span>
        metadata:
          labels:
            foo: bar
        spec:
          provider:
            type: gcp
            region: europe-west1
          taints:
          - key: seed.gardener.cloud/protected
          ...
      controllers:
        shoot:
          concurrentSyncs: 20
      featureGates:
        CachedRuntimeClients: <span style=color:#00f>true</span>
      ...
    bootstrap: BootstrapToken
    mergeWithParent: <span style=color:#00f>true</span>
</code></pre></div><h3 id=managedseed-controller>ManagedSeed Controller</h3><p>ManagedSeeds are reconciled by a new <em>managed seed controller</em> in <code>gardenlet</code>. Its implementation is very similar to the current <a href=https://github.com/gardener/gardener/blob/master/pkg/gardenlet/controller/shoot/seed_registration_control.go>seed registration controller</a>, and in fact could be regarded as a refactoring of the latter, with the difference that it uses the <code>ManagedSeed</code> resource rather than the <code>use-as-seed</code> annotation on a Shoot. The <code>gardenlet</code> only reconciles ManagedSeeds that refer to Shoots scheduled on Seeds the <code>gardenlet</code> is responsible for.</p><p>Once this controller is considered sufficiently stable, the current <code>use-as-seed</code> annotation and the controller mentioned above should be marked as deprecated and eventually removed.</p><p>A <code>ManagedSeed</code> that is in use by shoots cannot be deleted, unless the shoots are either deleted or moved to other seeds first. The managed seed controller ensures that this is the case by only allowing a ManagedSeed to be deleted if its Seed has been already deleted.</p><h3 id=managedseed-admission-plugins>ManagedSeed Admission Plugins</h3><p>In addition to the managed seed controller mentioned above, new <code>gardener-apiserver</code> admission plugins should be introduced to properly validate the creation and update of ManagedSeeds, as well as the deletion of shoots registered as seeds. These plugins should ensure that:</p><ul><li>A <code>Shoot</code> that is being referred to by a <code>ManagedSeed</code> cannot be deleted.</li><li>Certain <code>Seed</code> spec fields, for example the provider type and region, networking CIDRs for pods, services, and nodes, etc., are the same as (or compatible with) the corresponding <code>Shoot</code> spec fields of the shoot that is being registered as seed.</li><li>If such <code>Seed</code> spec fields are omitted or empty, the plugins should supply proper defaults based on the values in the <code>Shoot</code> resource.</li></ul><h3 id=provider-specific-seed-bootstrapping-actions>Provider-specific Seed Bootstrapping Actions</h3><p>Bootstrapping a new seed might require additional provider-specific actions to the ones performed automatically by the managed seed controller. For example, on Azure this might include getting a new subscription, extending quotas, etc. This could eventually be automated by introducing an extension mechanism for the Gardener seed bootstrapping flow, to be handled by a new type of controller in the provider extensions. However, such an extension mechanism is not in the scope of this proposal and might require a separate GEP.</p><p>One idea that could be further explored is the use <em>shoot readiness gates</em>, similar to Kubernetes <a href=https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate>pod readiness gates</a>, in order to control whether a Shoot is considered <code>Ready</code> before it could be registered as a Seed. A provider-specific extension could set the special condition that is specified as a readiness gate to <code>True</code> only after it has successfully performed the provider-specific actions needed.</p><h3 id=changes-to-existing-controllers>Changes to Existing Controllers</h3><p>Since the Shoot registration as a Seed is decoupled from the Shoot reconciliation, existing <code>gardenlet</code> controllers would not have to be changed in order to properly support ManagedSeeds. The main change to <code>gardenlet</code> that would be needed is introducing the new <em>managed seed controller</em> mentioned above, and possibly retiring the old one at some point. In addition, the Shoot controller would need to be adapted as it currently performs certain actions differently if the shoot has a &ldquo;shooted seed&rdquo;.</p><p>The introduction of the <code>ManagedSeed</code> resource would also require no changes to existing <code>gardener-controller-manager</code> controllers that operate on Shoots (for example, shoot hibernation and maintenance controllers).</p><h2 id=managedseedsets>ManagedSeedSets</h2><p>Similarly to a <a href=https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>, the purpose of a ManagedSeedSet is to maintain a stable set of replica <a href=#managedseeds>ManagedSeeds</a> available at any given time. As such, it is used to guarantee the availability of a specified number of identical ManagedSeeds, on an equal number of identical Shoots.</p><h3 id=managedseedset-resource>ManagedSeedSet Resource</h3><p>The <code>ManagedSeedSet</code> resource has a <code>selector</code> field that specifies how to identify ManagedSeeds it can acquire, a number of <code>replicas</code> indicating how many ManagedSeeds (and their corresponding Shoots) it should be maintaining, and a two templates:</p><ul><li>A ManagedSeed template (<code>template</code>) specifying the data of new ManagedSeeds it should create to meet the number of replicas criteria.</li><li>A Shoot template (<code>shootTemplate</code>) specifying the data of new Shoots it should create to host the ManagedSeeds.</li></ul><p>A ManagedSeedSet then fulfills its purpose by creating and deleting ManagedSeeds (and their corresponding Shoots) as needed to reach the desired number.</p><p>A ManagedSeedSet is linked to its ManagedSeeds and Shoots via the <code>metadata.ownerReferences</code> field, which specifies what resource the current object is owned by. All ManagedSeeds and Shoots acquired by a ManagedSeedSet have their owning ManagedSeedSet&rsquo;s identifying information within their <code>ownerReferences</code> field.</p><p>Example <code>ManagedSeedSet</code> resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: seedmanagement.gardener.cloud/v1alpha1
kind: ManagedSeedSet
metadata:
  name: crazy-botany
  namespace: garden
spec:
  replicas: 3
  selector:
    matchLabels:
      foo: bar
  updateStrategy:
    type: RollingUpdate <span style=color:green># Update strategy, must be `RollingUpdate`</span>
    rollingUpdate:
      partition: 2 <span style=color:green># Only update the last replica (#2), assuming there are no gaps (&#34;rolling out a canary&#34;)</span>
  template: <span style=color:green># ManagedSeed template, including spec and parts of the metadata</span>
    metadata:
      labels:
        foo: bar
    spec: 
      <span style=color:green># shoot.name is not specified since it&#39;s filled automatically by the controller</span>
      seedTemplate: <span style=color:green># Either a seed or a gardenlet section must be specified, see above</span>
        metadata:
          labels:
            foo: bar
        provider:
          type: gcp
          region: europe-west1
        taints:
        - key: seed.gardener.cloud/protected
        ...
  shootTemplate: <span style=color:green># Shoot template, including spec and parts of the metadata</span>
    metadata:
      labels:
        foo: bar
    spec:
      cloudProfileName: gcp
      secretBindingName: shoot-operator-gcp
      region: europe-west1
      provider:
        type: gcp
      ...
</code></pre></div><h3 id=managedseedset-controller>ManagedSeedSet Controller</h3><p>ManagedSeedSets are reconciled by a new <em>managed seed set controller</em> in <code>gardener-controller-manager</code>. During the reconciliation this controller creates and deletes ManagedSeeds and Shoots in response to changes to the <code>replicas</code> and <code>selector</code> fields.</p><p><strong>Note:</strong> The introduction of the <code>ManagedSeedSet</code> resource would not require any changes to <code>gardenlet</code> or to existing <code>gardener-controller-manager</code> controllers.</p><h3 id=managing-managedseed-updates>Managing ManagedSeed Updates</h3><p>To manage ManagedSeed updates, we considered two possible approaches:</p><ul><li>A ManagedSeedSet, similarly to a ReplicaSet, does not manage updates to its replicas in any way. In the future, we might introduce ManagedSeedDeployments, a higher-level concept that manages ManagedSeedSets and provides declarative updates to ManagedSeeds along with other useful features, similarly to a <a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/>Deployment</a>. Such a mechanism would involve creating new ManagedSeedSets, and therefore new seeds, behind the scenes, and moving existing shoots to them.</li><li>A ManagedSeedSet does manage updates to its replicas, similarly to a <a href=https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>. Updates are performed &ldquo;in-place&rdquo;, without creating new seeds and moving existing shoots to them. Such a mechanism could also take advantage of other StatefulSet features, such as ordered rolling updates and phased rollouts.</li></ul><p>There is an important difference between seeds and pods or nodes in that seeds are more &ldquo;heavyweight&rdquo; and therefore updating a set of seeds by introducing new seeds and moving shoots to them tends to be much more complex, time-consuming, and prone to failures compared to updating the seeds &ldquo;in place&rdquo;. Furthermore, updating seeds in this way depends on a mature implementation of <a href=/docs/gardener/proposals/07-shoot-control-plane-migration/>GEP-7: Shoot Control Plane Migration</a>, which is not available right now. Due to these considerations, we favor the second approach over the first one.</p><h4 id=managedseed-identity-and-order>ManagedSeed Identity and Order</h4><p>A StatefulSet manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. It maintains a <em>stable identity</em> (including network identity) for each of their Pods. These pods are created from the same spec, but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling.</p><p>A StatefulSet achieves the above by associating each replica with an <em>ordinal number</em>. With n replicas, these ordinal numbers range from 0 to n-1. When scaling out, newly added replicas always have ordinal numbers larger than those of previously existing replicas. When scaling in, it is the replicas with the largest original numbers that are removed.</p><p>Besides stable identity and persistent storage, these ordinal numbers are also used to implement the following StatefulSet features:</p><ul><li>Ordered, graceful deployment and scaling.</li><li>Ordered, automated rolling updates. Such rolling updates can be <em>partitioned</em> (limited to replicas with ordinal numbers greater than or equal to the &ldquo;partition&rdquo;) to achieve <em>phased rollouts</em>.</li></ul><p>A ManagedSeedSet, unlike a StatefulSet, does not need to maintain a stable identity for its ManagedSeeds. Furthermore, it would not be practical to always remove the replicas with the largest ordinal numbers when scaling in, since the corresponding seeds may have shoots scheduled onto them, while other seeds, with lower ordinals, may have fewer shoots (or none), and therefore be much better candidates for being removed.</p><p>On the other hand, it would be beneficial if a ManagedSeedSet, like a StatefulSet, provides ordered deployment and scaling, ordered rolling updates, and phased rollouts. The main advantage of these features is that a deployment or update failure would affect fewer replicas (ideally just one), containing any potential damage and making the situation easier to handle, thus achieving some of the goals stated in <a href=https://github.com/gardener/gardener/issues/87>Issue #87</a>. They could also help to contain seed rolling updates outside business hours.</p><p>Based on the above considerations, we propose the following mechanism for handling ManagedSeed identity and order:</p><ul><li>A ManagedSeedSet uses <em>ordinal numbers generated by an increasing sequence</em> to identify ManagedSeeds and Shoots it creates and manages. These numbers always start from 0 and are incremented by 1 for each newly added replica.</li><li>Replicas (both ManagedSeeds and Shoots) are named after the ManagedSeedSet with the ordinal number appended. For example, for a ManagedSeedSet named <code>test</code> its replicas are named <code>test-0</code>, <code>test-1</code>, etc.</li><li>Gaps in the sequence created by removing replicas with ordinal numbers in the middle of the range are never filled in. A newly added replica always receives a number that is not only free, but also unique to itself. For example, if there are 2 replicas named <code>test-0</code> and <code>test-1</code> and any one of them is removed, a newly added replica will still be named <code>test-2</code>.</li></ul><p>Although such ordinal numbers can also provide some form of stable identity, in this case it is much more important that they can provide a predictable ordering for deployments and updates, and can also be used to partition rolling updates similarly to StatefulSet ordinal numbers.</p><h4 id=update-strategies>Update Strategies</h4><p>The ManagedSeedSet&rsquo;s <code>.spec.updateStrategy</code> field allows configuring automated rolling updates for the ManagedSeeds and Shoots in a ManagedSeedSet.</p><p><strong>Rolling Updates</strong></p><p>The <code>RollingUpdate</code> update strategy implements automated, rolling update for the ManagedSeeds and Shoots in a ManagedSeedSet. With this strategy, the ManagedSeedSet controller will update each ManagedSeed and Shoot in the ManagedSeedSet. It will proceed from the largest number to the smallest, updating each ManagedSeed and its corresponding Shoot one at a time. It will wait until both the Shoot and the Seed of an updated ManagedSeed are Ready prior to updating its predecessor.</p><p>As a further improvement upon the above, the controller could check not only the ManagedSeeds and their corresponding Shoots for readiness, but also the Shoots scheduled onto these ManagedSeeds. The rollout would then only continue if no more than X percent of these Shoots are not reconciled and Ready. Since checking all these additional conditions might require some complex logic, it should be performed by an independent <em>managed seed care controller</em> that updates the ManagedSeed resource with the readiness of its Seed and all Shoots scheduled onto the Seed.</p><p>Note that unlike a StatefulSet, an <code>OnDelete</code> update strategy is not supported.</p><p><strong>Partitions</strong></p><p>The <code>RollingUpdate</code> update strategy can be partitioned, by specifying a <code>.spec.updateStrategy.rollingUpdate.partition</code>. If a partition is specified, only ManagedSeeds and Shoots with ordinals greater than or equal to the partition will be updated when any of the ManagedSeedSet&rsquo;s templates is updated. All remaining ManagedSeeds and Shoots will not be updated. If a ManagedSeedSet&rsquo;s <code>.spec.updateStrategy.rollingUpdate.partition</code> is greater than the largest ordinal number in use by a replica, updates to its templates will not be propagated to its replicas (but newly added replicas may still use the updated templates depending on the partition value).</p><h4 id=keeping-track-of-revision-history-and-performing-rollbacks>Keeping Track of Revision History and Performing Rollbacks</h4><p>Similarly to a StatefulSet, the ManagedSeedSet controller uses <a href=https://pkg.go.dev/k8s.io/api/apps/v1#ControllerRevision>ControllerRevisions</a> to keep track of the revision history, and <code>controller-revision-hash</code> labels to maintain an association between a ManagedSeed or a Shoot and the concrete template revisions based on which they were created or last updated. These are used for the following purposes:</p><ul><li>During an update, determine which replicas are still not on the latest revision and therefore should be updated.</li><li>Display the revision history of a ManagedSeedSet via <code>kubectl rollout history</code>.</li><li>Roll back all ManagedSeedSet replicas to a specific revision via <code>kubectl rollout undo</code></li></ul><p><strong>Note:</strong> The above <code>kubectl rollout</code> commands will not work with custom resources such as ManagedSeedSets out of the box (the <a href=https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout>documentation</a> says explicitly that valid resource types are only deployments, daemonsets, and statefulsets), but it should be possible to eventually support such commands for ManagedSeedSets via a <a href=https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/>kubectl plugin</a>.</p><h3 id=scaling-in-managedseedsets>Scaling-in ManagedSeedSets</h3><p>Deleting ManagedSeeds in response to decreasing the replicas of a ManagedSeedSet deserves special attention for two reasons:</p><ul><li>A seed that is already in use by shoots cannot be deleted, unless the shoots are either deleted or moved to other seeds first.</li><li>When there are more empty seeds than requested for deletion, determining which seeds to delete might not be as straightforward as with pods or nodes.</li></ul><p>The above challenges could be addressed as follows:</p><ul><li>In order to scale in a ManagedSeedSet successfully, there should be at least as many empty ManagedSeeds as the difference between the old and the new replicas. In some cases, the user might need to ensure that this is the case by draining some seeds manually before decreasing the replicas field.</li><li>It should be possible to protect ManagedSeeds from deletion even if they are empty, perhaps via an annotation such as <code>seedmanagement.gardener.cloud/protect-from-deletion</code>. Such seeds are not taken into account when determining whether the scale in operation can succeed.</li><li>The decision which seeds to delete among the ManagedSeeds that are empty and not protected should be based on hints, perhaps again in the form of annotations, that could be added manually by the user, as well as other factors, see <a href=#prioritizing-managedseed-deletion>Prioritizing ManagedSeed Deletion</a>.</li></ul><h4 id=prioritizing-managedseed-deletion>Prioritizing ManagedSeed Deletion</h4><p>To help the controller decide which empty ManagedSeeds are to be deleted first, the user could manually annotate ManagedSeeds with a <em>seed priority annotation</em> such as <code>seedmanagement.gardener.cloud/priority</code>. ManagedSeeds with lower priority are more likely to be deleted first. If not specified, a certain default value is assumed, for example 3.</p><p>Besides this annotation, the controller should take into account also other factors, such as the current seed conditions (<code>NotReady</code> should be preferred for deletion over <code>Ready</code>), as well as its age (older should be preferred for deletion over newer).</p><h2 id=auto-scaling-seeds>Auto-scaling Seeds</h2><p>The most interesting and advanced automated seed management feature is making sure that a Garden cluster has enough seeds registered to schedule new shoots (and, in the future, reschedule shoots from drained seeds) without exceeding the seeds capacity for shoots, but not more than actually needed at any given moment. This would involve introducing an auto-scaling mechanism for seeds in Garden clusters.</p><p>The proposed solution builds upon the ideas introduced earlier. The <a href=#managedseeds><code>ManagedSeedSet</code></a> resource (and in the future, also the <code>ManagedSeedDeployment</code> resource) could have a <code>scale</code> subresource that changes the <code>replicas</code> field. This would allow a new &ldquo;seed autoscaler&rdquo; controller to scale these resources via a special &ldquo;autoscaler&rdquo; resource (for example <code>SeedAutoscaler</code>), similarly to how the Kubernetes <a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscaler</a> controller scales pods, as described in <a href=https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>Horizontal Pod Autoscaler Walkthrough</a>.</p><p>The primary metric used for scaling should be the number of shoots already scheduled onto that seed either as a direct value or as a percentage of the seed&rsquo;s capacity for shoots introduced in <a href=#ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring Seeds Capacity for Shoots Is Not Exceeded</a> (<em>utilization</em>). Later, custom metrics based on other resources, including provider-specific resources, could be considered as well.</p><p><strong>Note:</strong> Even if the controller is called <em>Horizontal Pod Autoscaler</em>, it is capable of scaling any resource with a <code>scale</code> subresource, using any custom metric. Therefore, initially it was proposed to use this controller directly. However, a number of important drawbacks were identified with this approach, and so it is no longer proposed here.</p><h3 id=seedautoscaler-resource>SeedAutoscaler Resource</h3><p>The SeedAutoscaler automatically scales the number of <a href=#managedseeds>ManagedSeeds</a> in a <a href=#managedseedsets>ManagedSeedSet</a> based on observed resource utilization. The resource could be any resource that is tracked via the <code>capacity</code> and <code>allocatable</code> fields in the Seed status, including in particular the number of shoots already scheduled onto the seed.</p><p>The SeedAutoscaler is implemented as a custom resource and a new controller. The resource determines the behavior of the controller. The <code>SeedAutoscaler</code> resource has a <code>scaleTargetRef</code> that specifies the target resource to be scaled, the minimum and maximum number of replicas, as well as a list of metrics. The only supported metric type initially is <code>Resource</code> for resources that are tracked via the <code>capacity</code> and <code>allocatable</code> fields in the Seed status. The resource target can be of type <code>Utilization</code> or <code>AverageValue</code>.</p><p>Example <code>SeedAutoscaler</code> resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: seedmanagement.gardener.cloud/v1alpha1
kind: SeedAutoscaler
metadata:
  name: crazy-botany
  namespace: garden
spec:
  scaleTargetRef:
    apiVersion: seedmanagement.gardener.cloud/v1alpha1
    kind: ManagedSeedSet
    name: crazy-botany
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Resource <span style=color:green># Only Resource is supported</span>
    resource:
      name: shoots
      target:
        type: Utilization <span style=color:green># Utilization or AverageValue</span>
        averageUtilization: 50
</code></pre></div><h3 id=seedautoscaler-controller>SeedAutoscaler Controller</h3><p><code>SeedAutoscaler</code> resources are reconciled by a new <em>seed autoscaler controller</em>, either in <code>gardener-controller-manager</code> or out-of-tree, similarly to <a href=https://github.com/gardener/autoscaler>cluster-autoscaler</a>. The controller periodically adjusts the number of replicas in a ManagedSeedSet to match the observed average resource utilization to the target specified by user.</p><p><strong>Note:</strong> The SeedAutoscaler controller should perhaps not be limited to evaluating only metrics, it could also take into account also taints, label selectors, etc. This is not yet reflected in the example <code>SeedAutoscaler</code> resource above. Such details are intentionally not specified in this GEP, they should be further explored in the issues created to track the actual implementation.</p><h4 id=evaluating-metrics-for-autoscaling>Evaluating Metrics for Autoscaling</h4><p>The metrics used by the controller, for example the <code>shoots</code> metric above, could be evaluated in one of the following ways:</p><ul><li>Directly, by looking at the <code>capacity</code> and <code>allocatable</code> fields in the Seed status and comparing to the actual resource consumption calculated by simply counting all shoots that meet a certain criteria (e.g. shoots that are scheduled onto the seed), then taking an average over all seeds in the set.</li><li>By sampling existing metrics exported for example by <a href=https://github.com/gardener/gardener-metrics-exporter><code>gardener-metrics-exporter</code></a>.</li></ul><p>The second approach decouples the seed autoscaler controller from the actual metrics evaluation, and therefore allows plugging in new metrics more easily. It also has the advantage that the exported metrics could also be used for other purposes, e.g. for triggering Prometheus alerts or building Grafana dashboards. It has the disadvantage that the seed autoscaler controller would depend on the metrics exporter to do its job properly.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-37ede2ec02b1dbd34b37081524495a25>7.13 - 17 Shoot Control Plane Migration Bad Case</h1><h1 id=shoot-control-plane-migration-bad-case-scenario>Shoot Control Plane Migration &ldquo;Bad Case&rdquo; Scenario</h1><p>The <a href=/docs/gardener/proposals/07-shoot-control-plane-migration/#migration-workflow>migration flow</a> described as part of <a href=/docs/gardener/proposals/07-shoot-control-plane-migration/>GEP-7</a> can only be executed if both the Garden cluster and source seed cluster are healthy, and <code>gardenlet</code> in the source seed cluster can connect to the Garden cluster. In this case, <code>gardenlet</code> can directly scale down the shoot&rsquo;s control plane in the source seed, after checking the <code>spec.seedName</code> field.</p><p>However, there might be situations in which <code>gardenlet</code> in the source seed cluster can&rsquo;t connect to the Garden cluster and determine that <code>spec.seedName</code> has changed. Similarly, the connection to the seed <code>kube-apiserver</code> could also be broken. This might be caused by issues with the seed cluster itself. In other situations, the migration flow steps in the source seed might have started but might not be able to finish successfully. In all such cases, it should still be possible to migrate a shoot&rsquo;s control plane to a different seed, even though executing the migration flow steps in the source seed might not be possible. The potential &ldquo;split brain&rdquo; situation caused by having the shoot&rsquo;s control plane components attempting to reconcile the shoot resources in two different seeds must still be avoided, by ensuring that the shoot&rsquo;s control plane in the source seed is deactivated before it is activated in the destination seed.</p><p>The mechanisms and adaptations described below have been tested as part of a PoC prior to describing them here.</p><h2 id=owner-election--copying-snapshots>Owner Election / Copying Snapshots</h2><p>To achieve the goals outlined above, an &ldquo;owner election&rdquo; (or rather, &ldquo;ownership passing&rdquo;) mechanism is introduced to ensure that the source and destination seeds are able to successfully negotiate a single &ldquo;owner&rdquo; during the migration. This mechanism is based on special <em>owner DNS records</em> that uniquely identify the seed that currently hosts the shoot&rsquo;s control plane (&ldquo;owns&rdquo; the shoot).</p><p>For example, for a shoot named <code>i500152-gcp</code> in project <code>dev</code> that uses an internal domain suffix <code>internal.dev.k8s.ondemand.com</code> and is scheduled on a seed with an identity <code>shoot--i500152--gcp2-0841c87f-8db9-4d04-a603-35570da6341f-sap-landscape-dev</code>, the owner DNS record is a TXT record with a domain name <code>owner.i500152-gcp.dev.internal.dev.k8s.ondemand.com</code> and a single value <code>shoot--i500152--gcp2-0841c87f-8db9-4d04-a603-35570da6341f-sap-landscape-dev</code>. The owner DNS record is created and maintained by reconciling an <code>owner</code> DNSRecord resource, if the recently introduced DNSRecords feature is enabled via the <code>UseDNSRecords</code> feature gate.</p><p>Unlike other extension resources, the <code>owner</code> DNSRecord resource is not reconciled every time the shoot is reconciled, but only when the resource is created. Therefore, the owner DNS record value (the owner ID) is updated only when the shoot is migrated to a different seed. For more information, see <a href=https://github.com/gardener/gardener/pull/4307>Add handling of owner DNSRecord resources</a>.</p><p>The owner DNS record domain name and owner ID are passed to components that need to perform ownership checks, such as the <code>backup-restore</code> container of the <code>etcd-main</code> StatefulSet, and all extension controllers. These components then check regularly whether the actual owner ID (the value of the record) matches the passed ID. If they don&rsquo;t, the ownership check is considered failed, which causes the special behavior described below.</p><p><strong>Note:</strong> A previous revision of this document proposed using &ldquo;sync objects&rdquo; written to and read from the backup container of the source seed as JSON files by the <code>etcd-backup-restore</code> processes in both seeds. With the introduction of owner DNS records such sync objects are no longer needed.</p><p>For the destination seed to actually become the owner, it needs to acquire the shoot&rsquo;s etcd data by copying the final full snapshot (and potentially also older snapshots) from the backup container of the source seed.</p><p>The mechanism to copy the snapshots and pass the ownership from the source to the destination seed consists of the following steps:</p><ol><li><p>The reconciliation flow (&ldquo;restore&rdquo; phase) is triggered in the destination seed without first executing the migration flow in the source seed (or perhaps it was executed, but it failed, and its state is currently unknown).</p></li><li><p>The <code>owner</code> DNSRecord resource is created in the destination seed. As a result, the actual owner DNS record is updated with the destination seed ID. From this point, ownership checks by the <code>etcd-backup-restore</code> process and <a href=#extension-controller-watchdogs>extension controller watchdogs</a> in the source seed will fail, which will cause the special behavior described below.</p></li><li><p>An additional &ldquo;source&rdquo; backup entry referencing the source seed backup bucket is deployed to the Garden cluster and the destination seed and reconciled by the backup entry controller. As a result, a secret with the appropriate credentials for accessing the source seed backup container named <code>source-etcd-backup</code> is created in the destination seed. The normal backup entry (referencing the destination seed backup container) is also deployed and reconciled, as usual, resulting in the usual <code>etcd-backup</code> secret being created.</p></li><li><p>A special &ldquo;copy&rdquo; version of the <code>etcd-main</code> Etcd resource is deployed to the destination seed. In its <code>backup</code> section, this resource contains a <code>sourceStore</code> in addition to the usual <code>store</code>, which contains the parameters needed to use the source seed backup container, such as its name and the secret created in the previous step.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  backup:
    ...
    store:
      container: 408740b8-6491-415e-98e6-76e92e5956ac
      secretRef:
        name: etcd-backup
      ...
    sourceStore:
      container: d1435fea-cd5e-4d5b-a198-81f4025454ff
      secretRef:
        name: source-etcd-backup
      ...
</code></pre></div></li><li><p>The <code>etcd-druid</code> in the destination seed reconciles the above resource by deploying a <code>etcd-copy</code> Job that contains a single <code>backup-restore</code> container. It executes the newly introduced <code>copy</code> command of <code>etcd-backup-restore</code> that copies the snapshots from the source to the destination backup container.</p></li><li><p>Before starting the copy itself, the <code>etcd-backup-restore</code> process in the destination seed checks if a final full snapshot (a full snapshot marked as <code>final=true</code>) exists in the backup container. If such a snapshot is not found, it waits for it to appear in order to proceed. This waiting is up to a certain timeout that should be sufficient for a full snapshot to be taken; after this timeout has elapsed, it proceeds anyway, and the reconciliation flow continues from step 9. As described in <a href=#handling-inability-to-access-the-backup-container>Handling Inability to Access the Backup Container</a> below, this is safe to do.</p></li><li><p>The <code>etcd-backup-restore</code> process in the source seed detects that the owner ID in the owner DNS record is different from the expected owner ID (because it was updated in step 2) and switches to a special &ldquo;final snapshot&rdquo; mode. In this mode the regular snapshotter is stopped, the readiness probe of the main <code>etcd</code> container starts returning 503, and one final full snapshot is taken. This snapshot is marked as <code>final=true</code> in order to ensure that it&rsquo;s only taken once, and in order to enable the <code>etcd-backup-restore</code> process in the destination seed to find it (see step 6).</p><p><strong>Note:</strong> While testing our PoC, we noticed that simply making the readiness probe of the main <code>etcd</code> container fail doesn&rsquo;t terminate the existing open connections from <code>kube-apiserver</code> to <code>etcd</code>. For this to happen, either the <code>kube-apiserver</code> or the <code>etcd</code> process has to be restarted at least once. Therefore, when the snapshotter is stopped because an ownership change has been detected, the main <code>etcd</code> process is killed (using <code>SIGTERM</code> to allow graceful termination) to ensure that any open connections from <code>kube-apiserver</code> are terminated. For this to work, the 2 containers must <a href=https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/>share the process namespace</a>.</p></li><li><p>Since the <code>kube-apiserver</code> process in the source seed is no longer able to connect to <code>etcd</code>, all shoot control plane controllers (<code>kube-controller-manager</code>, <code>kube-scheduler</code>, <code>machine-controller-manager</code>, etc.) and extension controllers reconciling shoot resources in the source seed that require a connection to the shoot in order to work start failing. All remaining extension controllers are prevented from reconciling shoot resources via the <a href=#extension-controller-watchdogs>watchdogs</a> mechanism. At this point, the source seed has effectively lost its ownership of the shoot, and it is safe for the destination seed to assume the ownership.</p></li><li><p>After the <code>etcd-backup-restore</code> process in the destination seed detects that a final full snapshot exists, it copies all snapshots (or a subset of all snapshots) from the source to the destination backup container. When this is done, the Job finishes successfully which signals to the reconciliation flow that the snapshots have been copied.</p><p><strong>Note:</strong> To save time, only the final full snapshot taken in step 6, or a subset defined by some criteria, could be copied, instead of all snapshots.</p></li><li><p>The special &ldquo;copy&rdquo; version of the <code>etcd-main</code> Etcd resource is deleted from the source seed, and as a result the <code>etcd-copy</code> Job is also deleted by <code>etcd-druid</code>.</p></li><li><p>The additional &ldquo;source&rdquo; backup entry referencing the source seed backup container is deleted from the Garden cluster and the destination seed. As a result, its corresponding <code>source-etcd-backup</code> secret is also deleted from the destination seed.</p></li><li><p>From this point, the reconciliation flow proceeds as already described in <a href=/docs/gardener/proposals/07-shoot-control-plane-migration/>GEP-7</a>. This is safe, since the source seed cluster is no longer able to interfere with the shoot.</p></li></ol><h2 id=handling-inability-to-access-the-backup-container>Handling Inability to Access the Backup Container</h2><p>The mechanism described above assumes that the <code>etcd-backup-restore</code> process in the source seed is able to access its backup container in order to take snapshots. If this is not the case, but an ownership change was detected, the <code>etcd-backup-restore</code> process still sets the readiness probe status of the main <code>etcd</code> container to 503, and kills the main <code>etcd</code> process as described above to ensure that any open connections from <code>kube-apiserver</code> are terminated. This effectively deactivates the source seed control plane to ensure that the ownership of the shoot can be passed to a different seed.</p><p>Because of this, <code>etcd-backup-restore</code> process in the destination seed responsible for copying the snapshots can avoid waiting forever for a final full snapshot to appear. Instead, after a certain timeout has elapsed, it can proceed with the copying. In this situation, whatever latest snapshot is found in the source backup container will be restored in the destination seed. The shoot is still migrated to a healthy seed at the cost of losing the etcd data that accumulated between the point in time when the connection to the source backup container was lost, and the point in time when the source seed cluster was deactivated.</p><p>When the connection to the backup container is restored in the source seed, a final full snapshot will be eventually taken. Depending on the stage of the restoration flow in the destination seed, this snapshot may be copied to the destination seed and restored, or it may simply be ignored since the snapshots have already been copied.</p><h2 id=handling-inability-to-resolve-the-owner-dns-record>Handling Inability to Resolve the Owner DNS Record</h2><p>The situation when the owner DNS record cannot be resolved is treated similarly to a failed ownership check: the <code>etcd-backup-restore</code> process sets the readiness probe status of the main <code>etcd</code> container to 503, and kills the main <code>etcd</code> process as described above to ensure that any open connections from <code>kube-apiserver</code> are terminated, effectively deactivating the source seed control plane. The final full snapshot is not taken in this case to ensure that the control plane can be re-activated if needed.</p><p>When the owner DNS record can be resolved again, the following 2 situations are possible:</p><ul><li>If the source seed is still the owner of the shoot, the <code>etcd-backup-restore</code> process will set the readiness probe status of the main <code>etcd</code> container to 200, so <code>kube-apiserver</code> will be able to connect to <code>etcd</code> and the source seed control plane will be activated again.</li><li>If the source seed is no longer the owner of the shoot, the etcd readiness probe will continue to fail, and the source seed control plane will remain inactive. In addition, the final full snapshot will be taken at this time, for the same reason as described in <a href=#handling-inability-to-access-the-backup-container>Handling Inability to Access the Backup Container</a>.</li></ul><p><strong>Note:</strong> We expect that actual DNS outages are extremely unlikely. A more likely reason for an inability to resolve a DNS record could be network issues with the underlying infrastructure. In such cases, the shoot would usually not be usable / reachable anyway, so deactivating its control plane would not cause a worse outage.</p><h2 id=migration-flow-adaptations>Migration Flow Adaptations</h2><p>Certain changes to the migration flow are needed in order to ensure that it is compatible with the <a href=#owner-election--copying-snapshots>owner election</a> mechanism described above. Instead of taking a full snapshot of the source seed etcd, the flow deletes the owner DNS record by deleting the <code>owner</code> DNSRecord resource. This causes the ownership check by <code>etcd-backup-restore</code> to fail, and the final full snapshot to be eventually taken, so the migration flow waits for a final full snapshot to appear as the last step before deleting the shoot namespace in the source seed. This ensures that the reconciliation flow described above will find a final full snapshot waiting to be copied at step 6.</p><p>Checking for the final full snapshot is performed by calling the already existing <code>etcd-backup-restore</code> endpoint <code>snapshot/latest</code>. This is possible, since the <code>backup-restore</code> container is always running at this point.</p><p>After the final full snapshot has been taken, the readiness probe of the main <code>etcd</code> container starts failing, which means that if the migration flow is retried due to an error it must skip the step that waits for <code>etcd-main</code> to become ready. To determine if this is the case, a check whether the final full snapshot has been taken or not is performed by calling the same <code>etcd-backup-restore</code> endpoint, e.g. <code>snapshot/latest</code>. This is possible if the <code>etcd-main</code> Etcd resource exists with non-zero replicas. Otherwise:</p><ul><li>If the resource doesn&rsquo;t exist, it must have been already deleted, so the final full snapshot n must have been already taken.</li><li>If it exists with zero replicas, the shoot must be hibernated, and the migration flow must have never been executed (since it scales up etcd as one of its first steps), so the final full snapshot must not have been taken yet.</li></ul><h2 id=extension-controller-watchdogs>Extension Controller Watchdogs</h2><p>Some extension controllers will stop reconciling shoot resources after the connection to the shoot&rsquo;s <code>kube-apiserver</code> is lost. Others, most notably the infrastructure controller, will not be affected. Even though new shoot reconciliations won&rsquo;t be performed by <code>gardenlet</code>, such extension controllers might be stuck in a retry loop triggered by a previous reconciliation, which may cause them to reconcile their resources after <code>gardenlet</code> has already stopped reconciling the shoot. In addition, a reconciliation started when the seed still owned the shoot might take some time and therefore might still be running after the ownership has changed. To ensure that the source seed is completely deactivated, an additional safety mechanism is needed.</p><p>This mechanism should handle the following interesting cases:</p><ul><li><code>gardenlet</code> cannot connect to the Garden <code>kube-apiserver</code>. In this case it cannot fetch shoots and therefore does not know if control plane migration has been triggered. Even though <code>gardenlet</code> will not trigger new reconciliations, extension controllers could still attempt to reconcile their resources if they are stuck a retry loop from a previous reconciliation, and already running reconciliations will not be stopped.</li><li><code>gardenlet</code> cannot connect to the seed&rsquo;s <code>kube-apiserver</code>. In this case <code>gardenlet</code> knows if migration has been triggered, but it will not start shoot migration or reconciliation as it will first check the seed conditions and try to update the <code>Cluster</code> resource, both of which will fail. Extension controllers could still be able to connect to the seed&rsquo;s <code>kube-apiserver</code> (if they are not running where <code>gardenlet</code> is running), and similarly to the previous case, they could still attempt to reconcile their resources.</li><li>The seed components (<code>etcd-druid</code>, extension controllers, etc) cannot connect to the seed&rsquo;s <code>kube-apiserver</code>. In this case extension controllers would not be able to reconcile their resources as they cannot fetch them from the seed&rsquo;s <code>kube-apiserver</code>. When the connection to the <code>kube-apiserver</code> comes back, the controllers might be stuck in a retry loop from a previous reconciliation, or the resources could still be annotated with <code>gardener.cloud/operation=reconcile</code>. This could lead to a race condition depending on who manages to <code>update</code> or <code>get</code> the resources first. If <code>gardenlet</code> manages to update the resources before they are read by the extension controllers, they would be properly updated with <code>gardener.cloud/operation=migrate</code>. Otherwise, they would be reconciled as usual.</li></ul><p><strong>Note:</strong> A previous revision of this document proposed using &ldquo;cluster leases&rdquo; as such an additional safety mechanism. With the introduction of owner DNS records cluster leases are no longer needed.</p><p>The safety mechanism is based on <em>extension controller watchdogs</em>. These are simply additional goroutines that are started when a reconciliation is started by an extension controller. These goroutines perform an ownership check on a regular basis using the owner DNS record, similar to the check performed by the <code>etcd-backup-restore</code> process described above. If the check fails, the watchdog cancels the reconciliation context, which immediately aborts the reconciliation.</p><p><strong>Note:</strong> The <code>dns-external</code> extension controller is the only extension controller that neither needs the shoot&rsquo;s <code>kube-apiserver</code>, nor uses the watchdog mechanism described here. Therefore, this controller will continue reconciling <code>DNSEntry</code> resources even after the source seed has lost the ownership of the shoot. With the PoC, we manually delete the <code>DNSOwner</code> resources from the source seed cluster to prevent this from happening. Eventually, the <code>dns-external</code> controller should be adapted to use the owner DNS records to ensure that it disables itself after the seed has lost the ownership of the shoot. Changes in this direction have already been agreed and relevant PRs proposed.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-790545861fe7f3b616f4d087f63febbb>7.14 - Bastion Management and SSH Key Pair Rotation</h1><h1 id=gep-15-bastion-management-and-ssh-key-pair-rotation>GEP-15: Bastion Management and SSH Key Pair Rotation</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a><ul><li><a href=#involved-components>Involved Components</a></li><li><a href=#ssh-flow>SSH Flow</a></li><li><a href=#resource-example>Resource Example</a></li></ul></li><li><a href=#ssh-key-pair-rotation>SSH Key Pair Rotation</a><ul><li><a href=#rotation-proposal>Rotation Proposal</a></li></ul></li></ul><h2 id=motivation>Motivation</h2><p><code>gardenctl</code> (v1) has the functionality to setup <code>ssh</code> sessions to the targeted shoot cluster (nodes). To this end, infrastructure resources like VMs, public IPs, firewall rules, etc. have to be created. <code>gardenctl</code> will clean up the resources after termination of the <code>ssh</code> session (or rather when the operator is done with her work). However, there were issues in the past where these infrastructure resources were not properly cleaned up afterwards, e.g. due to some error (no retries either). Hence, the proposal is to have a dedicated controller (for each infrastructure) that manages the infrastructure resources and their cleanup. The current <code>gardenctl</code> also re-used the <code>ssh</code> node credentials for the bastion host. While that&rsquo;s possible, it would be safer to rather use personal or generated <code>ssh</code> key pairs to access the bastion host.
The static shoot-specific <code>ssh</code> key pair should be rotated regularly, e.g. once in the maintenance time window. This also means that we cannot create the node VMs anymore with infrastructure public keys as these cannot be revoked or rotated (e.g. in AWS) without terminating the VM itself.</p><p>Changes to the <code>Bastion</code> resource should only be allowed for controllers on seeds that are responsible for it. This cannot be restricted when using custom resources.
The proposal, as outlined below, suggests to implement the necessary changes in the gardener core components and to adapt the <a href=https://github.com/gardener/gardener/issues/1723>SeedAuthorizer</a> to consider <code>Bastion</code> resources that the Gardener API Server serves.</p><h3 id=goals>Goals</h3><ul><li>Operators can request and will be granted time-limited <code>ssh</code> access to shoot cluster nodes via bastion hosts.</li><li>To that end, requestors must present their public <code>ssh</code> key and only this will be installed into <code>sshd</code> on the bastion hosts.</li><li>The bastion hosts will be firewalled and ingress traffic will be permitted only from the client IP of the requestor. Except for traffic on port 22 to the cluster worker nodes, no egress from the bastion is allowed.</li><li>The actual node <code>ssh</code> private key (resp. key pair) will be rotated by Gardener and access to the nodes is only possible with this constantly rotated key pair and not with the personal one that is used only for the bastion host.</li><li>Bastion host and access is granted only for the extent of this operator request (of course multiple <code>ssh</code> sessions are possible, in parallel or repeatedly, but after &ldquo;the time is up&rdquo;, access is no longer possible).</li><li>By these means (personal public key and allow-listed client IP) nobody else can use (a.k.a. impersonate) the requestor (not even other operators).</li><li>Necessary infrastructure resources for <code>ssh</code> access (such as VMs, public IPs, firewall rules, etc.) are automatically created and also terminated after usage, but at the latest after the above mentioned time span is up.</li></ul><h3 id=non-goals>Non-Goals</h3><ul><li>Node-specific access</li><li>Auditability on operating system level (not only auditing the <code>ssh</code> login, but everything that is done on a node and other respective resources, e.g. by using dedicated operating system users)</li><li>Reuse of temporarily created necessary infrastructure resources by different users</li></ul><h2 id=proposal>Proposal</h2><h3 id=involved-components>Involved Components</h3><p>The following is a list of involved components, that either need to be newly introduced or extended if already existing</p><ul><li>Gardener API Server (<code>GAPI</code>)<ul><li>New <code>operations.gardener.cloud</code> API Group</li><li>New resource type <code>Bastion</code>, see <a href=#resource-example>resource example</a> below</li><li>New Admission Webhooks for <code>Bastion</code> resource</li><li><code>SeedAuthorizer</code>: The <code>SeedAuthorizer</code> and dependency graph needs to be extended to consider the <code>Bastion</code> resource <a href=https://github.com/gardener/gardener/tree/master/pkg/admissioncontroller/webhooks/auth/seed/graph>https://github.com/gardener/gardener/tree/master/pkg/admissioncontroller/webhooks/auth/seed/graph</a></li><li>Is configured with <code>timeToLive</code>, the time to add to the current time on each heartbeat</li></ul></li><li><code>gardenlet</code><ul><li>Deploys <code>Bastion</code> CRD under the <code>extensions.gardener.cloud</code> API Group to the Seed, see <a href=#resource-example>resource example</a> below</li><li>Similar to <code>BackupBucket</code>s or <code>BackupEntry</code>, the <code>gardenlet</code> watches the <code>Bastion</code> resource in the garden cluster and creates a seed-local <code>Bastion</code> resource, on which the provider specific bastion controller acts upon</li></ul></li><li><code>gardenctlv2</code> (or any other client)<ul><li>Creates <code>Bastion</code> resource in the garden cluster</li><li>Establishes an <code>ssh</code> connection to a shoot node, using a bastion host as proxy</li><li>Heartbeats / keeps alive the <code>Bastion</code> resource during <code>ssh</code> connection</li></ul></li><li>Gardener extension provider <infra><ul><li>Provider specific bastion controller</li><li>Should be added to gardener-extension-provider-<infra> repos, e.g. <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller>https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller</a></li><li>Has the permission to update the <code>Bastion/status</code> subresource on the seed cluster</li><li>Runs on seed (of course)</li></ul></li><li>Gardener Controller Manager (<code>GCM</code>)<ul><li><code>Bastion</code> heartbeat controller<ul><li>Cleans up <code>Bastion</code> resource on missing heartbeat.</li><li>Is configured with a <code>maxLifetime</code> for the <code>Bastion</code> resource</li></ul></li></ul></li><li>Gardener (RBAC)<ul><li>The project <code>admin</code> role should be extended to allow CRUD operations on the <code>Bastion</code> resource. The <code>gardener.cloud:system:project-member-aggregation</code> <code>ClusterRole</code> needs to be updated accordingly (<a href=https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/charts/application/templates/rbac-user.yaml>https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/charts/application/templates/rbac-user.yaml</a>)</li></ul></li></ul><h3 id=ssh-flow>SSH Flow</h3><ol start=0><li>Users should only get the RBAC permission to <code>create</code> / <code>update</code> <code>Bastion</code> resources for a namespace, if they should be allowed to <code>ssh</code> onto the shoot nodes in this namespace. A project member with <code>admin</code> role will have these permissions.</li><li>User/<code>gardenctlv2</code> creates <code>Bastion</code> resource in garden cluster (see <a href=#resource-example>resource example</a> below)<ul><li>First, gardenctl would figure out the own public IP of the user&rsquo;s machine. Either by calling an external service (gardenctl (v1) uses <a href=https://github.com/gardener/gardenctl/blob/master/pkg/cmd/miscellaneous.go#L226>https://github.com/gardener/gardenctl/blob/master/pkg/cmd/miscellaneous.go#L226</a>) or by calling a binary that prints the public IP(s) to stdout. The binary should be configurable. The result is set under <code>spec.ingress[].ipBlock.cidr</code></li><li>Creates new <code>ssh</code> key pair. The newly created key pair is used only once for each bastion host, so it has a 1:1 relationship to it. It is cleaned up after it is not used anymore, e.g. if the <code>Bastion</code> resource was deleted.</li><li>The public <code>ssh</code> key is set under <code>spec.sshPublicKey</code></li><li>The targeted shoot is set under <code>spec.shootRef</code></li></ul></li><li>GAPI Admission Plugin for the <code>Bastion</code> resource in the garden cluster<ul><li>on creation, sets <code>metadata.annotations["gardener.cloud/created-by"]</code> according to the user that created the resource</li><li>when <code>gardener.cloud/operation: keepalive</code> is set it will be removed by GAPI from the annotations and <code>status.lastHeartbeatTimestamp</code> will be set with the current timestamp. The <code>status.expirationTimestamp</code> will be calculated by taking the last heartbeat timestamp and adding <code>x</code> minutes (configurable, default <code>60</code> Minutes).</li><li>validates that only the creator of the bastion (see <code>gardener.cloud/created-by</code> annotation) can update <code>spec.ingress</code></li><li>validates that a Bastion can only be created for a Shoot if that Shoot is already assigned to a Seed</li><li>sets <code>spec.seedName</code> and <code>spec.providerType</code> based on the <code>spec.shootRef</code></li></ul></li><li><code>gardenlet</code><ul><li>Watches <code>Bastion</code> resource for own seed under api group <code>operations.gardener.cloud</code> in the garden cluster</li><li>Creates <code>Bastion</code> custom resource under api group <code>extensions.gardener.cloud/v1alpha1</code> in the seed cluster<ul><li>Populates bastion user data under field under <code>spec.userData</code> similar to <a href=https://github.com/gardener/gardenctl/blob/1e3e5fa1d5603e2161f45046ba7c6b5b4107369e/pkg/cmd/ssh.go#L160-L171>https://github.com/gardener/gardenctl/blob/1e3e5fa1d5603e2161f45046ba7c6b5b4107369e/pkg/cmd/ssh.go#L160-L171</a>. By this means the <code>spec.sshPublicKey</code> from the <code>Bastion</code> resource in the garden cluster will end up in the <code>authorized_keys</code> file on the bastion host.</li></ul></li></ul></li><li>Gardener extension provider <infra>/ Bastion Controller on Seed:<ul><li>With own <code>Bastion</code> Custom Resource Definition in the seed under the api group <code>extensions.gardener.cloud/v1alpha1</code></li><li>Watches <code>Bastion</code> custom resources that are created by the <code>gardenlet</code> in the seed</li><li>Controller reads <code>cloudprovider</code> credentials from seed-shoot namespace</li><li>Deploy infrastructure resources<ul><li>Bastion VM. Uses user data from <code>spec.userData</code></li><li>attaches public IP, creates security group, firewall rules, etc.</li></ul></li><li>Updates status of <code>Bastion</code> resource:<ul><li>With bastion IP under <code>status.ingress.ip</code> or hostname under <code>status.ingress.hostname</code></li><li>Updates the <code>status.lastOperation</code> with the status of the last reconcile operation</li></ul></li></ul></li><li><code>gardenlet</code><ul><li>Syncs back the <code>status.ingress</code> and <code>status.conditions</code> of the <code>Bastion</code> resource in the seed to the garden cluster in case it changed</li></ul></li><li><code>gardenctl</code><ul><li>initiates <code>ssh</code> session once <code>status.conditions['BastionReady']</code> is true of the <code>Bastion</code> resource in the garden cluster<ul><li>locates private <code>ssh</code> key matching <code>spec["sshPublicKey"]</code> which was configured beforehand by the user</li><li>reads bastion IP (<code>status.ingress.ip</code>) or hostname (<code>status.ingress.hostname</code>)</li><li>reads the private key from the <code>ssh</code> key pair for the shoot node</li><li>opens <code>ssh</code> connection to the bastion and from there to the respective shoot node</li></ul></li><li>runs heartbeat in parallel as long as the <code>ssh</code> session is open by annotating the <code>Bastion</code> resource with <code>gardener.cloud/operation: keepalive</code></li></ul></li><li><code>GCM</code>:<ul><li>Once <code>status.expirationTimestamp</code> is reached, the <code>Bastion</code> will be marked for deletion</li></ul></li><li><code>gardenlet</code>:<ul><li>Once the <code>Bastion</code> resource in the garden cluster is marked for deletion, it marks the <code>Bastion</code> resource in the seed for deletion</li></ul></li><li>Gardener extension provider <infra>/ Bastion Controller on Seed:<ul><li>all created resources will be cleaned up</li><li>On succes, removes finalizer on <code>Bastion</code> resource in seed</li></ul></li><li><code>gardenlet</code>:<ul><li>removes finalizer on <code>Bastion</code> resource in garden cluster</li></ul></li></ol><h3 id=resource-example>Resource Example</h3><p><code>Bastion</code> resource in the garden cluster</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: operations.gardener.cloud/v1alpha1
kind: Bastion
metadata:
  generateName: cli-
  name: cli-abcdef
  namespace: garden-myproject
  annotations:
    gardener.cloud/created-by: foo <span style=color:green># immutable, set by the GAPI Admission Plugin</span>
    <span style=color:green># gardener.cloud/operation: keepalive # this annotation is removed by the GAPI and the status.lastHeartbeatTimestamp and status.expirationTimestamp will be updated accordingly</span>
spec:
  shootRef: <span style=color:green># namespace cannot be set / it&#39;s the same as .metadata.namespace</span>
    name: my-cluster <span style=color:green># immutable</span>

  <span style=color:green># the following fields are set by the GAPI</span>
  seedName: aws-eu2
  providerType: aws

  sshPublicKey: c3NoLXJzYSAuLi4K <span style=color:green># immutable, public `ssh` key of the user</span>

  ingress: <span style=color:green># can only be updated by the creator of the bastion</span>
  - ipBlock:
      cidr: 1.2.3.4/32 <span style=color:green># public IP of the user. CIDR is a string representing the IP Block. Valid examples are &#34;192.168.1.1/24&#34; or &#34;2001:db9::/64&#34;</span>

status:
  observedGeneration: 1

  <span style=color:green># the following fields are managed by the controller in the seed and synced by gardenlet</span>
  ingress: <span style=color:green># IP or hostname of the bastion</span>
    ip: 1.2.3.5
    <span style=color:green># hostname: foo.bar</span>

  conditions:
  - type: BastionReady <span style=color:green># when the `status` is true of condition type `BastionReady`, the client can initiate the `ssh` connection</span>
    status: <span style=color:#a31515>&#39;True&#39;</span>
    lastTransitionTime: <span style=color:#a31515>&#34;2021-03-19T11:59:00Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2021-03-19T11:59:00Z&#34;</span>
    reason: BastionReady
    message: Bastion for the cluster is ready.

  <span style=color:green># the following fields are only set by the GAPI</span>
  lastHeartbeatTimestamp: <span style=color:#a31515>&#34;2021-03-19T11:58:00Z&#34;</span> <span style=color:green># will be set when setting the annotation gardener.cloud/operation: keepalive</span>
  expirationTimestamp: <span style=color:#a31515>&#34;2021-03-19T12:58:00Z&#34;</span> <span style=color:green># extended on each keepalive</span>
</code></pre></div><p><code>Bastion</code> custom resource in the seed cluster</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: extensions.gardener.cloud/v1alpha1
kind: Bastion
metadata:
  name: cli-abcdef
  namespace: shoot--myproject--mycluster
spec:
  userData: |- <span style=color:green># this is normally base64-encoded, but decoded for the example. Contains spec.sshPublicKey from Bastion resource in garden cluster</span>
    <span style=color:green>#!/bin/bash</span>
    <span style=color:green># create user</span>
    <span style=color:green># add ssh public key to authorized_keys</span>
    <span style=color:green># ...</span>

  ingress:
  - ipBlock:
      cidr: 1.2.3.4/32

  type: aws <span style=color:green># from extensionsv1alpha1.DefaultSpec</span>

status:
  observedGeneration: 1
  ingress:
    ip: 1.2.3.5
    <span style=color:green># hostname: foo.bar</span>
  conditions:
  - type: BastionReady
    status: <span style=color:#a31515>&#39;True&#39;</span>
    lastTransitionTime: <span style=color:#a31515>&#34;2021-03-19T11:59:00Z&#34;</span>
    lastUpdateTime: <span style=color:#a31515>&#34;2021-03-19T11:59:00Z&#34;</span>
    reason: BastionReady
    message: Bastion for the cluster is ready.
</code></pre></div><h2 id=ssh-key-pair-rotation>SSH Key Pair Rotation</h2><p>Currently, the <code>ssh</code> key pair for the shoot nodes are created once during shoot cluster creation. These key pairs should be rotated on a regular basis.</p><h3 id=rotation-proposal>Rotation Proposal</h3><ul><li><code>gardeneruser</code> original user data <a href=https://github.com/gardener/gardener/tree/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/original/components/gardeneruser>component</a>:<ul><li>The <code>gardeneruser</code> create script should be changed into a reconcile script script, and renamed accordingly. It needs to be adapted so that the <code>authorized_keys</code> file will be updated / overwritten with the current and old <code>ssh</code> public key from the cloud-config user data.</li></ul></li><li>Rotation trigger:<ul><li>Once in the maintenance time window</li><li>On demand, by annotating the shoot with <code>gardener.cloud/operation: rotate-ssh-keypair</code></li></ul></li><li>On rotation trigger:<ul><li><code>gardenlet</code><ul><li>Prerequisite of <code>ssh</code> key pair rotation: all nodes of all the worker pools have successfully applied the desired version of their cloud-config user data</li><li>Creates or updates the secret <code>ssh-keypair.old</code> with the content of <code>ssh-keypair</code> in the seed-shoot namespace. The old private key can be used by clients as fallback, in case the new <code>ssh</code> public key is not yet applied on the node</li><li>Generates new <code>ssh-keypair</code> secret</li><li>The <code>OperatingSystemConfig</code> needs to be re-generated and deployed with the new and old <code>ssh</code> public key</li></ul></li><li>As usual (for more details, see <a href=/docs/gardener/extensions/operatingsystemconfig/>here</a>):<ul><li>Once the <code>cloud-config-&lt;X></code> secret in the <code>kube-system</code> namespace of the shoot cluster is updated, it will be picked up by the <a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/downloader/templates/scripts/download-cloud-config.tpl.sh><code>downloader</code> script</a> (checks every 30s for updates)</li><li>The <code>downloader</code> runs the <a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/executor/templates/scripts/execute-cloud-config.tpl.sh>&ldquo;execution&rdquo; script</a> from the <code>cloud-config-&lt;X></code> secret</li><li>The &ldquo;execution&rdquo; script includes also the original user data script, which it writes to <code>PATH_CLOUDCONFIG</code>, compares it against the previous cloud config and runs the script in case it has changed</li><li>Running the <a href=https://github.com/gardener/gardener/tree/master/pkg/operation/botanist/component/extensions/operatingsystemconfig/original>original user data</a> script will also run the <code>gardeneruser</code> component, where the <code>authorized_keys</code> file will be updated</li><li>After the most recent cloud-config user data was applied, the &ldquo;execution&rdquo; script annotates the node with <code>checksum/cloud-config-data: &lt;cloud-config-checksum></code> to indicate the success</li></ul></li></ul></li></ul><h3 id=limitations>Limitations</h3><p>Each operating system has its own default user (e.g. <code>core</code>, <code>admin</code>, <code>ec2-user</code> etc). These users get their SSH keys during VM creation (however there is a different handling on Google Cloud Platform as stated below). These keys currently do not get rotated respectively are not removed from the <code>authorized_keys</code> file. This means that the initial <code>ssh</code> key will still be valid for the default operating system user.</p><p>On Google Cloud Platform, the VMs do not have any static users (i.e. no <code>gardener</code> user) and there is an agent on the nodes that syncs the users with their SSH keypairs from the GCP IAM service.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fb3867149339478f45ee6b887f9089ff>7.15 - Dynamic kubeconfig generation for Shoot clusters</h1><h1 id=gep-16-dynamic-kubeconfig-generation-for-shoot-clusters>GEP-16: Dynamic kubeconfig generation for Shoot clusters</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#gep-16-dynamic-kubeconfig-generation-for-shoot-clusters>GEP-16: Dynamic kubeconfig generation for Shoot clusters</a><ul><li><a href=#table-of-contents>Table of Contents</a></li><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a></li><li><a href=#alternatives>Alternatives</a></li></ul></li></ul><h2 id=summary>Summary</h2><p>This <code>GEP</code> introduces new <code>Shoot</code> subresource called <code>AdminKubeconfigRequest</code> allowing for users to dynamically generate a short-lived <code>kubeconfig</code> that can be used to access the <code>Shoot</code> cluster as <code>cluster-admin</code>.</p><h2 id=motivation>Motivation</h2><p>Today, when access to the created <code>Shoot</code> clusters is needed, a <code>kubeconfig</code> with static token credentials is used. This static token is in the <code>system:masters</code> group, granting it <code>cluster-admin</code> privileges. The <code>kubeconfig</code> is generated when the cluster is reconciled, stored in <code>ShootState</code> and replicated in the <code>Project</code>&rsquo;s namespace in a <code>Secret</code>. End-users can fetch the secret and use the <code>kubeconfig</code> inside it.</p><p>There are several problems with this approach:</p><ul><li>The token in the <code>kubeconfig</code> does not have any expiration, so end-users have to request a <code>kubeconfig</code> credential rotation if they want revoke the token.</li><li>There is no user identity in the token. e.g. if user <code>Joe</code> gets the <code>kubeconfig</code> from the <code>Secret</code>, user in that token would be <code>system:cluster-admin</code> and not <code>Joe</code> when accessing the <code>Shoot</code> cluster with it. This makes auditing events in the cluster almost impossible.</li></ul><h3 id=goals>Goals</h3><ul><li><p>Add a <code>Shoot</code> subresource called <code>adminkubeconfig</code> that would produce a <code>kubeconfig</code> used to access that <code>Shoot</code> cluster.</p></li><li><p>The <code>kubeconfig</code> is not stored in the API Server, but generated for each request.</p></li><li><p>In the <code>AdminKubeconfigRequest</code> send to that subresource, end-users can specify the expiration time of the credential.</p></li><li><p>The identity (user) in the Gardener cluster would be part of the identity (x509 client certificate). E.g if <code>Joe</code> authenticates against the Gardener API server, the generated certificate for <code>Shoot</code> authentication would have the following subject:</p><ul><li>Common Name: <code>Joe</code></li><li>Organisation: <code>system:masters</code></li></ul></li><li><p>The maximum validity of the certificate can be enforced by setting a flag on the <code>gardener-apiserver</code>.</p></li><li><p>Deprecate and remove the old <code>{shoot-name}.kubeconfig</code> secrets in each <code>Project</code> namespace.</p></li></ul><h3 id=non-goals>Non-Goals</h3><ul><li>Generate <code>OpenID Connect</code> kubeconfigs</li></ul><h2 id=proposal>Proposal</h2><p>The <code>gardener-apiserver</code> would serve a new <code>shoots/adminkubeconfig</code> resource. It can only accept <code>CREATE</code> calls and accept <code>AdminKubeconfigRequest</code>. A <code>AdminKubeconfigRequest</code> would have the following structure:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: authentication.gardener.cloud/v1alpha1
kind: AdminKubeconfigRequest
spec:
  expirationSeconds: 3600
</code></pre></div><p>Where <code>expirationSeconds</code> is the validity of the certificate in seconds. In this case it would be <code>1 hour</code>. The maximum validity of a <code>AdminKubeconfigRequest</code> is configured by <code>--shoot-admin-kubeconfig-max-expiration</code> flag in the <code>gardener-apiserver</code>.</p><p>When such request is received, the API server would find the <code>ShootState</code> associated with that cluster and generate a <code>kubeconfig</code>. The x509 client certificate would be signed by the <code>Shoot</code> cluster&rsquo;s CA and the user used in the subject&rsquo;s common name would be from the <code>User.Info</code> used to make the request.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: authentication.gardener.cloud/v1alpha1
kind: AdminKubeconfigRequest
spec:
  expirationSeconds: 3600
status:
  expirationTimestamp: <span style=color:#a31515>&#34;2021-02-22T09:06:51Z&#34;</span>
  kubeConfig: <span style=color:green># this is normally base64-encoded, but decoded for the example</span>
    apiVersion: v1
    clusters:
    - cluster:
        certificate-authority-data: LS0tLS1....
        server: https://api.shoot-cluster
      name: shoot-cluster-a
    contexts:
    - context:
        cluster: shoot-cluster-a
        user: shoot-cluster-a
      name: shoot-cluster-a
    current-context: shoot-cluster-a
    kind: Config
    preferences: {}
    users:
    - name: shoot-cluster-a
      user:
        client-certificate-data: LS0tLS1CRUd...
        client-key-data: LS0tLS1CRUd...
</code></pre></div><p>New feature gate called <code>AdminKubeconfigRequest</code> enables the above mentioned API in the <code>gardener-apiserver</code>. The old <code>{shoot-name}.kubeconfig</code> is kept, but deprecated and will be removed in the future.</p><p>In order to get the server&rsquo;s address used in the <code>kubeconfig</code>, the Shoot&rsquo;s <code>status</code> should be updated with new entries:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: crazy-botany
  namespace: garden-dev
spec: {}
status:
  advertisedAddresses:
  - name: external
    url: https://api.shoot-cluster.external.foo
  - name: internal
    url: https://api.shoot-cluster.internal.foo
  - name: ip
    url: https://1.2.3.4
</code></pre></div><p>This is needed, because the Gardener API server might not know on which IP address the API server is advertised on (e.g. DNS is disabled).</p><p>If there are multiple entries, each would be added in a separate <code>cluster</code> in the <code>kubeconfig</code> and a <code>context</code> with the same name would be added added as well. The current context would be selected as the first entry in the <code>advertisedAddresses</code> list (<code>.status.advertisedAddresses[0]</code>).</p><h2 id=alternatives>Alternatives</h2><ul><li><a href=https://github.com/gardener/oidc-webhook-authenticator>Dynamic OpenID Connect Webhook Authenticator</a> can be used instead. Ideally cluster admins can enable either or both.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bd5352a75eaa367044f38d5f9e2080ac>7.16 - GEP Title</h1><h1 id=gep-nnnn-your-short-descriptive-title>GEP-NNNN: Your short, descriptive title</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a></li><li><a href=#alternatives>Alternatives</a></li></ul><h2 id=summary>Summary</h2><h2 id=motivation>Motivation</h2><h3 id=goals>Goals</h3><h3 id=non-goals>Non-Goals</h3><h2 id=proposal>Proposal</h2><h2 id=alternatives>Alternatives</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-d9890d994643115baf0d880ffe41fc8f>7.17 - Reversed Cluster VPN</h1><h1 id=gep-14-reversed-cluster-vpn>GEP-14: Reversed Cluster VPN</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#Motivation>Motivation</a></li><li><a href=#Proposal>Proposal</a></li><li><a href=#Alternatives>Alternatives</a></li></ul><h2 id=motivation>Motivation</h2><p>It is necessary to describe the current VPN solution and outline its shortcomings in order to motivate this proposal.</p><h3 id=problem-statement>Problem Statement</h3><p>Today&rsquo;s Gardener cluster VPN solution has several issues including:</p><ol><li>Connection establishment is always from the seed cluster to the shoot cluster. This means that there needs to be connectivity both ways which is not desirable in many cases (OpenStack, VMware) and causes high effort in firewall configuration or extra infrastructure. These firewall configurations are prohibited in some cases due to security policies.</li><li>Shoot clusters must provide a VPN endpoint. This means extra cost for the endpoint (roughly €20/month on hyperscalers) or will consume scarce resources (limited number of VMware NSX-T load balancers).</li></ol><p>A first implementation has been provided to resolve the issues with the <a href=/docs/gardener/proposals/11-apiserver-network-proxy/>konnectivity server</a>. As we did find several shortcomings with the underlying technology component, the <a href=https://github.com/kubernetes-sigs/apiserver-network-proxy>apiserver-network-proxy</a> we believe that this is not a suitable way ahead. We have opened an <a href=https://github.com/kubernetes-sigs/apiserver-network-proxy/issues/180>issue</a> and provided two solution proposals to the community. We do see some remedies, e.g. using the <a href=https://de.wikipedia.org/wiki/Quick_UDP_Internet_Connections>Quick Protocol</a> instead of GRPC but we (a) consider the implementation effort significantly higher compared to this proposal and (b) would use an experimental protocol to solve a problem that can also be solved with existing and proven core network technologies.</p><p>We will therefore not continue to invest into this approach. We will however research a similar approach (see below in &ldquo;Further Research&rdquo;).</p><h3 id=current-solution-outline>Current Solution Outline</h3><p>The current solution consists of multiple VPN connections from each API server pod and the Prometheus pod of a control plane to an OpenVPN server running in the shoot cluster. This OpenVPN server is exposed via a load balancer that must have an IP address which is reachable from the seed cluster. The routing in the seed cluster pods is configured to route all traffic for the node, pod, and service ranges to the shoot cluster. This means that there is no address overlap allowed between seed- and shoot cluster node, pod, and service ranges.</p><p>In the seed cluster the <code>vpn-seed</code> container is a sidecar to the kube-apiserver and prometheus pods. OpenVPN acts as a TCP client connecting to an OpenVPN TCP server. This is not optimal (e.g. tunneling TCP over TCP is discouraged) but at the time of development there was no UDP load balancer available on at least one of the major hyperscalers. Connectivity could have been switched to UDP later but the development effort was not spent.</p><p>The solution is depicted in this diagram:</p><p><img src=/__resources/CurrentClusterVPN_095870.png alt="alt text" title="Overview Current Cluster VPN"></p><p>These are the essential parts of the OpenVPN client configuration in the <code>vpn-seed</code> sidecar container:</p><pre><code># use TCP instead of UDP (commonly not supported by load balancers)
proto tcp-client

[...]

# get all routing information from server
pull

tls-client
key &quot;/srv/secrets/vpn-seed/tls.key&quot;
cert &quot;/srv/secrets/vpn-seed/tls.crt&quot;
ca &quot;/srv/secrets/vpn-seed/ca.crt&quot;

tls-auth &quot;/srv/secrets/tlsauth/vpn.tlsauth&quot; 1
cipher AES-256-CBC

# https://openvpn.net/index.php/open-source/documentation/howto.html#mitm
remote-cert-tls server

# pull filter
pull-filter accept &quot;route 100.64.0.0 255.248.0.0&quot;
pull-filter accept &quot;route 100.96.0.0 255.224.0.0&quot;
pull-filter accept &quot;route 10.1.60.0 255.255.252.0&quot;
pull-filter accept &quot;route 192.168.123.&quot;
pull-filter ignore &quot;route&quot;
pull-filter ignore redirect-gateway
pull-filter ignore route-ipv6
pull-filter ignore redirect-gateway-ipv6
</code></pre><p>Encryption is based on SSL certificates with an additional HMAC signature to all SSL/TLS handshake packets. As multiple clients connect to the OpenVPN server in the shoot cluster, all clients must be assigned a unique IP address. This is done by the OpenVPN server pushing that configuration to the client (keyword <code>pull</code>). As this is potentially problematic because the OpenVPN server runs in an untrusted environment there are pull filters denying all but necessary routes for the pod, service, and node networks.</p><p>The OpenVPN server running in the shoot cluster is configured as follows:</p><pre><code>mode server
tls-server
proto tcp4-server
dev tun0

[...]

server 192.168.123.0 255.255.255.0

push &quot;route 10.243.0.0 255.255.128.0&quot;
push &quot;route 10.243.128.0 255.255.128.0&quot;

duplicate-cn

key &quot;/srv/secrets/vpn-shoot/tls.key&quot;
cert &quot;/srv/secrets/vpn-shoot/tls.crt&quot;
ca &quot;/srv/secrets/vpn-shoot/ca.crt&quot;
dh &quot;/srv/secrets/dh/dh2048.pem&quot;

tls-auth &quot;/srv/secrets/tlsauth/vpn.tlsauth&quot; 0
push &quot;route 10.242.0.0 255.255.0.0&quot;
</code></pre><p>It is a TCP TLS server and configured to automatically assign IP addresses for OpenVPN clients (<code>server</code> directive). In addition, it pushes the shoot cluster node-, pod-, and service ranges to the clients running in the seed cluster (<code>push</code> directive).</p><p><strong>Note:</strong> The network mesh spanned by OpenVPN uses the network range <code>192.168.123.0 - 192.168.123.255</code>. This network range cannot be used in either shoot-, or seed clusters. If it is used this might cause subtle problem due to network range overlaps. Unfortunately, this appears not to be well documented but this restriction exists since the very beginning. We should clean up this technical debt as part of the exercise.</p><h3 id=goals>Goals</h3><ul><li>We intend to supersede the current VPN solution with the solution outlined in this proposal.</li><li>We intend to remove the code for the konnectivity tunnel once this solution proposal has been validated.</li></ul><h3 id=non-goals>Non Goals</h3><ul><li>The solution is not a low latency, or high throughput solution. As the kube-apiserver to shoot cluster traffic does not demand these properties we do not intend to invest in improvements.</li><li>We do not intend to provide continuous availability to the shoot-seed VPN connection. We expect the availability to be comparable to the existing solution.</li></ul><h2 id=proposal>Proposal</h2><p>The proposal is depicted in the following diagram:</p><p><img src=/__resources/ReversedTunnelVPN_c0c514.png alt="alt text" title="Reversed Tunnel VPN"></p><p>We have added an OpenVPN server pod (<code>vpn-seed-server</code>) to each control plane. The OpenVPN client in the shoot cluster (<code>vpn-shoot-client</code>) connects to the OpenVPN server.</p><p>The two containers <code>vpn-seed-server</code> and <code>vpn-shoot-client</code> are new containers and are not related to containers in the github.com/gardener/vpn project. We will create a new project github.com/gardener/vpn2 for these containers. With this solution we intend to supersede the containers from the github.com/gardener/vpn project.</p><p>A service <code>vpn-seed-server</code> of type <code>ClusterIP</code> is created for each control plane in its namespace.</p><p>The <code>vpn-shoot-client</code> pod connects to the correct <code>vpn-seed-server</code> service via the SNI passthrough proxy introduced with <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>SNI Passthrough proxy for kube-apiservers</a> on port 8132.</p><p>Shoot OpenVPN clients (<code>vpn-shoot-client</code>) connect to the correct OpenVPN Server using the http proxy feature provided by OpenVPN. A configuration is added to the envoy proxy to detect http proxy requests and open a connection attempt to the correct OpenVPN server.</p><p>The <code>kube-apiserver</code> to shoot cluster connections are established using the API server proxy feature via an envoy proxy sidecar container of the <code>vpn-seed-server</code> container.</p><p>The restriction regarding the <code>192.168.123.0/24</code> network range in the current VPN solution still applies to this proposal. No other restrictions are introduced. In the context of this GEP a pull requst has been filed to block usage of that range by shoot clusters.</p><h3 id=performance-and-scalability>Performance and Scalability</h3><p>We do expect performance and throughput to be slightly lower compared to the existing solution. This is because the OpenVPN server acts as an additional hop and must decrypt and re-encrypt traffic that passes through. As there are no low latency, or high thoughput requirements for this connection we do not assume this to be an issue.</p><h3 id=availability-and-failure-scenarios>Availability and Failure Scenarios</h3><p>This solution re-uses multiple instances of the envoy component used for the kube-apiserver endpoints. We assume that the availability for kube-apiservers is good enough for the cluster VPN as well.</p><p>The OpenVPN client- and server pods are singleton pods in this approach and therefore are affected by potential failures and during cluster-, and control plane updates. Potential outages are only restricted to single shoot clusters and are comparable to the situation with the existing solution today.</p><h3 id=feature-gates-and-migration-strategy>Feature Gates and Migration Strategy</h3><p>We have introduced a gardenlet feature gate <code>ReversedVPN</code>. If <code>APIServerSNI</code> and <code>ReversedVPN</code> are enabled the proposed solution is automatically enabled for all shoot clusters hosted by the seed. If <code>ReversedVPN</code> is enabled but <code>APIServerSNI</code> is not the gardenlet will panic during startup as this is an invalid configuration. All existing shoot clusters will automatically be migrated during the next reconciliation. We assume that the <code>ReversedVPN</code> feature will work with Gardener as well as operator managed Istio.</p><p>We have also added a shoot annotation <code>alpha.featuregates.shoot.gardener.cloud/reversed-vpn</code> which can override the feature gate to enable or disable the solution for individual clusters. This is only respected if <code>APIServerSNI</code> is enabled, otherwise it is ignored.</p><h3 id=security-review>Security Review</h3><p>The change in the VPN solution will potentially open up new attack vectors. We will perform a thorough analysis outside of this document.</p><h2 id=alternatives>Alternatives</h2><h3 id=wireguard-and-kubelink-based-cluster-vpn>WireGuard and Kubelink based Cluster VPN</h3><p>We have done a detailed investigation and implementation of a reversed VPN based on WireGuard. While we believe that it is technically feasible and superior to the approach presented above there are some concerns with regards to scalability, and high availability. As the WireGuard scenario based on kubelink is relevant for other use cases we continue to improve this implementation and address the concerns but we concede that this might not be on time for the cluster VPN. We nevertheless keep the implementation and provide an outline as part of this proposal.</p><p>The general idea of the proposal is to keep the existing cluster VPN solution more or less as is, but change the underlying network used for the <code>vpn seed => vpn shoot</code> connection. The underlying network should be established in the reversed direction, i.e. the shoot cluster should initiate the network connection, but it nevertheless should work in both directions.</p><p>We achieve this by tunneling the open vpn connection through a WireGuard tunnel, which is established from the shoot to the seed (note that WireGuard uses UDP as protocol). Independent of that we can also use UDP for the OpenVPN connection, but we can also stay with TCP as it was before. While this might look like a big change, it only introduces minor changes to the existing solution, but let&rsquo;s look at the details. In essence, the OpenVPN connection does not require a public endpoint in the shoot cluster but it usees the internal endpoint provided by the WireGuard tunnel.</p><p>This is roughly depcited in this diagram. Note, that the <code>vpn-seed</code> and <code>vpn-shoot</code> containers only require very little changes and are fully backwards compatible.</p><p><img src=/__resources/WireGuardClusterVPN_ff18dd.png alt="alt text" title="Overview WireGuard Current Cluster VPN"></p><p>The WireGuard network needs a separate network range/CIDR. It has to be unique for the seed and all its shoot clusters. An example for an assumed workload of around 1000 shoot clusters would be <code>192.168.128.0/22</code> (1024 IP addresses), i.e. <code>192.168.128.0-192.168.131.255</code>. The IP addresses from this range need to be managed, but the IP address management (IPAM) using the Gardener Kubernetes objects like seed and shootstate as backing store is fairly straightforward. This is especially true as we do not expect large network ranges and only infrequent IP allocations. Hence, the IP address allocation can be quite simple, i.e. scan the range for a free IP address of all shoot clusters in a seed and allocate the first free address from the range.</p><p>There is another restriction: in case shoot clusters are configured to be seed clusters this network range must not overlap with the &ldquo;parent&rdquo; seed cluster. If the parent seed cluster uses <code>192.168.128.0/22</code> the child seed cluster can for example use <code>192.168.132.0/22</code>. Grandchildren can however use grandparent IP address ranges. Also 2 children seed clusters can use identical ranges.</p><p>This slightly adds to the restrictions described in the current solution outline. In that the arbitrary chosen <code>192.168.123.0/24</code> range is restricted. For the purpose of this implementation we propose to extend that restriction to <code>192.168.128.0/17</code> range. Most of it would be reserved for &ldquo;future use&rdquo; however. We are well aware that this adds to the burden of correctly configuring Gardener landscapes.</p><p>We do consider this to be a challenge that needs to be addressed by careful configuration of the Gardener seed cluster infrastructure. Together with the <code>192.168.123.0/24</code> address range these ranges should be automatically blocked for usage by shoots.</p><p>WireGuard can utilize the Linux kernel so that after initialization/configuration no user space processes are required. We propose to recommend the WireGuard kernel module as the default solution for all seeds. For shoot clusters, the WireGuard kernel based approach is also recommended, but the user space solution should also work as we expect less traffic on the shoot side. We expect the userspace implementation to work on all operating systems supported by Gardener in case no kernel module is available.</p><p>Almost all seed clusters are already managed by Gardener and we assume that those are configured with the WireGuard kernel module. There are however some cases where we use other Kubernetes distributions as seed cluster which may not have an operating system with WireGuard module available. We will therefore generally support the user space WireGuard process on seed cluster but place a size restriction on the number of control planes on those seeds.</p><p>There is a user space implementation of WireGuard, which can be used on Linux distributions without the WireGuard kernel module. (WireGuard moved into the standard Linux kernel 5.6.) Our proposal can handle the kernel/user space switch transparently, i.e. we include the user space binaries and use them only when required. However, especially for the seed the kernel based solution might be more attractive. Garden Linux 318.4.0 supports WireGuard.</p><p>We have looked at Ubuntu and SuSE chost:</p><ul><li>SuSE chost does not provide the WireGuard kernel module and it is not installable via zypper. It should however be straightforward for SuSE to include that in their next release.</li><li>Ubuntu does not provide the kernel module either but it can be installed using <code>apt-get install wireguard</code>. With that it appears straightforward to provide an image with WireGuard pre-installed.</li></ul><p>On the seed, we add a WireGuard device to one node on the host network. For all other nodes on the seed, we adapt the routes accordingly to route traffic destined for the WireGuard network to our WireGuard node. The Kubernetes pods managing the WireGuard device and routes are only used for initial configuration and later reconfiguration. During runtime, they can restart without any impact on the operation of the WireGuard network as the WireGuard device is managed by the Linux kernel.</p><p>With Calico as the networking solution it is not easily possible to put the WireGuard endpoint into a pod. Putting the WireGuard endpoint into a pod would require to define it as a gateway in the api server or prometheus pods but this is not possible since Calico does not span a proper subnet. While the defined CIDR in the pod network might be <code>100.96.0.0/11</code> the network visible from within a pod is only <code>100.96.0.5/32</code>. This restriction might not exist with other networking solutions.</p><p>The WireGuard endpoint on the seed is exposed via a load balancer. We propose to use <a href=https://github.com/mandelsoft/kubelink>kubelink</a> to manage the WireGuard configuration/device on the seed. We consider the management of the WireGuard endpoint to be complex especially in error situations which is the reason for utilizing kubelink as there is already significant experience managing an endpoint. We propose moving kubelink to the Gardener org in case it is used by this proposal.</p><p>Kubelink addresses three challenges managing WireGuard interfaces on cluster nodes. First, with WireGuard interfaces directly on the node (<code>hostNetwork=true</code>) the lifecycle of the interface is decoupled from the lifecycle of the pod that created it. This means that there will have to be means of cleaning up the interfaces and its configuration in case the interface moves to a different node. Second, additional routing information must be distributed across the cluster. The WireGuard CIDR is unknown to the network implementation so additional routes must be distributed on all nodes of the cluster. Third, kubelink dynamincally configures the Wireguard interface with endpoints and their public keys.</p><p>On the shoot, we create the keys and acquire the WireGuard IP in the standard secret generation. The data is added as a secret to the control plane and to the shootstate. The vpn shoot deployment is extended to include the WireGuard device setup inside the vpn shoot pod network. For certain infrastructures (AWS), we need a re-advertiser to resolve the seed WireGuard endpoint and evaluate whether the IP address changed.</p><p>While it is possible to configure a WireGuard device using DNS names only IP addresses can be stored in Linux Kernel data structures. A change of a load balancer IP address can therefore not be mitigated on that level. As WireGuard dynamically adapts endpoint IP addresses a change in load banlancer IPs is mitigated in most but not all cases. This is why a re-advertiser is required for public cloud providers such as AWS.</p><p>The load balancer exposing the OpenVPN endpoint in the shoot cluster is no longer required and therefore removed if this functionality is used.</p><p>As we want to slowly expand the usage of the WireGuard solution, we propose to introduce a feature gate for it. Furthermore, since the WireGuard network requires a separate network range, we propose to introduce a new section to the seed settings with two additional flags (enabled & cidr):</p><pre><code>apiVersion: core.gardener.cloud/v1beta1
kind: Seed
metadata:
  name: my-seed
  ...
spec:
  ...
  settings:
  ...
    wireguard:
      enabled: true
      cidr: 192.168.128.0/22
</code></pre><p>Last but not least, we propose to introduce an annotation to the shoots to enable/disable the WireGuard tunnel explicitly.</p><pre><code>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: my-shoot
  annotations:
    alpha.featuregates.shoot.gardener.cloud/wireguard-tunnel: &quot;true&quot;
  ...
</code></pre><p>Using this approach, it is easy to switch the solution on and off, i.e. migrate the shoot clusters automatically during ordinary reconciliation.</p><h4 id=high-availability>High Availability</h4><p>There is an issue if the node that hosts the WireGuard endpoint fails. The endpoint is migrated to another node however the time required to do this might exceed the budget for downtimes although one could argue that a disruption of less than 30 seconds to 1 minute does not qualify as a downtime and will in almost all cases not noticeable by end users.</p><p>In this case we also assume that TCP connections won&rsquo;t be interrupted - they would just appear to hang. We will confirm this behavior and the potential downtime as part of the development and testing effort as this is hard to predict.</p><p>As a possible mitigation we propose to instantiate 2 Kubelink instances in the seed cluster that are served by two different load balancers. The instances must run on different nodes (if possible but we assume a proper seed cluster has more than one node). Each shoot cluster connects to both endpoints. This means that the OpenVPN server is reachable with two different IP addresses. The VPN seed sidecars must attempt to connect to both of them and will continue to do so. The &ldquo;Persistent Keepalive&rdquo; feature is set to 21 seconds by default but could be reduced. Due to the redundancy this however appears not to be necessary.</p><p>It is desirable that both connections are used in an equal manner. One strategy could be to use the kubelink 1 connection if the first target WireGuard address is even (the last byte of the IPv4 address), otherwise the kubelink 2 connection. The <code>vpn-seed</code> sidecars can then use the following configuration in their OpenVPN configuration file:</p><pre><code>&lt;connection&gt;
remote 192.168.45.3 1194 udp
&lt;/connection&gt;

&lt;connection&gt;
remote 192.168.47.34 1194 udp
&lt;/connection&gt;
</code></pre><p>OpenVPN will go through the list sequentially and try to connect to these endpoints.</p><p>As an additional mitigation it appears possible to instantiate WireGuard devices on all hosts and replicate its relevant conntrack state across all cluster nodes. The relevant conntrack state keeps the state of all connections passing through the WireGuard interface (e.g. the WireGuard CIDR). conntrack and the tools to replicate conntrack state are part of the essential Linux netfilter tools package.</p><h4 id=load-considerations>Load Considerations</h4><p>What happens in case of a failure? In this case one router will end up owning all connections as the clients will attempt to use the next connection. This could be mitigated by adding a third redundant WireGuard connection. Using this strategy, the failure of one WireGuard endpoint would result in the equal distribution of connections to the two remaining interfaces. We believe however that this will not be necessary.</p><p>The cluster node running the Wireguard endpoint is essentially a router that routes all traffic to the various shoot clusters. This is established and proven technology that already exists since decades and has been highly optimized since then. This is also the technology that hyperscalers rely on to provide VPN connectivity to their customers. This said, hyperscalers essentially provide solutions based on IPsec which is known not to scale as well as Wireguard. Wireguard is a relatively new technology but we have no doubt that it is less stable than existing IPsec solution.</p><p>Regarding performance there is a lot of information on the Internet basically suggesting that Wireguard performs better than other VPN solutions such as IPsec or OpenVPN. One example is <a href=https://www.wireguard.com/performance/>https://www.wireguard.com/performance/</a> and <a href=https://www.net.in.tum.de/fileadmin/bibtex/publications/papers/2020-ifip-moonwire.pdf>https://www.net.in.tum.de/fileadmin/bibtex/publications/papers/2020-ifip-moonwire.pdf</a>.</p><p>Based on this, we have no reason to believe that one router will not be able to handle all traffic going to and coming from shoot clusters. Nevertheless, we will closely monitor the situation in our tests and will take action if necessary.</p><h4 id=further-research>Further Research</h4><p>Based on feedback on this proposal and while working on this implementation we identified two additinal approaches that we have not thought of so far. The first idea can be used to replace the &ldquo;inner&rdquo; OpenVPN implementation and the second can be used to replace WireGuard with OpenVPN and get rid of the single point of failure.</p><ol><li><p>Instead of using OpenVPN for the inner seed/shoot communication we can use the proxy protocol and use a TCP proxy (e.g. envoy) in the shoot cluster to broker the seed-shoot connections. The advantage is that with this solution seed- and shoot cluster network ranges are allowed to overlap. Disadvantages are increased implementation effort and less efficient network in terms of throughput and scalability. We believe however that the reduced network efficiency does not invalidate this option.</p></li><li><p>There is an option in OpenVPN to specify a tcp proxy as part of the endpoint configuration.</p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-67211574c9c9627ba4e942fa77ceda03>7.18 - Shoot CA Rotation</h1><h1 id=gep-18-automated-shoot-ca-rotation>GEP-18: Automated Shoot CA Rotation</h1><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#summary>Summary</a></li><li><a href=#motivation>Motivation</a><ul><li><a href=#goals>Goals</a></li><li><a href=#non-goals>Non-Goals</a></li></ul></li><li><a href=#proposal>Proposal</a></li><li><a href=#alternatives>Alternatives</a></li><li><a href=#open-questions>Open Questions</a></li></ul><h2 id=summary>Summary</h2><p>This proposal outlines an on-demand, multi-step approach to rotate all certificate authorities (CA) used in a Shoot cluster. This process includes creating new CAs, invalidating the old ones and recreating all certificates signed by the CAs.</p><p>We propose to bundle the rotation of <em>all</em> CAs in the Shoot together as one triggerable action. This includes the recreation and invalidation of the following CAs and all certificates signed by them:</p><ul><li>Cluster CA (currently used for signing <code>kube-apiserver</code> serving certificates and client certificates)</li><li><code>kubelet</code> CA (used for signing client certificates for talking to <code>kubelet</code> API, e.g. <code>kube-apiserver-kubelet</code>)</li><li><code>etcd</code> CA (used for signing <code>etcd</code> serving certificates and client certificates)</li><li>front-proxy CA (used for signing client certificates that <code>kube-aggregator</code> (part of <code>kube-apiserver</code>) uses to talk to extension API servers, filled into <code>extension-apiserver-authentication</code> ConfigMap and read by extension API servers to verify incoming <code>kube-aggregator</code> requests)</li><li><code>metrics-server</code> CA (used for signing serving certificates, filled into APIService <code>caBundle</code> field and read by <code>kube-aggregator</code> to verify the presented serving certificate)</li><li><code>ReversedVPN</code> CA (used for signing <code>vpn-seed-server</code> serving certificate and <code>vpn-shoot</code> client certificate)</li></ul><p>Out of scope for now:</p><ul><li><code>kubelet</code> serving CA is self-generated (valid for <code>1y</code>) and self-signed by <code>kubelet</code> on startup<ul><li><code>kube-apiserver</code> does not seem to verify the presented serving certificate</li><li><code>kubelet</code> can be configured to request serving certificate via CSR that can be verified by <code>kube-apiserver</code>, though, we consider this as a separate improvement outside of this GEP</li></ul></li><li>Legacy VPN solution uses the cluster CA for both serving and client certificates. As the solution is soon to be dropped in favor of the new <code>ReversedVPN</code> solution, we don&rsquo;t intend to introduce a dedicated CA for this component. If <code>ReversedVPN</code> is disabled and the CA rotation is triggered, we make sure to propagate the cluster CA to the relevant places in the legacy VPN solution.</li></ul><p>Naturally, not all certificates used for communication with the <code>kube-apiserver</code> are under control of Gardener. An example for a Gardener-controlled certificate is the kubelet client certificate used to communicate with the api server. An example for credentials not controlled by gardener are kubeconfigs or client certificates requested via <code>CertificateSigningRequest</code>s by the shoot owner.</p><p>We propose to use a two step approach to rotate CAs. The start of each phase is triggered by the shoot owner.
In summary the <strong>first phase</strong> is used to create new CAs (for example the new api server and client CA). Then we make sure that all servers and clients under Gardener&rsquo;s control trust <em>both</em> old and new CA. Next we renew all client certificates that are under Gardener&rsquo;s control so they are now signed by the new CAs. This includes a node rollout in order to propagate the certificates to kubelets and restart all pods. Afterwards the user needs to change their client credentials to trust both old and new cluster CA.
In the <strong>second phase</strong>, we remove all trust to the old CA for servers and clients under Gardener&rsquo;s control. This does not include a node rollout but all still running pods using <code>ServiceAccount</code>s will continue to trust the old CA until they restart. Also, the user needs to retrieve the new CA bundle to no longer trust the old CA.</p><p>A detailed overview of all steps required for each phase is given in the <a href=#proposal>proposal</a> section of this GEP.</p><p><em>Introducing a new client CA</em></p><p>Currently, client certificates and the kube-apiserver certificate are signed by the same CA. We propose to create a separate client CA when triggering the rotation. The client CA is used to sign certificates of clients talking to the API Server.</p><h2 id=motivation>Motivation</h2><p>There are a few reasons for rotating shoot cluster CAs:</p><ul><li>If we have to invalidate client certificates for the kube-apiserver or any other component we are forced to rotate the CA. The only way to invalidate them is to stop trusting all client certificates that are signed by the respective CA as kubernetes does not support revoking certificates.</li><li>If the CA itself got leaked.</li><li>If the CA is about to expire.</li><li>If a company policy requires to rotate a CA after a certain point in time.</li></ul><p>In each of those cases we currently need to basically manually recreate and replace all CAs and certificates. The process of rotating by hand is cumbersome and could lead to errors due to the many steps needing to be performed in the right order. By automating the process we want to create a way to securely and easily rotate shoot CAs.</p><h3 id=goals>Goals</h3><ul><li>Offer an automated and safe solution to rotate all CAs in a shoot cluster.</li><li>Offer a process that is easily understandable for developers and users.</li><li>Rotate the different CAs in the shoot with a similar process to reduce complexity.</li><li>Add visibility for Shoot owners when the last CA rotation happened</li></ul><h3 id=non-goals>Non-Goals</h3><ul><li>Offer an automated solution for rotating other static credentials (like static token).<ul><li>Later on, a similar two-phase approach could be implemented for the kubeconfig rotation. However, this is out of scope for this enhancement.</li></ul></li><li>Creating a process that runs fully automated without shoot owner interaction. As the shoot owner controls some secrets that would probably not even be possible.</li><li>Forcing the shoot owner to rotate after a certain time period. Our goal rather is to issue long-running certificates and let the user decide depending on their requirements to rotate as needed.</li><li>Configurable default CA lifetime</li></ul><h2 id=proposal>Proposal</h2><p>We will add a new feature gate <code>CARotation</code> for <code>gardener-apiserver</code> and <code>gardenlet</code> which allows to enable or disable the possibility to trigger the rotation.</p><h3 id=triggering-the-ca-rotation>Triggering the CA Rotation</h3><ul><li>Triggered via <code>gardener.cloud/operation</code> annotation in symmetry with other operations like reconciliation, kubeconfig rotation, etc.<ul><li>annotation increases the generation</li><li>value for triggering first phase: <code>start-ca-rotation</code></li><li>value for triggering the second phase: <code>complete-ca-rotation</code></li><li><code>gardener-apiserver</code> performs the needful validation: user can&rsquo;t trigger another rotation if one is already in progress, user can&rsquo;t trigger <code>complete-ca-rotation</code> if first phase has not been compeleted, etc.</li></ul></li><li>The annotation triggers a usual shoot reconciliation (just like a kubeconfig or SSH key rotation)</li><li>gardenlet begins the CA rotation sequence by setting the new status section <code>.status.credentials.caRotation</code> (probably in <code>updateShootStatusOperationStart</code>) and removes the annotation afterwards<ul><li>shoot reconciliation needs to be idemptotent to CA rotation phase, i.e. if a usual reconciliation or maintenance operation is triggered in between, no new CAs are generated or similar things that would interfere with the CA rotation sequence</li></ul></li></ul><h3 id=changing-the-shoot-status>Changing the Shoot Status</h3><p>A new section in the Shoot status is added when the first rotation is triggered:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>status:
  credentials:
    rotation:
      certificateAuthorities:
        phase: Prepare <span style=color:green># Prepare|Finalize|Completed</span>
        lastCompletion: 2022-02-07T14:23:44Z
    <span style=color:green># kubeconfig:</span>
    <span style=color:green>#   phase:</span>
    <span style=color:green>#   lastCompletion:</span>
</code></pre></div><p>Later on, this section could be augmented with other information like the names of the credentials secrets (e.g. <a href=https://github.com/gardener/gardener/issues/1749>gardener/gardener#1749</a>)</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>status:
  credentials:
    resources:
    - type: kubeconfig
      kind: Secret
      name: shoot-foo.kubeconfig
</code></pre></div><h3 id=rotation-sequence-for-cluster-and-client-ca>Rotation Sequence for Cluster and Client CA</h3><p>The proposal section includes a detailed description of all steps involved for rotating from a given <code>CA0</code> to the target <code>CA1</code>.</p><p><code>t0</code>: Today&rsquo;s situation</p><ul><li><code>kube-apiserver</code> uses SERVER CERT signed by <code>CA0</code> and trusts CLIENT CERTS signed by <code>CA0</code></li><li><code>kube-controller-manager</code> issues new CLIENT CERTS signed by <code>CA0</code></li><li>kubeconfig trusts only <code>CA0</code></li><li><code>ServiceAccount</code> secrets trust only <code>CA0</code></li><li>kubelet uses CLIENT CERT signed by <code>CA0</code></li></ul><p><code>t1</code>: Shoot owner triggers first step of CA rotation process (&ndash;> phase one is started):</p><ul><li>Generate <code>CA1</code></li><li>Generate <code>CLIENT_CA1</code></li><li>Update <code>kube-apiserver</code>, <code>kube-scheduler</code>, etc. to trust CLIENT CERTS signed by both <code>CA0</code> and <code>CLIENT_CA1</code> (<code>--client-ca-file</code> flag)</li><li>Update <code>kube-controller-manager</code> to issue new CLIENT CERTS now with <code>CLIENT_CA1</code></li><li>Update kubeconfig so that its CA bundle contains both <code>CA0</code> and<code>CA1</code> (if kubeconfig still contains a legacy CLIENT CERT then rotate the kubeconfig)</li><li>Update <code>kube-controller-manager</code> to populate both <code>CA0</code> and <code>CA1</code> in <code>ServiceAccount</code> secrets.</li><li>Restart control plane components so that their CA bundle contains both <code>CA0</code> and <code>CA1</code></li><li>Renew CLIENT CERTS (sign them with <code>CLIENT_CA1</code>) for the following control plane components: Prometheus, DWD, legacy VPN), if not dropped already in the context of <a href=https://github.com/gardener/gardener/issues/4661>gardener/gardener#4661</a></li><li>Trigger node rollout<ul><li>This issues new CLIENT CERTS for all kubelets signed by <code>CLIENT_CA1</code></li><li>This restarts all <code>Pod</code>s and propagates <code>CA0</code> and <code>CA1</code> into their mounted <code>ServiceAccount</code> secrets (note CAs can not be reloaded by go client, therefore we need a restart of pods.)</li></ul></li><li><em>Ask user to exchange all their client credentials (kubeconfig, CLIENT CERTS issued by <code>CertificateSigningRequest</code>s) to trust both CA0 and CA1</em></li></ul><p><code>t2</code>: Shoot owner triggers second step of CA rotation process (&ndash;> phase two is started):</p><p>Prerequisite: All Gardener-controlled actions listed in t1 were executed successfully (for example node rollout). The shoot owner has guaranteed that they exchanged their client credentials and triggered step 2 via an annotation.</p><ul><li>Renew SERVER CERTS (sign them with <code>CA1</code>) for <code>kube-apiserver</code>, etc.</li><li>Update <code>kube-apiserver</code>, <code>kube-scheduler</code>, etc. to trust only CLIENT CERTS signed by <code>CLIENT_CA1</code></li><li>Update kubeconfig so that its CA bundle contains only <code>CA1</code></li><li>Update <code>kube-controller-manager</code> to only contain CA1. <code>ServiceAccount</code> secrets created after this point will get secrets that include only <code>CA1</code></li><li>Restart control plane components so that their CA bundle contains only <code>CA1</code></li><li>Restart kubelets so that the CA bundle in their kubeconfigs contain only <code>CA1</code></li><li>Delete <code>CA0</code></li><li><em>Ask user to optionally restart their <code>Pod</code>s since they still contain <code>CA0</code> in memory in order to eliminate trust to the old cluster CA.</em></li><li><em>Ask user to exchange all their client credentials (download kubeconfig containing only <code>CA1</code>; when using CLIENT CERTS trust only <code>CA1</code>)</em></li></ul><h3 id=rotation-sequence-of-other-cas>Rotation Sequence of Other CAs</h3><p>Apart from the kube-apiserver CA (and the client CA) we also use 5 other CAs as mentioned above in the gardener codebase. We propose to rotate those CAs together with the kube-apiserver CA following the same trigger.</p><p>ℹ️ Note for the front-proxy CA: users need to make sure, extension API servers have reloaded the <code>extension-apiserver-authentication</code> ConfigMap, before triggering the second phase.</p><p>You can find gardener managed CAs listed <a href=https://github.com/gardener/gardener/blob/04d2b3f459d198e8db0ab57180ca2fea18e84da9/pkg/operation/botanist/wanted_secrets.go#L48>here</a>.</p><p>Regarding the rotation steps we want to follow a similar approach to the one we defined for the kube-apiserver CA. Exemplary, we are going to show the timeline for ETCD_CA but the logic should be similiar for all the above listed CAs.</p><ul><li><code>t0</code><ul><li>etcd trusts client certificates signed by <code>ETCD_CA0</code> and uses a server certificate signed by <code>ETCD_CA0</code></li><li><code>kube-apiserver</code> and <code>backup-restore</code> use a client certificate signed by <code>ETCD_CA0</code> and trust <code>ETCD_CA0</code></li></ul></li><li><code>t1</code>:<ul><li>Generate <code>ETCD_CA1</code></li><li>Update <code>etcd</code> to trust CLIENT CERTS signed by both <code>ETCD_CA0</code> and <code>ETCD_CA1</code></li><li>Update <code>kube-apiserver</code> and <code>backup-restore</code>:<ul><li>Adapt CA bundle to trust both <code>ETCD_CA0</code> and <code>ETCD_CA1</code></li><li>Renew CLIENT CERTS (sign them with <code>ETCD_CA1</code>)</li></ul></li></ul></li><li><code>t2</code>:<ul><li>Update <code>etcd</code>:<ul><li>Trust only CLIENT CERTS signed by <code>ETCD_CA1</code></li><li>Renew SERVER CERT (sign it with <code>ETCD_CA1</code>)</li></ul></li><li>Update <code>kube-apiserver</code> and <code>backup-restore</code> so that their CA bundle contains only <code>ETCD_CA1</code></li></ul></li></ul><p>ℹ️ This means we are requiring two restarts of etcd in total.</p><h2 id=alternatives>Alternatives</h2><p>This section presents a different approach to rotate the CAs which is to <em>temporarily create a second set of api-servers utilizing the new CA</em> . After presenting the approach advantages and disadvantages of both approaches are listed.</p><p><code>t0</code>: Today&rsquo;s situation</p><ul><li><code>kube-apiserver</code> uses SERVER CERT signed by <code>CA0</code> and trusts CLIENT CERTS signed by <code>CA0</code></li><li><code>kube-controller-manager</code> issues new CLIENT CERTS with <code>CA0</code></li><li>kubeconfig contains only <code>CA0</code></li><li><code>ServiceAccount</code> secrets contain only <code>CA0</code></li><li>kubelet uses CLIENT CERT signed by <code>CA0</code></li></ul><p><code>t1</code>: User triggers first step of CA rotation process (&ndash;> phase one):</p><ul><li>Generate <code>CA1</code></li><li>Generate <code>CLIENT_CA1</code></li><li>Create new <code>DNSRecord</code>, <code>Service</code>, Istio configuration, etc. for second <code>kube-apiserver</code> deployment</li><li>Deploy second <code>kube-apiserver</code> deployment trusting only CLIENT CERTS signed by <code>CLIENT_CA1</code> and using SERVER CERT signed by <code>CA1</code></li><li>Update <code>kube-scheduler</code>, etc. to trust only CLIENT CERTS signed by <code>CLIENT_CA1</code> (<code>--client-ca-file</code> flag)</li><li>Update <code>kube-controller-manager</code> to issue new CLIENT CERTS with <code>CLIENT_CA1</code></li><li>Update kubeconfig so that it points to the new <code>DNSRecord</code> and its CA bundle contains only <code>CA1</code> (if kubeconfig still contains a legacy CLIENT CERT then rotate the kubeconfig)</li><li>Update <code>ServiceAccount</code> secrets so that their CA bundle contains both <code>CA0</code> and <code>CA1</code></li><li>Restart control plane components so that they point to the second <code>kube-apiserver</code> <code>Service</code> and so that their CA bundle contains only <code>CA1</code></li><li>Renew CLIENT CERTS (sign them with <code>CLIENT_CA1</code>) for control plane components (Prometheus, DWD, legacy VPN) and point them to the second <code>kube-apiserver</code> <code>Service</code></li><li>Adapt <code>apiserver-proxy-pod-mutator</code> to point <code>KUBERNETES_SERVICE_HOST</code> env variable to second <code>kube-apiserver</code></li><li>Trigger node rollout<ul><li>This issues new CLIENT CERTS for all kubelets signed by <code>CLIENT_CA1</code> and points them to the second <code>DNSRecord</code></li><li>This restarts all <code>Pod</code>s and propagates <code>CA0</code> and <code>CA1</code> into their mounted <code>ServiceAccount</code> secrets</li></ul></li><li><em>Ask user to exchange all their client credentials (kubeconfig, CLIENT CERTS issued by <code>CertificateSigningRequest</code>s)</em></li></ul><p><code>t2</code>: User triggers second step of CA rotation process (&ndash;> phase two):</p><ul><li>Update <code>ServiceAccount</code> secrets so that their CA bundle contains only <code>CA1</code></li><li>Update <code>apiserver-proxy</code> to talk to second <code>kube-apiserver</code></li><li>Drop first <code>DNSRecord</code>, <code>Service</code>, Istio configuration and first <code>kube-apiserver</code> deployment</li><li>Drop <code>CA0</code></li><li><em>Ask user to optionally restart their <code>Pod</code>s since they still contain <code>CA0</code> in memory.</em></li></ul><h4 id=advantagesdisadvantages-approach-two-api-servers>Advantages/Disadvantages approach two api servers</h4><ul><li>(+) User needs to adapt client credentials only once</li><li>(/) Unstable API server domain</li><li>(-) Probably more implementation effort</li><li>(-) More complex</li><li>(-) CA rotation process does not work similar for all CAs in our system</li></ul><h4 id=advantagesdisadvantages-of-currently-preferred-approach-see-proposal>Advantages/Disadvantages of currently preferred approach (see proposal)</h4><ul><li>(+) Implementation effort seems &ldquo;straight-forward&rdquo;</li><li>(+) CA rotation process works similar for all CAs in our system</li><li>(/) Stable API server domain</li><li>(-) User needs to adapt client credentials twice</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a3aad4401fad43af26be493b4a8c8b0d>7.19 - Utilize API Server Network Proxy to Invert Seed-to-Shoot Connectivity</h1><h1 id=utilize-api-server-network-proxy-to-invert-seed-to-shoot-connectivity>Utilize API Server Network Proxy to Invert Seed-to-Shoot Connectivity</h1><ul><li><a href=#utilize-api-server-network-proxy-to-invert-seed-to-shoot-connectivity>Utilize API Server Network Proxy to Invert Seed-to-Shoot Connectivity</a><ul><li><a href=#problem>Problem</a></li><li><a href=#proposal>Proposal</a><ul><li><a href=#api-server-network-proxy>API Server Network Proxy</a></li></ul></li><li><a href=#challenges>Challenges</a><ul><li><a href=#prometheus-to-shoot-connectivity>Prometheus to Shoot connectivity</a><ul><li><a href=#possible-solutions>Possible Solutions</a></li><li><a href=#port-forwarder-sidecar>Port-forwarder Sidecar</a></li><li><a href=#proxy-client-sidecar>Proxy Client Sidecar</a></li><li><a href=#proxy-sub-resource>Proxy sub-resource</a></li></ul></li><li><a href=#proxy-server-loadbalancer-sharing-and-re-advertising>Proxy-server Loadbalancer Sharing and Re-advertising</a><ul><li><a href=#possible-solution>Possible Solution</a></li></ul></li><li><a href=#summary>Summary</a></li></ul></li></ul></li></ul><h2 id=problem>Problem</h2><p>Gardener&rsquo;s architecture for Kubernetes clusters relies on having the control-plane (e.g., kube-apiserver, kube-scheduler, kube-controller-manager, etc.) and the data-plane (e.g., kube-proxy, kubelet, etc.) of the cluster residing in separate places, this provides many benefits but poses some challenges, especially when API-server to system components communication is required. This problem is solved today in Gardener by <a href=https://github.com/gardener/vpn>making use of OpenVPN</a> to establish a VPN connection from the seed to the shoot. To do so, the following steps are required:</p><ul><li>Create a Loadbalancer service on the shoot.</li><li>Add a sidecar to the API server pod which knows the address of the newly created Loadbalancer.</li><li>Establish a connection over the internet to the VPN Loadbalancer</li><li>Install additional iptables rules that would redirect all the IPs of the shoot (i.e., service, pod, node CIDRs) to the established VPN tunnel</li></ul><p>There are however quite a few problems with the above approach, here are some:</p><ul><li>Every shoot would require an additional loadbalancer, this accounts for addition overhead in terms of both costs and troubleshooting efforts.</li><li>Private access use-cases would not be possible without having a seed residing in the same private domain as a hard requirement. For example, have a look at <a href=https://github.com/gardener/gardener-extension-provider-gcp/issues/56>this issue</a></li><li>Providing a public endpoint to access components in the shoot poses a security risk.</li></ul><h2 id=proposal>Proposal</h2><p>There are mutliple ways to tackle the directional connectivity issue mentioned above, one way would be to invert the connection between the API server and the system components, i.e., instead of having the API server side-car establish a tunnel, we would have an agent residing in the shoot cluster initiate the connection itself. This way we don&rsquo;t need a Loadbalancer for every shoot and from the security perspective, there is no ingress from outside, only controlled egress.</p><p>We want to replace this:</p><p><code>APIServer | VPN-seed ---> internet ---> LB --> VPN-Shoot (4314) --> Pods | Nodes | Services</code></p><p>With this:</p><p><code>APIServer &lt;-> Proxy-Server &lt;--- internet &lt;--- Proxy-Agent --> Pods | Nodes | Services</code></p><h3 id=api-server-network-proxy>API Server Network Proxy</h3><p>To solve this issue we can utilize the <a href=https://github.com/kubernetes-sigs/apiserver-network-proxy>apiserver-network-proxy</a> upstream implementation. Which provides a reference implementation for a reverse streaming server. The way it works is as follows:</p><ul><li>Proxy agent connects to proxy server to establish a sticky connection.</li><li>Traffic to the proxy server (residing in the seed) gets then re-directed to the agent (residing in the shoot) which forwards the traffic to in-cluster components.</li></ul><p>The initial motivation for the apiserver-network-proxy project is to get rid of provider-specific implementations that reside in the API-server (e.g., SSH), but it turns out that
it has other interesting use-cases such as data-plane connection decoupling, which is the main use-case for this proposal.</p><p>Starting with <strong>Kubernetes 1.18</strong> it&rsquo;s possible to make use of an <code>--egress-selector-config-file</code> flag, this helps point the API-server to traffic hook points based on traffic direction. For example, in the config below the API server would have to forward all cluster related traffic (e.g., logs, port-forward, exec, &mldr;etc.) to the <strong>proxy-server</strong> which then knows how to forward traffic to the shoot. For the rest of the traffic, e.g. API server to ETCD or other control-plane components <code>direct</code> is used which means legacy routing method, i.e., by-pass the proxy.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  egress-selector-configuration.yaml: |-<span style=color:#a31515>
</span><span style=color:#a31515>    apiVersion: apiserver.k8s.io/v1alpha1
</span><span style=color:#a31515>    kind: EgressSelectorConfiguration
</span><span style=color:#a31515>    egressSelections:
</span><span style=color:#a31515>    - name: cluster
</span><span style=color:#a31515>      connection:
</span><span style=color:#a31515>        proxyProtocol: httpConnect
</span><span style=color:#a31515>        transport:
</span><span style=color:#a31515>          tcp:
</span><span style=color:#a31515>            url: https://proxy-server:8131
</span><span style=color:#a31515>    - name: master
</span><span style=color:#a31515>      connection:
</span><span style=color:#a31515>        proxyProtocol: direct
</span><span style=color:#a31515>    - name: etcd
</span><span style=color:#a31515>      connection:
</span><span style=color:#a31515>        proxyProtocol: direct</span>    
</code></pre></div><h2 id=challenges>Challenges</h2><h3 id=prometheus-to-shoot-connectivity>Prometheus to Shoot connectivity</h3><p>One challenge remains to completely eliminate the need for a VPN connection. In today&rsquo;s Gardener setup, each control-plane has a Prometheus instance that directly scrapes cluster components such as CoreDNS, Kubelets, cadvisor, etc. This works because in addition to the VPN side car attached to the API server pod, we have another one attached to prometheus which knows how to forward traffic to these endpoints. Once the VPN is eliminated, it is required to find other means to forward traffic to these components.</p><h4 id=possible-solutions>Possible Solutions</h4><p>There are currently two ways to solve this problem:</p><ul><li>Attach a port-forwarder side-car to prometheus.</li><li>Utilize the proxy subresource on the API server.</li></ul><h4 id=port-forwarder-sidecar>Port-forwarder Sidecar</h4><p>With this solution each prometheus instance would have a side-car that has the kubeconfig of the shoot cluster, and which establishes a port-forward connection to the endpoints residing in the shoot.</p><p>There are a many problems with this approach:</p><ul><li>the port-forward connection is not reliable.</li><li>the connection would break if the API server instance dies.</li><li>requires an additional component.</li><li>would need to expose every pod / service via port-forward.</li></ul><pre><code class=language-console data-lang=console>Prom Pod (Prometheus -&gt; Port-forwarder) &lt;-&gt; APIServer -&gt; Proxy-server &lt;--- internet &lt;--- Proxy-Agent --&gt; Pods | Nodes | Services
</code></pre><h4 id=proxy-client-sidecar>Proxy Client Sidecar</h4><p>Another solution would be to implement a proxy-client as a sidecar for every component that wishes to communicate with the shoot cluster. For this to work, means to re-direct / inject that proxy to handle the component&rsquo;s traffic is necessary (e.g., additional IPtable rules).</p><pre><code class=language-console data-lang=console>Prometheus Pod (Prometheus -&gt; Proxy) &lt;-&gt; Proxy-Server &lt;--- internet &lt;--- Proxy-Agent --&gt; Pods | Nodes | Services
</code></pre><p>The problem with this approach is that it requires an additional sidecar (along with traffic redirection) to be attached to every client that wishes to communicate with the shoot cluster, this can cause:</p><ul><li>additional maintenance efforts (extra code).</li><li>other side-effects (e.g., if istio sidecar injection is enabled)</li></ul><h4 id=proxy-sub-resource>Proxy sub-resource</h4><p>Kubernetes supports proxying requests to nodes, services, and pod endpoints in the shoot cluster. This proxy connection can be utilized for scraping the necessary endpoints in the shoot.</p><p>This approach requires less components and is more reliable than the port-forward solution, however, it relies on having the API server supporting proxied connection for the required endpoints.</p><pre><code class=language-console data-lang=console>Prometheus  &lt;-&gt; APIServer &lt;-&gt; Proxy-Server &lt;--- internet &lt;--- Proxy-Agent --&gt; Pods | Nodes | Services
</code></pre><p>As simple as it is, it has a downside that it relies on the availability of the API server.</p><h3 id=proxy-server-loadbalancer-sharing-and-re-advertising>Proxy-server Loadbalancer Sharing and Re-advertising</h3><p>With the proxy-server in place, we need to provide means to enable the proxy-agent in the shoot to establish the connection with the server. As a result, we need to provide a public endpoint through which this channel of communication can be established, i.e., we need a Loadbalancer(s).</p><h4 id=possible-solution>Possible Solution</h4><p>Using a Loadbalancer / proxy server would not make sense since this is a pain-point we are trying to eliminate in the first-place, doing so just moves the costs to the control-plane. A possible solution is to communicate over a shared loadbalancer in the seed, similar to what has been proposed <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>here</a>, this way we can prevent the extra-costs for load-balancers.</p><p>With this in mind, we still have other pain-points, namely:</p><ul><li>Advertising Loadbalancer public IPs to the shoot.</li><li>Directing the traffic to the corresponding shoot proxy-server.</li></ul><p>For advertising the Loadbalancer IP, a DNS entry can be created for the proxy loadbalancer (or re-use the DNS entry for the SNI proxy), along with necessary certificates, which is then used to connect to the loadbalancer. At this point we can decide on either one of the two approaches:</p><ol><li>One Proxy / API server with a shared loadbalancer.</li><li>Use one proxy server for all agents.</li></ol><p>In the first case, we will probably need a proxy for the proxy-server that knows how to direct traffic to the correct proxy server based on the corresponding shoot cluster. In the second case, we don&rsquo;t need another proxy if the proxy server is cluster-aware, i.e., can pool and identify connections coming from the same cluster and peer them with the correct API. Unfortunately, the second case is not supported today.</p><h3 id=summary>Summary</h3><ul><li>API server proxy can be utilized to invert the connection (only for clusters >= 1.18, for older clusters the old VPN solution will remain).</li><li>This is achieved by utilizing the <code>--egress-selector-config-file</code> flag on the api-server.</li><li>For monitoring endpoints, the proxy subresources would be the preferable methods to go, but in the future we can also support sidecar proxies that can communicate with the proxy-server.</li><li>For Directing traffic to the correct proxy-server we will re-use the SNI proxy along with the load-balancer from <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>the shoot API server via SNI GEP</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d9bbacfebdbb87bb1858bcd155c5647f>8 - Usage</h1></div><div class=td-content><h1 id=pg-5092bba8dce7cbbc8af74c9d34288317>8.1 - Hibernate a Cluster</h1><h1 id=hibernate-a-cluster>Hibernate a Cluster</h1><p>Clusters are only needed 24 hours a day if they run productive workload. So whenever you do development in a cluster, or just use it for tests or demo purposes, you can save much money if you scale-down your Kubernetes resources whenever you don&rsquo;t need them. However, scaling them down manually can become time-consuming the more resources you have.</p><p>Gardener offers a clever way to automatically scale-down all resources to zero: cluster hibernation. You can either hibernate a cluster by pushing a button or by defining a hibernation schedule.</p><blockquote><p>To save costs, it&rsquo;s recommended to define a hibernation schedule before the creation of a cluster. You can hibernate your cluster or wake up your cluster manually even if there&rsquo;s a schedule for its hibernation.</p></blockquote><ul><li><a href=#what-is-hibernated>What is hibernated?</a></li><li><a href=#what-isnt-affected-by-the-hibernation>What isn’t affected by the hibernation?</a></li><li><a href=#hibernate-your-cluster-manually>Hibernate your cluster manually</a></li><li><a href=#wake-up-your-cluster-manually>Wake up your cluster manually</a></li><li><a href=#create-a-schedule-to-hibernate-your-cluster>Create a schedule to hibernate your cluster</a></li></ul><h2 id=what-is-hibernated>What is hibernated?</h2><p>When a cluster is hibernated, Gardener scales down worker nodes and the cluster&rsquo;s control plane to free resources at the IaaS provider. This affects:</p><ul><li>Your workload, for example, pods, deployments, custom resources.</li><li>The virtual machines running your workload.</li><li>The resources of the control plane of your cluster.</li></ul><h2 id=what-isnt-affected-by-the-hibernation>What isn’t affected by the hibernation?</h2><p>To scale up everything where it was before hibernation, Gardener doesn’t delete state-related information, that is, information stored in persistent volumes. The cluster state as persistent in <code>etcd</code> is also preserved.</p><h2 id=hibernate-your-cluster-manually>Hibernate your cluster manually</h2><p>To hibernate your cluster you can run the following <code>kubectl</code> command:</p><pre><code>$ kubectl patch shoot -n $NAMESPACE $SHOOT_NAME -p '{&quot;spec&quot;:{&quot;hibernation&quot;:{&quot;enabled&quot;: true}}}'
</code></pre><h2 id=wake-up-your-cluster-manually>Wake up your cluster manually</h2><p>To wake up your cluster you can run the following <code>kubectl</code> command:</p><pre><code>$ kubectl patch shoot -n $NAMESPACE $SHOOT_NAME -p '{&quot;spec&quot;:{&quot;hibernation&quot;:{&quot;enabled&quot;: false}}}'
</code></pre><p><strong>Hibernation schedule is also supported. More details can be found <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/core/v1beta1/types_shoot.go#L335-L348>here</a></strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-5cc140bc78ef125e0e6636c2d7cd748a>8.2 - Apiserver Sni Injection</h1><h1 id=apiserversni-environment-variable-injection>APIServerSNI environment variable injection</h1><p>If the Gardener administrator has enabled <code>APIServerSNI</code> feature gate for a particular Seed cluster, then in each Shoot cluster&rsquo;s <code>kube-system</code> namespace a <code>DaemonSet</code> called <code>apiserver-proxy</code> is deployed. It routes traffic to the upstream Shoot Kube APIServer. See the <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>APIServer SNI GEP</a> for more details.</p><p>To skip this extra network hop, a <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>mutating webhook</a> called <code>apiserver-proxy.networking.gardener.cloud</code> is deployed next to the API server in the Seed. It adds <code>KUBERNETES_SERVICE_HOST</code> environment variable to each container and init container that do not specify it. See the webhook <a href=https://github.com/gardener/apiserver-proxy/>repository</a> for more information.</p><h2 id=opt-out-of-pod-injection>Opt-out of pod injection</h2><p>In some cases it&rsquo;s desirable to opt-out of Pod injection:</p><ul><li>DNS is disabled on that individual Pod, but it still needs to talk to the kube-apiserver.</li><li>Want to test the <code>kube-proxy</code> and <code>kubelet</code> in-cluster discovery.</li></ul><h3 id=opt-out-of-pod-injection-for-specific-pods>Opt-out of pod injection for specific pods</h3><p>To opt out of the injection, the Pod should be labeled with <code>apiserver-proxy.networking.gardener.cloud/inject: disable</code> e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
        apiserver-proxy.networking.gardener.cloud/inject: disable
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
</code></pre></div><h3 id=opt-out-of-pod-injection-on-namespace-level>Opt-out of pod injection on namespace level</h3><p>To opt out of the injection of <strong>all</strong> Pods in a namespace, you should label your namespace with <code>apiserver-proxy.networking.gardener.cloud/inject: disable</code> e.g.:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Namespace
metadata:
  labels:
    apiserver-proxy.networking.gardener.cloud/inject: disable
  name: my-namespace
</code></pre></div><p>or via <code>kubectl</code> for existing namespace:</p><pre><code class=language-console data-lang=console>kubectl label namespace my-namespace apiserver-proxy.networking.gardener.cloud/inject=disable
</code></pre><blockquote><p>NOTE: Please be aware that it&rsquo;s not possible to disable injection on namespace level and enable it for individual pods in it.</p></blockquote><h3 id=opt-out-of-pod-injection-for-the-entire-cluster>Opt-out of pod injection for the entire cluster</h3><p>If the injection is causing problems for different workloads and ignoring individual pods or namespaces is not possible, then the feature could be disabled for the entire cluster with the <code>alpha.featuregates.shoot.gardener.cloud/apiserver-sni-pod-injector</code> annotation with value <code>disable</code> on the <code>Shoot</code> resource itself:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  annotations:
    alpha.featuregates.shoot.gardener.cloud/apiserver-sni-pod-injector: <span style=color:#a31515>&#39;disable&#39;</span>
  name: my-cluster
</code></pre></div><p>or via <code>kubectl</code> for existing shoot cluster:</p><pre><code class=language-console data-lang=console>kubectl label shoot my-cluster alpha.featuregates.shoot.gardener.cloud/apiserver-sni-pod-injector=disable
</code></pre><blockquote><p>NOTE: Please be aware that it&rsquo;s not possible to disable injection on cluster level and enable it for individual pods in it.</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-7e7022c7d80b227a07794be1c66352e7>8.3 - Configuration</h1><h1 id=gardener-configuration-and-usage>Gardener Configuration and Usage</h1><p>Gardener automates the full lifecycle of Kubernetes clusters as a service.
Additionally, it has several extension points allowing external controllers to plug-in to the lifecycle.
As a consequence, there are several configuration options for the various custom resources that are partially required.</p><p>This document describes the</p><ol><li><a href=#configuration-and-usage-of-gardener-as-operatoradministrator>configuration and usage of Gardener as operator/administrator</a>.</li><li><a href=#configuration-and-usage-of-gardener-as-end-userstakeholdercustomer>configuration and usage of Gardener as end-user/stakeholder/customer</a>.</li></ol><h2 id=configuration-and-usage-of-gardener-as-operatoradministrator>Configuration and Usage of Gardener as Operator/Administrator</h2><p>When we use the terms &ldquo;operator/administrator&rdquo; we refer to both the people deploying and operating Gardener.
Gardener consists of the following components:</p><ol><li><code>gardener-apiserver</code>, a Kubernetes-native API extension that serves custom resources in the Kubernetes-style (like <code>Seed</code>s and <code>Shoot</code>s), and a component that contains multiple admission plugins.</li><li><code>gardener-admission-controller</code>, an HTTP(S) server with several handlers to be used in a <a href=https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/charts/application/templates/validatingwebhook-admission-controller.yaml>ValidatingWebhookConfiguration</a>.</li><li><code>gardener-controller-manager</code>, a component consisting out of multiple controllers that implement reconciliation and deletion flows for some of the custom resources (e.g., it contains the logic for maintaining <code>Shoot</code>s, reconciling <code>Plant</code>s, etc.).</li><li><code>gardener-scheduler</code>, a component that assigns newly created <code>Shoot</code> clusters to appropriate <code>Seed</code> clusters.</li><li><code>gardenlet</code>, a component running in seed clusters and consisting out of multiple controllers that implement reconciliation and deletion flows for some of the custom resources (e.g., it contains the logic for reconciliation and deletion of <code>Shoot</code>s).</li></ol><p>Each of these components have various configuration options.
The <code>gardener-apiserver</code> uses the standard API server library maintained by the Kubernetes community, and as such it mainly supports command line flags.
Other components use so-called componentconfig files that describe their configuration in a Kubernetes-style versioned object.</p><h3 id=configuration-file-for-gardener-admission-controller>Configuration file for Gardener admission controller</h3><p>The Gardener admission controller does only support one command line flag which should be a path to a valid admission-controller configuration file.
Please take a look at <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardener-admission-controller.yaml>this</a> example configuration.</p><h3 id=configuration-file-for-gardener-controller-manager>Configuration file for Gardener controller manager</h3><p>The Gardener controller manager does only support one command line flag which should be a path to a valid controller-manager configuration file.
Please take a look at <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardener-controller-manager.yaml>this</a> example configuration.</p><h3 id=configuration-file-for-gardener-scheduler>Configuration file for Gardener scheduler</h3><p>The Gardener scheduler also only supports one command line flag which should be a path to a valid scheduler configuration file.
Please take a look at <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardener-scheduler.yaml>this</a> example configuration.
Information about the concepts of the Gardener scheduler can be found <a href=/docs/gardener/concepts/scheduler/>here</a></p><h3 id=configuration-file-for-gardenlet>Configuration file for Gardenlet</h3><p>The Gardenlet also only supports one command line flag which should be a path to a valid gardenlet configuration file.
Please take a look at <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>this</a> example configuration.
Information about the concepts of the Gardenlet can be found <a href=/docs/gardener/concepts/gardenlet/>here</a></p><h3 id=system-configuration>System configuration</h3><p>After successful deployment of the four components you need to setup the system.
Let&rsquo;s first focus on some &ldquo;static&rdquo; configuration.
When the <code>gardenlet</code> starts it scans the <code>garden</code> namespace of the garden cluster for <code>Secret</code>s that have influence on its reconciliation loops, mainly the <code>Shoot</code> reconciliation:</p><ul><li><p><strong>Internal domain secret</strong>, contains the DNS provider credentials (having appropriate privileges) which will be used to create/delete so-called &ldquo;internal&rdquo; DNS records for the Shoot clusters, please see <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-internal-domain.yaml>this</a> for an example.</p><ul><li>This secret is used in order to establish a stable endpoint for shoot clusters which is used internally by all control plane components.</li><li>The DNS records are normal DNS records but called &ldquo;internal&rdquo; in our scenario because only the kubeconfigs for the control plane components use this endpoint when talking to the shoot clusters.</li><li>It is forbidden to change the internal domain secret if there are existing shoot clusters.</li></ul></li><li><p><strong>Default domain secrets</strong> (optional), contain the DNS provider credentials (having appropriate privileges) which will be used to create/delete DNS records for a default domain for shoots (e.g., <code>example.com</code>), please see <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-default-domain.yaml>this</a> for an example.</p><ul><li>Not every end-user/stakeholder/customer has its own domain, however, Gardener needs to create a DNS record for every shoot cluster.</li><li>As landscape operator you might want to define a default domain owned and controlled by you that is used for all shoot clusters that don&rsquo;t specify their own domain.</li><li>If you have multiple default domain secrets defined you can add a priority as an annotation (<code>dns.gardener.cloud/domain-default-priority</code>) to select which domain should be used for new shoots while creation. The domain with the highest priority is selected while shoot creation. If there is no annotation defined the default priority is <code>0</code>, also all non integer values are considered as priority <code>0</code>.</li></ul></li></ul><p>⚠️ Please note that the mentioned domain secrets are only needed if you have at least one seed cluster that is not specifing <code>.spec.settings.shootDNS.enabled=false</code>.
Seeds with this taint don&rsquo;t create any DNS records for shoots scheduled on it, hence, if you only have such seeds, you don&rsquo;t need to create the domain secrets.</p><ul><li><p><strong>Alerting secrets</strong> (optional), contain the alerting configuration and credentials for the <a href=https://prometheus.io/docs/alerting/alertmanager/>AlertManager</a> to send email alerts. It is also possible to configure the monitoring stack to send alerts to an AlertManager not deployed by Gardener to handle alerting. Please see <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-alerting.yaml>this</a> for an example.</p><ul><li>If email alerting is configured:<ul><li>An AlertManager is deployed into each seed cluster that handles the alerting for all shoots on the seed cluster.</li><li>Gardener will inject the SMTP credentials into the configuration of the AlertManager.</li><li>The AlertManager will send emails to the configured email address in case any alerts are firing.</li></ul></li><li>If an external AlertManager is configured:<ul><li>Each shoot has a <a href=https://prometheus.io/docs/introduction/overview/>Prometheus</a> responsible for monitoring components and sending out alerts. The alerts will be sent to a URL configured in the alerting secret.</li><li>This external AlertManager is not managed by Gardener and can be configured however the operator sees fit.</li><li>Supported authentication types are no authentication, basic, or mutual TLS.</li></ul></li></ul></li><li><p><strong>OpenVPN Diffie-Hellmann Key secret</strong> (optional), contains the self-generated Diffie-Hellmann key used by OpenVPN in your landscape, please see <a href=https://github.com/gardener/gardener/blob/master/example/10-secret-openvpn-diffie-hellman.yaml>this</a> for an example.</p><ul><li>If you don&rsquo;t specify a custom key then a default key is used, but for productive landscapes it&rsquo;s recommend to create a landscape-specific key and define it.</li></ul></li><li><p><strong>Global monitoring secrets</strong> (optional), contains basic authentication credentials for the Prometheus aggregating metrics for all clusters.</p><ul><li>These secrets are synced to each seed cluster and used to gain access to the aggregate monitoring components.</li></ul></li></ul><p>Apart from this &ldquo;static&rdquo; configuration there are several custom resources extending the Kubernetes API and used by Gardener.
As an operator/administrator you have to configure some of them to make the system work.</p><h3 id=configuration-and-usage-of-gardener-as-end-userstakeholdercustomer>Configuration and Usage of Gardener as End-User/Stakeholder/Customer</h3><p>As an end-user/stakeholder/customer you are using a Gardener landscape that has been setup for you by another team.
You don&rsquo;t need to care about how Gardener itself has to be configured or how it has to be deployed.
Take a look at <a href=/docs/gardener/concepts/apiserver/>this document</a> - it describes which resources are offered by Gardener.
You may want to have a more detailed look for <code>Project</code>s, <code>SecretBinding</code>s, <code>Shoot</code>s, <code>Plant</code>s, and <code>(Cluster)OpenIDConnectPreset</code>s.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-557189bc540e3079a8a290a1db4e319f>8.4 - Control Plane Migration</h1><h1 id=control-plane-migration>Control Plane Migration</h1><h2 id=preconditions>Preconditions</h2><p>To be able to use this feature you need to enable the feature gate <code>SeedChange</code> in your <code>gardener-apiserver</code>
by adding the following command flag: <code>--feature-gates=SeedChange=true</code>.</p><p>Also, the involved Seeds need to have enabled BackupBuckets.</p><h2 id=shootstate>ShootState</h2><p><code>ShootState</code> is an API resource which stores non-reconstructible state and data required to completely recreate a <code>Shoot</code>&rsquo;s control plane on a new <code>Seed</code>. The <code>ShootState</code> resource is created on <code>Shoot</code> creation in its <code>Project</code> namespace and the required state/data is persisted during <code>Shoot</code> creation or reconciliation.</p><h2 id=shoot-control-plane-migration>Shoot Control Plane Migration</h2><p>Triggering the migration is done by changing the <code>Shoot</code>&rsquo;s <code>.spec.seedName</code> to a <code>Seed</code> that differs from the <code>.status.seedName</code>, we call this <code>Seed</code> <code>"Destination Seed"</code>. If the Destination <code>Seed</code> does not have a backup and restore configuration, the change to <code>spec.seedName</code> is rejected. Additionally, this Seed must not be set for deletion and must be healthy.</p><p>If the <code>Shoot</code> has different <code>.spec.seedName</code> and <code>.status.seedName</code> a process is started to prepare the Control Plane for migration:</p><ol><li><code>.status.lastOperation</code> is changed to <code>Migrate</code>.</li><li>Kubernetes API Server is stopped and the extension resources are annotated with <code>gardener.cloud/operation=migrate</code>.</li><li>Full snapshot of the ETCD is created and terminating of the Control Plane in the <code>Source Seed</code> is initiated.</li></ol><p>If the process is successful, we update the status of the <code>Shoot</code> by setting the <code>.status.seedName</code> to the null value. That way, a restoration is triggered in the <code>Destination Seed</code> and <code>.status.lastOperation</code> is changed to <code>Restore</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3a01742bcc319ec4dfb0ee2cdce04deb>8.5 - Csi Components</h1><h1 id=custom-csi-components>(Custom) CSI Components</h1><p>Some provider extensions for Gardener are using CSI components to manage persistent volumes in the shoot clusters.
Additionally, most of the provider extensions are deploying controllers for taking volume snapshots (CSI snapshotter).</p><p>End-users can deploy their own CSI components and controllers into shoot clusters.
In such situations, there are multiple controllers acting on the <code>VolumeSnapshot</code> custom resources (each responsible for those instances associated with their respective driver provisioner types).</p><p>However, this might lead to operational conflicts that cannot be overcome by Gardener alone.
Concretely, Gardener cannot know which custom CSI components were installed by end-users which can lead to issues, especially during shoot cluster deletion.
You can add a label to your custom CSI components indicating that Gardener should not try to remove them during shoot cluster deletion. This means you have to take care of the lifecycle for these components yourself!</p><h2 id=recommendations>Recommendations</h2><p>Custom CSI components are typically regular <code>Deployment</code>s running in the shoot clusters.</p><p><strong>Please label them with the <code>shoot.gardener.cloud/no-cleanup=true</code> label.</strong></p><h2 id=background-information>Background Information</h2><p>When a shoot cluster is deleted, Gardener deletes most Kubernetes resources (<code>Deployment</code>s, <code>DaemonSet</code>s, <code>StatefulSet</code>s, etc.). Gardener will also try to delete CSI components if they are not marked with the above mentioned label.</p><p>This can result in <code>VolumeSnapshot</code> resources still having finalizers that will never be cleaned up.
Consequently, manual intervention is required to clean them up before the cluster deletion can continue.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-84651b4d4651fa66c31fb34b1b24d215>8.6 - Custom Dns</h1><h1 id=custom-dns-configuration>Custom DNS Configuration</h1><p>Gardener provides Kubernetes-Clusters-As-A-Service where all the system components (e.g., kube-proxy, networking, dns, &mldr;) are managed.
As a result, Gardener needs to ensure and auto-correct additional configuration to those system components to avoid unnecessary down-time.</p><p>In some cases, auto-correcting system components can prevent users from deploying applications on top of the cluster that requires bits of customization, DNS configuration can be a good example.</p><p>To allow for customizations for DNS configuration (that could potentially lead to downtime) while having the option to &ldquo;undo&rdquo;, we utilize the <code>import</code> plugin from CoreDNS [1].
which enables in-line configuration changes.</p><h2 id=how-to-use>How to use</h2><p>To customize your CoreDNS cluster config, you can simply edit a <code>ConfigMap</code> named <code>coredns-custom</code> in the <code>kube-system</code> namespace.
By editing, this <code>ConfigMap</code>, you are modifying CoreDNS configuration, therefore care is advised.</p><p>For example, to apply new config to CoreDNS that would point all <code>.global</code> DNS requests to another DNS pod, simply edit the configuration as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns-custom
  namespace: kube-system
data:
  istio.server: |<span style=color:#a31515>
</span><span style=color:#a31515>    global:8053 {
</span><span style=color:#a31515>            errors
</span><span style=color:#a31515>            cache 30
</span><span style=color:#a31515>            forward . 1.2.3.4
</span><span style=color:#a31515>        }</span>    
  corefile.override: |<span style=color:#a31515>
</span><span style=color:#a31515>         # &lt;some-plugin&gt; &lt;some-plugin-config&gt;
</span><span style=color:#a31515>         debug
</span><span style=color:#a31515>         whoami</span>         
</code></pre></div><p>It is important to have the <code>ConfigMap</code> keys ending with <code>*.server</code> (if you would like to add a new server) or <code>*.override</code>
if you want to customize the current server configuration (it is optional setting both).</p><h2 id=optional-reload-coredns>[Optional] Reload CoreDNS</h2><p>As Gardener is configuring the <code>reload</code> <a href=https://coredns.io/plugins/reload/>plugin</a> of CoreDNS a restart of the CoreDNS components is typically not necessary to propagate <code>ConfigMap</code> changes. However, if you don&rsquo;t want to wait for the default (30s) to kick in, you can roll-out your CoreDNS deployment using:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n kube-system rollout restart deploy coredns
</code></pre></div><p>This will reload the config into CoreDNS.</p><p>The approach we follow here was inspired by AKS&rsquo;s approach [2].</p><h2 id=anti-pattern>Anti-Pattern</h2><p>Applying a configuration that is in-compatible with the running version of CoreDNS is an anti-pattern (sometimes plugin configuration changes,
simply applying a configuration can break DNS).</p><p>If incompatible changes are applied by mistake, simply delete the content of the <code>ConfigMap</code> and re-apply.
This should bring the cluster DNS back to functioning state.</p><h2 id=references>References</h2><p>[1] <a href=https://github.com/coredns/coredns/tree/master/plugin/import>Import plugin</a>
[2] <a href=https://docs.microsoft.com/en-us/azure/aks/coredns-custom>AKS Custom DNS</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-da5e6c1f64dc67e784358df56a1ec88d>8.7 - Dns Autoscaling</h1><h1 id=dns-autoscaling>DNS Autoscaling</h1><p>This is a short guide describing different options how to automatically scale CoreDNS in the shoot cluster.</p><h2 id=background>Background</h2><p>Currently, Gardener uses CoreDNS as DNS server. Per default, it is installed as a deployment into the shoot cluster that is auto-scaled horizontally to cover for QPS-intensive applications. However, doing so does not seem to be enough to completely circumvent DNS bottlenecks such as:</p><ul><li>Cloud provider limits for DNS lookups.</li><li>Unreliable UDP connections that forces a period of timeout in case packets are dropped.</li><li>Unnecessary node hopping since CoreDNS is not deployed on all nodes, and as a result DNS queries end-up traversing multiple nodes before reaching the destination server.</li><li>Inefficient load-balancing of services (e.g., round-robin might not be enough when using IPTables mode).</li><li>Overload of the CoreDNS replicas as the maximum amount of replicas is fixed.</li><li>and more &mldr;</li></ul><p>As an alternative with extended configuration options, Gardener provides cluster-proportional autoscaling of CoreDNS. This guide focuses on the configuration of cluster-proportional autoscaling of CoreDNS and its advantages/disadvantages compared to the horizontal
autoscaling.
Please note that there is also the option to use a <a href=/docs/gardener/usage/node-local-dns/>node-local DNS cache</a>, which helps mitigate potential DNS bottlenecks (see <a href=#trade-offs-in-conjunction-with-nodelocaldns>Trade-offs in conjunction with NodeLocalDNS</a> for considerations regarding using NodeLocalDNS together with one of the CoreDNS autoscaling approaches).</p><h2 id=configuring-cluster-proportional-dns-autoscaling>Configuring cluster-proportional DNS Autoscaling</h2><p>All that needs to be done to enable the usage of cluster-proportional autoscaling of CoreDNS is to set the corresponding option (<code>spec.systemComponents.coreDNS.autoscaling.mode</code>) in the <code>Shoot</code> resource to <code>cluster-proportional</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>...
spec:
  ...
  systemComponents:
    coreDNS:
      autoscaling:
        mode: cluster-proportional
...
</code></pre></div><p>To switch back to horizontal DNS autoscaling you can set the <code>spec.systemComponents.coreDNS.autoscaling.mode</code> to <code>horizontal</code> (or remove the <code>coreDNS</code> section).</p><p>Once the cluster-proportional autoscaling of CoreDNS has been enabled and the Shoot cluster has been reconciled afterwards, a ConfigMap called <code>coredns-autoscaler</code> will be created in the <code>kube-system</code> namespace with the default settings. The content will be similar to the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>linear: <span style=color:#a31515>&#39;{&#34;coresPerReplica&#34;:256,&#34;min&#34;:2,&#34;nodesPerReplica&#34;:16}&#39;</span>
</code></pre></div><p>It is possible to adapt the ConfigMap according to your needs in case the defaults do not work as desired. The number of CoreDNS replicas is calculated according to the following formula:</p><pre><code>replicas = max( ceil( cores × 1 / coresPerReplica ) , ceil( nodes × 1 / nodesPerReplica ) )
</code></pre><p>Depending on your needs, you can adjust <code>coresPerReplica</code> or <code>nodesPerReplica</code>, but it is also possible to override <code>min</code> if required.</p><h2 id=trade-offs-of-horizontal-and-cluster-proportional-dns-autoscaling>Trade-offs of horizontal and cluster-proportional DNS Autoscaling</h2><p>The horizontal autoscaling of CoreDNS as implemented by Gardener is fully managed, i.e. you do not need to perform any configuration changes. It scales according to the CPU usage of CoreDNS replicas meaning that it will create new replicas if the existing ones are under heavy load. This approach scales between 2 and 5 instances, which is sufficient for most workloads. In case this is not enough, the cluster-proportional autoscaling approach can be used instead with its more flexible configuration options.</p><p>The cluster-proportional autoscaling of CoreDNS as implemented by Gardener is fully managed, but allows more configuration options to adjust the default settings to your individual needs. It scales according to the cluster size, i.e. if your cluster grows in terms of cores/nodes so will the amount of CoreDNS replicas. However, it does not take the actual workload, e.g. CPU consumption, into account.</p><p>Experience shows that the horizontal autoscaling of CoreDNS works for a variety of workloads. It does reach its limits if a cluster has a high amount of DNS requests, though. The cluster-proportional autoscaling approach allows to fine-tune the amount of CoreDNS replicas. It helps to scale in clusters of changing size. However, please keep in mind that you need to cater for the maximum amount of DNS requests as the replicas will not be adapted according to the workload, but only according to the cluster size (cores/nodes).</p><h2 id=trade-offs-in-conjunction-with-nodelocaldns>Trade-offs in conjunction with NodeLocalDNS</h2><p>Using a <a href=/docs/gardener/usage/node-local-dns/>node-local DNS cache</a> can mitigate a lot of the potential DNS related problems. It works fine with a DNS workload that can be handle through the cache and reduces the inter-node DNS communication. As <a href=/docs/gardener/usage/node-local-dns/>node-local DNS cache</a> reduces the amount of traffic being sent to the cluster&rsquo;s CoreDNS replicas, it usually works fine with horizontally scaled CoreDNS. Nevertheless, it also works with CoreDNS scaled in a cluster-proportional approach. In this mode, though, it might make sense to adapt the default settings as the CoreDNS workload is likely significantly reduced.</p><p>Overall, you can view the DNS options on a scale. Horizontally scaled DNS provides a small amount of DNS servers. Especially for bigger clusters, a cluster-proportional approach will yield more CoreDNS instances and hence may yield a more balanced DNS solution. By adapting the settings you can further increase the amount of CoreDNS replicas. On the other end of the spectrum, a <a href=/docs/gardener/usage/node-local-dns/>node-local DNS cache</a> provides DNS on every node and allows to reduce the amount of (backend) CoreDNS instances regardless if they are horizontally or cluster-proportionally scaled.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2c8dcee576a95f02378e3b89966d6410>8.8 - Docker Shim Removal</h1><h1 id=kubernetes-dockershim-removal>Kubernetes dockershim removal</h1><h2 id=whats-happening>What&rsquo;s happening?</h2><p>With Kubernetes v1.20 the built-in dockershim <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#dockershim-deprecation>was deprecated</a> and is scheduled to be <a href=https://github.com/kubernetes/enhancements/issues/2221>removed with v1.24</a>.
Don&rsquo;t Panic! The Kubernetes community has <a href=https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/>published a blogpost</a> and an <a href=https://kubernetes.io/blog/2020/12/02/dockershim-faq/>FAQ</a> with more information.</p><p>Gardener also needs to switch from using the built-in dockershim to <code>containerd</code>.
Gardener will not change running Shoot clusters. But changes to the container runtime will be coupled to the K8s version selected by the Shoot:</p><ul><li>starting with K8s version 1.22 Shoots not explicitly selecting a container runtime will get <code>containerd</code> instead of <code>docker</code>. Shoots can still select <code>docker</code> explicitly if needed.</li><li>starting with K8s version 1.23 <code>docker</code> can no longer be selected.</li></ul><p>At this point in time, we have no plans to support other container runtimes, such as <code>cri-o</code>.</p><h2 id=what-should-i-do>What should I do?</h2><p>As a gardener operator:</p><ul><li>add <code>containerd</code> and <code>docker</code> to <code>.spec.machineImages[].versions[].cri.name</code> in your CloudProfile to allow users selecting a container runtime for their Shoots (see below). <strong>Note:</strong> Please take a look at our detailed information regarding <a href=#container-runtime-support-in-gardener-operating-system-extensions>container runtime support in Gardener Operating System Extensions</a></li><li>update your cloud provider extensions to avoid a node rollout when a Shoot is configured from <code>cri: nil</code> to <code>cri.name: docker</code>. <strong>Note:</strong> Please take a look at our detailed information regarding <a href=#stable-worker-node-hash-support-in-gardener-provider-extensions>stable Worker node hash support in Gardener Provider Extensions</a></li></ul><p>As a shoot owner:</p><ul><li><a href=https://kubernetes.io/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-deprecation-affects-you/#find-docker-dependencies>check if you have dependencies to the <code>docker</code> container runtime</a>. <strong>Note:</strong> This is not only about your actual workload, but also concerns ops tooling as well as logging, monitoring and metric agents installed on the nodes</li><li>test with <code>containerd</code>:<ul><li>create a new Shoot or add a Worker Pool to an existing one</li><li><a href=/docs/gardener/api-reference/core/#cri>set <code>.spec.provider.workers[].cri.name: containerd</code></a> for your Shoot</li></ul></li><li>once testing is successful, switch to <code>containerd</code> with your production workload. You don&rsquo;t need to wait for kubernetes v1.22, <code>containerd</code> is considered production ready as of today</li><li>if you find dependencies to <code>docker</code>, set <code>.spec.provider.workers[].cri.name: docker</code> explicitly to avoid defaulting to <code>containerd</code> once you update your Shoot to kubernetes v1.22</li></ul><h2 id=timeline>Timeline</h2><ul><li><strong>2021-08-04:</strong> Kubernetes v1.22 released. Shoots using this version get <code>containerd</code> as default container runtime. Shoots can still select <code>docker</code> explicitly if needed.</li><li><strong>2021-12-07:</strong> Kubernetes v1.23 released. Shoots using this version can no longer select <code>docker</code> as container runtime.</li><li><strong>2022-06-28:</strong> Kubernetes v1.21 goes out of maintenance. This is the last version not affected by these changes. Make sure you have tested thoroughly and set the correct configuration for your Shoots!</li><li><strong>2022-10-28:</strong> Kubernetes v1.22 goes out of maintenance. This is the last version that you can use with <code>docker</code> as container runtime. Make sure you have removed any dependencies to <code>docker</code> as container runtime!</li></ul><p>See <a href=https://kubernetes.io/releases/>the official kubernetes documentation</a> for the exact dates for all releases.</p><h2 id=container-runtime-support-in-gardener-operating-system-extensions>Container Runtime support in Gardener Operating System Extensions</h2><table><thead><tr><th>Operating System</th><th>docker support</th><th>containerd support</th></tr></thead><tbody><tr><td>GardenLinux</td><td>✅</td><td>>= v0.3.0</td></tr><tr><td>Ubuntu</td><td>✅</td><td>>= v1.4.0</td></tr><tr><td>SuSE CHost</td><td>✅</td><td>>= v1.14.0</td></tr><tr><td>CoreOS/FlatCar</td><td>✅</td><td>>= v1.8.0</td></tr></tbody></table><p><strong>Note</strong>: If you&rsquo;re using a different Operating System Extension, start evaluating now if it provides support for <code>containerd</code>. Please refer to <a href=/docs/gardener/extensions/operatingsystemconfig/#cri-support>our documentation of the <code>operatingsystemconfig</code> contract</a> to understand how to support <code>containerd</code> for an Operating System Extension.</p><h2 id=stable-worker-node-hash-support-in-gardener-provider-extensions>Stable Worker node hash support in Gardener Provider Extensions</h2><p>Upgrade to these versions to avoid a node rollout when a Shoot is configured from <code>cri: nil</code> to <code>cri.name: docker</code>.</p><table><thead><tr><th>Provider Extension</th><th>Stable worker hash support</th></tr></thead><tbody><tr><td>Alicloud</td><td>>= 1.26.0</td></tr><tr><td>AWS</td><td>>= 1.27.0</td></tr><tr><td>Azure</td><td>>= 1.21.0</td></tr><tr><td>GCP</td><td>>= 1.18.0</td></tr><tr><td>OpenStack</td><td>>= 1.21.0</td></tr><tr><td>vSphere</td><td>>= 0.11.0</td></tr></tbody></table><p><strong>Note</strong>: If you&rsquo;re using a different Provider Extension, start evaluating now if it keeps the worker hash stable when switching from <code>.spec.provider.workers[].cri: nil</code> to <code>.spec.provider.workers[].cri.name: docker</code>. This doesn&rsquo;t impact functional correctness, however, a node rollout will be triggered when users decide to configure <code>docker</code> for their shoots.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c846de8dc75ecb3d656ca901da206be3>8.9 - Exposureclasses</h1><h1 id=exposureclasses>ExposureClasses</h1><p>The Gardener API server provides a cluster-scoped <code>ExposureClass</code> resource.
This resource is used to allow exposing the control plane of a Shoot cluster in various network environments like restricted corporate networks, DMZ etc.</p><h2 id=background>Background</h2><p>The <code>ExposureClass</code> resource is based on the concept for the <code>RuntimeClass</code> resource in Kubernetes.</p><p>A <code>RuntimeClass</code> abstracts the installation of a certain container runtime (e.g. gVisor, Kata Containers) on all nodes or a subset of the nodes in a Kubernetes cluster.
See <a href=https://kubernetes.io/docs/concepts/containers/runtime-class/>here</a>.</p><p>In contrast, an <code>ExposureClass</code> abstracts the ability to expose a Shoot clusters control plane in certain network environments (e.g. corporate networks, DMZ, internet) on all Seeds or a subset of the Seeds.</p><p>Example: <code>RuntimeClass</code> and <code>ExposureClass</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: gvisor
handler: gvisorconfig
<span style=color:green># scheduling:</span>
<span style=color:green>#   nodeSelector:</span>
<span style=color:green>#     env: prod</span>
---
kind: ExposureClass
metadata:
  name: internet
handler: internet-config
<span style=color:green># scheduling:</span>
<span style=color:green>#   seedSelector:</span>
<span style=color:green>#     matchLabels:</span>
<span style=color:green>#       network/env: internet</span>
</code></pre></div><p>Similar to <code>RuntimeClasses</code>, <code>ExposureClasses</code> also define a <code>.handler</code> field reflecting the name reference for the corresponding CRI configuration of the <code>RuntimeClass</code> and the control plane exposure configuration for the <code>ExposureClass</code>.</p><p>The CRI handler for <code>RuntimeClasses</code> is usually installed by an administrator (e.g. via a <code>DaemonSet</code> which installs the corresponding container runtime on the nodes).
The control plane exposure configuration for <code>ExposureClasses</code> will be also provided by an administrator.
This exposure configuration is part of the Gardenlet configuration as this component is responsible to configure the control plane accordingly.
See <a href=#Gardenlet-Configuration-ExposureClass-handlers>here</a>.</p><p>The <code>RuntimeClass</code> also supports the selection of a node subset (which have the respective controller runtime binaries installed) for pod scheduling via its <code>.scheduling</code> section.
The <code>ExposureClass</code> also supports the selection of a subset of available Seed clusters whose Gardenlet is capable of applying the exposure configuration for the Shoot control plane accordingly via its <code>.scheduling</code> section.</p><h2 id=usage-by-a-shoot>Usage by a <code>Shoot</code></h2><p>A <code>Shoot</code> can reference an <code>ExposureClass</code> via the <code>.spec.exposureClassName</code> field.</p><p>⚠️ When creating a <code>Shoot</code> resource, the Gardener scheduler will try to assign the <code>Shoot</code> to a <code>Seed</code> which will host its control plane.
The scheduling behaviour can be influenced via the <code>.spec.seedSelectors</code> and/or <code>.spec.tolerations</code> fields in the <code>Shoot</code>.
<code>ExposureClass</code>es can contain also scheduling instructions.
If a <code>Shoot</code> is referencing an <code>ExposureClass</code> then the scheduling instructions of both will be merged into the <code>Shoot</code>.
Those unions of scheduling instructions might lead to a selection of a <code>Seed</code> which is not able to deal with the <code>handler</code> of the <code>ExposureClass</code> and the <code>Shoot</code> creation might end up in an error.
In such case, the <code>Shoot</code> scheduling instructions should be revisited to check that they are not interfere with the ones from the <code>ExposureClass</code>.
If this is not feasible then the combination with the <code>ExposureClass</code> is might not possible and you need to contact your Gardener administrator.</p><details><summary>Example: Shoot and ExposureClass scheduling instructions merge flow</summary><ol><li>Assuming there is the following <code>Shoot</code> which is referencing the <code>ExposureClass</code> below:</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: abc
  namespace: garden-dev
spec:
  exposureClassName: abc
  seedSelectors:
    matchLabels:
      env: prod
---
apiVersion: core.gardener.cloud/v1alpha1
kind: ExposureClass
metadata:
  name: abc
handler: abc
scheduling:
  seedSelector:
    matchLabels:
      network: internal
</code></pre></div><ol start=2><li>Both <code>seedSelectors</code> would be merged into the <code>Shoot</code>. The result would be the following:</li></ol><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1alpha1
kind: Shoot
metadata:
  name: abc
  namespace: garden-dev
spec:
  exposureClassName: abc
  seedSelectors:
    matchLabels:
      env: prod
      network: internal
</code></pre></div><ol start=3><li>Now the Gardener Scheduler would try to find a <code>Seed</code> with those labels.</li></ol><ul><li>If there are <strong>no</strong> Seeds with matching labels for the seed selector then the <code>Shoot</code> will be unschedulable</li><li>If there are Seeds with matching labels for the seed selector then the Shoot will be assigned to the best candidate after the scheduling strategy is applied, see <a href=/docs/gardener/concepts/scheduler/#algorithm-overview>here</a><ul><li>If the <code>Seed</code> is <strong>not</strong> able to serve the <code>ExposureClass</code> handler <code>abc</code> then the Shoot will end up in error state</li><li>If the <code>Seed</code> is able to serve the <code>ExposureClass</code> handler <code>abc</code> then the <code>Shoot</code> will be created</li></ul></li></ul></details><h2 id=gardenlet-configuration-exposureclass-handlers>Gardenlet Configuration <code>ExposureClass</code> handlers</h2><p>The Gardenlet is responsible to realize the control plane exposure strategy defined in the referenced <code>ExposureClass</code> of a <code>Shoot</code>.</p><p>Therefore, the <code>GardenletConfiguration</code> can contain an <code>.exposureClassHandlers</code> list with the respective configuration.</p><p>Example of the <code>GardenletConfiguration</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>exposureClassHandlers:
- name: internet-config
  loadBalancerService:
    annotations:
      loadbalancer/network: internet
- name: internal-config
  loadBalancerService:
    annotations:
      loadbalancer/network: internal
  sni:
    ingress:
      namespace: ingress-internal
      labels:
        network: internal
</code></pre></div><p>Each Gardenlet can define how the handler of a certain <code>ExposureClass</code> needs to be implemented for the Seed(s) where it is responsible for.</p><p>The <code>.name</code> is the name of the handler config and it must match to the <code>.handler</code> in the <code>ExposureClass</code>.</p><p>All control planes on a <code>Seed</code> are exposed via a load balancer.
Either a dedicated one or a central shared one.
The load balancer service needs to be configured in a way that it is reachable from the target network environment.
Therefore, the configuration of load balancer service need to be specified which can be done via the <code>.loadBalancerService</code> section.
The common way to influence load balancer service behaviour is via annotations where the respective cloud-controller-manager will react on and configure the infrastructure load balancer accordingly.</p><p>In case the Gardenlet runs with activated <code>APIServerSNI</code> feature flag (default), the control planes on a <code>Seed</code> will be exposed via a central load balancer and with Envoy via TLS SNI passthrough proxy.
In this case, the Gardenlet will install a dedicated ingress gateway (Envoy + load balancer + respective configuration) for each handler on the <code>Seed</code>.
The configuration of the ingress gateways can be controlled via the <code>.sni</code> section in the same way like for the default ingress gateways.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e25b3c63361fa049e4ac90bb38e50ff1>8.10 - Istio</h1><h1 id=istio>Istio</h1><p><a href=https://istio.io>Istio</a> offers a service mesh implementation with focus on several important features - traffic, observability, security and policy.</p><h2 id=gardener-managedistio-feature-gate>Gardener <code>ManagedIstio</code> feature gate</h2><p>When enabled in gardenlet the <code>ManagedIstio</code> feature gate can be used to deploy a Gardener-tailored Istio installation in Seed clusters. It&rsquo;s main usage is to enable features such as <a href=/docs/gardener/proposals/08-shoot-apiserver-via-sni/>Shoot API server SNI</a>. This feature should not be enabled on a Seed cluster where Istio is already deployed.</p><h2 id=prerequisites>Prerequisites</h2><ul><li>Third-party JWT is used, therefore each Seed cluster where this feature is enabled must have <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>Service Account Token Volume Projection</a> enabled.</li><li>Kubernetes 1.16+</li></ul><h2 id=differences-with-istios-default-profile>Differences with Istio&rsquo;s default profile</h2><p>The <a href=https://istio.io/docs/setup/additional-setup/config-profiles/>default profile</a> which is recommended for production deployment, is not suitable for the Gardener use case as it offers more functionality than desired. The current installation goes through heavy refactorings due to the <code>IstioOperator</code> and the mixture of Helm values + Kubernetes API specification makes configuring and fine-tuning it very hard. A more simplistic deployment is used by Gardener. The differences are the following:</p><ul><li>Telemetry is not deployed.</li><li><code>istiod</code> is deployed.</li><li><code>istio-ingress-gateway</code> is deployed in a separate <code>istio-ingress</code> namespace.</li><li><code>istio-egress-gateway</code> is not deployed.</li><li>None of the Istio addons are deployed.</li><li>Mixer (deprecated) is not deployed</li><li>Mixer CDRs are not deployed.</li><li>Kubernetes <code>Service</code>, Istio&rsquo;s <code>VirtualService</code> and <code>ServiceEntry</code> are <strong>NOT</strong> advertised in the service mesh. This means that if a <code>Service</code> needs to be accessed directly from the Istio Ingress Gateway, it should have <code>networking.istio.io/exportTo: "*"</code> annotation. <code>VirtualService</code> and <code>ServiceEntry</code> must have <code>.spec.exportTo: ["*"]</code> set on them respectively.</li><li>Istio injector is not enabled.</li><li>mTLS is enabled by default.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c25983cd195ac0d27b90213377bdf169>8.11 - Logging</h1><h1 id=logging-stack>Logging stack</h1><h3 id=motivation>Motivation</h3><p>Kubernetes uses the underlying container runtime logging, which does not persist logs for stopped and destroyed containers. This makes it difficult to investigate issues in the very common case of not running containers. Gardener provides a solution to this problem for the managed cluster components, by introducing its own logging stack.</p><h3 id=components>Components:</h3><p><img src=/__resources/logging-architecture_c8dc32.png alt></p><ul><li>A Fluent-bit daemonset which works like a log collector and custom custom Golang plugin which spreads log messages to their Loki instances</li><li>One Loki Statefulset in the <code>garden</code> namespace which contains logs for the seed cluster and one per shoot namespace which contains logs for shoot&rsquo;s controlplane.</li><li>One Grafana Deployment in <code>garden</code> namespace and two Deployments per shoot namespace (one exposed to the end users and one for the operators). Grafana is the UI component used in the logging stack.</li></ul><h3 id=how-to-access-the-logs>How to access the logs</h3><p>The first step is to authenticate in front of the Grafana ingress. The secret with the credentials can be found in <code>garden-&lt;project></code> namespace under <code>&lt;shoot-name>.monitoring</code>.
Logs are accessible via Grafana UI. Its URL can be found in the <code>Logging and Monitoring</code> section of a cluster in the Gardener Dashboard.</p><p>There are two methods to explore logs:</p><ul><li><p>The first option is to use the <code>Explore</code> view (available at the left side of the screen). It is used for creating log queries using the predefined filters in Loki. For example:
<code>{pod_name='prometheus-0'}</code>
or with regex:
<code>{pod_name=~'prometheus.+'}</code></p></li><li><p>The other option is to use <code>Dashboards</code> panel. There are custom dashboards for pod logs with one selector field for <code>pod_name</code> and one <code>search</code> field. The <code>search</code> field allows to filter the logs for a particular string. The following dashboards can be used for logs:</p><ul><li>Garden Grafana<ul><li>Pod Logs</li><li>Extensions</li><li>Systemd Logs</li></ul></li><li>User Grafana<ul><li>Kube Apiserver</li><li>Kube Controller Manager</li><li>Kube Scheduler</li><li>Cluster Autoscaler * Operator Grafana</li></ul></li><li>Operator Grafana<ul><li>All user&rsquo;s dashboards</li><li>Kubernetes Pods</li></ul></li></ul></li></ul><h3 id=expose-logs-for-component-to-user-grafana>Expose logs for component to User Grafana</h3><p>Exposing logs for a new component to the User&rsquo;s Grafana is described <a href=/docs/gardener/extensions/logging-and-monitoring/#how-to-expose-logs-to-the-users>here</a></p><h3 id=configuration>Configuration</h3><h4 id=fluent-bit>Fluent-bit</h4><p>The Fluent-bit configurations can be found on <code>charts/seed-bootstrap/charts/fluent-bit/templates/fluent-bit-configmap.yaml</code>
There are five different specifications:</p><ul><li>SERVICE: Defines the location of the server specifications</li><li>INPUT: Defines the location of the input stream of the logs</li><li>OUTPUT: Defines the location of the output source (Loki for example)</li><li>FILTER: Defines filters which match specific keys</li><li>PARSER: Defines parsers which are used by the filters</li></ul><h4 id=loki>Loki</h4><p>The Loki configurations can be found on <code>charts/seed-bootstrap/charts/loki/templates/loki-configmap.yaml</code></p><p>The main specifications there are:</p><ul><li>Index configuration: Currently is used the following one:</li></ul><pre><code>    schema_config:
      configs:
      - from: 2018-04-15
        store: boltdb
        object_store: filesystem
        schema: v11
        index:
          prefix: index_
          period: 24h
</code></pre><ul><li><code>from</code>: is the date from which logs collection is started. Using a date in the past is okay.</li><li><code>store</code>: The DB used for storing the index.</li><li><code>object_store</code>: Where the data is stored</li><li><code>schema</code>: Schema version which should be used (v11 is currently recommended)</li><li><code>index.prefix</code>: The prefix for the index.</li><li><code>index.period</code>: The period for updating the indices</li></ul><p><strong>Adding of new index happens with new config block definition. <code>from</code> field should start from the current day + previous <code>index.period</code> and should not overlap with the current index. The <code>prefix</code> also should be different</strong></p><pre><code>    schema_config:
      configs:
      - from: 2018-04-15
        store: boltdb
        object_store: filesystem
        schema: v11
        index:
          prefix: index_
          period: 24h
      - from: 2020-06-18
        store: boltdb
        object_store: filesystem
        schema: v11
        index:
          prefix: index_new_
          period: 24h
</code></pre><ul><li>chunk_store_config Configuration</li></ul><pre><code>    chunk_store_config: 
      max_look_back_period: 336h
</code></pre><p><strong><code>chunk_store_config.max_look_back_period</code> should be the same as the <code>retention_period</code></strong></p><ul><li>table_manager Configuration</li></ul><pre><code>    table_manager:
      retention_deletes_enabled: true
      retention_period: 336h
</code></pre><p><code>table_manager.retention_period</code> is the living time for each log message. Loki will keep messages for sure for (<code>table_manager.retention_period</code> - <code>index.period</code>) time due to specification in the Loki implementation.</p><h4 id=grafana>Grafana</h4><p>The Grafana configurations can be found on <code>charts/seed-bootstrap/charts/templates/grafana/grafana-datasources-configmap.yaml</code> and
<code>charts/seed-monitoring/charts/grafana/tempates/grafana-datasources-configmap.yaml</code></p><p>This is the Loki configuration that Grafana uses:</p><pre><code>    - name: loki
      type: loki
      access: proxy
      url: http://loki.{{ .Release.Namespace }}.svc:3100
      jsonData:
        maxLines: 5000
</code></pre><ul><li><code>name</code>: is the name of the datasource</li><li><code>type</code>: is the type of the datasource</li><li><code>access</code>: should be set to proxy</li><li><code>url</code>: Loki&rsquo;s url</li><li><code>svc</code>: Loki&rsquo;s port</li><li><code>jsonData.maxLines</code>: The limit of the log messages which Grafana will show to the users.</li></ul><p><strong>Decrease this value if the browser works slowly!</strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-b03cef45b6b25f644cf6ab64d3c5c66c>8.12 - Managed See</h1><h1 id=register-shoot-as-seed>Register Shoot as Seed</h1><p>An existing shoot can be registered as a seed by creating a <code>ManagedSeed</code> resource. This resource replaces the <code>use-as-seed</code> annotation that was previously used to create <a href=/docs/gardener/usage/shooted_seed/>shooted seeds</a>, and that is already deprecated. It contains:</p><ul><li>The name of the shoot that should be registered as seed.</li><li>An optional <code>seedTemplate</code> section that contains the <code>Seed</code> spec and parts of its metadata, such as labels and annotations.</li><li>An optional <code>gardenlet</code> section that contains:<ul><li><code>gardenlet</code> deployment parameters, such as the number of replicas, the image, etc.</li><li>The <code>GardenletConfiguration</code> resource that contains controllers configuration, feature gates, and a <code>seedConfig</code> section that contains the <code>Seed</code> spec and parts of its metadata.</li><li>Additional configuration parameters, such as the garden connection bootstrap mechanism (see <a href=/docs/gardener/concepts/gardenlet/#tls-bootstrapping>TLS Bootstrapping</a>), and whether to merge the provided configuration with the configuration of the parent <code>gardenlet</code>.</li></ul></li></ul><p>Either the <code>seedTemplate</code> or the <code>gardenlet</code> section must be specified, but not both:</p><ul><li>If the <code>seedTemplate</code> section is specified, <code>gardenlet</code> is not deployed to the shoot, and a new <code>Seed</code> resource is created based on the template.</li><li>If the <code>gardenlet</code> section is specified, <code>gardenlet</code> is deployed to the shoot, and it registers a new seed upon startup based on the <code>seedConfig</code> section of the <code>GardenletConfiguration</code> resource.</li></ul><p>Note the following important aspects:</p><ul><li>Unlike the <code>Seed</code> resource, the <code>ManagedSeed</code> resource is namespaced. Currently, managed seeds are restricted to the <code>garden</code> namespace.</li><li>The newly created <code>Seed</code> resource always has the same name as the <code>ManagedSeed</code> resource. Attempting to specify a different name in <code>seedTemplate</code> or <code>seedConfig</code> will fail.</li><li>The <code>ManagedSeed</code> resource must always refer to an existing shoot. Attempting to create a <code>ManagedSeed</code> referring to a non-existing shoot will fail.</li><li>A shoot that is being referred to by a <code>ManagedSeed</code> cannot be deleted. Attempting to delete such a shoot will fail.</li><li>You can omit practically everything from the <code>seedTemplate</code> or <code>gardenlet</code> section, including all or most of the <code>Seed</code> spec fields. Proper defaults will be supplied in all cases, based either on the most common use cases or the information already available in the <code>Shoot</code> resource.</li><li>Some <code>Seed</code> spec fields, for example the provider type and region, networking CIDRs for pods, services, and nodes, etc., must be the same as the corresponding <code>Shoot</code> spec fields of the shoot that is being registered as seed. Attempting to use different values (except empty ones, so that they are supplied by the defaulting mechanims) will fail.</li></ul><h2 id=deploying-gardenlet-to-the-shoot>Deploying Gardenlet to the Shoot</h2><p>To register a shoot as a seed and deploy <code>gardenlet</code> to the shoot using a default configuration, create a <code>ManagedSeed</code> resource similar to the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: seedmanagement.gardener.cloud/v1alpha1
kind: ManagedSeed
metadata:
  name: my-managed-seed
  namespace: garden
spec:
  shoot:
    name: crazy-botany
  gardenlet: {}
</code></pre></div><p>For an example that uses non-default configuration, see <a href=https://github.com/gardener/gardener/blob/master/example/55-managedseed-gardenlet.yaml>55-managed-seed-gardenlet.yaml</a></p><h2 id=creating-a-seed-from-a-template>Creating a Seed from a Template</h2><p>To register a shoot as a seed from a template without deploying <code>gardenlet</code> to the shoot using a default configuration, create a <code>ManagedSeed</code> resource similar to the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: seedmanagement.gardener.cloud/v1alpha1
kind: ManagedSeed
metadata:
  name: my-managed-seed
  namespace: garden
spec:
  shoot:
    name: crazy-botany
  seedTemplate:
    spec:
      dns:
        ingressDomain: <span style=color:#a31515>&#34;&#34;</span>
      networks:
        pods: <span style=color:#a31515>&#34;&#34;</span>
        services: <span style=color:#a31515>&#34;&#34;</span>
      provider:
        type: <span style=color:#a31515>&#34;&#34;</span>
        region: <span style=color:#a31515>&#34;&#34;</span>
</code></pre></div><p>For an example that uses non-default configuration, see <a href=https://github.com/gardener/gardener/blob/master/example/55-managedseed-seedtemplate.yaml>55-managed-seed-seedtemplate.yaml</a></p><h2 id=migrating-from-the-use-as-seed-annotation-to-managedseeds>Migrating from the <code>use-as-seed</code> Annotation to <code>ManagedSeeds</code></h2><p>If you have existing seeds managed via the <code>use-as-seed</code> annotation, you should migrate them to <code>ManagedSeed</code> resources before support for the annotation has been completely removed from Gardener.</p><p>The <em>seed registration controller</em> that is responsible for reconciling the <code>use-as-seed</code> annotation is still functional, However, instead of reconciling the annotation directly as before, it converts it to a <code>ManagedSeed</code> resource and lets the <em>managed seed controller</em> perform the actual reconciliation. Therefore, for every <code>use-as-seed</code> annotation, you already have an equivalent <code>ManagedSeed</code> resource in your cluster. Since it has been created by reconciling an annotation on a shoot, it is also &ldquo;owned&rdquo; by the shoot, that is it contains an <code>ownerReference</code> to the corresponding shoot. This owner reference is used by the seed registration controller to determine that it should continue updating (or deleting) the <code>ManagedSeed</code> as a result of reconciling changes to (or the removal of) the <code>use-as-seed</code> annotation.</p><p>In order to migrate the <code>use-as-seed</code> annotation to a <code>ManagedSeed</code>, you should simply:</p><ul><li>Remove the owner reference to the shoot from the existing <code>ManagedSeed</code> resource.</li><li>Remove the <code>use-as-seed</code> annotation from the <code>Shoot</code> resource.</li><li>From this moment on, update or delete the <code>ManagedSeed</code> directly, instead of indirectly via the <code>use-as-seed</code> annotation.</li></ul><p>If the shoot containing the <code>use-as-seed</code> annotation was created via a yaml file (e.g. via <code>kubectl apply -f</code>), a helm chart, or a script, you should update the corresponding file, template, or script so that it contains or generates the <code>ManagedSeed</code> that you have in your cluster, instead of the <code>use-as-seed</code> annotation. If you use an automated approach, make sure that the owner reference is removed from the existing <code>ManagedSeed</code> before removing the annotation from the <code>Shoot</code>.</p><h3 id=specifying-apiserver-replicas-and-autoscaler-options>Specifying <code>apiServer</code> <code>replicas</code> and <code>autoscaler</code> options</h3><p>A few of <code>use-as-seed</code> configuration options are not supported in a <code>Seed</code> resource, and therefore also not in a <code>ManagedSeed</code>. These options are (from the <a href=/docs/gardener/usage/shooted_seed/>shooted seeds</a> description):</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>apiServer.autoscaler.minReplicas</code></td><td>Controls the minimum number of <code>kube-apiserver</code> replicas for the shooted seed cluster.</td></tr><tr><td><code>apiServer.autoscaler.maxReplicas</code></td><td>Controls the maximum number of <code>kube-apiserver</code> replicas for the shooted seed cluster.</td></tr><tr><td><code>apiServer.replicas</code></td><td>Controls how many <code>kube-apiserver</code> replicas the shooted seed cluster gets by default.</td></tr></tbody></table><p>For backward compatibility, it is still possible to specify these options via the <code>shoot.gardener.cloud/managed-seed-api-server</code> annotation, using exactly the same syntax as before.</p><p>If you use any of these fields in any or your <code>use-as-seed</code> annotations, instead of removing the annotation completely as mentioned above, simply rename it to <code>managed-seed-api-server</code>, keeping these fields, and removing everything else.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8d5f560b3aa48903f7142745f2944770>8.13 - Node Local Dns</h1><h1 id=nodelocaldns-configuration>NodeLocalDNS Configuration</h1><p>This is a short guide describing how to enable DNS caching on the shoot cluster nodes.</p><h2 id=background>Background</h2><p>Currently in Gardener we are using CoreDNS as a deployment that is auto-scaled horizontally to cover for QPS-intensive applications. However, doing so does not seem to be enough to completely circumvent DNS bottlenecks such as:</p><ul><li>Cloud provider limits for DNS lookups.</li><li>Unreliable UDP connections that forces a period of timeout in case packets are dropped.</li><li>Unnecessary node hopping since CoreDNS is not deployed on all nodes, and as a result DNS queries end-up traversing multiple nodes before reaching the destination server.</li><li>Inefficient load-balancing of services (e.g., round-robin might not be enough when using IPTables mode)</li><li>and more &mldr;</li></ul><p>To workaround the issues described above, <code>node-local-dns</code> was introduced. The architecture is described below. The idea is simple:</p><ul><li>For new queries, the connection is upgraded from UDP to TCP and forwarded towards the cluster IP for the original CoreDNS server.</li><li>For previously resolved queries, an immediate response from the same node where the requester workload / pod resides is provided.</li></ul><p><img src=/__resources/node-local-dns_cbcbae.png alt=node-local-dns-architecture></p><h2 id=configuring-nodelocaldns>Configuring NodeLocalDNS</h2><p>All that needs to be done to enable the usage of the <code>node-local-dns</code> feature is to annotate the <code>Shoot</code> resource with the annotation <code>alpha.featuregates.shoot.gardener.cloud/node-local-dns</code> set to <code>"true"</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml> annotations:
   alpha.featuregates.shoot.gardener.cloud/node-local-dns: <span style=color:#a31515>&#34;true&#34;</span>
</code></pre></div><p>It is worth noting that:</p><ul><li>When migrating from IPVS to IPTables, existing pods will continue to leverage the node-local-dns cache.</li><li>When migrating from IPtables to IPVS, only newer pods will be switched to the node-local-dns cache.</li><li>The annotation will take effect during the next shoot reconciliation. This happens automatically once per day in the maintenance period (unless you have disabled it).</li><li>During the reconfiguration of the node-local-dns there might be a short disruption in terms of domain name resolution depending on the setup. Usually, dns requests are repeated for some time as udp is an unreliable protocol, but that strictly depends on the application/way the domain name resolution happens. It is recommended to let the shoot be reconciled during the next maintenance period.</li><li>If a short DNS outage is not a big issue, you can <a href=/docs/gardener/usage/shoot_operations/#immediate-reconciliation>trigger reconciliation</a> directly after setting the annotation.</li><li>Switching node-local-dns off by removing the annotation can be a rather destructive operation that will result in pods without a working dns configuration.</li></ul><p>For more information about <code>node-local-dns</code> please refer to the <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/1024-nodelocal-cache-dns/README.md>KEP</a> or to the <a href=https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/>usage documentation</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6aba6b44b714cf2748c3009e8eadd0c0>8.14 - Openidconnect Presets</h1><h1 id=clusteropenidconnectpreset-and-openidconnectpreset>ClusterOpenIDConnectPreset and OpenIDConnectPreset</h1><p>This page provides an overview of ClusterOpenIDConnectPresets and OpenIDConnectPresets, which are objects for injecting <a href=https://openid.net/connect/>OpenIDConnect Configuration</a> into <code>Shoot</code> at creation time. The injected information contains configuration for the Kube API Server and optionally configuration for kubeconfig generation using said configuration.</p><h2 id=openidconnectpreset>OpenIDConnectPreset</h2><p>An OpenIDConnectPreset is an API resource for injecting additional runtime OIDC requirements into a Shoot at creation time. You use label selectors to specify the <code>Shoot</code> to which a given OpenIDConnectPreset applies.</p><p>Using a OpenIDConnectPresets allows project owners to not have to explicitly provide the same OIDC configuration for every <code>Shoot</code> in their <code>Project</code>.</p><p>For more information about the background, see the <a href=https://github.com/gardener/gardener/issues/1161>issue</a> for OpenIDConnectPreset.</p><h3 id=how-openidconnectpreset-works>How OpenIDConnectPreset works</h3><p>Gardener provides an admission controller (OpenIDConnectPreset) which, when enabled, applies OpenIDConnectPresets to incoming <code>Shoot</code> creation requests. When a <code>Shoot</code> creation request occurs, the system does the following:</p><ul><li><p>Retrieve all OpenIDConnectPreset available for use in the <code>Shoot</code> namespace.</p></li><li><p>Check if the shoot label selectors of any OpenIDConnectPreset matches the labels on the Shoot being created.</p></li><li><p>If multiple presets are matched then only one is chosen and results are sorted based on:</p><ol><li><code>.spec.weight</code> value.</li><li>lexicographically ordering their names ( e.g. <code>002preset</code> > <code>001preset</code> )</li></ol></li><li><p>If the <code>Shoot</code> already has a <code>.spec.kubernetes.kubeAPIServer.oidcConfig</code> then no mutation occurs.</p></li></ul><h3 id=simple-openidconnectpreset-example>Simple OpenIDConnectPreset example</h3><p>This is a simple example to show how a <code>Shoot</code> is modified by the OpenIDConnectPreset</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: settings.gardener.cloud/v1alpha1
kind: OpenIDConnectPreset
metadata:
  name:  test-1
  namespace: default
spec:
  shootSelector:
    matchLabels:
      oidc: enabled
  server:
    clientID: test-1
    issuerURL: https://foo.bar
    <span style=color:green># caBundle: |</span>
    <span style=color:green>#   -----BEGIN CERTIFICATE-----</span>
    <span style=color:green>#   Li4u</span>
    <span style=color:green>#   -----END CERTIFICATE-----</span>
    groupsClaim: groups-claim
    groupsPrefix: groups-prefix
    usernameClaim: username-claim
    usernamePrefix: username-prefix
    signingAlgs:
    - RS256
    requiredClaims:
      key: value
  client:
    secret: oidc-client-secret
    extraConfig:
      extra-scopes: <span style=color:#a31515>&#34;email,offline_access,profile&#34;</span>
      foo: bar
  weight: 90
</code></pre></div><p>Create the OpenIDConnectPreset:</p><pre><code class=language-console data-lang=console>kubectl apply -f preset.yaml
</code></pre><p>Examine the created OpenIDConnectPreset:</p><pre><code class=language-console data-lang=console>kubectl get openidconnectpresets
NAME     ISSUER            SHOOT-SELECTOR   AGE
test-1   https://foo.bar   oidc=enabled     1s
</code></pre><p>Simple <code>Shoot</code> example:</p><p>This is a sample of a <code>Shoot</code> with some fields omitted:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: preset
  namespace: default
  labels:
    oidc: enabled
spec:
  kubernetes:
    allowPrivilegedContainers: <span style=color:#00f>true</span>
    version: 1.20.2
</code></pre></div><p>Create the Shoot:</p><pre><code class=language-console data-lang=console>kubectl apply -f shoot.yaml
</code></pre><p>Examine the created Shoot:</p><pre><code class=language-console data-lang=console>kubectl get shoot preset -o yaml
</code></pre><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: preset
  namespace: default
  labels:
    oidc: enabled
spec:
  kubernetes:
    kubeAPIServer:
      oidcConfig:
        clientAuthentication:
          extraConfig:
            extra-scopes: email,offline_access,profile
            foo: bar
          secret: oidc-client-secret
        clientID: test-1
        groupsClaim: groups-claim
        groupsPrefix: groups-prefix
        issuerURL: https://foo.bar
        requiredClaims:
          key: value
        signingAlgs:
        - RS256
        usernameClaim: username-claim
        usernamePrefix: username-prefix
    version: 1.20.2
</code></pre></div><h3 id=disable-openidconnectpreset>Disable OpenIDConnectPreset</h3><p>The OpenIDConnectPreset admission control is enabled by default. To disable it use the <code>--disable-admission-plugins</code> flag on the gardener-apiserver.</p><p>For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>--disable-admission-plugins=OpenIDConnectPreset
</code></pre></div><h2 id=clusteropenidconnectpreset>ClusterOpenIDConnectPreset</h2><p>A ClusterOpenIDConnectPreset is an API resource for injecting additional runtime OIDC requirements into a Shoot at creation time. In contrast to OpenIDConnect it&rsquo;s a cluster-scoped resource. You use label selectors to specify the <code>Project</code> and <code>Shoot</code> to which a given OpenIDCConnectPreset applies.</p><p>Using a OpenIDConnectPresets allows cluster owners to not have to explicitly provide the same OIDC configuration for every <code>Shoot</code> in specific <code>Project</code>.</p><p>For more information about the background, see the <a href=https://github.com/gardener/gardener/issues/1161>issue</a> for ClusterOpenIDConnectPreset.</p><h3 id=how-clusteropenidconnectpreset-works>How ClusterOpenIDConnectPreset works</h3><p>Gardener provides an admission controller (ClusterOpenIDConnectPreset) which, when enabled, applies ClusterOpenIDConnectPresets to incoming <code>Shoot</code> creation requests. When a <code>Shoot</code> creation request occurs, the system does the following:</p><ul><li><p>Retrieve all ClusterOpenIDConnectPresets available.</p></li><li><p>Check if the project label selector of any ClusterOpenIDConnectPreset matches the labels of the <code>Project</code> in which the <code>Shoot</code> is being created.</p></li><li><p>Check if the shoot label selectors of any ClusterOpenIDConnectPreset matches the labels on the <code>Shoot</code> being created.</p></li><li><p>If multiple presets are matched then only one is chosen and results are sorted based on:</p><ol><li><code>.spec.weight</code> value.</li><li>lexicographically ordering their names ( e.g. <code>002preset</code> > <code>001preset</code> )</li></ol></li><li><p>If the <code>Shoot</code> already has a <code>.spec.kubernetes.kubeAPIServer.oidcConfig</code> then no mutation occurs.</p></li></ul><blockquote><p>Note: Due to the previous requirement if a <code>Shoot</code> is matched by both <code>OpenIDConnectPreset</code> and <code>ClusterOpenIDConnectPreset</code> then <code>OpenIDConnectPreset</code> takes precedence over <code>ClusterOpenIDConnectPreset</code>.</p></blockquote><h3 id=simple-clusteropenidconnectpreset-example>Simple ClusterOpenIDConnectPreset example</h3><p>This is a simple example to show how a <code>Shoot</code> is modified by the ClusterOpenIDConnectPreset</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: settings.gardener.cloud/v1alpha1
kind: ClusterOpenIDConnectPreset
metadata:
  name:  test
spec:
  shootSelector:
    matchLabels:
      oidc: enabled
  projectSelector: {} <span style=color:green># selects all projects.</span>
  server:
    clientID: cluster-preset
    issuerURL: https://foo.bar
    <span style=color:green># caBundle: |</span>
    <span style=color:green>#   -----BEGIN CERTIFICATE-----</span>
    <span style=color:green>#   Li4u</span>
    <span style=color:green>#   -----END CERTIFICATE-----</span>
    groupsClaim: groups-claim
    groupsPrefix: groups-prefix
    usernameClaim: username-claim
    usernamePrefix: username-prefix
    signingAlgs:
    - RS256
    requiredClaims:
      key: value
  client:
    secret: oidc-client-secret
    extraConfig:
      extra-scopes: <span style=color:#a31515>&#34;email,offline_access,profile&#34;</span>
      foo: bar
  weight: 90
</code></pre></div><p>Create the ClusterOpenIDConnectPreset:</p><pre><code class=language-console data-lang=console>kubectl apply -f preset.yaml
</code></pre><p>Examine the created ClusterOpenIDConnectPreset:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get clusteropenidconnectpresets
NAME     ISSUER            PROJECT-SELECTOR   SHOOT-SELECTOR   AGE
test     https://foo.bar   &lt;none&gt;             oidc=enabled     1s
</code></pre></div><p>This is a sample of a <code>Shoot</code> with some fields omitted:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>kind: Shoot
apiVersion: core.gardener.cloud/v1beta1
metadata:
  name: preset
  namespace: default
  labels:
    oidc: enabled
spec:
  kubernetes:
    allowPrivilegedContainers: <span style=color:#00f>true</span>
    version: 1.20.2
</code></pre></div><p>Create the Shoot:</p><pre><code class=language-console data-lang=console>kubectl apply -f shoot.yaml
</code></pre><p>Examine the created Shoot:</p><pre><code class=language-console data-lang=console>kubectl get shoot preset -o yaml
</code></pre><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
metadata:
  name: preset
  namespace: default
  labels:
    oidc: enabled
spec:
  kubernetes:
    kubeAPIServer:
      oidcConfig:
        clientAuthentication:
          extraConfig:
            extra-scopes: email,offline_access,profile
            foo: bar
          secret: oidc-client-secret
        clientID: cluster-preset
        groupsClaim: groups-claim
        groupsPrefix: groups-prefix
        issuerURL: https://foo.bar
        requiredClaims:
          key: value
        signingAlgs:
        - RS256
        usernameClaim: username-claim
        usernamePrefix: username-prefix
    version: 1.20.2
</code></pre></div><h3 id=disable-clusteropenidconnectpreset>Disable ClusterOpenIDConnectPreset</h3><p>The ClusterOpenIDConnectPreset admission control is enabled by default. To disable it use the <code>--disable-admission-plugins</code> flag on the gardener-apiserver.</p><p>For example:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>--disable-admission-plugins=ClusterOpenIDConnectPreset
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5312b08cd06fa7b827ab36d682e935b0>8.15 - Projects</h1><h1 id=projects>Projects</h1><p>The Gardener API server supports a cluster-scoped <code>Project</code> resource which is used for data isolation between individual Gardener consumers. For example, each development team has its own project to manage its own shoot clusters.</p><p>Each <code>Project</code> is backed by a Kubernetes <code>Namespace</code> that contains the actual related Kubernetes resources like <code>Secret</code>s or <code>Shoot</code>s.</p><p><strong>Example resource:</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Project
metadata:
  name: dev
spec:
  namespace: garden-dev
  description: <span style=color:#a31515>&#34;This is my first project&#34;</span>
  purpose: <span style=color:#a31515>&#34;Experimenting with Gardener&#34;</span>
  owner:
    apiGroup: rbac.authorization.k8s.io
    kind: User
    name: john.doe@example.com
  members:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: alice.doe@example.com
    role: admin
  <span style=color:green># roles:</span>
  <span style=color:green># - viewer </span>
  <span style=color:green># - uam</span>
  <span style=color:green># - extension:foo</span>
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: bob.doe@example.com
    role: viewer
<span style=color:green># tolerations:</span>
<span style=color:green>#   defaults:</span>
<span style=color:green>#   - key: &lt;some-key&gt;</span>
<span style=color:green>#   whitelist:</span>
<span style=color:green>#   - key: &lt;some-key&gt;</span>
</code></pre></div><p>The <code>.spec.namespace</code> field is optional and will be initialized if it&rsquo;s unset.
The name of the resulting namespace will be generated and look like <code>garden-dev-5anj3</code>, i.e., it has a random suffix.
It&rsquo;s also possible to adopt existing namespaces by labeling them <code>gardener.cloud/role=project</code> and <code>project.gardener.cloud/name=dev</code> beforehand (otherwise, they cannot be adopted).</p><p>When deleting a Project resource, the corresponding namespace is also deleted.
To keep a namespace after project deletion, an administrator/operator (not Project members!) can annotate the project-namespace with <code>namespace.gardener.cloud/keep-after-project-deletion</code>.</p><p>The <code>spec.description</code> and <code>.spec.purpose</code> fields can be used to describe to fellow team members and Gardener operators what this project is used for.</p><p>Each project has one dedicated owner, configured in <code>.spec.owner</code> using the <code>rbac.authorization.k8s.io/v1.Subject</code> type.
The owner is the main contact person for Gardener operators.
Please note that the <code>.spec.owner</code> field is deprecated and will be removed in future API versions in favor of the <code>owner</code> role, see below.</p><p>The list of members (again a list in <code>.spec.members[]</code> using the <code>rbac.authorization.k8s.io/v1.Subject</code> type) contains all the people that are associated with the project in any way.
Each project member must have at least one role (currently described in <code>.spec.members[].role</code>, additional roles can be added to <code>.spec.members[].roles[]</code>). The following roles exist:</p><ul><li><code>admin</code>: This allows to fully manage resources inside the project (e.g., secrets, shoots, configmaps, and similar).</li><li><code>uam</code>: This allows to add/modify/remove human users or groups to/from the project member list. Technical users (service accounts) can be managed by all admins.</li><li><code>viewer</code>: This allows to read all resources inside the project except secrets.</li><li><code>owner</code>: This combines the <code>admin</code> and <code>uam</code> roles.</li><li>Extension roles (prefixed with <code>extension:</code>): Please refer to <a href=/docs/gardener/extensions/project-roles/>this document</a>.</li></ul><p>The <a href=/docs/gardener/concepts/controller-manager/#project-controller>project controller</a> inside the Gardener Controller Manager is managing RBAC resources that grant the described privileges to the respective members.</p><p>There are two central <code>ClusterRole</code>s <code>gardener.cloud:system:project-member</code> and <code>gardener.cloud:system:project-viewer</code> that grant the permissions for namespaced resources (e.g., <code>Secret</code>s, <code>Shoot</code>s, etc.).
Via referring <code>RoleBinding</code>s created in the respective namespace the project members get bound to these <code>ClusterRole</code>s and, thus, the needed permissions.
There are also project-specific <code>ClusterRole</code>s granting the permissions for cluster-scoped resources, e.g. the <code>Namespace</code> or <code>Project</code> itself.<br>For each role, the following <code>ClusterRole</code>s, <code>ClusterRoleBinding</code>s, and <code>RoleBinding</code>s are created:</p><table><thead><tr><th>Role</th><th><code>ClusterRole</code></th><th><code>ClusterRoleBinding</code></th><th><code>RoleBinding</code></th></tr></thead><tbody><tr><td><code>admin</code></td><td><code>gardener.cloud:system:project-member:&lt;projectName></code></td><td><code>gardener.cloud:system:project-member:&lt;projectName></code></td><td><code>gardener.cloud:system:project-member</code></td></tr><tr><td><code>uam</code></td><td><code>gardener.cloud:system:project-uam:&lt;projectName></code></td><td><code>gardener.cloud:system:project-uam:&lt;projectName></code></td><td></td></tr><tr><td><code>viewer</code></td><td><code>gardener.cloud:system:project-viewer:&lt;projectName></code></td><td><code>gardener.cloud:system:project-viewer:&lt;projectName></code></td><td><code>gardener.cloud:system:project-viewer</code></td></tr><tr><td><code>owner</code></td><td><code>gardener.cloud:system:project:&lt;projectName></code></td><td><code>gardener.cloud:system:project:&lt;projectName></code></td><td></td></tr><tr><td><code>extension:*</code></td><td><code>gardener.cloud:extension:project:&lt;projectName>:&lt;extensionRoleName></code></td><td></td><td><code>gardener.cloud:extension:project:&lt;projectName>:&lt;extensionRoleName></code></td></tr></tbody></table><h2 id=user-access-management>User Access Management</h2><p>For <code>Project</code>s created before Gardener v1.8 all admins were allowed to manage other members.
Beginning with v1.8 the new <code>uam</code> role is being introduced.
It is backed by the <code>manage-members</code> custom RBAC verb which allows to add/modify/remove human users or groups to/from the project member list.
Human users are subjects with <code>kind=User</code> and <code>name!=system:serviceaccount:*</code>, and groups are subjects with <code>kind=Group</code>.
The management of service account subjects (<code>kind=ServiecAccount</code> or <code>name=system:serviceaccount:*</code>) is not controlled via the <code>uam</code> custom verb but with the standard <code>update</code>/<code>patch</code> verbs for projects.</p><p>All newly created projects will only bind the owner to the <code>uam</code> role.
The owner can still grant the <code>uam</code> role to other members if desired.
For projects created before Gardener v1.8 the Gardener Controller Manager will migrate all projects to also assign the <code>uam</code> role to all <code>admin</code> members (to not break existing use-cases). The corresponding migration logic is present in Gardener Controller Manager from v1.8 to v1.13.
The project owner can gradually remove these roles if desired.</p><h2 id=stale-projects>Stale Projects</h2><p>When a project is not actively used for some period of time the project is marked as &ldquo;stale&rdquo;. This is done by controller called &ldquo;Stale Projects Reconciler&rdquo;. Once the project is marked as stale there is a time frame in which if not used it will be deleted by that controller. More detailed information can be found <a href=/docs/gardener/concepts/controller-manager/#stale-projects-reconciler>here</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-51f43840ca475366ea7f9ff5a443fac5>8.16 - Reversed Vpn Tunnel</h1><h1 id=reversed-vpn-tunnel-setup-and-configuration>Reversed VPN Tunnel Setup and Configuration</h1><p>This is a short guide describing how to enable tunneling traffic from shoot cluster to seed cluster instead of the default &ldquo;seed to shoot&rdquo; direction.</p><h2 id=the-openvpn-default>The OpenVPN Default</h2><p>By default, Gardener makes use of OpenVPN to connect the shoot controlplane running on the seed cluster to the dataplane
running on the shoot worker nodes, usually in isolated networks. This is achieved by having a sidecar to certain control plane components such as the <code>kube-apiserver</code> and <code>prometheus</code>.</p><p>With a sidecar, all traffic directed to the cluster is intercepted by iptables rules and redirected
to the tunnel endpoint in the shoot cluster deployed behind a cloud loadbalancer. This has the following disadvantages:</p><ul><li>Every shoot would require an additional loadbalancer, this accounts for additional overhead in terms of both costs and troubleshooting efforts.</li><li>Private access use-cases would not be possible without having a seed residing in the same private domain as a hard requirement. For example, have a look at <a href=https://github.com/gardener/gardener-extension-provider-gcp/issues/56>this issue</a></li><li>Providing a public endpoint to access components in the shoot poses a security risk.</li></ul><p>This is how it looks like today with the OpenVPN solution:</p><p><code>APIServer | VPN-seed ---> internet ---> LB --> VPN-Shoot (4314) --> Pods | Nodes | Services</code></p><h2 id=reversing-the-tunnel>Reversing the Tunnel</h2><p>To address the above issues, the tunnel can establishment direction can be reverted, i.e. instead of having the client reside in the seed,
we deploy the client in the shoot and initiate the connection from there. This way, there is no need to deploy a special purpose
loadbalancer for the sake of addressing the dataplane, in addition to saving costs, this is considered the more secure alternative.
For more information on how this is achieved, please have a look at the following <a href=/docs/gardener/proposals/14-reversed-cluster-vpn/>GEP</a>.</p><p>How it should look like at the end:</p><p><code>APIServer --> Envoy-Proxy | VPN-Seed-Server &lt;-- Istio/Envoy-Proxy &lt;-- SNI API Server Endpoint &lt;-- LB (one for all clusters of a seed) &lt;--- internet &lt;--- VPN-Shoot-Client --> Pods | Nodes | Services</code></p><h3 id=how-to-configure>How to Configure</h3><p>To enable the usage of the reversed vpn tunnel feature, either the Gardenlet <code>ReversedVPN</code> feature-gate must be set to <code>true</code> as shown below or the shoot must be annotated with <code>"alpha.featuregates.shoot.gardener.cloud/reversed-vpn: true"</code>.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>featureGates:
  ReversedVPN: <span style=color:#00f>true</span>
</code></pre></div><p>Please refer to the examples <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>here</a> for more information.</p><p>To disable the feature-gate the shoot must be annotated with <code>"alpha.featuregates.shoot.gardener.cloud/reversed-vpn: false"</code></p><p>Once the feature-gate is enabled, a <code>vpn-seed-server</code> deployment will be added to the controlplane. The <code>kube-apiserver</code> will be configured to connect to resources in the dataplane such as pods, services and nodes though the <code>vpn-seed-service</code> via http proxy/connect protocol.
In the dataplane of the cluster, the <code>vpn-shoot</code> will establish the connection to the <code>vpn-seed-server</code> indirectly using the SNI API Server endpoint as a http proxy. After the connection has been established requests from the <code>kube-apiserver</code> will be handled by the tunnel.</p><blockquote><p>Please note this feature is available ONLY for >= 1.18 kubernetes clusters. For clusters with Kubernetes version &lt; 1.18, the default OpenVPN setup will be used by default even if the featuregate is enabled.
Furthermore, this feature is still in Alpha, so you might see instabilities every now and then.</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-950da554bf8a0407b2a5fbbc1058ed8e>8.17 - Secrets Rotation</h1><h1 id=secrets-and-rotation>Secrets and rotation</h1><p>The following sections contain information about <code>Secret</code>s in the Garden cluster that are either provided by users or
generated by Gardener for users.</p><h2 id=list-of-secrets>List of secrets</h2><h3 id=user-provided-secrets>User provided secrets</h3><h4 id=cloudprovider-secret>Cloudprovider Secret</h4><p><em>Example</em>: <a href=https://github.com/gardener/gardener/blob/master/example/70-secret-provider.yaml>https://github.com/gardener/gardener/blob/master/example/70-secret-provider.yaml</a></p><p><em>Usage</em>: Authenticate gardener and kubernetes components for infrastructure operations</p><p><em>Description</em>: Gardener uses the cloudprovider secret to interact with the infrastructure when setting up shoot networks or security groups via the <a href=https://github.com/gardener/terraformer>terraformer</a>. It is also used by the <a href=https://kubernetes.io/docs/concepts/architecture/cloud-controller/>cloud-controller-manager</a> of your Shoot to communicate with the infrastructure for example to create Loadbalancer services, routes or retrieve information about Node objects.
Depending on the cloudprovider the format of the secret differs. Please consult the example above and respective infrastructure extension documentation for the concrete layout.</p><p>To put it in use, a cloudprovider secret is bound to one more namespaces (and therefore projects) using a <a href=https://github.com/gardener/gardener/blob/master/example/80-secretbinding.yaml>SecretBinding</a>. For Shoots created in those projects the secret is synced to the shoot namespace in the seed cluster.</p><p><em>Rotation</em>: Rotating the cloudprovider secret requires multiple steps:</p><ol><li>Update the data keys in the secret.</li><li>⚠️ Wait until all Shoots using the secret are reconciled before you disable the old secret in your infrastructure account! Otherwise the shoots will no longer function.</li><li>After all Shoots using the secret were reconciled you can go ahead and deactivate the old secret in your infrastructure account.</li></ol><h3 id=gardener-generated-secrets>Gardener generated secrets</h3><h4 id=kubeconfig>Kubeconfig</h4><p><em>Name</em>: <code>&lt;shoot-name>.kubeconfig</code></p><p><em>Description</em>: Admin Kubeconfig provided by Gardener for the managed shoot cluster.</p><p>This <code>Secret</code> has multiple keys:</p><ul><li><code>kubeconfig</code>: the completed kubeconfig</li><li><code>token</code>: token for <code>system:cluster-admin</code> user</li><li><code>username</code>/<code>password</code>: basic auth credentials (if enabled via <code>Shoot.spec.kubernetes.kubeAPIServer.enableBasicAuthentication</code>)</li><li><code>ca.crt</code>: the CA bundle for establishing trust to the API server (same as in the <a href=#cluster-certificate-authority-bundle>Cluster CA bundle secret</a>)</li></ul><hr><p><strong>NOTE</strong></p><p>This Kubeconfig contains the highest privileges in the cluster. We strongly discourage distributing or using this Kubeconfig.
Instead, configure dedicated <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/>Service Accounts</a>,
<a href=https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens>OIDC</a> or similar alternatives
to grant role-based and revocable access for a broader audience.</p><hr><p><em>Rotation</em>: Kubeconfig can be rotated by annotating the shoot resource with <code>gardener.cloud/operation: rotate-kubeconfig-credentials</code>.
The substituted Kubeconfig are provided after the initialized reconciliation was performed. Please note, shoot clusters
which were created with Gardener version <code>&lt;= 0.28.0</code> used to have a Kubeconfig based on a client certificate instead of a static token.
These client certificates are not revocable and thus a full credential rotation is not supported.</p><p>You can check the <code>.status.credentials.rotation.kubeconfig</code> field in the <code>Shoot</code> to see when the rotation was last initiated or last completed.</p><h4 id=cluster-certificate-authority-bundle>Cluster Certificate Authority Bundle</h4><p><em>Name</em>: <code>&lt;shoot-name>.ca-cluster</code></p><p><em>Description</em>: Certificate Authority (CA) bundle of the Cluster (<code>Secret</code> key: <code>ca.crt</code>).</p><p>This bundle contains one or multiple CAs which are used for signing serving certificates of the Shoot&rsquo;s API server. Hence, the certificates contained in this <code>Secret</code> can be used to verify the API server&rsquo;s identity when communicating with its public endpoint (e.g. as <code>certificate-authority-data</code> in a Kubeconfig).
This is the same certificate that is also contained in the Kubeconfig&rsquo;s <code>certificate-authority-data</code> field.</p><p><em>Rotation</em>: Not supported yet, but work is in progress. See <a href=https://github.com/gardener/gardener/issues/3292>gardener/gardener#3292</a> and <a href=https://github.com/gardener/gardener/blob/release-v1.42/docs/proposals/18-shoot-CA-rotation.md>GEP-18</a> for more details.</p><h4 id=monitoring>Monitoring</h4><p><em>Name</em>: <code>&lt;shoot-name>.monitoring</code></p><p><em>Description</em>: Username/password for accessing the user Grafana instance of a shoot cluster (<code>Secret</code> keys: <code>username</code>/<code>password</code>).</p><p><em>Rotation</em>: Not supported yet.</p><h4 id=ssh-keypair>SSH-Keypair</h4><p><em>Name</em>: <code>&lt;shoot-name>.ssh-keypair</code></p><p><em>Description</em>: SSH-Keypair that is propagated to the worker nodes of the shoot cluster.
The private key can be used to establish an SSH connection to the workers for troubleshooting purposes (<code>Secret</code> keys: <code>id_rsa</code>/<code>id_rsa.pub</code>).</p><p><em>Rotation</em>: Keypair can be rotated by annotating the shoot resource with <code>gardener.cloud/operation: rotate-ssh-keypair</code>.
Propagating the new keypair to all worker nodes may take longer than the initiated reconciliation of the shoot.
The previous keypair can still be found in the <code>&lt;shoot-name>.ssh-keypair.old</code> secret and is still valid until the next rotation.</p><p>You can check the <code>.status.credentials.rotation.sshKeypair</code> field in the <code>Shoot</code> to see when the rotation was last initiated or last completed.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-42e1bcea9f49e68fd1fe7ce23506a673>8.18 - Seed Bootstrapping</h1><h1 id=seed-bootstrapping>Seed Bootstrapping</h1><p>Whenever the Gardenlet is responsible for a new <code>Seed</code> resource its &ldquo;seed controller&rdquo; is being activated.
One part of this controller&rsquo;s reconciliation logic is deploying certain components into the <code>garden</code> namespace of the seed cluster itself.
These components are required to spawn and manage control planes for shoot clusters later on.
This document is providing an overview which actions are performed during this bootstrapping phase, and it explains the rationale behind them.</p><h2 id=dependency-watchdog>Dependency Watchdog</h2><p>The dependency watchdog (abbreviation: DWD) is a component developed separately in the <a href=https://github.com/gardener/dependency-watchdog>gardener/dependency-watchdog</a> GitHub repository.
Gardener is using it for two purposes:</p><ol><li>Prevention of melt-down situations when the load balancer used to expose the kube-apiserver of shoot clusters goes down while the kube-apiserver itself is still up and running</li><li>Fast recovery times for crash-looping pods when depending pods are again available</li></ol><p>For the sake of separating these concerns, two instances of the DWD are deployed by the seed controller.</p><h3 id=probe>Probe</h3><p>The <code>dependency-watchdog-probe</code> deployment is responsible for above mentioned first point.</p><p>The <code>kube-apiserver</code> of shoot clusters is exposed via a load balancer, usually with an attached public IP, which serves as the main entry point when it comes to interaction with the shoot cluster (e.g., via <code>kubectl</code>).
While end-users are talking to their clusters via this load balancer, other control plane components like the <code>kube-controller-manager</code> or <code>kube-scheduler</code> run in the same namespace/same cluster, so they can communicate via the in-cluster <code>Service</code> directly instead of using the detour with the load balancer.
However, the worker nodes of shoot clusters run in isolated, distinct networks.
This means that the <code>kubelet</code>s and <code>kube-proxy</code>s also have to talk to the control plane via the load balancer.</p><p>The <code>kube-controller-manager</code> has a special control loop called <a href=https://github.com/kubernetes/kubernetes/tree/master/pkg/controller/nodelifecycle><code>nodelifecycle</code></a> which will set the status of <code>Node</code>s to <code>NotReady</code> in case the kubelet stops to regularly renew its lease/to send its heartbeat.
This will trigger other self-healing capabilities of Kubernetes, for example the eviction of pods from such &ldquo;unready&rdquo; nodes to healthy nodes.
Similarly, the <code>cloud-controller-manager</code> has a control loop that will disconnect load balancers from &ldquo;unready&rdquo; nodes, i.e., such workload would no longer be accessible until moved to a healthy node.</p><p>While these are awesome Kubernetes features on their own, they have a dangerous drawback when applied in the context of Gardener&rsquo;s architecture:
When the <code>kube-apiserver</code> load balancer fails for whatever reason then the <code>kubelet</code>s can&rsquo;t talk to the <code>kube-apiserver</code> to renew their lease anymore.
After a minute or so the <code>kube-controller-manager</code> will get the impression that all nodes have died and will mark them as <code>NotReady</code>.
This will trigger above mentioned eviction as well as detachment of load balancers.
As a result, the customer&rsquo;s workload will go down and become unreachable.</p><p>This is exactly the situation that the DWD prevents:
It regularly tries to talk to the <code>kube-apiserver</code>s of the shoot clusters, once by using their load balancer, and once by talking via the in-cluster <code>Service</code>.
If it detects that the <code>kube-apiserver</code> is reachable internally but not externally it scales down the <code>kube-controller-manager</code> to <code>0</code>.
This will prevent it from marking the shoot worker nodes as &ldquo;unready&rdquo;.
As soon as the <code>kube-apiserver</code> is reachable externally again the <code>kube-controller-manager</code> will be scaled up to <code>1</code> again.</p><h3 id=endpoint>Endpoint</h3><p>The <code>dependency-watchdog-endpoint</code> deployment is responsible for above mentioned second point.</p><p>Kubernetes is restarting failing pods with an exponentially increasing backoff time.
While this is a great strategy to prevent system overloads it has the disadvantage that the delay between restarts is increasing up to multiple minutes very fast.</p><p>In the Gardener context, we are deploying many components that are depending on other components.
For example, the <code>kube-apiserver</code> is depending on a running <code>etcd</code>, or the <code>kube-controller-manager</code> and <code>kube-scheduler</code> are depending on a running <code>kube-apiserver</code>.
In case such a &ldquo;higher-level&rdquo; component fails for whatever reason, the dependent pods will fail and end-up in crash-loops.
As Kubernetes does not know anything about these hierarchies it won&rsquo;t recognize that such pods can be restarted faster as soon as their dependents are up and running again.</p><p>This is exactly the situation in which the DWD will become active:
If it detects that a certain <code>Service</code> is available again (e.g., after the <code>etcd</code> was temporarily down while being moved to another seed node) then DWD will restart all crash-looping dependant pods.
These dependant pods are detected via a pre-configured label selector.</p><p>As of today, the DWD is configured to restart a crash-looping <code>kube-apiserver</code> after <code>etcd</code> became available again, or any pod depending on the <code>kube-apiserver</code> that has a <code>gardener.cloud/role=controlplane</code> label (e.g., <code>kube-controller-manager</code>, <code>kube-scheduler</code>, etc.).</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a4713902bcc1223db8a52f790b8cd0ef>8.19 - Seed Settings</h1><h1 id=settings-for-seeds>Settings for <code>Seed</code>s</h1><p>The <code>Seed</code> resource offers a few settings that are used to control the behaviour of certain Gardener components.
This document provides an overview over the available settings:</p><h2 id=dependency-watchdog>Dependency Watchdog</h2><p>Gardenlet can deploy two instances of the <a href=https://github.com/gardener/dependency-watchdog>dependency-watchdog</a> into the <code>garden</code> namespace of the seed cluster.
One instance only activates the <code>endpoint</code> controller while the second instance only activates the <code>probe</code> controller.</p><h3 id=endpoint-controller>Endpoint Controller</h3><p>The <code>endpoint</code> controller helps to alleviate the delay where control plane components remain unavailable by finding the respective pods in CrashLoopBackoff status and restarting them once their dependants become ready and available again.
For example, if <code>etcd</code> goes down then also <code>kube-apiserver</code> goes down (and into a <code>CrashLoopBackoff</code> state). If <code>etcd</code> comes up again then (without the <code>endpoint</code> controller) it might take some time until <code>kube-apiserver</code> gets restarted as well.</p><p>It can be enabled/disabled via the <code>.spec.settings.dependencyWatchdog.endpoint.enabled</code> field.
It defaults to <code>true</code>.</p><h3 id=probe-controller>Probe Controller</h3><p>The <code>probe</code> controller scales down the <code>kube-controller-manager</code> of shoot clusters in case their respective <code>kube-apiserver</code> is not reachable via its external ingress.
This is in order to avoid melt-down situations since the <code>kube-controller-manager</code> uses in-cluster communication when talking to the <code>kube-apiserver</code>, i.e., it wouldn&rsquo;t be affected if the external access to the <code>kube-apiserver</code> is interrupted for whatever reason.
The <code>kubelet</code>s on the shoot worker nodes, however, would indeed be affected since they typically run in different networks and use the external ingress when talking to the <code>kube-apiserver</code>.
Hence, without scaling down <code>kube-controller-manager</code>, the nodes might be marked as <code>NotReady</code> and eventually replaced (since the <code>kubelet</code>s cannot report their status anymore).
To prevent such unnecessary turbulences, <code>kube-controller-manager</code> is being scaled down until the external ingress becomes available again.</p><p>It can be enabled/disabled via the <code>.spec.settings.dependencyWatchdog.probe.enabled</code> field.
It defaults to <code>true</code>.</p><h2 id=reserve-excess-capacity>Reserve Excess Capacity</h2><p>If the excess capacity reservation is enabled then the Gardenlet will deploy a special <code>Deployment</code> into the <code>garden</code> namespace of the seed cluster.
This <code>Deployment</code>&rsquo;s pod template has only one container, the <code>pause</code> container, which simply runs in an infinite loop.
The priority of the deployment is very low, so any other pod will preempt these <code>pause</code> pods.
This is especially useful if new shoot control planes are created in the seed.
In case the seed cluster runs at its capacity then there is no waiting time required during the scale-up.
Instead, the low-priority <code>pause</code> pods will be preempted and allow newly created shoot control plane pods to be scheduled fast.
In the meantime, the cluster-autoscaler will trigger the scale-up because the preempted <code>pause</code> pods want to run again.
However, this delay doesn&rsquo;t affect the important shoot control plane pods which will improve the user experience.</p><p>It can be enabled/disabled via the <code>.spec.settings.excessCapacityReservation.enabled</code> field.
It defaults to <code>true</code>.</p><h2 id=scheduling>Scheduling</h2><p>By default, the Gardener Scheduler will consider all seed clusters when a new shoot cluster shall be created.
However, administrators/operators might want to exclude some of them from being considered by the scheduler.
Therefore, seed clusters can be marked as &ldquo;invisible&rdquo;.
In this case, the scheduler simply ignores them as if they wouldn&rsquo;t exist.
Shoots can still use the invisible seed but only by explicitly specifying the name in their <code>.spec.seedName</code> field.</p><p>Seed clusters can be marked visible/invisible via the <code>.spec.settings.scheduling.visible</code> field.
It defaults to <code>true</code>.</p><h2 id=shoot-dns>Shoot DNS</h2><p>Generally, the Gardenlet creates a few DNS records during the creation/reconciliation of a shoot cluster (see <a href=/docs/gardener/usage/configuration/>here</a>).
However, some infrastructures don&rsquo;t need/want this behaviour.
Instead, they want to directly use the IP addresses/hostnames of load balancers.
Another use-case is a local development setup where DNS is not needed for simplicity reasons.</p><p>By setting the <code>.spec.settings.shootDNS.enabled</code> field this behavior can be controlled.</p><p>ℹ️ In previous Gardener versions (&lt; 1.5) these settings were controlled via taint keys (<code>seed.gardener.cloud/{disable-capacity-reservation,disable-dns,invisible}</code>).
The taint keys are no longer supported and removed in version 1.12.
The rationale behind it is the implementation of tolerations similar to Kubernetes tolerations.
More information about it can be found in <a href=https://github.com/gardener/gardener/issues/2193>#2193</a>.</p><h2 id=load-balancer-services>Load Balancer Services</h2><p>Gardener creates certain Kubernetes <code>Service</code> objects of type <code>LoadBalancer</code> in the seed cluster.
Most prominently, they are used for exposing the shoot control planes, namely the kube-apiserver of the shoot clusters.
In most cases, the cloud-controller-manager (responsible for managing these load balancers on the respective underlying infrastructure) supports certain customization and settings via annotations.
<a href=https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer>This document</a> provides a good overview and many examples.</p><p>By setting the <code>.spec.settings.loadBalancerServices.annotations</code> field the Gardener administrator can specify a list of annotations which will be injected into the <code>Service</code>s of type <code>LoadBalancer</code>.</p><h2 id=vertical-pod-autoscaler>Vertical Pod Autoscaler</h2><p>Gardener heavily relies on the Kubernetes <a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler><code>vertical-pod-autoscaler</code> component</a>.
By default, the seed controller deploys the VPA components into the <code>garden</code> namespace of the respective seed clusters.
In case you want to manage the VPA deployment on your own or have a custom one then you might want to disable the automatic deployment of Gardener.
Otherwise, you might end up with two VPAs which will cause erratic behaviour.
By setting the <code>.spec.settings.verticalPodAutoscaler.enabled=false</code> you can disable the automatic deployment.</p><p>⚠️ In any case, there must be a VPA available for your seed cluster. Using a seed without VPA is not supported.</p><h2 id=owner-checks>Owner Checks</h2><p>When a shoot is scheduled to a seed and actually reconciled, Gardener appoints the seed as the current &ldquo;owner&rdquo; of the shoot by creating a special &ldquo;owner DNS record&rdquo; and checking against it if the seed still owns the shoot in order to guard against &ldquo;split brain scenario&rdquo; during control plane migration, as described in <a href=/docs/gardener/proposals/17-shoot-control-plane-migration-bad-case/>GEP-17 Shoot Control Plane Migration &ldquo;Bad Case&rdquo; Scenario</a>.
This mechanism relies on the DNS resolution of TXT DNS records being possible and highly reliable, since if the owner check fails the shoot will be effectively disabled for the duration of the failure.
In environments where resolving TXT DNS records is either not possible or not considered reliable enough, it may be necessary to disable the owner check mechanism, in order to avoid shoots failing to reconcile or temporary outages due to transient DNS failures.
By setting the <code>.spec.settings.ownerChecks.enabled=false</code> (default is <code>true</code>) the creation and checking of owner DNS records can be disabled for all shoots scheduled on this seed. Note that if owner checks are disabled, migrating shoots scheduled on this seed to other seeds should be considered unsafe, and in the future will be disabled as well.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ac6a66f3733149171ad802e94f5dc7e7>8.20 - Shoot Auditpolicy</h1><h1 id=audit-a-kubernetes-cluster>Audit a Kubernetes Cluster</h1><p>The shoot cluster is a kubernetes cluster and its <code>kube-apiserver</code> handles the audit events. In order to define which audit events must be logged, a proper audit policy file must be passed to the kubernetes API server. You could find more information about auditing a kubernetes cluster <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/>here</a>.</p><h2 id=default-audit-policy>Default Audit Policy</h2><p>By default, the Gardener will deploy the shoot cluster with audit policy defined in the <a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/component/kubeapiserver/secrets.go>kube-apiserver package</a>.</p><h2 id=custom-audit-policy>Custom Audit Policy</h2><p>If you need specific audit policy for your shoot cluster, then you could deploy the required audit policy in the garden cluster as <code>ConfigMap</code> resource and set up your shoot to refer this <code>ConfigMap</code>. Note, the policy must be stored under the key <code>policy</code> in the data section of the <code>ConfigMap</code>.</p><p>For example, deploy the auditpolicy <code>ConfigMap</code> in the same namespace as your <code>Shoot</code> resource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f example/95-configmap-custom-audit-policy.yaml
</code></pre></div><p>then set your shoot to refer that <code>ConfigMap</code> (only related fields are shown):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  kubernetes:
    kubeAPIServer:
      auditConfig:
        auditPolicy:
          configMapRef:
            name: auditpolicy
</code></pre></div><p>The Gardener validate the <code>Shoot</code> resource to refer only existing <code>ConfigMap</code> containing valid audit policy, and rejects the <code>Shoot</code> on failure.
If you want to switch back to the default audit policy, you have to remove the section</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>auditPolicy:
  configMapRef:
    name: &lt;configmap-name&gt;
</code></pre></div><p>from the shoot spec.</p><h2 id=rolling-out-changes-to-the-audit-policy>Rolling Out Changes to the Audit Policy</h2><p>Gardener is not automatically rolling out changes to the Audit Policy to minimize the amount of Shoot reconciliations in order to prevent cloud provider rate limits, etc.
Gardener will pick up the changes on the next reconciliation of Shoots referencing the Audit Policy ConfigMap.
If users want to immediately rollout Audit Policy changes, they can manually trigger a Shoot reconciliation as described in <a href=/docs/gardener/usage/shoot_operations/#immediate-reconciliation>triggering an immediate reconciliation</a>.
This is similar to changes to the cloud provider secret referenced by Shoots.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fca47cfc40d1ae8a466ee0cce9f8b9e3>8.21 - Shoot Autoscaling</h1><h1 id=auto-scaling-in-shoot-clusters>Auto-Scaling in Shoot Clusters</h1><p>There are two parts that relate to auto-scaling in Kubernetes clusters in general:</p><ul><li>Horizontal node auto-scaling, i.e., dynamically adding and removing worker nodes</li><li>Vertical pod auto-scaling, i.e., dynamically raising or shrinking the resource requests/limits of pods</li></ul><p>This document provides an overview of both scenarios.</p><h2 id=horizontal-node-auto-scaling>Horizontal Node Auto-Scaling</h2><p>Every shoot cluster that has at least one worker pool with <code>minimum &lt; maximum</code> nodes configuration will get a <code>cluster-autoscaler</code> deployment.
Gardener is leveraging the upstream community Kubernetes <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler><code>cluster-autoscaler</code> component</a>.
We have forked it to <a href=https://github.com/gardener/autoscaler/>gardener/autoscaler</a> so that it supports the way how Gardener manages the worker nodes (leveraging <a href=https://github.com/gardener/machine-controller-manager>gardener/machine-controller-manager</a>).
However, we have not touched the logic how it performs auto-scaling decisions.
Consequently, please refer to the <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler#faqdocumentation>offical documentation</a> for this component.</p><p>The <code>Shoot</code> API allows to configure a few flags of the <code>cluster-autoscaler</code>:</p><ul><li><code>.spec.kubernetes.clusterAutoscaler.ScaleDownDelayAfterAdd</code> defines how long after scale up that scale down evaluation resumes (default: <code>1h</code>).</li><li><code>.spec.kubernetes.clusterAutoscaler.ScaleDownDelayAfterDelete</code> defines how long after node deletion that scale down evaluation resumes (defaults to <code>ScanInterval</code>).</li><li><code>.spec.kubernetes.clusterAutoscaler.ScaleDownDelayAfterFailure</code> defines how long after scale down failure that scale down evaluation resumes (default: <code>3m</code>).</li><li><code>.spec.kubernetes.clusterAutoscaler.ScaleDownUnneededTime</code> defines how long a node should be unneeded before it is eligible for scale down (default: <code>30m</code>).</li><li><code>.spec.kubernetes.clusterAutoscaler.ScaleDownUtilizationThreshold</code> defines the threshold under which a node is being removed (default: <code>0.5</code>).</li><li><code>.spec.kubernetes.clusterAutoscaler.ScanInterval</code> defines how often cluster is reevaluated for scale up or down (default: <code>10s</code>).</li><li><code>.spec.kubernetes.clusterAutoscaler.IgnoreTaints</code> specifies a list of taint keys to ignore in node templates when considering to scale a node group (default: <code>nil</code>).</li></ul><h2 id=vertical-pod-auto-scaling>Vertical Pod Auto-Scaling</h2><p>This form of auto-scaling is not enabled by default and must be explicitly enabled in the <code>Shoot</code> by setting <code>.spec.kubernetes.verticalPodAutoscaler.enabled=true</code>.
The reason is that it was only introduced lately, and some end-users might have already deployed their own VPA into their clusters, i.e., enabling it by default would interfere with such custom deployments and lead to issues, eventually.</p><p>Gardener is also leveraging an upstream community tool, i.e., the Kubernetes <a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler><code>vertical-pod-autoscaler</code> component</a>.
If enabled, Gardener will deploy it as part of the control plane into the seed cluster.
It will also be used for the vertical autoscaling of Gardener&rsquo;s system components deployed into the <code>kube-system</code> namespace of shoot clusters, for example, <code>kube-proxy</code> or <code>metrics-server</code>.</p><p>You might want to refer to the <a href=https://github.com/kubernetes/autoscaler/blob/master/vertical-pod-autoscaler/README.md>official documentation</a> for this component to get more information how to use it.</p><p>The <code>Shoot</code> API allows to configure a few flags of the <code>vertical-pod-autoscaler</code>:</p><ul><li><code>.spec.kubernetes.verticalPodAutoscaler.evictAfterOOMThreshold</code> defines the threshold that will lead to pod eviction in case it OOMed in less than the given threshold since its start and if it has only one container (default: <code>10m0s</code>).</li><li><code>.spec.kubernetes.verticalPodAutoscaler.evictionRateBurst</code> defines the burst of pods that can be evicted (default: <code>1</code>).</li><li><code>.spec.kubernetes.verticalPodAutoscaler.evictionRateLimit</code> defines the number of pods that can be evicted per second. A rate limit set to 0 or -1 will disable the rate limiter (default: <code>-1</code>).</li><li><code>.spec.kubernetes.verticalPodAutoscaler.evictionTolerance</code> defines the fraction of replica count that can be evicted for update in case more than one pod can be evicted (default: <code>0.5</code>).</li><li><code>.spec.kubernetes.verticalPodAutoscaler.recommendationMarginFraction</code> is the fraction of usage added as the safety margin to the recommended request (default: <code>0.15</code>).</li><li><code>.spec.kubernetes.verticalPodAutoscaler.updaterInterval</code> is the interval how often the updater should run (default: <code>1m0s</code>).</li><li><code>.spec.kubernetes.verticalPodAutoscaler.RecommenderInterval</code> is the interval how often metrics should be fetched (default: <code>1m0s</code>).</li></ul><p>⚠️ Please note that if you disable the VPA again then the related <code>CustomResourceDefinition</code>s will remain in your shoot cluster (although, nobody will act on them).
This will also keep all existing <code>VerticalPodAutoscaler</code> objects in the system, including those that might be created by you. You can delete the <code>CustomResourceDefinition</code>s yourself using <code>kubectl delete crd</code> if you want to get rid of them.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cdc20eb6ababa209934b6e4bb03138d6>8.22 - Shoot Cleanup</h1><h1 id=cleanup-of-shoot-clusters-in-deletion>Cleanup of Shoot clusters in deletion</h1><p>When a shoot cluster is deleted then Gardener tries to gracefully remove most of the Kubernetes resources inside the cluster.
This is to prevent that any infrastructure or other artefacts remain after the shoot deletion.</p><p>The cleanup is performed in four steps.
Some resources are deleted with a grace period, and all resources are forcefully deleted (by removing blocking finalizers) after some time to not block the cluster deletion entirely.</p><p><strong>Cleanup steps:</strong></p><ol><li>All <code>ValidatingWebhookConfiguration</code>s and <code>MutatingWebhookConfiguration</code>s are deleted with a <code>5m</code> grace period. Forceful finalization happens after <code>5m</code>.</li><li>All <code>APIService</code>s and <code>CustomResourceDefinition</code>s are deleted with a <code>5m</code> grace period. Forceful finalization happens after <code>1h</code>.</li><li>All <code>CronJob</code>s, <code>DaemonSet</code>s, <code>Deployment</code>s, <code>Ingress</code>s, <code>Job</code>s, <code>Pod</code>s, <code>ReplicaSet</code>s, <code>ReplicationController</code>s, <code>Service</code>s, <code>StatefulSet</code>s, <code>PersistentVolumeClaim</code>s are deleted with a <code>5m</code> grace period. Forceful finalization happens after <code>5m</code>.<blockquote><p>If the <code>Shoot</code> is annotated with <code>shoot.gardener.cloud/skip-cleanup=true</code> then only <code>Service</code>s and <code>PersistentVolumeClaim</code>s are considered.</p></blockquote></li><li>All <code>VolumeSnapshot</code>s and <code>VolumeSnapshotContent</code>s are deleted with a <code>5m</code> grace period. Forceful finalization happens after <code>1h</code>.</li><li>All <code>Namespace</code>s are deleted without any grace period. Forceful finalization happens after <code>5m</code>.</li></ol><p>It is possible to override the finalization grace periods via annotations on the <code>Shoot</code>:</p><ul><li><code>shoot.gardener.cloud/cleanup-webhooks-finalize-grace-period-seconds</code> (for the resources handled in step 1)</li><li><code>shoot.gardener.cloud/cleanup-extended-apis-finalize-grace-period-seconds</code> (for the resources handled in step 2)</li><li><code>shoot.gardener.cloud/cleanup-kubernetes-resources-finalize-grace-period-seconds</code> (for the resources handled in step 3)</li><li><code>shoot.gardener.cloud/cleanup-namespaces-finalize-grace-period-seconds</code> (for the resources handled in step 4)</li></ul><p>⚠️ If <code>"0"</code> is provided then all resources are finalized immediately without waiting for any graceful deletion.
Please be aware that this might lead to orphaned infrastructure artefacts.</p><h2 id=infrastructure-cleanup-wait-period>Infrastructure Cleanup Wait Period</h2><p>After all above cleanup steps have been performed and the <code>Infrastructure</code> extension resource has been deleted the gardenlet waits for a certain duration to allow controllers to properly cleanup infrastructure resources.</p><p>By default, this duration is set to <code>5m</code>. Only after this time has passed the shoot deletion flow continues with the entire tear-down of the remaining control plane components (including <code>kube-apiserver</code>s, etc.).</p><p>It is also possible to override this wait period via an annotations on the <code>Shoot</code>:</p><ul><li><code>shoot.gardener.cloud/infrastructure-cleanup-wait-period-seconds</code></li></ul><blockquote><p>ℹ️️ All provided period values larger than the above mentioned defaults are ignored.</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-6e28d817b7a970b189d7b89840fa8925>8.23 - Shoot Info Configmap</h1><h1 id=shoot-info-configmap>Shoot Info <code>ConfigMap</code></h1><h2 id=overview>Overview</h2><p>Gardenlet maintains a <a href=https://kubernetes.io/docs/concepts/configuration/configmap/>ConfigMap</a> inside the Shoot cluster that contains information about the cluster itself. The ConfigMap is named <code>shoot-info</code> and located in the <code>kube-system</code> namespace.</p><h2 id=fields>Fields</h2><p>The following fields are provided:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ConfigMap
metadata:
  name: shoot-info
  namespace: kube-system
data:
  domain: crazy-botany.core.my-custom-domain.com     <span style=color:green># .spec.dns.domain field from the Shoot resource</span>
  extensions: foobar,foobaz                          <span style=color:green># List of extensions that are enabled</span>
  kubernetesVersion: 1.20.1                          <span style=color:green># .spec.kubernetes.version field from the Shoot resource</span>
  maintenanceBegin: 220000+0100                      <span style=color:green># .spec.maintenance.timeWindow.begin field from the Shoot resource</span>
  maintenanceEnd: 230000+0100                        <span style=color:green># .spec.maintenance.timeWindow.end field from the Shoot resource</span>
  nodeNetwork: 10.250.0.0/16                         <span style=color:green># .spec.networking.nodes field from the Shoot resource</span>
  podNetwork: 100.96.0.0/11                          <span style=color:green># .spec.networking.pods field from the Shoot resource</span>
  projectName: dev                                   <span style=color:green># .metadata.name of the Project</span>
  provider: &lt;some-provider-name&gt;                     <span style=color:green># .spec.provider.type field from the Shoot resource</span>
  region: europe-central-1                           <span style=color:green># .spec.region field from the Shoot resource</span>
  serviceNetwork: 100.64.0.0/13                      <span style=color:green># .spec.networking.services field from the Shoot resource</span>
  shootName: crazy-botany                            <span style=color:green># .metadata.name from the Shoot resource</span>
</code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-530324ec62b83dd4fb4dbc1c64e21ea4>8.24 - Shoot Maintenance</h1><h1 id=shoot-maintenance>Shoot Maintenance</h1><p>Shoots configure a maintenance time window in which Gardener performs certain operations that may restart the control plane, roll out the nodes, result in higher network traffic, etc.
This document outlines what happens during a shoot maintenance.</p><h2 id=time-window>Time Window</h2><p>Via the <code>.spec.maintenance.timeWindow</code> field in the shoot specification end-users can configure the time window in which maintenance operations are executed.
Gardener runs one maintenance operation per day in this time window:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  maintenance:
    timeWindow:
      begin: 220000+0100
      end: 230000+0100
</code></pre></div><p>The offset (<code>+0100</code>) is considered with respect to UTC time.
The minimum time window is <code>30m</code> and the maximum is <code>6h</code>.</p><p>⚠️ Please note that there is no guarantee that a maintenance operation that e.g. starts a node roll-out will finish <em>within</em> the time window.
Especially for large clusters it may take several hours until a graceful rolling update of the worker nodes succeeds (also depending on the workload and the configured pod disruption budgets/termination grace periods).</p><p>Internally, Gardener is subtracting <code>15m</code> from the end of the time window to (best-effort) try to finish the maintenance until the end is reached, however, it might not work in all cases.</p><p>If you don&rsquo;t specify a time window then Gardener will randomly compute it.
You can change it later, of course.</p><h2 id=automatic-version-updates>Automatic Version Updates</h2><p>The <code>.spec.maintenance.autoUpdate</code> field in the shoot specification allows you to control how/whether automatic updates of Kubernetes patch and machine image versions are performed.
Machine image versions are updated per worker pool.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  maintenance:
    autoUpdate:
      kubernetesVersion: <span style=color:#00f>true</span>
      machineImageVersion: <span style=color:#00f>true</span>
</code></pre></div><p>During the daily maintenance, the Gardener Controller Manager updates the Shoot&rsquo;s Kubernetes and machine image version if any of the following criteria applies:</p><ul><li>there is a higher version available and the Shoot opted-in for automatic version updates</li><li>the currently used version is <code>expired</code></li></ul><p>Gardener creates events with type <code>MaintenanceDone</code> on the Shoot describing the action performed during maintenance including the reason why an update has been triggered.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>MaintenanceDone  Updated image of worker-pool &#39;coreos-xy&#39; from &#39;coreos&#39; version &#39;xy&#39; to version &#39;abc&#39;. Reason: AutoUpdate of MachineImage configured.
MaintenanceDone  Updated Kubernetes version &#39;0.0.1&#39; to version &#39;0.0.5&#39;. This is an increase in the patch level. Reason: AutoUpdate of Kubernetes version configured.
MaintenanceDone  Updated Kubernetes version &#39;0.0.5&#39; to version &#39;0.1.5&#39;. This is an increase in the minor level. Reason: Kubernetes version expired - force update required.
</code></pre></div><p>Please refer to <a href=/docs/gardener/usage/shoot_versions/>this document</a> for more information about Kubernetes and machine image versions in Gardener.</p><h2 id=cluster-reconciliation>Cluster Reconciliation</h2><p>Gardener administrators/operators can configure the Gardenlet in a way that it only reconciles shoot clusters during their maintenance time windows.
This behaviour is not controllable by end-users but might make sense for large Gardener installations.
Concretely, your shoot will be reconciled regularly during its maintenance time window.
Outside of the maintenance time window it will only reconcile if you change the specification or if you explicitly trigger it, see also <a href=/docs/gardener/usage/shoot_operations/>this document</a>.</p><h2 id=confine-specification-changesupdates-roll-out>Confine Specification Changes/Updates Roll Out</h2><p>Via the <code>.spec.maintenance.confineSpecUpdateRollout</code> field you can control whether you want to make Gardener roll out changes/updates to your shoot specification only during the maintenance time window.
It is <code>false</code> by default, i.e., any change to your shoot specification triggers a reconciliation (even outside of the maintenance time window).
This is helpful if you want to update your shoot but don&rsquo;t want the changes to be applied immediately. One example use-case would be a Kubernetes version upgrade that you want to roll out during the maintenance time window.
Any update to the specification will not increase the <code>.metadata.generation</code> of the <code>Shoot</code> which is something you should be aware of.
Also, even if Gardener administrators/operators have not enabled the &ldquo;reconciliation in maintenance time window only&rdquo; configuration (as mentioned above) then your shoot will only reconcile in the maintenance time window.
The reason is that Gardener cannot differentiate between create/update/reconcile operations.</p><p>⚠️ If <code>confineSpecUpdateRollout=true</code>, please note that if you change the maintenance time window itself then it will only be effective after the upcoming maintenance.</p><p>⚠️ There is one exceptional change in the shoot specification that triggers an immediate roll out which is changes to the <code>.spec.hibernation.enabled</code> field.
If you hibernate or wake-up your shoot then Gardener gets active right away.</p><h2 id=special-operations-during-maintenance>Special Operations During Maintenance</h2><p>The shoot maintenance controller triggers special operations that are performed as part of the shoot reconciliation.</p><h3 id=infrastructure-and-dnsrecord-reconciliation><code>Infrastructure</code> and <code>DNSRecord</code> Reconciliation</h3><p>The reconciliation of the <code>Infrastructure</code> and <code>DNSRecord</code> extension resources is only demanded during the shoot&rsquo;s maintenance time window.
The rationale behind it is to prevent sending too many requests against the cloud provider APIs, especially on large landscapes or if a user has many shoot clusters in the same cloud provider account.</p><h3 id=restart-control-plane-controllers>Restart Control Plane Controllers</h3><p>Gardener operators can make Gardener restart/delete certain control plane pods during a shoot maintenance.
This feature helps to automatically solve service denials of controllers due to stale caches, dead-locks or starving routines.</p><p>Please note that these are exceptional cases but they are observed from time to time.
Gardener, for example, takes this precautionary measure for <code>kube-controller-manager</code> pods.</p><p>See <a href=/docs/gardener/extensions/shoot-maintenance/>this document</a> to see how extension developers can extend this behaviour.</p><h3 id=restart-some-core-addons>Restart Some Core Addons</h3><p>Gardener operators can make Gardener restart some core addons, at the moment only CoreDNS, during a shoot maintenance.</p><p>CoreDNS benefits from this feature as it automatically solve problems with clients stuck to single replica of the deployment and thus overloading it.
Please note that these are exceptional cases but they are observed from time to time.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-97d7360c220fe009f695e761863dd64c>8.25 - Shoot Network Policies</h1><h2 id=network-policies-in-the-shoot-cluster>Network policies in the Shoot Cluster</h2><p>In addition to deploying network policies <a href=/docs/gardener/development/seed_network_policies/>into the Seed</a>,
Gardener deploys network policies into the <code>kube-system</code> namespace of the Shoot.
These network policies are used by Shoot system components (that are not part of the control plane).
Other namespaces in the Shoot do not contain network policies deployed by Gardener.</p><p>As best practice, every pod deployed into the <code>kube-system</code> namespace should use appropriate network policies in order to only allow <strong>required</strong> network traffic.
Therefore, pods should have labels matching to the selectors of the available network policies.</p><p>Gardener deploys the following network policies:</p><pre><code>NAME                                       POD-SELECTOR
gardener.cloud--allow-dns                  k8s-app in (kube-dns)
gardener.cloud--allow-from-seed            networking.gardener.cloud/from-seed=allowed
gardener.cloud--allow-to-apiserver         networking.gardener.cloud/to-apiserver=allowed
gardener.cloud--allow-to-dns               networking.gardener.cloud/to-dns=allowed
gardener.cloud--allow-to-from-nginx        app=nginx-ingress
gardener.cloud--allow-to-kubelet           networking.gardener.cloud/to-kubelet=allowed
gardener.cloud--allow-to-public-networks   networking.gardener.cloud/to-public-networks=allowed
gardener.cloud--allow-vpn                  app=vpn-shoot
</code></pre><p>Additionally, there can be network policies deployed by Gardener extensions such as <a href=https://github.com/gardener/gardener-extension-networking-calico>extension-calico</a>.</p><pre><code>NAME                                       POD-SELECTOR
gardener.cloud--allow-from-calico-node     k8s-app=calico-typha
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-ee4728cf7f71a3c0ae90d16a7c9cf79a>8.26 - Shoot Networking</h1><h1 id=shoot-networking>Shoot Networking</h1><p>This document contains network related information for Shoot clusters.</p><h2 id=pod-network>Pod Network</h2><p>A Pod network is imperative for any kind of cluster communication with Pods not started within the Node&rsquo;s host network.
More information about the Kubernetes network model can be found <a href=https://kubernetes.io/docs/concepts/cluster-administration/networking/>here</a>.</p><p>Gardener allows users to configure the Pod network&rsquo;s CIDR during Shoot creation:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
spec:
  networking:
    type: &lt;some-network-extension-name&gt; <span style=color:green># {calico,cilium}</span>
    pods: 100.96.0.0/16
    nodes: ...
    services: ...
</code></pre></div><blockquote><p>⚠️ The <code>networking.pods</code> IP configuration is immutable and cannot be changed afterwards.
Please consider the following paragraph to choose a configuration which will meet your demands.</p></blockquote><p>One of the network plugin&rsquo;s (CNI) tasks is to assign IP addresses to Pods started in the Pod network.
Different network plugins come with different IP address management (IPAM) features, so we can&rsquo;t give any definite advice how IP ranges should be configured.
Nevertheless, we want to outline the standard configuration.</p><p>Information in <code>.spec.networking.pods</code> matches the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/>&ndash;cluster-cidr flag</a> of the Kube-Controller-Manager of your Shoot cluster.
This IP range is divided into smaller subnets, also called <code>podCIDRs</code> (default mask <code>/24</code>) and assigned to Node objects <code>.spec.podCIDR</code>.
Pods get their IP address from this smaller node subnet in a default IPAM setup.
Thus, it must be guaranteed that enough of these subnets can be created for the maximum amount of nodes you expect in the cluster.</p><p><em><strong>Example 1</strong></em></p><pre><code>Pod network: 100.96.0.0/16
nodeCIDRMaskSize: /24
-------------------------

Number of podCIDRs: 256 --&gt; max. Node count 
Number of IPs per podCIDRs: 256
</code></pre><p>With the configuration above a Shoot cluster can at most have <strong>256 nodes</strong> which are ready to run workload in the Pod network.</p><p><em><strong>Example 2</strong></em></p><pre><code>Pod network: 100.96.0.0/20
nodeCIDRMaskSize: /24
-------------------------

Number of podCIDRs: 16 --&gt; max. Node count 
Number of IPs per podCIDRs: 256
</code></pre><p>With the configuration above a Shoot cluster can at most have <strong>16 nodes</strong> which are ready to run workload in the Pod network.</p><p>Beside the configuration in <code>.spec.networking.pods</code>, users can tune the <code>nodeCIDRMaskSize</code> used by Kube-Controller-Manager on shoot creation.
A smaller IP range per node means more <code>podCIDRs</code> and thus the ability to provision more nodes in the cluster, but less available IPs for Pods running on each of the nodes.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Shoot
spec:
  kubeControllerManager:
    nodeCIDRMaskSize: 24 (default)
</code></pre></div><blockquote><p>⚠️ The <code>nodeCIDRMaskSize</code> configuration is immutable and cannot be changed afterwards.</p></blockquote><p><em><strong>Example 3</strong></em></p><pre><code>Pod network: 100.96.0.0/20
nodeCIDRMaskSize: /25
-------------------------

Number of podCIDRs: 32 --&gt; max. Node count 
Number of IPs per podCIDRs: 128
</code></pre><p>With the configuration above a Shoot cluster can at most have <strong>32 nodes</strong> which are ready to run workload in the Pod network.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-aa95d2c4d5739a992f6e2fe3ce04db73>8.27 - Shoot Operations</h1><h1 id=trigger-shoot-operations>Trigger shoot operations</h1><p>You can trigger a few explicit operations by annotating the <code>Shoot</code> with an operation annotation.
This might allow you to induct certain behavior without the need to change the <code>Shoot</code> specification.
Some of the operations can also not be caused by changing something in the shoot specification because they can&rsquo;t properly be reflected here.
Note, once the triggered operation is considered by the controllers, the annotation will be automatically removed and you have to add it each time you want to trigger the operation.</p><p>Please note: If <code>.spec.maintenance.confineSpecUpdateRollout=true</code> then the only way to trigger a shoot reconciliation is by setting the <code>reconcile</code> operation, see below.</p><h2 id=immediate-reconciliation>Immediate reconciliation</h2><p>Annotate the shoot with <code>gardener.cloud/operation=reconcile</code> to make the <code>gardenlet</code> start a reconciliation operation without changing the shoot spec and possibly without being in its maintenance time window:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-&lt;project-name&gt; annotate shoot &lt;shoot-name&gt; gardener.cloud/operation=reconcile
</code></pre></div><h2 id=immediate-maintenance>Immediate maintenance</h2><p>Annotate the shoot with <code>gardener.cloud/operation=maintain</code> to make the <code>gardener-controller-manager</code> start maintaining your shoot immediately (possibly without being in its maintenance time window).
If no reconciliation starts then nothing needed to be maintained:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-&lt;project-name&gt; annotate shoot &lt;shoot-name&gt; gardener.cloud/operation=maintain
</code></pre></div><h2 id=retry-failed-operation>Retry failed operation</h2><p>Annotate the shoot with <code>gardener.cloud/operation=retry</code> to make the <code>gardenlet</code> start a new reconciliation loop on a failed shoot.
Failed shoots are only reconciled again if a new Gardener version is deployed, the shoot specification is changed or this annotation is set</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-&lt;project-name&gt; annotate shoot &lt;shoot-name&gt; gardener.cloud/operation=retry
</code></pre></div><h2 id=rotate-kubeconfig-credentials>Rotate kubeconfig credentials</h2><p>Annotate the shoot with <code>gardener.cloud/operation=rotate-kubeconfig-credentials</code> to make the <code>gardenlet</code> exchange the credentials in your shoot cluster&rsquo;s kubeconfig.
This operation is not allowed for shoot clusters that are already in deletion.
Please note that only the token (and basic auth password, if enabled) are exchanged. The cluster CAs remain the same.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n garden-&lt;project-name&gt; annotate shoot &lt;shoot-name&gt; gardener.cloud/operation=rotate-kubeconfig-credentials
</code></pre></div><p>You can check the <code>.status.credentials.rotation.kubeconfig</code> field in the <code>Shoot</code> to see when the rotation was last initiated or last completed.</p><h2 id=restart-systemd-services-on-particular-worker-nodes>Restart systemd services on particular worker nodes</h2><p>It is possible to make Gardener restart particular systemd services on your shoot worker nodes if needed.
The annotation is not set on the <code>Shoot</code> resource but directly on the <code>Node</code> object you want to target.
For example, the following will restart both the <code>kubelet</code> and the <code>docker</code> services:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl annotate node &lt;node-name&gt; worker.gardener.cloud/restart-systemd-services=kubelet,docker
</code></pre></div><p>It may take up to a minute until the service is restarted.
The annotation will be removed from the <code>Node</code> object after all specified systemd services have been restarted.
It will also be removed even if the restart of one or more services failed.</p><blockquote><p>ℹ️ In the example mentioned above, you could additionally verify when/whether the kubelet restarted by using <code>kubectl describe node &lt;node-name></code> and looking for such a <code>Starting kubelet</code> event.</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-ce24e382e35468e5c98ad64130e0653b>8.28 - Shoot Purposes</h1><h1 id=shoot-cluster-purpose>Shoot Cluster Purpose</h1><p>The <code>Shoot</code> resource contains a <code>.spec.purpose</code> field indicating how the shoot is used whose allowed values are as follows:</p><ul><li><code>evaluation</code> (default): Indicates that the shoot cluster is for evaluation scenarios.</li><li><code>development</code>: Indicates that the shoot cluster is for development scenarios.</li><li><code>testing</code>: Indicates that the shoot cluster is for testing scenarios.</li><li><code>production</code>: Indicates that the shoot cluster is for production scenarios.</li><li><code>infrastructure</code>: Indicates that the shoot cluster is for infrastructure scenarios (only allowed for shoots in the <code>garden</code> namespace).</li></ul><h2 id=behavioral-differences>Behavioral Differences</h2><p>The following enlists the differences in the way the shoot clusters are set up based on the selected purpose:</p><ul><li><code>testing</code> shoot clusters <strong>do not</strong> get a monitoring or a logging stack as part of their control planes.</li><li><code>production</code> shoot clusters get at least two replicas of the <code>kube-apiserver</code> for their control planes.
Auto-scaling scale down of the main ETCD is disabled for such clusters.</li></ul><p>There are also differences with respect to how <code>testing</code> shoots are scheduled after creation, please consult the <a href=/docs/gardener/concepts/scheduler/>Scheduler documentation</a>.</p><h2 id=future-steps>Future Steps</h2><p>We might introduce more behavioral difference depending on the shoot purpose in the future.
As of today, there are no plans yet.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c9d857194e434604d822b4e8baf96323>8.29 - Shoot Status</h1><h1 id=shoot-status>Shoot Status</h1><p>This document provides an overview of the <a href=/docs/gardener/api-reference/core/#shootstatus>ShootStatus</a>.</p><h2 id=conditions>Conditions</h2><p>The Shoot status consists of a set of conditions. A <a href=/docs/gardener/api-reference/core/#condition>Condition</a> has the following fields:</p><table><thead><tr><th>Field name</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></td><td>Name of the condition.</td></tr><tr><td><code>status</code></td><td>Indicates whether the condition is applicable, with possible values <code>True</code>, <code>False</code>, <code>Unknown</code>, or <code>Progressing</code>.</td></tr><tr><td><code>lastTransitionTime</code></td><td>Timestamp for when the condition last transitioned from one status to another.</td></tr><tr><td><code>lastUpdateTime</code></td><td>Timestamp for when the condition was updated. Usually changes when <code>reason</code> or <code>message</code> in condition is updated.</td></tr><tr><td><code>reason</code></td><td>Machine-readable, UpperCamelCase text indicating the reason for the condition&rsquo;s last transition.</td></tr><tr><td><code>message</code></td><td>Human-readable message indicating details about the last status transition.</td></tr><tr><td><code>codes</code></td><td>Well-defined error codes in case the condition reports a problem.</td></tr></tbody></table><p>Currently the available Shoot condition types are:</p><ul><li><p><code>APIServerAvailable</code></p><p>This condition type indicates whether the Shoot&rsquo;s kube-apiserver is available or not. In particular, the <code>/healthz</code> endpoint of the kube-apiserver is called, and the expected response code is <code>HTTP 200</code>.</p></li><li><p><code>ControlPlaneHealthy</code></p><p>This condition type indicates whether all the control plane components deployed to the Shoot&rsquo;s namespace in the Seed do exist and are running fine.</p></li><li><p><code>EveryNodeReady</code></p><p>This condition type indicates whether at least the requested minimum number of Nodes is present per each worker pool and whether all Nodes are healthy.</p></li><li><p><code>SystemComponentsHealthy</code></p><p>This condition type indicates whether all system components deployed to the <code>kube-system</code> namespace in the shoot do exist and are running fine. It also reflects whether the tunnel connection between the control plane and the Shoot networks can be established.</p></li></ul><p>The Shoot conditions are maintained by the <a href=https://github.com/gardener/gardener/blob/master/pkg/gardenlet/controller/shoot/shoot_care_control.go>shoot care control</a> of gardenlet.</p><h3 id=sync-period>Sync Period</h3><p>The condition checks are executed periodically at interval which is configurable in the <code>GardenletConfiguration</code> (<code>.controllers.shootCare.syncPeriod</code>, defaults to <code>1m</code>).</p><h3 id=condition-thresholds>Condition Thresholds</h3><p>The <code>GardenletConfiguration</code> also allows configuring condition thresholds (<code>controllers.shootCare.conditionThresholds</code>). Condition threshold is the amount of time to consider condition as <code>Processing</code> on condition status changes.</p><p>Let&rsquo;s check the following example to get better understanding. Let&rsquo;s say that the <code>APIServerAvailable</code> condition of our Shoot is with status <code>True</code>. If the next condition check fails (for example kube-apiserver becomes unreachable), then the condition first goes to <code>Processing</code> state. Only if this state remains for condition threshold amount of time, then the condition finally is updated to <code>False</code>.</p><h3 id=constraints>Constraints</h3><p>Constraints represent conditions of a Shoot’s current state that constraint some operations on it.
Currently there are two constraints:</p><p><strong><code>HibernationPossible</code></strong>:</p><p>This constraint indicates whether a Shoot is allowed to be hibernated.
The rationale behind this constraint is that a Shoot can have <code>ValidatingWebhookConfiguration</code>s or <code>MutatingWebhookConfiguration</code>s acting on resources that are critical for waking up a cluster.
For example, if a webhook has rules for <code>CREATE/UPDATE</code> Pods or Nodes and <code>failurePolicy=Fail</code>, the webhook will block joining <code>Nodes</code> and creating critical system component Pods and thus block the entire wakeup operation, because the server backing the webhook is not running.</p><p>Even if the <code>failurePolicy</code> is set to <code>Ignore</code>, high timeouts (<code>>15s</code>) can lead to blocking requests of control plane components.
That&rsquo;s because most control-plane API calls are made with a client-side timeout of <code>30s</code>, so if a webhook has <code>timeoutSeconds=30</code>
the overall request might still fail as there is overhead in communication with the API server and potential other webhooks.
Generally, it&rsquo;s <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#timeouts>best pratice</a> to specify low timeouts in WebhookConfigs.
Also, it&rsquo;s <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#avoiding-operating-on-the-kube-system-namespace>best practice</a>
to exclude the <code>kube-system</code> namespace from webhooks to avoid blocking critical operations on system components of the cluster.
Shoot owners can do so by adding a <code>namespaceSelector</code> similar to this one to their webhook configurations:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>namespaceSelector:
  matchExpressions:
  - key: gardener.cloud/purpose
    operator: NotIn
    values:
    - kube-system
</code></pre></div><p>If the Shoot still has webhooks with either <code>failurePolicy={Fail,nil}</code> or <code>failurePolicy=Ignore && timeoutSeconds>15</code> that act on <a href=https://github.com/gardener/gardener/blob/master/pkg/operation/botanist/matchers/matcher.go#L60>critical resources</a> in the <code>kube-system</code> namespace, Gardener will set the <code>HibernationPossible</code> to <code>False</code> indicating, that the Shoot can probably not be woken up again after hibernation without manual intervention of the Gardener Operator.
<code>gardener-apiserver</code> will prevent any Shoot with the <code>HibernationPossible</code> constraint set to <code>False</code> from being hibernated, that is via manual hibernation as well as scheduled hibernation.</p><p><strong><code>MaintenancePreconditionsSatisfied</code></strong>:</p><p>This constraint indicates whether all preconditions for a safe maintenance operation are satisfied (see also <a href=/docs/gardener/usage/shoot_maintenance/>this document</a> for more information about what happens during a shoot maintenance).
As of today, the same checks as in the <code>HibernationPossible</code> constraint are being performed (user-deployed webhooks that might interfere with potential rolling updates of shoot worker nodes).
There is no further action being performed on this constraint&rsquo;s status (maintenance is still being performed).
It is meant to make the user aware of potential problems that might occur due to his configurations.</p><h3 id=last-operation>Last Operation</h3><p>The Shoot status holds information about the last operation that is performed on the Shoot. The last operation field reflects overall progress and the tasks that are currently being executed. Allowed operation types are <code>Create</code>, <code>Reconcile</code>, <code>Delete</code>, <code>Migrate</code> and <code>Restore</code>. Allowed operation states are <code>Processing</code>, <code>Succeeded</code>, <code>Error</code>, <code>Failed</code>, <code>Pending</code> and <code>Aborted</code>. An operation in <code>Error</code> state is an operation that will be retried for a configurable amount of time (<code>controllers.shoot.retryDuration</code> field in <code>GardenletConfiguration</code>, defaults to <code>12h</code>). If the operation cannot complete successfully for the configured retry duration, it will be marked as <code>Failed</code>. An operation in <code>Failed</code> state is an operation that won&rsquo;t be retried automatically (to retry such an operation, see <a href=/docs/gardener/usage/shoot_operations/#retry-failed-operation>Retry failed operation</a>).</p><h3 id=last-errors>Last Errors</h3><p>The Shoot status also contains information about the last occurred error(s) (if any) during an operation. A <a href=/docs/gardener/api-reference/core/#lasterror>LastError</a> consists of identifier of the task returned error, human-readable message of the error and error codes (if any) associated with the error.</p><h3 id=error-codes>Error Codes</h3><p>Known error codes are:</p><ul><li><code>ERR_INFRA_UNAUTHENTICATED</code> - indicates that the last error occurred due to the client request not being completed because it lacks valid authentication credentials for the requested resource. It is classified as a non-retryable error code.</li><li><code>ERR_INFRA_UNAUTHORIZED</code> - indicates that the last error occurred due to the server understanding the request but refusing to authorize it. It is classified as a non-retryable error code.</li><li><code>ERR_INFRA_QUOTA_EXCEEDED</code> - indicates that the last error occurred due to infrastructure quota limits. It is classified as a non-retryable error code.</li><li><code>ERR_INFRA_RATE_LIMITS_EXCEEDED</code> - indicates that the last error occurred due to exceeded infrastructure request rate limits.</li><li><code>ERR_INFRA_DEPENDENCIES</code> - indicates that the last error occurred due to dependent objects on the infrastructure level. It is classified as a non-retryable error code.</li><li><code>ERR_RETRYABLE_INFRA_DEPENDENCIES</code> - indicates that the last error occurred due to dependent objects on the infrastructure level, but the operation should be retried.</li><li><code>ERR_INFRA_RESOURCES_DEPLETED</code> - indicates that the last error occurred due to depleted resource in the infrastructure.</li><li><code>ERR_CLEANUP_CLUSTER_RESOURCES</code> - indicates that the last error occurred due to resources in the cluster that are stuck in deletion.</li><li><code>ERR_CONFIGURATION_PROBLEM</code> - indicates that the last error occurred due to a configuration problem. It is classified as a non-retryable error code.</li><li><code>ERR_RETRYABLE_CONFIGURATION_PROBLEM</code> - indicates that the last error occurred due to a retryable configuration problem. &ldquo;Retryable&rdquo; means that the occurred error is likely to be resolved in a ungraceful manner after given period of time.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-442c557a128e8fd2c4f787af32cd900f>8.30 - Shoot Updates</h1><h1 id=shoot-updates-and-upgrades>Shoot Updates and Upgrades</h1><p>This document describes what happens during shoot updates (changes incorporated in a newly deployed Gardener version) and during shoot upgrades (changes for version controllable by end-users).</p><h2 id=updates>Updates</h2><p>Updates to all aspects of the shoot cluster happen when the gardenlet reconciles the <code>Shoot</code> resource.</p><h3 id=when-are-reconciliations-triggered>When are Reconciliations Triggered</h3><p>Generally, when you change the specification of your <code>Shoot</code> the reconciliation will start immediately, potentially updating your cluster.
Please note that you can also confine the reconciliation triggered due to your specification updates to the cluster&rsquo;s maintenance time window. Please find more information <a href=/docs/gardener/usage/shoot_maintenance/#confine-specification-changesupdates-roll-out>here</a>.</p><p>You can also annotate your shoot with special operation annotations (see <a href=/docs/gardener/usage/shoot_operations/>this document</a>) which will cause the reconciliation to start due to your actions.</p><p>There is also an automatic reconciliation by Gardener.
The period, i.e., how often it is performed, depends on the configuration of the Gardener administrators/operators.
In some Gardener installations the operators might enable &ldquo;reconciliation in maintenance time window only&rdquo; (<a href=/docs/gardener/usage/shoot_maintenance/#cluster-reconciliation>more information</a>) which will result in at least one reconciliation during the time configured in the <code>Shoot</code>&rsquo;s <code>.spec.maintenance.timeWindow</code> field.</p><h3 id=which-updates-are-applied>Which Updates are Applied</h3><p>As end-users can only control the <code>Shoot</code> resource&rsquo;s specification but not the used Gardener version, they don&rsquo;t have any influence on which of the updates are rolled out (other than those settings configurable in the <code>Shoot</code>).
A Gardener operator can deploy a new Gardener version at any point in time.
Any subsequent reconciliation of <code>Shoot</code>s will update them by rolling out the changes incorporated in this new Gardener version.</p><p>Some examples for such shoot updates are:</p><ul><li>Add a new/remove an old component to/from the shoot&rsquo;s control plane running in the seed, or to/from the shoot&rsquo;s system components running on the worker nodes.</li><li>Change the configuration of an existing control plane/system component.</li><li>Restart of existing control plane/system components (this might result in a short unavailability of the Kubernetes API server, e.g., when etcd or a kube-apiserver itself is being restarted)</li></ul><h3 id=behavioural-changes>Behavioural Changes</h3><p>Generally, some of such updates (e.g., configuration changes) could theoretically result in different behaviour of controllers.
If such changes would be backwards-incompatible then we usually follow one of those approaches (depends on the concrete change):</p><ul><li>Only apply the change for new clusters.</li><li>Expose a new field in the <code>Shoot</code> resource that lets users control this changed behaviour to enable it at a convenient point in time.</li><li>Put the change behind an alpha feature gate (disabled by default) in the gardenlet (only controllable by Gardener operators) which will be promoted to beta (enabled by default) in subsequent releases (in this case, end-users have no influence on when the behaviour changes - Gardener operators should inform their end-users and provide clear timelines when they will enable the feature gate).</li></ul><h2 id=upgrades>Upgrades</h2><p>We consider shoot upgrades to change either the</p><ul><li>Kubernetes version (<code>.spec.kubernetes.version</code>)</li><li>Kubernetes version of the worker pool if specified (<code>.spec.provider.workers[].kubernetes.version</code>)</li><li>Machine image version of at least one worker pool (<code>.spec.provider.workers[].machine.image.version</code>)</li></ul><p>Generally, an upgrade is also performed through a reconciliation of the <code>Shoot</code> resource, i.e., the same concepts like for <a href=#updates>shoot updates</a> apply.
If an end-user triggers an upgrade (e.g., by changing the Kubernetes version) after a new Gardener version was deployed but before the shoot was reconciled again, then this upgrade might incorporate the changes delivered with this new Gardener version.</p><h3 id=in-place-vs-rolling-updates>In-Place vs. Rolling Updates</h3><p>If the Kubernetes patch version is changed then the upgrade happens in-place.
This means that the shoot worker nodes remain untouched and only the <code>kubelet</code> process restarts with the new Kubernetes version binary.
The same applies for configuration changes of the kubelet.</p><p>If the Kubernetes minor version is changed then the upgrade is done in a &ldquo;rolling update&rdquo; fashion, similar to how pods in Kubernetes are updated (when backed by a <code>Deployment</code>).
The worker nodes will be terminated one after another and replaced by new machines.
The existing workload is gracefully drained and evicted from the old worker nodes to new worker nodes, respecting the configured <code>PodDisruptionBudget</code>s (see <a href=https://kubernetes.io/docs/tasks/run-application/configure-pdb/>Kubernetes documentation</a>).</p><h4 id=customize-rolling-update-behaviour-of-shoot-worker-nodes>Customize Rolling Update Behaviour of Shoot Worker Nodes</h4><p>The <code>.spec.provider.workers[]</code> list exposes two fields that you might configure based on your workload&rsquo;s needs: <code>maxSurge</code> and <code>maxUnavailable</code>.
The same concepts <a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>like in Kubernetes</a> apply.
Additionally, you might customize how the machine-controller-manager (abbrev.: MCM; the component instrumenting this rolling update) is behaving. You can configure the following fields in <code>.spec.provider.worker[].machineControllerManager</code>:</p><ul><li><code>machineDrainTimeout</code>: Timeout (in duration) used while draining of machine before deletion, beyond which MCM forcefully deletes machine (default: <code>10m</code>).</li><li><code>machineHealthTimeout</code>: Timeout (in duration) used while re-joining (in case of temporary health issues) of machine before it is declared as failed (default: <code>10m</code>).</li><li><code>machineCreationTimeout</code>: Timeout (in duration) used while joining (during creation) of machine before it is declared as failed (default: <code>10m</code>).</li><li><code>maxEvictRetries</code>: Maximum number of times evicts would be attempted on a pod before it is forcibly deleted during draining of a machine (default: <code>10</code>).</li><li><code>nodeConditions</code>: List of case-sensitive node-conditions which will change a machine to a <code>Failed</code> state after the <code>machineHealthTimeout</code> duration. It may further be replaced with a new machine if the machine is backed by a machine-set object (defaults: <code>KernelDeadlock</code>, <code>ReadonlyFilesystem</code> , <code>DiskPressure</code>).</li></ul><h4 id=rolling-update-triggers>Rolling Update Triggers</h4><p>Apart from the above mentioned triggers, a rolling update of the shoot worker nodes is also triggered for some changes to your worker pool specification (<code>.spec.provider.workers[]</code>, even if you don&rsquo;t change the Kubernetes or machine image version).
The complete list of fields that trigger a rolling update:</p><ul><li><code>.spec.kubernetes.version</code> (except for patch version changes)</li><li><code>.spec.provider.workers[].machine.image.name</code></li><li><code>.spec.provider.workers[].machine.image.version</code></li><li><code>.spec.provider.workers[].machine.type</code></li><li><code>.spec.provider.workers[].volume.type</code></li><li><code>.spec.provider.workers[].volume.size</code></li><li><code>.spec.provider.workers[].providerConfig</code></li><li><code>.spec.provider.workers[].cri.name</code></li><li><code>.spec.provider.workers[].kubernetes.version</code> (except for patch version changes)</li></ul><p>Generally, the provider extension controllers might have additional constraints for changes leading to rolling updates, so please consult the respective documentation as well.</p><h2 id=related-documentation>Related Documentation</h2><ul><li><a href=/docs/gardener/usage/shoot_operations/>Shoot Operations</a></li><li><a href=/docs/gardener/usage/shoot_maintenance/>Shoot Maintenance</a></li><li><a href=/docs/gardener/usage/shoot_maintenance/#confine-specification-changesupdates-roll-out>Confine Specification Changes/Updates Roll Out To Maintenance Time Window</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-76b0c7e5bbbfbafbbf70acec450a467b>8.31 - Shoot Versions</h1><h1 id=shoot-kubernetes-and-operating-system-versioning-in-gardener>Shoot Kubernetes and Operating System Versioning in Gardener</h1><h2 id=motivation>Motivation</h2><p>On the one hand-side, Gardener is responsible for managing the Kubernetes and the Operating System (OS) versions of its Shoot clusters.
On the other hand-side, Gardener needs to be configured and updated based on the availability and support of the Kubernetes and Operating System version it provides.
For instance, the Kubernetes community releases <strong>minor</strong> versions roughly every three months and usually maintains <strong>three minor</strong> versions (the current and the last two) with bug fixes and security updates.
Patch releases are done more frequently.</p><p>When using the term <code>Machine image</code> in the following, we refer to the OS version that comes with the machine image of the node/worker pool of a Gardener Shoot cluster.
As such we are not referring to the <code>CloudProvider</code> specific machine image like the <a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html><code>AMI</code></a> for AWS.
For more information how Gardener maps machine image versions to <code>CloudProvider</code> specific machine images, take a look at the individual gardener extension providers
such as the <a href=/docs/extensions/infrastructure-extensions/gardener-extension-provider-aws/docs/usage-as-operator/>provider for AWS</a>.</p><p>Gardener should be configured accordingly to reflect the &ldquo;logical state&rdquo; of a version.
It should be possible to define the Kubernetes or Machine image versions that still receive bug fixes and security patches, and also vice-versa to define the version that are out-of-maintenance and are potentially vulnerable.
Moreover, this allows Gardener to &ldquo;understand&rdquo; the current state of a version and act upon it (more information in the following sections).</p><h2 id=overview>Overview</h2><p><strong>As a Gardener operator</strong>:</p><ul><li>I can classify a version based on it&rsquo;s logical state (<code>preview</code>, <code>supported</code>, <code>deprecated</code> and <code>expired</code> see <a href=#version-classifications>Version Classification</a>).</li><li>I can define which Machine image and Kubernetes versions are eligible for the auto update of clusters during the maintenance time.</li><li>I can disallow the creation of clusters having a certain version (think of severe security issues).</li></ul><p><strong>As an end-user/Shoot owner of Gardener</strong>:</p><ul><li>I can get information about which Kubernetes and Machine image versions exist and their classification.</li><li>I can determine the time when my Shoot clusters Machine image and Kubernetes version will be forcefully updated to the next patch or minor version (in case the cluster is running a deprecated version with an expiration date).</li><li>I can get this information via API from the <code>CloudProfile</code>.</li></ul><h2 id=version-classifications>Version Classifications</h2><p>Administrators can classify versions into four distinct &ldquo;logical states&rdquo;: <code>preview</code>, <code>supported</code>, <code>deprecated</code> and <code>expired</code>.
The version classification serves as a &ldquo;point-of-reference&rdquo; for end-users and also has implications during shoot creation and the maintenance time.</p><p>If a version is unclassified, Gardener cannot make those decision based on the &ldquo;logical state&rdquo;.
Nevertheless, Gardener can operate without version classifications and can be added at any time to the Kubernetes and machine image versions in the <code>CloudProfile</code>.</p><p>As a best practice, versions usually start with the classification <code>preview</code>, then are promoted to <code>supported</code>, eventually <code>deprecated</code> and finally <code>expired</code>.
This information is programmatically available in the <code>CloudProfiles</code> of the Garden cluster.</p><ul><li><p><strong>preview:</strong> A <code>preview</code> version is a new version that has not yet undergone thorough testing, possibly a new release, and needs time to be validated.
Due to its short early age, there is a higher probability of undiscovered issues and is therefore not yet recommended for production usage.
A Shoot does not update (neither <code>auto-update</code> or <code>force-update</code>) to a <code>preview</code> version during the maintenance time.
Also <code>preview</code> versions are not considered for the defaulting to the highest available version when deliberately omitting the patch version during Shoot creation.
Typically, after a fresh release of a new Kubernetes (e.g. v1.23.0) or Machine image version (e.g. coreos-2023.5), the operator tags it as <code>preview</code> until he has gained sufficient experience and regards this version to be reliable.
After the operator gained sufficient trust, the version can be manually promoted to <code>supported</code>.</p></li><li><p><strong>supported:</strong> A <code>supported</code> version is the recommended version for new and existing Shoot clusters. New Shoot clusters should use and existing clusters should update to this version.
Typically for Kubernetes versions, the latest Kubernetes patch versions of the actual (if not still in <code>preview</code>) and the last 3 minor Kubernetes versions are maintained by the community. An operator could define these versions as being <code>supported</code> (e.g. v1.22.1, v1.21.4, v1.20.9 and v1.19.12).</p></li><li><p><strong>deprecated:</strong> A <code>deprecated</code> version is a version that approaches the end of its lifecycle and can contain issues which are probably resolved in a supported version.
New Shoots should not use this version any more.
Existing Shoots will be updated to a newer version if <code>auto-update</code> is enabled (<code>.spec.maintenance.autoUpdate.kubernetesVersion</code> for Kubernetes version <code>auto-update</code>, or <code>.spec.maintenance.autoUpdate.machineImageVersion</code> for machine machine image version <code>auto-update</code>).
Using automatic upgrades, however, does not guarantee that a Shoot runs a non-deprecated version, as the latest version (overall or of the minor version) can be deprecated as well.
Deprecated versions <strong>should</strong> have an expiration date set for eventual expiration.</p></li><li><p><strong>expired:</strong> An <code>expired</code> versions has an expiration date (based on the <a href=https://golang.org/src/time/time.go>Golang time package</a>) in the past.
New clusters with that version cannot be created and existing clusters are forcefully migrated to a higher version during the maintenance time.</p></li></ul><p>Below is an example how the relevant section of the <code>CloudProfile</code> might look like:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: CloudProfile
metadata:
  name: alicloud
spec:
  kubernetes:
    versions:
      - classification: supported
        version: 1.17.1
      - classification: deprecated
        expirationDate: <span style=color:#a31515>&#34;2020-07-24T16:13:26Z&#34;</span>
        version: 1.17.0
      - classification: preview
        version: 1.16.6
      - classification: supported
        version: 1.16.5
      - classification: deprecated
        expirationDate: <span style=color:#a31515>&#34;2020-04-25T09:30:40Z&#34;</span>
        version: 1.16.4
      - classification: supported
        version: 1.15.7
      - classification: deprecated
        expirationDate: <span style=color:#a31515>&#34;2020-06-09T14:01:39Z&#34;</span>
        version: 1.15.6
</code></pre></div><h2 id=version-requirements-kubernetes-and-machine-image>Version Requirements (Kubernetes and Machine image)</h2><p>The Gardener API server enforces the following requirements for versions:</p><h3 id=deletion-of-a-version>Deletion of a version</h3><ul><li>A version that is in use by a Shoot cannot be deleted from the <code>CloudProfile</code>.</li></ul><h3 id=adding-a-version>Adding a version</h3><ul><li>A version must not have an expiration date in the past.</li><li>There can be only one <code>supported</code> version per minor version.</li><li>The latest Kubernetes version cannot have an expiration date.</li><li>The latest version for a machine image can have an expiration date. [*]</li></ul><p><sub>[*] Useful for cases in which support for given machine image needs to be deprecated and removed (for example the machine image reaches end of life).</sub></p><h2 id=forceful-migration-of-expired-versions>Forceful migration of expired versions</h2><p>If a Shoot is running a version after its expiration date has passed, it will be forcefully migrated during its maintenance time.
This happens <strong>even if the owner has opted out of automatic cluster updates!</strong></p><p>For <strong>Machine images</strong>, the Shoots worker pools will be updated to the latest <code>non-preview</code> version of the pools respective image.</p><p>For <strong>Kubernetes versions</strong>, the forceful update picks the latest <code>non-preview</code> patch version of the current minor version.</p><p>If the cluster is already on the latest patch version and the latest patch version is also expired,
it will continue with the latest patch version of the <strong>next consecutive minor Kubernetes version</strong>, so <strong>it will result in an
update of a minor Kubernetes version!</strong></p><p>Please note, that multiple consecutive minor version upgrades are possible.
This can occur if the Shoot is updated to a version that in turn is also <code>expired</code>.
In this case, the version is again upgraded in the <strong>next</strong> maintenance time.</p><p><strong>Depending on the circumstances described above, it can happen that the cluster receives multiple consecutive minor Kubernetes version updates!</strong></p><p>Kubernetes &ldquo;minor version jumps&rdquo; are not allowed - meaning to skip the update to the consecutive minor version and directly update to any version after that.
For instance, the version <code>1.10.x</code> can only update to a version <code>1.11.x</code>, not to <code>1.12.x</code> or any other version.
This is because Kubernetes does not guarantee upgradeability in this case, leading to possibly broken Shoot clusters.
The administrator has to set up the <code>CloudProfile</code> in such a way, that consecutive Kubernetes minor versions are available.
Otherwise, Shoot clusters will fail to upgrade during the maintenance time.</p><p>Consider the <code>CloudProfile</code> below with a Shoot using the Kubernetes version <code>1.10.12</code>.
Even though the version is <code>expired</code>, due to missing <code>1.11.x</code> versions, the Gardener Controller Manager cannot upgrade the Shoot&rsquo;s Kubernetes version.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  kubernetes:
    versions:
    - version: 1.12.8
    - version: 1.12.7
    - version: 1.10.12
      expirationDate: <span style=color:#a31515>&#34;&lt;expiration date in the past&gt;&#34;</span>
</code></pre></div><p>The <code>CloudProfile</code> must specify versions <code>1.11.x</code> of the <strong>consecutive</strong> minor version.
Configuring the <code>CloudProfile</code> in such a way, the Shoot&rsquo;s Kubernetes version will be upgraded to version <code>1.11.10</code> in the next maintenance time.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  kubernetes:
    versions:
    - version: 1.12.8
    - version: 1.11.10
    - version: 1.11.09
    - version: 1.10.12
      expirationDate: <span style=color:#a31515>&#34;&lt;expiration date in the past&gt;&#34;</span>
</code></pre></div><h2 id=related-documentation>Related Documentation</h2><p>You might want to read about the <a href=/docs/gardener/usage/shoot_updates/>Shoot Updates and Upgrades</a> procedures to get to know the effects of such operations.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cd0360e42e0991fd12773a6ac9995dbe>8.32 - Shooted See</h1><h1 id=create-shooted-seed-cluster>Create Shooted Seed Cluster</h1><p>Create managed seed (aka &ldquo;shooted seed&rdquo;) cluster with the <code>shoot.gardener.cloud/use-as-seed</code> annotation.</p><p><strong>Note:</strong> Starting with Gardener v1.18, the <code>shoot.gardener.cloud/use-as-seed</code> annotation is deprecated.
It still works as described here, however behind the scenes a <code>ManagedSeed</code> resource is created and reconciled.
It is strongly recommended to use such resources directly to register shoots as seeds, as described in <a href=/docs/gardener/usage/managed_seed/>Register Shoot as Seed</a>. For instructions how to migrate existing seeds managed via the <code>use-as-seed</code> annotation, see <a href=/docs/gardener/usage/managed_seed/#migrating-from-the-use-as-seed-annotation-to-managedseeds>Migrating from the <code>use-as-seed</code> Annotation to <code>ManagedSeeds</code></a>.</p><h2 id=procedure>Procedure</h2><ol><li><p>Add the following project labels to the <code>garden</code> namespace if they don&rsquo;t exist yet:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>labels:
  gardener.cloud/role: project
  project.gardener.cloud/name: garden
</code></pre></div></li><li><p>The annotation works only for shoot clusters created in the <code>garden</code> namespace. Create a project for the <code>garden</code> namespace using <code>kubectl</code> if you don&rsquo;t have one yet.</p><blockquote><p>⚠️<br>Don&rsquo;t use the Gardener Dashboard as it would add a <code>garden</code> prefix for the namespace.</p></blockquote><p>Example: <a href=https://github.com/gardener/gardener/blob/master/example/05-project-dev.yaml>/example/05-project-dev.yaml</a></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: core.gardener.cloud/v1beta1
kind: Project
metadata:
  name: garden
spec:
  owner:
...
  namespace: garden
</code></pre></div></li><li><p>Create the shoot cluster.</p><p>Set the following annotation on the <code>Shoot</code> to mark it as a shooted seed cluster.</p><p>Example (full example: <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml>/example/90-shoot.yaml</a>):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  annotations:
    shoot.gardener.cloud/use-as-seed: &gt;-<span style=color:#a31515>
</span><span style=color:#a31515>      </span>      <span style=color:#00f>true</span>,shootDefaults.pods=100.96.0.0/11,shootDefaults.services=100.64.0.0/13,disable-capacity-reservation,with-secret-ref
</code></pre></div><blockquote><ul><li>The networks from the seed cluster and its shoot clusters have to be different. To create shoot clusters with the dashboard you have to set a different worker CIDR in the shooted seed cluster (<code>spec.provider.infrastructureConfig</code> and <code>spec.networking.nodes</code>) and set the <code>shootDefaults</code> in the <code>shoot.gardener.cloud/use-as-seed</code> annotation to different CIDRs.</li><li>Optional: The shoot clusters to be created can use the same network as the garden cluster. To use the same network, set different CIDRs for pods and services in the shooted seed cluster (<code>spec.networking.pods</code> and <code>spec.networking.services</code>).</li></ul></blockquote></li></ol><h2 id=configuration-options-for-the-seed-cluster>Configuration Options for the Seed Cluster</h2><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>true</code></td><td>Registers the cluster as a seed cluster. Automatically deploys the gardenlet into the shoot cluster, unless specified otherwise (e.g. setting the <code>no-gardenlet</code> flag).</td></tr><tr><td><code>no-gardenlet</code></td><td>Prevents the automatic deployment of the gardenlet into the shoot cluster. Instead, the <code>Seed</code> object will be created with the assumption that another gardenlet will be responsible for managing it (according to its <code>seedConfig</code> configuration).</td></tr><tr><td><code>disable-capacity-reservation</code></td><td>Set <code>spec.settings.excessCapacity.enabled</code> in the seed cluster to false (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>invisible</code></td><td>Set <code>spec.settings.scheduling.visible</code> in the seed cluster to false (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>)</td></tr><tr><td><code>visible</code></td><td>Set <code>spec.settings.scheduling.visible</code> in the seed cluster to true (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>) (<strong>default</strong>).</td></tr><tr><td><code>disable-dns</code></td><td>Set <code>spec.settings.shootDNS.enabled</code> in the seed cluster to false (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>protected</code></td><td>Only shoot clusters in the <code>garden</code> namespace can use this seed cluster.</td></tr><tr><td><code>unprotected</code></td><td>Shoot clusters from all namespaces can use this seed cluster (<strong>default</strong>).</td></tr><tr><td><code>loadBalancerServices.annotations.*</code></td><td>Set <code>spec.settings.loadBalancerServices.annotations</code> in the seed cluster (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>), e.g <code>loadBalancerServices.annotations.service.beta.kubernetes.io/aws-load-balancer-type=nlb</code>.</td></tr><tr><td><code>with-secret-ref</code></td><td>Creates a secret with the <code>kubeconfig</code> of the cluster in the <code>garden</code> namespace in the garden cluster and specifies the <code>.spec.secretRef</code> in the <code>Seed</code> object accordingly.</td></tr><tr><td><code>shootDefaults.pods</code></td><td>Default pod network CIDR for shoot clusters created on this seed cluster.</td></tr><tr><td><code>shootDefaults.services</code></td><td>Default service network CIDR for shoot clusters created on this seed cluster.</td></tr><tr><td><code>minimumVolumeSize</code></td><td>Set <code>spec.volume.minimumSize</code> in the seed cluster (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>blockCIDRs</code></td><td>Set <code>spec.network.blockCIDRs</code> seperated by <code>;</code> (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>backup.provider</code></td><td>Set <code>spec.backup.provider</code> in the seed cluster (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>backup.region</code></td><td>Set <code>spec.backup.region</code> in the seed cluster (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>backup.secretRef.name</code></td><td>Set <code>spec.backup.secretRef.name</code> in the seed cluster (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>backup.secretRef.namespace</code></td><td>Set <code>spec.backup.secretRef.namespace</code> in the seed cluster (see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>/example/50-seed.yaml</a>).</td></tr><tr><td><code>apiServer.autoscaler.minReplicas</code></td><td>Controls the minimum number of <code>kube-apiserver</code> replicas for the shooted seed cluster.</td></tr><tr><td><code>apiServer.autoscaler.maxReplicas</code></td><td>Controls the maximum number of <code>kube-apiserver</code> replicas for the shooted seed cluster.</td></tr><tr><td><code>apiServer.replicas</code></td><td>Controls how many <code>kube-apiserver</code> replicas the shooted seed cluster gets by default.</td></tr><tr><td><code>use-serviceaccount-bootstrapping</code></td><td>States that the gardenlet registers with the garden cluster using a temporary <code>ServiceAccount</code> instead of a <code>CertificateSigningRequest</code> (<strong>default</strong>)</td></tr><tr><td><code>providerConfig.*</code></td><td>Sets <code>providerConfig</code> configuration parameters of the Seed resource. Each parameter is specified via its path, e.g. <code>providerConfig.param1=foo</code> or <code>providerConfig.sublevel1.sublevel2.param3=bar</code></td></tr><tr><td><code>featureGates.*={true,false}</code></td><td>Overwrites the <code>.featureGates</code> in the gardenlet configuration (only applicable when the <code>no-gardenlet</code> setting is <strong>not</strong> set), e.g. <code>featureGates.APIServerSNI=true</code></td></tr><tr><td><code>resources.capacity.*</code></td><td>Overwrites the <code>resources.capacity</code> field in the gardenlet configuration (only applicable when the <code>no-gardenlet</code> setting is <strong>not</strong> set), e.g. <code>resources.capacity.shoots=250</code></td></tr><tr><td><code>resources.reserved.*</code></td><td>Overwrites the <code>resources.reserved</code> field in the gardenlet configuration (only applicable when the <code>no-gardenlet</code> setting is <strong>not</strong> set), e.g. <code>resources.reserved.foo=42</code></td></tr><tr><td><code>ingress.controller.kind</code></td><td>Activates and specifies the kind of the managed ingress controller in the seed</td></tr><tr><td><code>ingress.controller.providerConfig.*</code></td><td>Sets provider specific configuration parameters for the managed ingress controller. Each parameter is specified via its path, e.g. <code>ingress.controller.providerConfig.param1=foo</code> or <code>ingress.controller.providerConfig.sublevel1.sublevel2.param3=bar</code></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ba6ea030a94e576907f8029c24109302>8.33 - Supported K8s Versions</h1><h1 id=supported-kubernetes-versions>Supported Kubernetes Versions</h1><p>Currently, the Gardener supports the following Kubernetes versions:</p><h2 id=garden-cluster-version>Garden cluster version</h2><p>⚠️ The minimum version of the garden cluster that can be used to run Gardener is <strong><code>1.17.x</code></strong>.</p><h2 id=seed-cluster-versions>Seed cluster versions</h2><p>⚠️ The minimum version of a seed cluster that can be connected to Gardener is <strong><code>1.18.x</code></strong>.
Kubernetes <code>1.18</code> sets the common ground for several Gardener features, e.g. <code>SeedKubeScheduler</code> (<a href=/docs/gardener/deployment/feature_gates/#list-of-feature-gates>ref</a>).
It also enables the Gardener code base to leverage more advanced Kubernetes features, like <a href=https://kubernetes.io/docs/reference/using-api/server-side-apply/>Server-Side Apply</a>, in the future.</p><h2 id=shoot-cluster-versions>Shoot cluster versions</h2><p>Gardener itself is capable of spinning up clusters with Kubernetes versions <strong><code>1.17</code></strong> up to <strong><code>1.23</code></strong>.
However, the concrete versions that can be used for shoot clusters depend on the installed provider extension.
Consequently, please consult the documentation of your provider extension to see which Kubernetes versions are supported for shoot clusters.</p><blockquote><p>👨🏼‍💻 Developers note: <a href=/docs/gardener/development/new-kubernetes-version/>This document</a> explains what needs to be done in order to add support for a new Kubernetes version.</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-f92740830de9285764daf47f392d76d6>8.34 - Tolerations</h1><h1 id=taints-and-tolerations-for-seeds-and-shoots>Taints and Tolerations for <code>Seed</code>s and <code>Shoot</code>s</h1><p>Similar to <a href=https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/>taints and tolerations</a> for <code>Node</code>s and <code>Pod</code>s in Kubernetes, the <code>Seed</code> resource supports specifying taints (<code>.spec.taints</code>, see <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml#L48-L55>this example</a>) while the <code>Shoot</code> resource supports specifying tolerations (<code>.spec.tolerations</code>, see <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L268-L269>this example</a>).
The feature is used to control scheduling to seeds as well as decisions whether a shoot can use a certain seed.</p><p>Compared to Kubernetes, Gardener&rsquo;s taints and tolerations are very much down-stripped right now and have some behavioral differences.
Please read the following explanations carefully if you plan to use it.</p><h2 id=scheduling>Scheduling</h2><p>When scheduling a new shoot then the gardener-scheduler will filter all seed candidates whose taints are not tolerated by the shoot.
As Gardener&rsquo;s taints/tolerations don&rsquo;t support <code>effect</code>s yet you can compare this behaviour with using a <code>NoSchedule</code> effect taint in Kubernetes.</p><p>Be reminded that taints/tolerations are no means to define any affinity or selection for seeds - please use <code>.spec.seedSelector</code> in the <code>Shoot</code> to state such desires.</p><p>⚠️ Please note that - unlike how it&rsquo;s implemented in Kubernetes - a certain seed cluster <strong>may</strong> only be used when the shoot tolerates <strong>all</strong> the seed&rsquo;s taints.
This means that specifying <code>.spec.seedName</code> for a seed whose taints are not tolerated will make the gardener-apiserver rejecting the request.</p><p>Consequently, the taints/tolerations feature can be used as means to restrict usage of certain seeds.</p><h2 id=toleration-defaults-and-whitelist>Toleration Defaults and Whitelist</h2><p>The <code>Project</code> resource features a <code>.spec.tolerations</code> object that may carry <code>defaults</code> and a <code>whitelist</code> (see <a href=https://github.com/gardener/gardener/blob/master/example/05-project-dev.yaml#L33-L37>this example</a>).
The corresponding <code>ShootTolerationRestriction</code> admission plugin (cf. Kubernetes' <code>PodTolerationRestriction</code> admission plugin) is responsible for evaluating these settings during creation/update of <code>Shoot</code>s.</p><h3 id=whitelist>Whitelist</h3><p>If a shoot gets created or updated with tolerations then it is validated that only those tolerations may be used which were added to either a) the <code>Project</code>&rsquo;s <code>.spec.tolerations.whitelist</code>, or b) to the global whitelist in the <code>ShootTolerationRestriction</code>&rsquo;s admission config (see <a href=https://github.com/gardener/gardener/blob/master/example/20-admissionconfig.yaml#L7-L14>this example</a>).</p><p>⚠️ Please note that the tolerations whitelist of <code>Project</code>s can only be changed if the user trying to change it is bound to the <code>modify-spec-tolerations-whitelist</code> custom RBAC role, e.g. via the following <code>ClusterRole</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: full-project-modification-access
rules:
- apiGroups:
  - core.gardener.cloud
  resources:
  - projects
  verbs:
  - create
  - patch
  - update
  - modify-spec-tolerations-whitelist
  - delete
</code></pre></div><h3 id=defaults>Defaults</h3><p>If a shoot gets created then the default tolerations specified in both the <code>Project</code>&rsquo;s <code>.spec.tolerations.defaults</code> and global default list in the <code>ShootTolerationRestriction</code> admission plugin&rsquo;s configuration will be added to the <code>.spec.tolerations</code> of the <code>Shoot</code> (unless it already specifies a certain key).</p></div><div class=td-content style=page-break-before:always><h1 id=pg-717af96646de8dc0584626ea13c573c8>8.35 - Trouble Shooting Guide</h1><h1 id=trouble-shooting-guide>Trouble Shooting Guide</h1><h2 id=are-there-really-issue-that-cannot-be-fixed-o>Are there really issue that cannot be fixed :O?</h2><p>Well, of course not :P. With continuous development of Gardener, over the time its architecture and API might have to be changed to reduce complexity and support more features. In this process developers are bound to keep Gardener version backward compatible with last two releases. But maintaining backward compatibility is quite complex and effortful tasks. So, to save short term complex effort, its common practice in open source community to use work around or hacky solutions sometimes. This results in rare issues which are supposed to be resolved by human interaction across upgrades of Gardener version.</p><p>This guide records the issues that are quite possible across upgrade of Gardener version, root cause and the human action required for graceful resolution of issue. For troubleshooting guide of bugs which are not yet fixed, please refer the associated github issue.</p><p><strong>Note To Maintainers:</strong> Please use only mention the resolution of issues which are by design. For bugs please report the temporary resolution on github issue create for the bug.</p><h3 id=etcd-main-pod-fails-to-come-up-since-backup-restore-sidecar-is-reporting-revisionconsistencycheckerr>Etcd-Main pod fails to come up, since backup-restore sidecar is reporting RevisionConsistencyCheckErr</h3><h4 id=issue>Issue</h4><ul><li>Etcd-main pod goes in <code>CrashLoopBackoff</code>.</li><li>Etcd-backup-restore sidecar reports validation error with RevisionConsistencyCheckErr.</li></ul><h4 id=environment>Environment</h4><ul><li>Gardener version: 0.29.0+</li></ul><h4 id=root-cause>Root Cause</h4><ul><li>From version 0.29.0, Gardener uses shared backup bucket for storing etcd backups, replacing old logic of having single bucket per shoot as per <a href=/docs/gardener/proposals/02-backupinfra/>proposal</a>.</li><li>Since there are very rare chances that etcd data directory will get corrupt, while doing this migration, to avoid etcd down time and implementation effort, we decided to switch directly from old bucket to new shared bucket without migrating old snapshot from old bucket to new bucket.</li><li>In this case just for safety side we added sanity check in etcd-backup-restore sidecar of etcd-main pod, which checks if etcd data revision is greater than the last snapshot revision from old bucket.</li><li>If above check fails mean there is surely some data corruption occurred with etcd, so etcd-backup-restore reports error and then etcd-main pod goes in <code>CrashLoopBackoff</code> creating etcd-main down alerts.</li></ul><h4 id=action>Action</h4><ol><li>Disable the Gardener reconciliation for Shoot by annotating it with <code>shoot.gardener.cloud/ignore=true</code></li><li>Scale down the etcd-main statefulset in seed cluster.</li><li>Find out the latest full snapshot and delta snapshot from old backup bucket. The old backup bucket name is same as the backupInfra resource associated with Shoot in Garden cluster.</li><li>Move them manually to new backup bucket.</li><li>Enable the Gardener reconciliation for shoot by removing annotation <code>shoot.gardener.cloud/ignore=true</code>.</li></ol><h3 id=after-upgradingrestarting-a-local-gardener-setup-the-dnsentries-on-the-seeds-show-the-error--already-busy-for-owner->After upgrading/restarting a local Gardener setup, the DNSEntries on the seeds show the error &ldquo;&mldr; already busy for owner &mldr;&rdquo;</h3><h4 id=issue-1>Issue</h4><ul><li>custom resources DNSEntries on the seeds show the error &ldquo;dns name &ldquo;api.myshoot.mygarden.internal.dev.k8s.ondemand.com&rdquo; already busy for owner &ldquo;seed.gardener.cloud/a1234567-XXXX-XXXX-XXXX-025000000001/aws&rdquo;</li><li>API server is not available via DNS name</li></ul><h4 id=environment-1>Environment</h4><ul><li>Gardener version: 0.20.0+</li></ul><h4 id=root-cause-1>Root Cause</h4><p>DNS records created by Gardener&rsquo;s dns-controller-manager are stored together with meta data, especially
with an owner identifier. In this way the dns-controller-manager knows which records belong to it.
It never changes records which are not owned by it.
The owner identifier is unique for every seed and computed from the Gardener identity and the seed identity.
The Gardener identity is the UUID of the garden namespace of the Gardener cluster.
Especially if you have a local Gardener setup, there are situations where the Kubernetes cluster and therefore the garden namespace have to be recreated.
For example, on updating docker-desktop all containers may have been deleted and are recreated.</p><h4 id=action-1>Action</h4><p>On each seed, you have to tell the dns-controller-manager, that it is also responsible for secondary owner
identifiers. For this purpose create a custom resource <code>DNSOwner</code> and set the attribute <code>ownerId</code> to the old
owner identifier shown in the error message of the DNS entries, e.g.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: dns.gardener.cloud/v1alpha1
kind: DNSOwner
metadata:
  name: old-owner
  namespace: default
spec:
  ownerId: seed.gardener.cloud/a1234567-XXXX-XXXX-XXXX-025000000001/aws
  active: <span style=color:#00f>true</span>
</code></pre></div><p>Currently the dns-controller-manager has to be restarted (i.e. delete its current pod) to make it known of
the secondary owner identifier.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cf607bc71a1ae64925c002dc4829df51>8.36 - Trusted Tls For Control Planes</h1><h1 id=trusted-tls-certificate-for-shoot-control-planes>Trusted TLS certificate for shoot control planes</h1><p>Shoot clusters are composed of several control plane components deployed by the Gardener and corresponding extensions.</p><p>Some components are exposed via <code>Ingress</code> resources which make them addressable under the HTTPS protocol.</p><p>Examples:</p><ul><li>Alertmanager</li><li>Grafana for operators and end-users</li><li>Prometheus</li></ul><p>Gardener generates the backing TLS certificates which are signed by the shoot cluster&rsquo;s CA by default (self-signed).</p><p>Unlike with a self-contained Kubeconfig file, common internet browsers or operating systems don&rsquo;t trust a shoot&rsquo;s cluster CA and adding it as a trusted root is often undesired in enterprise environments.</p><p>Therefore, Gardener operators can predefine trusted wildcard certificates under which the mentioned endpoints will be served instead.</p><h2 id=register-a-trusted-wildcard-certificate>Register a trusted wildcard certificate</h2><p>Since control plane components are published under the ingress domain (<code>core.gardener.cloud/v1beta1.Seed.spec.dns.ingressDomain</code>) a wildcard certificate is required.</p><p>For example:</p><ul><li>Seed ingress domain: <code>dev.my-seed.example.com</code></li><li><code>CN</code> or <code>SAN</code> for certificate: <code>*.dev.my-seed.example.com</code></li></ul><p>A wildcard certificate matches exactly one seed. It must be deployed as part of your landscape setup as a Kubernetes <code>Secret</code> inside the <code>garden</code> namespace of the corresponding seed cluster.</p><p>Please ensure that the secret has the <code>gardener.cloud/role</code> label shown below.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
data:
  ca.crt: base64-encoded-ca.crt
  tls.crt: base64-encoded-tls.crt
  tls.key: base64-encoded-tls.key
kind: Secret
metadata:
  labels:
    gardener.cloud/role: controlplane-cert
  name: seed-ingress-certificate
  namespace: garden
type: Opaque
</code></pre></div><p>Gardener copies the secret during the reconciliation of shoot clusters to the shoot namespace in the seed. Afterwards, <code>Ingress</code> resources in that namespace for the mentioned components will refer to the wildcard certificate.</p><h2 id=best-practice>Best practice</h2><p>While it is possible to create the wildcard certificates manually and deploy them to seed clusters, it is recommended to let certificate management components do this job. Often, a seed cluster is also a shoot cluster at the same time (shooted seed) and might already provide a certificate service extension.
Otherwise, a Gardener operator may use solutions like <a href=https://github.com/gardener/cert-management>Cert-Management</a> or <a href=https://github.com/jetstack/cert-manager>Cert-Manager</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2a827ed3506304fa29f2a71110704fb0>8.37 - Worker Pool K8s Versions</h1><h1 id=controlling-the-kubernetes-versions-for-specific-worker-pools>Controlling the Kubernetes versions for specific worker pools</h1><p>Since Gardener <code>v1.36</code>, worker pools can have different Kubernetes versions specified than the control plane.</p><p>It must be enabled by setting the featureGate <code>WorkerPoolKubernetesVersion: true</code> in the gardenlet&rsquo;s component configuration.</p><p>In earlier Gardener versions all worker pools inherited the Kubernetes version of the control plane. Once the Kubernetes version of the control plane was modified, all worker pools have been updated as well (either by rolling the nodes in case of a minor version change, or in-place for patch version changes).</p><p>In order to gracefully perform Kubernetes upgrades (triggering a rolling update of the nodes) with workloads sensitive to restarts (e.g., those dealing with lots of data), it might be required to be able to gradually perform the upgrade process.
In such cases, the Kubernetes version for the worker pools can be pinned (<code>.spec.provider.workers[].kubernetes.version</code>) while the control plane Kubernetes version (<code>.spec.kubernetes.version</code>) is updated.
This results in the nodes being untouched while the control plane is upgraded.
Now a new worker pool (with the version equal to the control plane version) can be added.
Administrators can then reschedule their workloads to the new worekr pool according to their upgrade requirements and processes.</p><h2 id=example-usage-in-a-shoot>Example Usage in a <code>Shoot</code></h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  kubernetes:
    version: 1.20.1
  provider:
    workers:
    - name: data1
      kubernetes:
        version: 1.19.1
    - name: data2
</code></pre></div><ul><li>If <code>.kubernetes.version</code> is not specified in a worker pool then the Kubernetes version of the kubelet is inherited from the control plane (<code>.spec.kubernetes.version</code>), i.e., in above example the <code>data2</code> pool will use <code>1.20.1</code>.</li><li>If <code>.kubernetes.version</code> is specified in a worker pool then it must meet the following constraints:<ul><li>It must be at most two minor versions lower than the control plane version.</li><li>If it was not specified before then no downgrade is possible (you cannot set it to <code>1.19.1</code> while <code>.spec.kubernetes.version</code> is already <code>1.20.1</code>). The &ldquo;two minor version skew&rdquo; is only possible if the worker pool version is set to control plane version and then the control plane was updated gradually two minor versions.</li><li>If the version is removed from the worker pool, only one minor version difference is allowed to the control plane (you cannot upgrade a pool from version <code>1.18.0</code> to <code>1.20.0</code> in one go).</li></ul></li></ul><p>Automatic updates of Kubernetes versions (see <a href=/docs/gardener/usage/shoot_maintenance/#automatic-version-updates>this document</a>) also apply to worker pool Kubernetes versions.</p></div></main></div></div><footer class="footer row d-print-none"><div class="container-fluid footer-wrapper"><ul class=nav><li><a href=https://gardener.cloud/blog/>Blogs</a></li><li><a href=https://gardener.cloud/community/>Community</a></li><li><a href=https://gardener.cloud/adopter/>Adopters</a></li><li><a href=/docs/>Documentation</a></li></ul><img src=/images/lp/gardener-logo.svg alt="Logo Gardener" class=logo><ul class=media-wr><li><a target=_blank href=https://kubernetes.slack.com/archives/CB57N0BFG><img src=/images/branding/slack-logo-white.svg class=media-icon><div class=media-text>Slack</div></a></li><li><a target=_blank href=https://github.com/gardener><img src=/images/branding/github-mark-logo.png class=media-icon><div class=media-text>GitHub</div></a></li><li><a target=_blank href=https://www.youtube.com/channel/UCwUhwKFREV8Su0gwAJQX7tw><img src=/images/branding/youtube-logo-dark.svg class=media-icon><div class=media-text>YouTube</div></a></li><li><a target=_blank href=https://twitter.com/GardenerProject><img src=/images/branding/twitter-logo-white.svg class=media-icon><div class=media-text>Twitter</div></a></li></ul><span class=copyright>Copyright 2019-2022 Gardener project authors. <a href=https://www.sap.com/corporate/en/legal/privacy.html>Privacy policy
<i class="fa fa-external-link" aria-hidden=true></i></a></span></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity=sha384-uQikAXnCAqsMb3ygtdqBYvcwvHUkzGIpjdGyy9owhURXHUxLC5LgTcSxJQH/RzjK crossorigin=anonymous></script><script src=/js/main.min.ef8e0714aff556fd5a9768ed6ecabd2964dd962cd9f89762a373947bb53bc742.js integrity="sha256-744HFK/1Vv1al2jtbsq9KWTdlizZ+Jdio3OUe7U7x0I=" crossorigin=anonymous></script></body></html>