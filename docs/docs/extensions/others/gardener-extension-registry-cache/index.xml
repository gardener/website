<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener – Registry cache</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/</link><description>Recent content in Registry cache on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Configuring the Registry Cache Extension</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/configuration/</guid><description>
&lt;h1 id="configuring-the-registry-cache-extension">Configuring the Registry Cache Extension&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;h3 id="use-case">Use Case&lt;/h3>
&lt;p>For a Shoot cluster, the containerd daemon of every Node goes to the internet and fetches an image that it doesn&amp;rsquo;t have locally in the Node&amp;rsquo;s image cache. New Nodes are often created due to events such as auto-scaling (scale up), rolling update, or replacement of unhealthy Node. Such a new Node would need to pull all of the images of the Pods running on it from the internet because the Node&amp;rsquo;s cache is initially empty. Pulling an image from a registry produces network traffic and registry costs. To avoid these network traffic and registry costs, you can use the registry-cache extension to run a registry as pull-through cache.&lt;/p>
&lt;p>The following diagram shows a rough outline of how an image pull looks like for a Shoot cluster &lt;strong>without registry cache&lt;/strong>:
&lt;img src="https://gardener.cloud/__resources/shoot-cluster-without-registry-cache_e266ba.png" alt="shoot-cluster-without-registry-cache">&lt;/p>
&lt;h3 id="solution">Solution&lt;/h3>
&lt;p>The registry-cache extension deploys and manages a registry in the Shoot cluster that runs as pull-through cache. The used registry implementation is &lt;a href="https://github.com/distribution/distribution">distribution/distribution&lt;/a>.&lt;/p>
&lt;h3 id="how-does-it-work">How does it work?&lt;/h3>
&lt;p>When the extension is enabled, a registry cache for each configured upstream is deployed to the Shoot cluster. Along with this, the containerd daemon on the Shoot cluster Nodes gets configured to use as a mirror the Service IP address of the deployed registry cache. For example, if a registry cache for upstream &lt;code>docker.io&lt;/code> is requested via the Shoot spec, then containerd gets configured to first pull the image from the deployed cache in the Shoot cluster. If this image pull operation fails, containerd falls back to the upstream itself (&lt;code>docker.io&lt;/code> in that case).&lt;/p>
&lt;p>The first time an image is requested from the pull-through cache, it pulls the image from the configured upstream registry and stores it locally, before handing it back to the client. On subsequent requests, the pull-through cache is able to serve the image from its own storage.&lt;/p>
&lt;blockquote>
&lt;p>Note: The used registry implementation (&lt;a href="https://github.com/distribution/distribution">distribution/distribution&lt;/a>) supports mirroring of only one upstream registry.&lt;/p>
&lt;/blockquote>
&lt;p>The following diagram shows a rough outline of how an image pull looks like for a Shoot cluster &lt;strong>with registry cache&lt;/strong>:
&lt;img src="https://gardener.cloud/__resources/shoot-cluster-with-registry-cache_9e6b5f.png" alt="shoot-cluster-with-registry-cache">&lt;/p>
&lt;h2 id="shoot-configuration">Shoot Configuration&lt;/h2>
&lt;p>The extension is not globally enabled and must be configured per Shoot cluster. The Shoot specification has to be adapted to include the &lt;code>registry-cache&lt;/code> extension configuration.&lt;/p>
&lt;p>Below is an example of &lt;code>registry-cache&lt;/code> extension configuration as part of the Shoot spec:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: crazy-botany
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: registry-cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: registry.extensions.gardener.cloud/v1alpha3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: RegistryConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> caches:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: 100Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># storageClassName: premium&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: ghcr.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: quay.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> garbageCollection:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ttl: 0s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretReferenceName: quay-credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: my-registry.io:5000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remoteURL: http://my-registry.io:5000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: quay-credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: quay-credentials-v1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>providerConfig&lt;/code> field is required.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches&lt;/code> field contains information about the registry caches to deploy. It is a required field. At least one cache has to be specified.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].upstream&lt;/code> field is the remote registry host to cache. It is a required field.
The value must be a valid DNS subdomain (RFC 1123) and optionally a port (i.e. &lt;code>&amp;lt;host&amp;gt;[:&amp;lt;port&amp;gt;]&lt;/code>). It must not include a scheme.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].remoteURL&lt;/code> optional field is the remote registry URL. If configured, it must include an &lt;code>https://&lt;/code> or &lt;code>http://&lt;/code> scheme.
If the field is not configured, the remote registry URL defaults to &lt;code>https://&amp;lt;upstream&amp;gt;&lt;/code>. In case the upstream is &lt;code>docker.io&lt;/code>, it defaults to &lt;code>https://registry-1.docker.io&lt;/code>.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].volume&lt;/code> field contains settings for the registry cache volume.
The registry-cache extension deploys a StatefulSet with a volume claim template. A PersistentVolumeClaim is created with the configured size and StorageClass name.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].volume.size&lt;/code> field is the size of the registry cache volume. Defaults to &lt;code>10Gi&lt;/code>. The size must be a positive quantity (greater than 0).
This field is immutable. See &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/configuration/#increase-the-cache-disk-size">Increase the cache disk size&lt;/a> on how to resize the disk.
The extension defines &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/v0.10.0/pkg/component/registrycaches/monitoring.go#L40-L105">alerts&lt;/a> for the volume. See &lt;a href="https://gardener.cloud/docs/gardener/monitoring/alerting/#alerting-for-users">Alerting for Users&lt;/a> on how to enable notifications for Shoot cluster alerts.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].volume.storageClassName&lt;/code> field is the name of the StorageClass used by the registry cache volume.
This field is immutable. If the field is not specified, then the &lt;a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#default-storageclass">default StorageClass&lt;/a> will be used.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].garbageCollection.ttl&lt;/code> field is the time to live of a blob in the cache. If the field is set to &lt;code>0s&lt;/code>, the garbage collection is disabled. Defaults to &lt;code>168h&lt;/code> (7 days). See the &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/configuration/#garbage-collection">Garbage Collection section&lt;/a> for more details.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].secretReferenceName&lt;/code> is the name of the reference for the Secret containing the upstream registry credentials. To cache images from a private registry, credentials to the upstream registry should be supplied. For more details, see &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/upstream-credentials/#how-to-provide-credentials-for-upstream-registry">How to provide credentials for upstream registry&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: It is only possible to provide one set of credentials for one private upstream registry.&lt;/p>
&lt;/blockquote>
&lt;h2 id="garbage-collection">Garbage Collection&lt;/h2>
&lt;p>When the registry cache receives a request for an image that is not present in its local store, it fetches the image from the upstream, returns it to the client and stores the image in the local store. The registry cache runs a scheduler that deletes images when their time to live (ttl) expires. When adding an image to the local store, the registry cache also adds a time to live for the image. The ttl defaults to &lt;code>168h&lt;/code> (7 days) and is configurable. The garbage collection can be disabled by setting the ttl to &lt;code>0s&lt;/code>. Requesting an image from the registry cache does not extend the time to live of the image. Hence, an image is always garbage collected from the registry cache store when its ttl expires.
At the time of writing this document, there is no functionality for garbage collection based on disk size - e.g., garbage collecting images when a certain disk usage threshold is passed.
The garbage collection cannot be enabled once it is disabled. This constraint is added to mitigate &lt;a href="https://github.com/distribution/distribution/issues/4249">distribution/distribution#4249&lt;/a>.&lt;/p>
&lt;h2 id="increase-the-cache-disk-size">Increase the Cache Disk Size&lt;/h2>
&lt;p>When there is no available disk space, the registry cache continues to respond to requests. However, it cannot store the remotely fetched images locally because it has no free disk space. In such case, it is simply acting as a proxy without being able to cache the images in its local store. The disk has to be resized to ensure that the registry cache continues to cache images.&lt;/p>
&lt;p>There are two alternatives to enlarge the cache&amp;rsquo;s disk size:&lt;/p>
&lt;h3 id="alternative-1-resize-the-pvc">[Alternative 1] Resize the PVC&lt;/h3>
&lt;p>To enlarge the PVC&amp;rsquo;s size, perform the following steps:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Make sure that the &lt;code>KUBECONFIG&lt;/code> environment variable is targeting the correct Shoot cluster.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Find the PVC name to resize for the desired upstream. The below example fetches the PVC for the &lt;code>docker.io&lt;/code> upstream:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl -n kube-system get pvc -l upstream-host=docker.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Patch the PVC&amp;rsquo;s size to the desired size. The below example patches the size of a PVC to &lt;code>10Gi&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl -n kube-system patch pvc $PVC_NAME --type merge -p &lt;span style="color:#a31515">&amp;#39;{&amp;#34;spec&amp;#34;:{&amp;#34;resources&amp;#34;:{&amp;#34;requests&amp;#34;: {&amp;#34;storage&amp;#34;: &amp;#34;10Gi&amp;#34;}}}}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Make sure that the PVC gets resized. Describe the PVC to check the resize operation result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl -n kube-system describe pvc -l upstream-host=docker.io
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Drawback of this approach: The cache&amp;rsquo;s size in the Shoot spec (&lt;code>providerConfig.caches[].size&lt;/code>) diverges from the PVC&amp;rsquo;s size.&lt;/p>
&lt;/blockquote>
&lt;h3 id="alternative-2-remove-and-readd-the-cache">[Alternative 2] Remove and Readd the Cache&lt;/h3>
&lt;p>There is always the option to remove the cache from the Shoot spec and to readd it again with the updated size.&lt;/p>
&lt;blockquote>
&lt;p>Drawback of this approach: The already cached images get lost and the cache starts with an empty disk.&lt;/p>
&lt;/blockquote>
&lt;h2 id="high-аvailability">High Аvailability&lt;/h2>
&lt;p>The registry cache runs with a single replica. This fact may lead to concerns for the high availability such as &amp;ldquo;What happens when the registry cache is down? Does containerd fail to pull the image?&amp;rdquo;. As outlined in the &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/configuration/#how-does-it-work">How does it work? section&lt;/a>, containerd is configured to fall back to the upstream registry if it fails to pull the image from the registry cache. Hence, when the registry cache is unavailable, the containerd&amp;rsquo;s image pull operations are not affected because containerd falls back to image pull from the upstream registry.&lt;/p>
&lt;h2 id="possible-pitfalls">Possible Pitfalls&lt;/h2>
&lt;ul>
&lt;li>The used registry implementation (the &lt;a href="https://github.com/distribution/distribution">Distribution project&lt;/a>) supports mirroring of only one upstream registry. The extension deploys a pull-through cache for each configured upstream.&lt;/li>
&lt;li>&lt;code>us-docker.pkg.dev&lt;/code>, &lt;code>europe-docker.pkg.dev&lt;/code>, and &lt;code>asia-docker.pkg.dev&lt;/code> are different upstreams. Hence, configuring &lt;code>pkg.dev&lt;/code> as upstream won&amp;rsquo;t cache images from &lt;code>us-docker.pkg.dev&lt;/code>, &lt;code>europe-docker.pkg.dev&lt;/code>, or &lt;code>asia-docker.pkg.dev&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="limitations">Limitations&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Images that are pulled before a registry cache Pod is running or before a registry cache Service is reachable from the corresponding Node won&amp;rsquo;t be cached - containerd will pull these images directly from the upstream.&lt;/p>
&lt;p>The reasoning behind this limitation is that a registry cache Pod is running in the Shoot cluster. To have a registry cache&amp;rsquo;s Service cluster IP reachable from containerd running on the Node, the registry cache Pod has to be running and kube-proxy has to configure iptables/IPVS rules for the registry cache Service. If kube-proxy hasn&amp;rsquo;t configured iptables/IPVS rules for the registry cache Service, then the image pull times (and new Node bootstrap times) will be increased significantly. For more detailed explanations, see point 2. and &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/pull/68">gardener/gardener-extension-registry-cache#68&lt;/a>.&lt;/p>
&lt;p>That&amp;rsquo;s why the registry configuration on a Node is applied only after the registry cache Service is reachable from the Node. The &lt;code>gardener-node-agent.service&lt;/code> systemd unit sends requests to the registry cache&amp;rsquo;s Service. Once the registry cache responds with &lt;code>HTTP 200&lt;/code>, the unit creates the needed registry configuration file (&lt;code>hosts.toml&lt;/code>).&lt;/p>
&lt;p>As a result, for images from Shoot system components:&lt;/p>
&lt;ul>
&lt;li>On Shoot creation with the registry cache extension enabled, a registry cache is unable to cache all of the images from the Shoot system components. Usually, until the registry cache Pod is running, containerd pulls from upstream the images from Shoot system components (before the registry configuration gets applied).&lt;/li>
&lt;li>On new Node creation for existing Shoot with the registry cache extension enabled, a registry cache is unable to cache most of the images from Shoot system components. The reachability of the registry cache Service requires the Service network to be set up, i.e., the kube-proxy for that new Node to be running and to have set up iptables/IPVS configuration for the registry cache Service.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>containerd requests will time out in 30s in case kube-proxy hasn&amp;rsquo;t configured iptables/IPVS rules for the registry cache Service - the image pull times will increase significantly.&lt;/p>
&lt;p>containerd is configured to fall back to the upstream itself if a request against the cache fails. However, if the cluster IP of the registry cache Service does not exist or if kube-proxy hasn&amp;rsquo;t configured iptables/IPVS rules for the registry cache Service, then containerd requests against the registry cache time out in 30 seconds. This significantly increases the image pull times because containerd does multiple requests as part of the image pull (HEAD request to resolve the manifest by tag, GET request for the manifest by SHA, GET requests for blobs)&lt;/p>
&lt;p>Example: If the Service of a registry cache is deleted, then a new Service will be created. containerd&amp;rsquo;s registry config will still contain the old Service&amp;rsquo;s cluster IP. containerd requests against the old Service&amp;rsquo;s cluster IP will time out and containerd will fall back to upstream.&lt;/p>
&lt;ul>
&lt;li>Image pull of &lt;code>docker.io/library/alpine:3.13.2&lt;/code> from the upstream takes ~2s while image pull of the same image with invalid registry cache cluster IP takes ~2m.2s.&lt;/li>
&lt;li>Image pull of &lt;code>eu.gcr.io/gardener-project/gardener/ops-toolbelt:0.18.0&lt;/code> from the upstream takes ~10s while image pull of the same image with invalid registry cache cluster IP takes ~3m.10s.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: Configuring the Registry Mirror Extension</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-mirror/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-mirror/configuration/</guid><description>
&lt;h1 id="configuring-the-registry-mirror-extension">Configuring the Registry Mirror Extension&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;h3 id="use-case">Use Case&lt;/h3>
&lt;p>containerd allows registry mirrors to be configured. Use cases are:&lt;/p>
&lt;ul>
&lt;li>Usage of public mirror(s) - for example, circumvent issues with the upstream registry such as rate limiting, outages, and others.&lt;/li>
&lt;li>Usage of private mirror(s) - for example, reduce network costs by using a private mirror running in the same network.&lt;/li>
&lt;/ul>
&lt;h3 id="solution">Solution&lt;/h3>
&lt;p>The registry-mirror extension allows the registry mirror configuration to be configured via the Shoot spec directly.&lt;/p>
&lt;h3 id="how-does-it-work">How does it work?&lt;/h3>
&lt;p>When the extension is enabled, the containerd daemon on the Shoot cluster Nodes gets configured to use the requested mirrors as a mirror. For example, if for the upstream &lt;code>docker.io&lt;/code> the mirror &lt;code>https://mirror.gcr.io&lt;/code> is configured in the Shoot spec, then containerd gets configured to first pull the image from the mirror (&lt;code>https://mirror.gcr.io&lt;/code> in that case). If this image pull operation fails, containerd falls back to the upstream itself (&lt;code>docker.io&lt;/code> in that case).&lt;/p>
&lt;p>The extension is based on the contract described in &lt;a href="https://gardener.cloud/docs/gardener/containerd-registry-configuration/">&lt;code>containerd&lt;/code> Registry Configuration&lt;/a>. The corresponding upstream documentation in containerd is &lt;a href="https://github.com/containerd/containerd/blob/v1.7.0/docs/hosts.md">Registry Configuration - Introduction&lt;/a>.&lt;/p>
&lt;h2 id="shoot-configuration">Shoot Configuration&lt;/h2>
&lt;p>The Shoot specification has to be adapted to include the &lt;code>registry-mirror&lt;/code> extension configuration.&lt;/p>
&lt;p>Below is an example of &lt;code>registry-mirror&lt;/code> extension configuration as part of the Shoot spec:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: crazy-botany
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: registry-mirror
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: mirror.extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: MirrorConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mirrors:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hosts:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - host: &lt;span style="color:#a31515">&amp;#34;https://mirror.gcr.io&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> capabilities: [&lt;span style="color:#a31515">&amp;#34;pull&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>providerConfig&lt;/code> field is required.&lt;/p>
&lt;p>The &lt;code>providerConfig.mirrors&lt;/code> field contains information about the registry mirrors to configure. It is a required field. At least one mirror has to be specified.&lt;/p>
&lt;p>The &lt;code>providerConfig.mirror[].upstream&lt;/code> field is the remote registry host to mirror. It is a required field.
The value must be a valid DNS subdomain (RFC 1123) and optionally a port (i.e. &lt;code>&amp;lt;host&amp;gt;[:&amp;lt;port&amp;gt;]&lt;/code>). It must not include a scheme.&lt;/p>
&lt;p>The &lt;code>providerConfig.mirror[].hosts&lt;/code> field represents the mirror hosts to be used for the upstream. At least one mirror host has to be specified.&lt;/p>
&lt;p>The &lt;code>providerConfig.mirror[].hosts[].host&lt;/code> field is the mirror host. It is a required field.
The value must include a scheme - &lt;code>http://&lt;/code> or &lt;code>https://&lt;/code>.&lt;/p>
&lt;p>The &lt;code>providerConfig.mirror[].hosts[].capabilities&lt;/code> field represents the operations a host is capable of performing. This also represents the set of operations for which the mirror host may be trusted to perform. Defaults to &lt;code>[&amp;quot;pull&amp;quot;]&lt;/code>. The supported values are &lt;code>pull&lt;/code> and &lt;code>resolve&lt;/code>.
See the &lt;a href="https://github.com/containerd/containerd/blob/v1.7.0/docs/hosts.md#capabilities-field">capabilities field documentation&lt;/a> for more information on which operations are considered trusted ones against public/private mirrors.&lt;/p></description></item><item><title>Docs: Deploying Registry Cache Extension in Gardener's Local Setup with Provider Extensions</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/getting-started-remotely/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/getting-started-remotely/</guid><description>
&lt;h1 id="deploying-registry-cache-extension-in-gardeners-local-setup-with-provider-extensions">Deploying Registry Cache Extension in Gardener&amp;rsquo;s Local Setup with Provider Extensions&lt;/h1>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;ul>
&lt;li>Make sure that you have a running local Gardener setup with enabled provider extensions. The steps to complete this can be found in the &lt;a href="https://gardener.cloud/docs/gardener/deployment/getting_started_locally_with_extensions/">Deploying Gardener Locally and Enabling Provider-Extensions&lt;/a> guide.&lt;/li>
&lt;/ul>
&lt;h2 id="setting-up-the-registry-cache-extension">Setting up the Registry Cache Extension&lt;/h2>
&lt;p>Make sure that your &lt;code>KUBECONFIG&lt;/code> environment variable is targeting the local Gardener cluster.&lt;/p>
&lt;p>The location of the Gardener project from the Gardener setup step is expected to be under the same root (e.g. &lt;code>~/go/src/github.com/gardener/&lt;/code>). If this is not the case, the location of Gardener project should be specified in &lt;code>GARDENER_REPO_ROOT&lt;/code> environment variable:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export GARDENER_REPO_ROOT=&lt;span style="color:#a31515">&amp;#34;&amp;lt;path_to_gardener_project&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then you can run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make remote-extension-up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In case you have added additional Seeds you can specify the seed name:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make remote-extension-up SEED_NAME=&amp;lt;seed-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The corresponding make target will build the extension image, push it into the Seed cluster image registry, and deploy the registry-cache ControllerDeployment and ControllerRegistration resources into the kind cluster.
The container image in the ControllerDeployment will be the image that was build and pushed into the Seed cluster image registry.&lt;/p>
&lt;p>The make target will then deploy the registry-cache admission component. It will build the admission image, push it into the kind cluster image registry, and finally install the admission component charts to the kind cluster.&lt;/p>
&lt;h2 id="creating-a-shoot-cluster">Creating a Shoot Cluster&lt;/h2>
&lt;p>Once the above step is completed, you can create a Shoot cluster. In order to create a Shoot cluster, please create your own Shoot definition depending on providers on your Seed cluster.&lt;/p>
&lt;h2 id="tearing-down-the-development-environment">Tearing Down the Development Environment&lt;/h2>
&lt;p>To tear down the development environment, delete the Shoot cluster or disable the &lt;code>registry-cache&lt;/code> extension in the Shoot&amp;rsquo;s specification. When the extension is not used by the Shoot anymore, you can run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make remote-extension-down
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The make target will delete the ControllerDeployment and ControllerRegistration of the extension, and the registry-cache admission helm deployment.&lt;/p></description></item><item><title>Docs: Deploying Registry Cache Extension Locally</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/getting-started-locally/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/getting-started-locally/</guid><description>
&lt;h1 id="deploying-registry-cache-extension-locally">Deploying Registry Cache Extension Locally&lt;/h1>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;ul>
&lt;li>Make sure that you have a running local Gardener setup. The steps to complete this can be found in the &lt;a href="https://gardener.cloud/docs/gardener/deployment/getting_started_locally/">Deploying Gardener Locally guide&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="setting-up-the-registry-cache-extension">Setting up the Registry Cache Extension&lt;/h2>
&lt;p>Make sure that your &lt;code>KUBECONFIG&lt;/code> environment variable is targeting the local Gardener cluster. When this is ensured, run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make extension-up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The corresponding make target will build the extension image, load it into the kind cluster Nodes, and deploy the registry-cache ControllerDeployment and ControllerRegistration resources. The container image in the ControllerDeployment will be the image that was build and loaded into the kind cluster Nodes.&lt;/p>
&lt;p>The make target will then deploy the registry-cache admission component. It will build the admission image, load it into the kind cluster Nodes, and finally install the admission component charts to the kind cluster.&lt;/p>
&lt;h2 id="creating-a-shoot-cluster">Creating a Shoot Cluster&lt;/h2>
&lt;p>Once the above step is completed, you can create a Shoot cluster.&lt;/p>
&lt;p>&lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/example/shoot-registry-cache.yaml">&lt;code>example/shoot-registry-cache.yaml&lt;/code>&lt;/a> contains a Shoot specification with the &lt;code>registry-cache&lt;/code> extension:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -f example/shoot-registry-cache.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/example/shoot-registry-mirror.yaml">&lt;code>example/shoot-registry-mirror.yaml&lt;/code>&lt;/a> contains a Shoot specification with the &lt;code>registry-mirror&lt;/code> extension:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -f example/shoot-registry-mirror.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tearing-down-the-development-environment">Tearing Down the Development Environment&lt;/h2>
&lt;p>To tear down the development environment, delete the Shoot cluster or disable the &lt;code>registry-cache&lt;/code> extension in the Shoot&amp;rsquo;s specification. When the extension is not used by the Shoot anymore, you can run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make extension-down
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The make target will delete the ControllerDeployment and ControllerRegistration of the extension, and the registry-cache admission helm deployment.&lt;/p></description></item><item><title>Docs: Developer Docs for Gardener Extension Registry Cache</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/extension-registry-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/extension-registry-cache/</guid><description>
&lt;h1 id="developer-docs-for-gardener-extension-registry-cache">Developer Docs for Gardener Extension Registry Cache&lt;/h1>
&lt;p>This document outlines how Shoot reconciliation and deletion works for a Shoot with the registry-cache extension enabled.&lt;/p>
&lt;h2 id="shoot-reconciliation">Shoot Reconciliation&lt;/h2>
&lt;p>This section outlines how the reconciliation works for a Shoot with the registry-cache extension enabled.&lt;/p>
&lt;h3 id="extension-enablement--reconciliation">Extension Enablement / Reconciliation&lt;/h3>
&lt;p>This section outlines how the extension enablement/reconciliation works, e.g., the extension has been added to the Shoot spec.&lt;/p>
&lt;ol>
&lt;li>As part of the Shoot reconciliation flow, the gardenlet deploys the &lt;a href="https://gardener.cloud/docs/gardener/extensions/extension/">Extension&lt;/a> resource.&lt;/li>
&lt;li>The registry-cache extension reconciles the Extension resource. &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/controller/cache/actuator.go">pkg/controller/cache/actuator.go&lt;/a> contains the implementation of the &lt;a href="https://github.com/gardener/gardener/blob/v1.88.0/extensions/pkg/controller/extension/actuator.go">extension.Actuator&lt;/a> interface. The reconciliation of an Extension of type &lt;code>registry-cache&lt;/code> consists of the following steps:
&lt;ol>
&lt;li>The registry-cache extension deploys resources to the Shoot cluster via ManagedResource. For every configured upstream, it creates a StatefulSet (with PVC), Service, and other resources.&lt;/li>
&lt;li>It lists all Services from the &lt;code>kube-system&lt;/code> namespace that have the &lt;code>upstream-host&lt;/code> label. It will return an error (and retry in exponential backoff) until the Services count matches the configured registries count.&lt;/li>
&lt;li>When there is a Service created for each configured upstream registry, the registry-cache extension populates the Extension resource status. In the Extension status, for each upstream, it maintains an endpoint (in the format &lt;code>http://&amp;lt;cluster-ip&amp;gt;:5000&lt;/code>) which can be used to access the registry cache from within the Shoot cluster. &lt;code>&amp;lt;cluster-ip&amp;gt;&lt;/code> is the cluster IP of the registry cache Service. The cluster IP of a Service is assigned by the Kubernetes API server on Service creation.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>As part of the Shoot reconciliation flow, the gardenlet deploys the &lt;a href="https://gardener.cloud/docs/gardener/extensions/operatingsystemconfig/">OperatingSystemConfig&lt;/a> resource.&lt;/li>
&lt;li>The registry-cache extension serves a webhook that mutates the OperatingSystemConfig resource for Shoots having the registry-cache extension enabled (the corresponding namespace gets labeled by the gardenlet with &lt;code>extensions.gardener.cloud/registry-cache=true&lt;/code>). &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/webhook/cache/ensurer.go">pkg/webhook/cache/ensurer.go&lt;/a> contains an implementation of the &lt;a href="https://github.com/gardener/gardener/blob/v1.88.0/extensions/pkg/webhook/controlplane/genericmutator/mutator.go">genericmutator.Ensurer&lt;/a> interface.
&lt;ol>
&lt;li>The webhook appends or updates &lt;code>RegistryConfig&lt;/code> entries in the &lt;a href="https://gardener.cloud/docs/gardener/extensions/operatingsystemconfig/#cri-support">OperatingSystemConfig CRI&lt;/a> configuration that corresponds to configured registry caches in the Shoot. The &lt;code>RegistryConfig&lt;/code> readiness probe is enabled so that &lt;a href="https://gardener.cloud/docs/gardener/concepts/node-agent/">gardener-node-agent&lt;/a> creates a &lt;code>hosts.toml&lt;/code> containerd registry configuration file when all &lt;code>RegistryConfig&lt;/code> hosts are reachable.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h3 id="extension-disablement">Extension Disablement&lt;/h3>
&lt;p>This section outlines how the extension disablement works, i.e., the extension has to be removed from the Shoot spec.&lt;/p>
&lt;ol>
&lt;li>As part of the Shoot reconciliation flow, the gardenlet destroys the &lt;a href="https://gardener.cloud/docs/gardener/extensions/extension/">Extension&lt;/a> resource because it is no longer needed.
&lt;ol>
&lt;li>The extension deletes the ManagedResource containing the registry cache resources.&lt;/li>
&lt;li>The OperatingSystemConfig resource will not be mutated and no &lt;code>RegistryConfig&lt;/code> entries will be added or updated. The &lt;a href="https://gardener.cloud/docs/gardener/concepts/node-agent/">gardener-node-agent&lt;/a> detects that &lt;code>RegistryConfig&lt;/code> entries have been removed or changed and deletes or updates corresponding &lt;code>hosts.toml&lt;/code> configuration files under &lt;code>/etc/containerd/certs.d&lt;/code> folder.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="shoot-deletion">Shoot Deletion&lt;/h2>
&lt;p>This section outlines how the deletion works for a Shoot with the registry-cache extension enabled.&lt;/p>
&lt;ol>
&lt;li>As part of the Shoot deletion flow, the gardenlet destroys the &lt;a href="https://gardener.cloud/docs/gardener/extensions/extension/">Extension&lt;/a> resource.
&lt;ol>
&lt;li>The extension deletes the ManagedResource containing the registry cache resources.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: How to provide credentials for upstream registry?</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/upstream-credentials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/upstream-credentials/</guid><description>
&lt;h1 id="how-to-provide-credentials-for-upstream-registry">How to provide credentials for upstream registry?&lt;/h1>
&lt;p>In Kubernetes, to pull images from private container image registries you either have to specify an image pull Secret (see &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/">Pull an Image from a Private Registry&lt;/a>) or you have to configure the kubelet to dynamically retrieve credentials using a credential provider plugin (see &lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/kubelet-credential-provider/">Configure a kubelet image credential provider&lt;/a>). When pulling an image, the kubelet is providing the credentials to the CRI implementation. The CRI implementation uses the provided credentials against the upstream registry to pull the image.&lt;/p>
&lt;p>The registry-cache extension is using the &lt;a href="https://github.com/distribution/distribution">Distribution project&lt;/a> as pull through cache implementation. The Distribution project does not use the provided credentials from the CRI implementation while fetching an image from the upstream. Hence, the above-described scenarios such as configuring image pull Secret for a Pod or configuring kubelet credential provider plugins don&amp;rsquo;t work out of the box with the pull through cache provided by the registry-cache extension.
Instead, the Distribution project supports configuring only one set of credentials for a given pull through cache instance (for a given upstream).&lt;/p>
&lt;p>This document describe how to supply credentials for the private upstream registry in order to pull private image with the registry cache.&lt;/p>
&lt;h2 id="how-to-configure-the-registry-cache-to-use-upstream-registry-credentials">How to configure the registry cache to use upstream registry credentials?&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Create an immutable Secret with the upstream registry credentials in the Garden cluster:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -f - &lt;span style="color:#a31515">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">apiVersion: v1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">kind: Secret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">metadata:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> name: ro-docker-secret-v1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> namespace: garden-dev
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">type: Opaque
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">immutable: true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">data:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> username: $(echo -n $USERNAME | base64 -w0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> password: $(echo -n $PASSWORD | base64 -w0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For Artifact Registry, the username is &lt;code>_json_key&lt;/code> and the password is the service account key in JSON format. To base64 encode the service account key, copy it and run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo -n $SERVICE_ACCOUNT_KEY_JSON | base64 -w0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Add the newly created Secret as a reference to the Shoot spec, and then to the registry-cache extension configuration.&lt;/p>
&lt;p>In the registry-cache configuration, set the &lt;code>secretReferenceName&lt;/code> field. It should point to a resource reference under &lt;code>spec.resources&lt;/code>. The resource reference itself points to the Secret in project namespace.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: registry-cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: registry.extensions.gardener.cloud/v1alpha3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: RegistryConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> caches:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretReferenceName: docker-secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: docker-secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: ro-docker-secret-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: Do not delete the referenced Secret when there is a Shoot still using it.&lt;/p>
&lt;/blockquote>
&lt;h2 id="how-to-rotate-the-registry-credentials">How to rotate the registry credentials?&lt;/h2>
&lt;p>To rotate registry credentials perform the following steps:&lt;/p>
&lt;ol>
&lt;li>Generate a new pair of credentials in the cloud provider account. Do not invalidate the old ones.&lt;/li>
&lt;li>Create a new Secret (e.g., &lt;code>ro-docker-secret-v2&lt;/code>) with the newly generated credentials as described in step 1. in &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/upstream-credentials/#how-to-configure-the-registry-cache-to-use-upstream-registry-credentials">How to configure the registry cache to use upstream registry credentials?&lt;/a>.&lt;/li>
&lt;li>Update the Shoot spec with newly created Secret as described in step 2. in &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/registry-cache/upstream-credentials/#how-to-configure-the-registry-cache-to-use-upstream-registry-credentials">How to configure the registry cache to use upstream registry credentials?&lt;/a>.&lt;/li>
&lt;li>The above step will trigger a Shoot reconciliation. Wait for it to complete.&lt;/li>
&lt;li>Make sure that the old Secret is no longer referenced by any Shoot cluster. Finally, delete the Secret containing the old credentials (e.g., &lt;code>ro-docker-secret-v1&lt;/code>).&lt;/li>
&lt;li>Delete the corresponding old credentials from the cloud provider account.&lt;/li>
&lt;/ol>
&lt;h2 id="possible-pitfalls">Possible Pitfalls&lt;/h2>
&lt;ul>
&lt;li>The registry cache is not protected by any authentication/authorization mechanism. The cached images (incl. private images) can be fetched from the registry cache without authentication/authorization. Note that the registry cache itself is not exposed publicly.&lt;/li>
&lt;li>The registry cache provides the credentials for every request against the corresponding upstream. In some cases, misconfigured credentials can prevent the registry cache to pull even public images from the upstream (for example: invalid service account key for Artifact Registry). However, this behaviour is controlled by the server-side logic of the upstream registry.&lt;/li>
&lt;/ul></description></item></channel></rss>