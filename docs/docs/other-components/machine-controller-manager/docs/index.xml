<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener – Documentation</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/</link><description>Recent content in Documentation on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/other-components/machine-controller-manager/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Deployment</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/deployment/</guid><description/></item><item><title>Docs: Development</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/development/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/development/</guid><description/></item><item><title>Docs: Documents</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/documents/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/documents/</guid><description/></item><item><title>Docs: Proposals</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/</guid><description/></item><item><title>Docs: Usage</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/usage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/usage/</guid><description/></item><item><title>Docs: Apis</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/docs/apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/docs/apis/</guid><description>
&lt;h2 id="specification">Specification&lt;/h2>
&lt;h3 id="providerspec-schema">ProviderSpec Schema&lt;/h3>
&lt;br>
&lt;h3 id="Machine">
&lt;b>Machine&lt;/b>
&lt;/h3>
&lt;p>
&lt;p>Machine is the representation of a physical or virtual machine.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>apiVersion&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>
machine.sapcloud.io.v1alpha1
&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>kind&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>Machine&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>metadata&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>ObjectMeta for machine object&lt;/p>
Refer to the Kubernetes API documentation for the fields of the
&lt;code>metadata&lt;/code> field.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>spec&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineSpec">
MachineSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Spec contains the specification of the machine&lt;/p>
&lt;br/>
&lt;br/>
&lt;table>
&lt;tr>
&lt;td>
&lt;code>class&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ClassSpec">
ClassSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Class contains the machineclass attributes of a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>providerID&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>ProviderID represents the provider&amp;rsquo;s unique ID given to a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>nodeTemplate&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#NodeTemplateSpec">
NodeTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>NodeTemplateSpec describes the data a node should have when created from a template&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>MachineConfiguration&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineConfiguration">
MachineConfiguration
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>
(Members of &lt;code>MachineConfiguration&lt;/code> are embedded into this type.)
&lt;/p>
&lt;em>(Optional)&lt;/em>
&lt;p>Configuration for the machine-controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/table>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>status&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineStatus">
MachineStatus
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Status contains fields depicting the status&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineClass">
&lt;b>MachineClass&lt;/b>
&lt;/h3>
&lt;p>
&lt;p>MachineClass can be used to templatize and re-use provider configuration
across multiple Machines / MachineSets / MachineDeployments.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>apiVersion&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>
machine.sapcloud.io.v1alpha1
&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>kind&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>MachineClass&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>metadata&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
Refer to the Kubernetes API documentation for the fields of the
&lt;code>metadata&lt;/code> field.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>nodeTemplate&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#NodeTemplate">
NodeTemplate
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>NodeTemplate contains subfields to track all node resources and other node info required to scale nodegroup from zero&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>credentialsSecretRef&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23secretreference-v1-core">
Kubernetes core/v1.SecretReference
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>CredentialsSecretRef can optionally store the credentials (in this case the SecretRef does not need to store them).
This might be useful if multiple machine classes with the same credentials but different user-datas are used.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>providerSpec&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fgodoc.org%2fk8s.io%2fapimachinery%2fpkg%2fruntime%23RawExtension">
k8s.io/apimachinery/pkg/runtime.RawExtension
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Provider-specific configuration to use during node creation.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>provider&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Provider is the combination of name and location of cloud-specific drivers.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>secretRef&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23secretreference-v1-core">
Kubernetes core/v1.SecretReference
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>SecretRef stores the necessary secrets such as credentials or userdata.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineDeployment">
&lt;b>MachineDeployment&lt;/b>
&lt;/h3>
&lt;p>
&lt;p>MachineDeployment enables declarative updates for machines and MachineSets.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>apiVersion&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>
machine.sapcloud.io.v1alpha1
&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>kind&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>MachineDeployment&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>metadata&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Standard object metadata.&lt;/p>
Refer to the Kubernetes API documentation for the fields of the
&lt;code>metadata&lt;/code> field.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>spec&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentSpec">
MachineDeploymentSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Specification of the desired behavior of the MachineDeployment.&lt;/p>
&lt;br/>
&lt;br/>
&lt;table>
&lt;tr>
&lt;td>
&lt;code>replicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Number of desired machines. This is a pointer to distinguish between explicit
zero and not specified. Defaults to 0.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>selector&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Label selector for machines. Existing MachineSets whose machines are
selected by this will be the ones affected by this MachineDeployment.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>template&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineTemplateSpec">
MachineTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Template describes the machines that will be created.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>strategy&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentStrategy">
MachineDeploymentStrategy
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The MachineDeployment strategy to use to replace existing machines with new ones.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>minReadySeconds&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Minimum number of seconds for which a newly created machine should be ready
without any of its container crashing, for it to be considered available.
Defaults to 0 (machine will be considered available as soon as it is ready)&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>revisionHistoryLimit&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The number of old MachineSets to retain to allow rollback.
This is a pointer to distinguish between explicit zero and not specified.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>paused&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
bool
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Indicates that the MachineDeployment is paused and will not be processed by the
MachineDeployment controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>rollbackTo&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#RollbackConfig">
RollbackConfig
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>DEPRECATED.
The config this MachineDeployment is rolling back to. Will be cleared after rollback is done.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>progressDeadlineSeconds&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The maximum time in seconds for a MachineDeployment to make progress before it
is considered to be failed. The MachineDeployment controller will continue to
process failed MachineDeployments and a condition with a ProgressDeadlineExceeded
reason will be surfaced in the MachineDeployment status. Note that progress will
not be estimated during the time a MachineDeployment is paused. This is not set
by default, which is treated as infinite deadline.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/table>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>status&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentStatus">
MachineDeploymentStatus
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Most recently observed status of the MachineDeployment.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineSet">
&lt;b>MachineSet&lt;/b>
&lt;/h3>
&lt;p>
&lt;p>MachineSet TODO&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>apiVersion&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>
machine.sapcloud.io.v1alpha1
&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>kind&lt;/code>
&lt;/td>
&lt;td>
string
&lt;/td>
&lt;td>
&lt;code>MachineSet&lt;/code>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>metadata&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
Refer to the Kubernetes API documentation for the fields of the
&lt;code>metadata&lt;/code> field.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>spec&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineSetSpec">
MachineSetSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;br/>
&lt;br/>
&lt;table>
&lt;tr>
&lt;td>
&lt;code>replicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>selector&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>machineClass&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ClassSpec">
ClassSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>template&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineTemplateSpec">
MachineTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>minReadySeconds&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;/table>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>status&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineSetStatus">
MachineSetStatus
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="ClassSpec">
&lt;b>ClassSpec&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSetSpec">MachineSetSpec&lt;/a>,
&lt;a href="#MachineSpec">MachineSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>ClassSpec is the class specification of machine&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>apiGroup&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>API group to which it belongs&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>kind&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Kind for machine class&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>name&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Name of machine class&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="ConditionStatus">
&lt;b>ConditionStatus&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentCondition">MachineDeploymentCondition&lt;/a>,
&lt;a href="#MachineSetCondition">MachineSetCondition&lt;/a>)
&lt;/p>
&lt;p>
&lt;/p>
&lt;br>
&lt;h3 id="CurrentStatus">
&lt;b>CurrentStatus&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineStatus">MachineStatus&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>CurrentStatus contains information about the current status of Machine.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>phase&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachinePhase">
MachinePhase
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>timeoutActive&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
bool
&lt;/em>
&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastUpdateTime&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23time-v1-meta">
Kubernetes meta/v1.Time
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Last update time of current status&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="LastOperation">
&lt;b>LastOperation&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSetStatus">MachineSetStatus&lt;/a>,
&lt;a href="#MachineStatus">MachineStatus&lt;/a>,
&lt;a href="#MachineSummary">MachineSummary&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>LastOperation suggests the last operation performed on the object&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>description&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Description of the current operation&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastUpdateTime&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23time-v1-meta">
Kubernetes meta/v1.Time
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Last update time of current operation&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>state&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineState">
MachineState
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>State of operation&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>type&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineOperationType">
MachineOperationType
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Type of operation&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineConfiguration">
&lt;b>MachineConfiguration&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSpec">MachineSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineConfiguration describes the configurations useful for the machine-controller.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>drainTimeout&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fgodoc.org%2fk8s.io%2fapimachinery%2fpkg%2fapis%2fmeta%2fv1%23Duration">
Kubernetes meta/v1.Duration
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>MachineDraintimeout is the timeout after which machine is forcefully deleted.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>healthTimeout&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fgodoc.org%2fk8s.io%2fapimachinery%2fpkg%2fapis%2fmeta%2fv1%23Duration">
Kubernetes meta/v1.Duration
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>MachineHealthTimeout is the timeout after which machine is declared unhealhty/failed.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>creationTimeout&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fgodoc.org%2fk8s.io%2fapimachinery%2fpkg%2fapis%2fmeta%2fv1%23Duration">
Kubernetes meta/v1.Duration
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>MachineCreationTimeout is the timeout after which machinie creation is declared failed.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>maxEvictRetries&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>MaxEvictRetries is the number of retries that will be attempted while draining the node.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>nodeConditions&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>NodeConditions are the set of conditions if set to true for MachineHealthTimeOut, machine will be declared failed.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineDeploymentCondition">
&lt;b>MachineDeploymentCondition&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentStatus">MachineDeploymentStatus&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineDeploymentCondition describes the state of a MachineDeployment at a certain point.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>type&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentConditionType">
MachineDeploymentConditionType
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Type of MachineDeployment condition.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>status&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ConditionStatus">
ConditionStatus
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Status of the condition, one of True, False, Unknown.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastUpdateTime&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23time-v1-meta">
Kubernetes meta/v1.Time
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>The last time this condition was updated.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastTransitionTime&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23time-v1-meta">
Kubernetes meta/v1.Time
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Last time the condition transitioned from one status to another.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>reason&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>The reason for the condition&amp;rsquo;s last transition.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>message&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>A human readable message indicating details about the transition.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineDeploymentConditionType">
&lt;b>MachineDeploymentConditionType&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentCondition">MachineDeploymentCondition&lt;/a>)
&lt;/p>
&lt;p>
&lt;/p>
&lt;br>
&lt;h3 id="MachineDeploymentSpec">
&lt;b>MachineDeploymentSpec&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeployment">MachineDeployment&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineDeploymentSpec is the specification of the desired behavior of the MachineDeployment.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>replicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Number of desired machines. This is a pointer to distinguish between explicit
zero and not specified. Defaults to 0.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>selector&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Label selector for machines. Existing MachineSets whose machines are
selected by this will be the ones affected by this MachineDeployment.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>template&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineTemplateSpec">
MachineTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Template describes the machines that will be created.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>strategy&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentStrategy">
MachineDeploymentStrategy
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The MachineDeployment strategy to use to replace existing machines with new ones.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>minReadySeconds&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Minimum number of seconds for which a newly created machine should be ready
without any of its container crashing, for it to be considered available.
Defaults to 0 (machine will be considered available as soon as it is ready)&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>revisionHistoryLimit&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The number of old MachineSets to retain to allow rollback.
This is a pointer to distinguish between explicit zero and not specified.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>paused&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
bool
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Indicates that the MachineDeployment is paused and will not be processed by the
MachineDeployment controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>rollbackTo&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#RollbackConfig">
RollbackConfig
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>DEPRECATED.
The config this MachineDeployment is rolling back to. Will be cleared after rollback is done.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>progressDeadlineSeconds&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The maximum time in seconds for a MachineDeployment to make progress before it
is considered to be failed. The MachineDeployment controller will continue to
process failed MachineDeployments and a condition with a ProgressDeadlineExceeded
reason will be surfaced in the MachineDeployment status. Note that progress will
not be estimated during the time a MachineDeployment is paused. This is not set
by default, which is treated as infinite deadline.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineDeploymentStatus">
&lt;b>MachineDeploymentStatus&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeployment">MachineDeployment&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineDeploymentStatus is the most recently observed status of the MachineDeployment.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>observedGeneration&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int64
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The generation observed by the MachineDeployment controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>replicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Total number of non-terminated machines targeted by this MachineDeployment (their labels match the selector).&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>updatedReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Total number of non-terminated machines targeted by this MachineDeployment that have the desired template spec.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>readyReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Total number of ready machines targeted by this MachineDeployment.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>availableReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Total number of available machines (ready for at least minReadySeconds) targeted by this MachineDeployment.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>unavailableReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Total number of unavailable machines targeted by this MachineDeployment. This is the total number of
machines that are still required for the MachineDeployment to have 100% available capacity. They may
either be machines that are running but not yet available or machines that still have not been created.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>conditions&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentCondition">
[]MachineDeploymentCondition
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Represents the latest available observations of a MachineDeployment&amp;rsquo;s current state.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>collisionCount&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
*int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Count of hash collisions for the MachineDeployment. The MachineDeployment controller uses this
field as a collision avoidance mechanism when it needs to create the name for the
newest MachineSet.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>failedMachines&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#%2a..%2f..%2fpkg%2fapis%2fmachine%2fv1alpha1.MachineSummary">
[]*../../pkg/apis/machine/v1alpha1.MachineSummary
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>FailedMachines has summary of machines on which lastOperation Failed&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineDeploymentStrategy">
&lt;b>MachineDeploymentStrategy&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentSpec">MachineDeploymentSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineDeploymentStrategy describes how to replace existing machines with new ones.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>type&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineDeploymentStrategyType">
MachineDeploymentStrategyType
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Type of MachineDeployment. Can be &amp;ldquo;Recreate&amp;rdquo; or &amp;ldquo;RollingUpdate&amp;rdquo;. Default is RollingUpdate.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>rollingUpdate&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#RollingUpdateMachineDeployment">
RollingUpdateMachineDeployment
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Rolling update config params. Present only if MachineDeploymentStrategyType =&lt;/p>
&lt;h2>RollingUpdate.&lt;/h2>
&lt;p>TODO: Update this to follow our convention for oneOf, whatever we decide it
to be.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineDeploymentStrategyType">
&lt;b>MachineDeploymentStrategyType&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentStrategy">MachineDeploymentStrategy&lt;/a>)
&lt;/p>
&lt;p>
&lt;/p>
&lt;br>
&lt;h3 id="MachineOperationType">
&lt;b>MachineOperationType&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#LastOperation">LastOperation&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineOperationType is a label for the operation performed on a machine object.&lt;/p>
&lt;/p>
&lt;br>
&lt;h3 id="MachinePhase">
&lt;b>MachinePhase&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#CurrentStatus">CurrentStatus&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachinePhase is a label for the condition of a machines at the current time.&lt;/p>
&lt;/p>
&lt;br>
&lt;h3 id="MachineSetCondition">
&lt;b>MachineSetCondition&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSetStatus">MachineSetStatus&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineSetCondition describes the state of a machine set at a certain point.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>type&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineSetConditionType">
MachineSetConditionType
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Type of machine set condition.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>status&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ConditionStatus">
ConditionStatus
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Status of the condition, one of True, False, Unknown.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastTransitionTime&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23time-v1-meta">
Kubernetes meta/v1.Time
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The last time the condition transitioned from one status to another.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>reason&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The reason for the condition&amp;rsquo;s last transition.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>message&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>A human readable message indicating details about the transition.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineSetConditionType">
&lt;b>MachineSetConditionType&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSetCondition">MachineSetCondition&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineSetConditionType is the condition on machineset object&lt;/p>
&lt;/p>
&lt;br>
&lt;h3 id="MachineSetSpec">
&lt;b>MachineSetSpec&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSet">MachineSet&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineSetSpec is the specification of a MachineSet.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>replicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>selector&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23labelselector-v1-meta">
Kubernetes meta/v1.LabelSelector
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>machineClass&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ClassSpec">
ClassSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>template&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineTemplateSpec">
MachineTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>minReadySeconds&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineSetStatus">
&lt;b>MachineSetStatus&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSet">MachineSet&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineSetStatus holds the most recently observed status of MachineSet.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>replicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Replicas is the number of actual replicas.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>fullyLabeledReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The number of pods that have labels matching the labels of the pod template of the replicaset.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>readyReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The number of ready replicas for this replica set.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>availableReplicas&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int32
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The number of available replicas (ready for at least minReadySeconds) for this replica set.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>observedGeneration&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int64
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>ObservedGeneration is the most recent generation observed by the controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>machineSetCondition&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineSetCondition">
[]MachineSetCondition
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Represents the latest available observations of a replica set&amp;rsquo;s current state.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastOperation&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#LastOperation">
LastOperation
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>LastOperation performed&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>failedMachines&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#%5b%5d..%2f..%2fpkg%2fapis%2fmachine%2fv1alpha1.MachineSummary">
[]../../pkg/apis/machine/v1alpha1.MachineSummary
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>FailedMachines has summary of machines on which lastOperation Failed&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineSpec">
&lt;b>MachineSpec&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#Machine">Machine&lt;/a>,
&lt;a href="#MachineTemplateSpec">MachineTemplateSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineSpec is the specification of a Machine.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>class&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ClassSpec">
ClassSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Class contains the machineclass attributes of a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>providerID&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>ProviderID represents the provider&amp;rsquo;s unique ID given to a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>nodeTemplate&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#NodeTemplateSpec">
NodeTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>NodeTemplateSpec describes the data a node should have when created from a template&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>MachineConfiguration&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineConfiguration">
MachineConfiguration
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>
(Members of &lt;code>MachineConfiguration&lt;/code> are embedded into this type.)
&lt;/p>
&lt;em>(Optional)&lt;/em>
&lt;p>Configuration for the machine-controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineState">
&lt;b>MachineState&lt;/b>
(&lt;code>string&lt;/code> alias)&lt;/p>&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#LastOperation">LastOperation&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineState is a current state of the machine.&lt;/p>
&lt;/p>
&lt;br>
&lt;h3 id="MachineStatus">
&lt;b>MachineStatus&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#Machine">Machine&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineStatus holds the most recently observed status of Machine.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>conditions&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23nodecondition-v1-core">
[]Kubernetes core/v1.NodeCondition
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Conditions of this machine, same as node&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastOperation&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#LastOperation">
LastOperation
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Last operation refers to the status of the last operation performed&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>currentStatus&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#CurrentStatus">
CurrentStatus
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Current status of the machine object&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastKnownState&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>LastKnownState can store details of the last known state of the VM by the plugins.
It can be used by future operation calls to determine current infrastucture state&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineSummary">
&lt;b>MachineSummary&lt;/b>
&lt;/h3>
&lt;p>
&lt;p>MachineSummary store the summary of machine.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>name&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Name of the machine object&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>providerID&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>ProviderID represents the provider&amp;rsquo;s unique ID given to a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>lastOperation&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#LastOperation">
LastOperation
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Last operation refers to the status of the last operation performed&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>ownerRef&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>OwnerRef&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="MachineTemplateSpec">
&lt;b>MachineTemplateSpec&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentSpec">MachineDeploymentSpec&lt;/a>,
&lt;a href="#MachineSetSpec">MachineSetSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>MachineTemplateSpec describes the data a machine should have when created from a template&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>metadata&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Standard object&amp;rsquo;s metadata.
More info: &lt;a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata">https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata&lt;/a>&lt;/p>
Refer to the Kubernetes API documentation for the fields of the
&lt;code>metadata&lt;/code> field.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>spec&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineSpec">
MachineSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Specification of the desired behavior of the machine.
More info: &lt;a href="https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status">https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status&lt;/a>&lt;/p>
&lt;br/>
&lt;br/>
&lt;table>
&lt;tr>
&lt;td>
&lt;code>class&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#ClassSpec">
ClassSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Class contains the machineclass attributes of a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>providerID&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>ProviderID represents the provider&amp;rsquo;s unique ID given to a machine&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>nodeTemplate&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#NodeTemplateSpec">
NodeTemplateSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>NodeTemplateSpec describes the data a node should have when created from a template&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>MachineConfiguration&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#MachineConfiguration">
MachineConfiguration
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>
(Members of &lt;code>MachineConfiguration&lt;/code> are embedded into this type.)
&lt;/p>
&lt;em>(Optional)&lt;/em>
&lt;p>Configuration for the machine-controller.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/table>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="NodeTemplate">
&lt;b>NodeTemplate&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineClass">MachineClass&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>NodeTemplate contains subfields to track all node resources and other node info required to scale nodegroup from zero&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>capacity&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23resourcelist-v1-core">
Kubernetes core/v1.ResourceList
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Capacity contains subfields to track all node resources required to scale nodegroup from zero&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>instanceType&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Instance type of the node belonging to nodeGroup&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>region&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Region of the expected node belonging to nodeGroup&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>zone&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;p>Zone of the expected node belonging to nodeGroup&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="NodeTemplateSpec">
&lt;b>NodeTemplateSpec&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineSpec">MachineSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>NodeTemplateSpec describes the data a node should have when created from a template&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>metadata&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
Refer to the Kubernetes API documentation for the fields of the
&lt;code>metadata&lt;/code> field.
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>spec&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23nodespec-v1-core">
Kubernetes core/v1.NodeSpec
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>NodeSpec describes the attributes that a node is created with.&lt;/p>
&lt;br/>
&lt;br/>
&lt;table>
&lt;tr>
&lt;td>
&lt;code>podCIDR&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>PodCIDR represents the pod IP range assigned to the node.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>podCIDRs&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
[]string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
each of IPv4 and IPv6.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>providerID&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>ID of the node assigned by the cloud provider in the format: &lt;ProviderName>://&lt;ProviderSpecificNodeID>&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>unschedulable&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
bool
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Unschedulable controls node schedulability of new pods. By default, node is schedulable.
More info: &lt;a href="https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration">https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration&lt;/a>&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>taints&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23taint-v1-core">
[]Kubernetes core/v1.Taint
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>If specified, the node&amp;rsquo;s taints.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>configSource&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fkubernetes.io%2fdocs%2freference%2fgenerated%2fkubernetes-api%2fv1.19%2f%23nodeconfigsource-v1-core">
Kubernetes core/v1.NodeConfigSource
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Deprecated: Previously used to specify the source of the node&amp;rsquo;s configuration for the DynamicKubeletConfig feature. This feature is removed.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>externalID&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
string
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>Deprecated. Not all kubelets will set this field. Remove field after 1.13.
see: &lt;a href="https://issues.k8s.io/61966">https://issues.k8s.io/61966&lt;/a>&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/table>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="RollbackConfig">
&lt;b>RollbackConfig&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentSpec">MachineDeploymentSpec&lt;/a>)
&lt;/p>
&lt;p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>revision&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
int64
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The revision to rollback to. If set to 0, rollback to the last revision.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;br>
&lt;h3 id="RollingUpdateMachineDeployment">
&lt;b>RollingUpdateMachineDeployment&lt;/b>
&lt;/h3>
&lt;p>
(&lt;em>Appears on:&lt;/em>
&lt;a href="#MachineDeploymentStrategy">MachineDeploymentStrategy&lt;/a>)
&lt;/p>
&lt;p>
&lt;p>Spec to control the desired behavior of rolling update.&lt;/p>
&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Field&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>
&lt;code>maxUnavailable&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fgodoc.org%2fk8s.io%2fapimachinery%2fpkg%2futil%2fintstr%23IntOrString">
k8s.io/apimachinery/pkg/util/intstr.IntOrString
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The maximum number of machines that can be unavailable during the update.
Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%).
Absolute number is calculated from percentage by rounding down.
This can not be 0 if MaxSurge is 0.
By default, a fixed value of 1 is used.
Example: when this is set to 30%, the old MC can be scaled down to 70% of desired machines
immediately when the rolling update starts. Once new machines are ready, old MC
can be scaled down further, followed by scaling up the new MC, ensuring
that the total number of machines available at all times during the update is at
least 70% of desired machines.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>
&lt;code>maxSurge&lt;/code>
&lt;/td>
&lt;td>
&lt;em>
&lt;a href="#https%3a%2f%2fgodoc.org%2fk8s.io%2fapimachinery%2fpkg%2futil%2fintstr%23IntOrString">
k8s.io/apimachinery/pkg/util/intstr.IntOrString
&lt;/a>
&lt;/em>
&lt;/td>
&lt;td>
&lt;em>(Optional)&lt;/em>
&lt;p>The maximum number of machines that can be scheduled above the desired number of
machines.
Value can be an absolute number (ex: 5) or a percentage of desired machines (ex: 10%).
This can not be 0 if MaxUnavailable is 0.
Absolute number is calculated from percentage by rounding up.
By default, a value of 1 is used.
Example: when this is set to 30%, the new MC can be scaled up immediately when
the rolling update starts, such that the total number of old and new machines do not exceed
130% of desired machines. Once old machines have been killed,
new MC can be scaled up further, ensuring that total number of machines running
at any time during the update is atmost 130% of desired machines.&lt;/p>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr/>
&lt;p>&lt;em>
Generated with &lt;a href="https://github.com/ahmetb/gen-crd-api-reference-docs">gen-crd-api-reference-docs&lt;/a>
&lt;/em>&lt;/p></description></item><item><title>Docs: Machine Controller Manager FAQ</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/faq/</guid><description>
&lt;h1 id="frequently-asked-questions">Frequently Asked Questions&lt;/h1>
&lt;p>The answers in this FAQ apply to the newest (HEAD) version of Machine Controller Manager. If
you&amp;rsquo;re using an older version of MCM please refer to corresponding version of
this document. Few of the answers assume that the MCM being used is in conjuction with &lt;a href="https://github.com/gardener/autoscaler">cluster-autoscaler&lt;/a>:&lt;/p>
&lt;h1 id="table-of-contents">Table of Contents:&lt;/h1>
&lt;!--- TOC BEGIN -->
&lt;ul>
&lt;li>
&lt;p>&lt;a href="#basics">Basics&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#what-is-machine-controller-manager">What is Machine Controller Manager?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#Why-is-my-machine-deleted">Why is my machine deleted?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#What-are-the-different-sub-controllers-in-MCM">What are the different sub-controllers in MCM?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#What-is-safety-controller-in-MCM">What is Safety Controller in MCM?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#how-to">How to?&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#How-to-install-MCM-in-a-kubernetes-cluster">How to install MCM in a Kubernetes cluster?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-to-better-control-the-rollout-process-of-the-worker-nodes">How to better control the rollout process of the worker nodes?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-to-scale-down-machinedeployment-by-selective-deletion-of-machines">How to scale down MachineDeployment by selective deletion of machines?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-to-force-delete-a-machine">How to force delete a machine?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-to-pause-the-ongoing-rolling-update-of-the-machinedeployment">How to pause the ongoing rolling-update of the machinedeployment?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-to-avoid-garbage-collection-of-your-node">How to avoid garbage collection of your node?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#internals">Internals&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#What-is-the-high-level-design-of-MCM">What is the high level design of MCM?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#What-are-the-different-configuration-options-in-MCM">What are the different configuration options in MCM?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#What-are-the-different-timeoutsconfigurations-in-a-machines-lifecycle">What are the different timeouts/configurations in a machine&amp;rsquo;s lifecycle?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-is-the-drain-of-a-machine-implemented">How is the drain of a machine implemented?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-are-the-stateful-applications-drained-during-machine-deletion">How are the stateful applications drained during machine deletion?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-does-maxEvictRetries-configuration-work-with-drainTimeout-configuration">How does maxEvictRetries configuration work with drainTimeout configuration?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#What-are-the-different-phases-of-a-machine">What are the different phases of a machine?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#troubleshooting">Troubleshooting&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#My-machine-is-stuck-in-deletion-for-1-hr-why">My machine is stuck in deletion for 1 hr, why?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#My-machine-is-not-joining-the-cluster-why">My machine is not joining the cluster, why?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#developer">Developer&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#How-should-I-test-my-code-before-submitting-a-PR">How should I test my code before submitting a PR?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#I-need-to-change-the-APIs-what-are-the-recommended-steps">I need to change the APIs, what are the recommended steps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-can-I-update-the-dependencies-of-MCM">How can I update the dependencies of MCM?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="#in-the-context-of-gardener">In the context of Gardener&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#How-can-I-configure-MCM-using-Shoot-resource">How can I configure MCM using Shoot resource?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#How-is-my-worker-pool-spread-across-zones">How is my worker-pool spread across zones?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--- TOC END -->
&lt;h1 id="basics">Basics&lt;/h1>
&lt;h3 id="what-is-machine-controller-manager">What is Machine Controller Manager?&lt;/h3>
&lt;p>Machine Controller Manager aka MCM is a bunch of controllers used for the lifecycle management of the worker machines. It reconciles a set of CRDs such as &lt;code>Machine&lt;/code>, &lt;code>MachineSet&lt;/code>, &lt;code>MachineDeployment&lt;/code> which depicts the functionality of &lt;code>Pod&lt;/code>, &lt;code>Replicaset&lt;/code>, &lt;code>Deployment&lt;/code> of the core Kubernetes respectively. Read more about it at &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/docs">README&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Gardener uses MCM to manage its Kubernetes nodes of the shoot cluster. However, by design, MCM can be used independent of Gardener.&lt;/li>
&lt;/ul>
&lt;h3 id="why-is-my-machine-deleted">Why is my machine deleted?&lt;/h3>
&lt;p>A machine is deleted by MCM generally for 2 reasons-&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Machine is unhealthy for at least &lt;code>MachineHealthTimeout&lt;/code> period. The default &lt;code>MachineHealthTimeout&lt;/code> is 10 minutes.&lt;/p>
&lt;ul>
&lt;li>By default, a machine is considered unhealthy if any of the following node conditions - &lt;code>DiskPressure&lt;/code>, &lt;code>KernelDeadlock&lt;/code>, &lt;code>FileSystem&lt;/code>, &lt;code>Readonly&lt;/code> is set to &lt;code>true&lt;/code>, or &lt;code>KubeletReady&lt;/code> is set to &lt;code>false&lt;/code>. However, this is something that is configurable using the following &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/deployment/out-of-tree/deployment.yaml#L30">flag&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Machine is scaled down by the &lt;code>MachineDeployment&lt;/code> resource.&lt;/p>
&lt;ul>
&lt;li>This is very usual when an external controller cluster-autoscaler (aka CA) is used with MCM. CA deletes the under-utilized machines by scaling down the &lt;code>MachineDeployment&lt;/code>. Read more about cluster-autoscaler&amp;rsquo;s scale down behavior &lt;a href="https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md#how-does-scale-down-work">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="what-are-the-different-sub-controllers-in-mcm">What are the different sub-controllers in MCM?&lt;/h3>
&lt;p>MCM mainly contains the following sub-controllers:&lt;/p>
&lt;ul>
&lt;li>&lt;code>MachineDeployment Controller&lt;/code>: Responsible for reconciling the &lt;code>MachineDeployment&lt;/code> objects. It manages the lifecycle of the &lt;code>MachineSet&lt;/code> objects.&lt;/li>
&lt;li>&lt;code>MachineSet Controller&lt;/code>: Responsible for reconciling the &lt;code>MachineSet&lt;/code> objects. It manages the lifecycle of the &lt;code>Machine&lt;/code> objects.&lt;/li>
&lt;li>&lt;code>Machine Controller&lt;/code>: responsible for reconciling the &lt;code>Machine&lt;/code> objects. It manages the lifecycle of the actual VMs/machines created in cloud/on-prem. This controller has been moved out of tree. Please refer an AWS machine controller for more info - &lt;a href="https://github.com/gardener/machine-controller-manager-provider-gcp">link&lt;/a>.&lt;/li>
&lt;li>Safety-controller: Responsible for handling the unidentified/unknown behaviors from the cloud providers. Please read more about its functionality &lt;a href="#what-is-safety-controller">below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h3 id="what-is-safety-controller-in-mcm">What is Safety Controller in MCM?&lt;/h3>
&lt;p>&lt;code>Safety Controller&lt;/code> contains following functions:&lt;/p>
&lt;ul>
&lt;li>Orphan VM handler:
&lt;ul>
&lt;li>It lists all the VMs in the cloud matching the &lt;code>tag&lt;/code> of given cluster name and maps the VMs with the &lt;code>machine&lt;/code> objects using the &lt;code>ProviderID&lt;/code> field. VMs without any backing &lt;code>machine&lt;/code> objects are logged and deleted after confirmation.&lt;/li>
&lt;li>This handler runs every 30 minutes and is configurable via &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go#L112">machine-safety-orphan-vms-period&lt;/a> flag.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Freeze mechanism:
&lt;ul>
&lt;li>&lt;code>Safety Controller&lt;/code> freezes the &lt;code>MachineDeployment&lt;/code> and &lt;code>MachineSet&lt;/code> controller if the number of &lt;code>machine&lt;/code> objects goes beyond a certain threshold on top of &lt;code>Spec.Replicas&lt;/code>. It can be configured by the flag &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go#L102-L103">&amp;ndash;safety-up or &amp;ndash;safety-down&lt;/a> and also &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go#L113">machine-safety-overshooting-period&lt;/a>.&lt;/li>
&lt;li>&lt;code>Safety Controller&lt;/code> freezes the functionality of the MCM if either of the &lt;code>target-apiserver&lt;/code> or the &lt;code>control-apiserver&lt;/code> is not reachable.&lt;/li>
&lt;li>&lt;code>Safety Controller&lt;/code> unfreezes the MCM automatically once situation is resolved to normal. A &lt;code>freeze&lt;/code> label is applied on &lt;code>MachineDeployment&lt;/code>/&lt;code>MachineSet&lt;/code> to enforce the freeze condition.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="how-to">How to?&lt;/h1>
&lt;h3 id="how-to-install-mcm-in-a-kubernetes-cluster">How to install MCM in a Kubernetes cluster?&lt;/h3>
&lt;p>MCM can be installed in a cluster with following steps:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Apply all the CRDs from &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/kubernetes/crds">here&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Apply all the deployment, role-related objects from &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/kubernetes/deployment/out-of-tree">here&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Control cluster is the one where the &lt;code>machine-*&lt;/code> objects are stored. Target cluster is where all the node objects are registered.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="how-to-better-control-the-rollout-process-of-the-worker-nodes">How to better control the rollout process of the worker nodes?&lt;/h3>
&lt;p>MCM allows configuring the rollout of the worker machines using &lt;code>maxSurge&lt;/code> and &lt;code>maxUnavailable&lt;/code> fields. These fields are applicable only during the rollout process and means nothing in general scale up/down scenarios.
The overall process is very similar to how the &lt;code>Deployment Controller&lt;/code> manages pods during &lt;code>RollingUpdate&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>maxSurge&lt;/code> refers to the number of additional machines that can be added on top of the &lt;code>Spec.Replicas&lt;/code> of MachineDeployment &lt;em>during rollout process&lt;/em>.&lt;/li>
&lt;li>&lt;code>maxUnavailable&lt;/code> refers to the number of machines that can be deleted from &lt;code>Spec.Replicas&lt;/code> field of the MachineDeployment &lt;em>during rollout process&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h3 id="how-to-scale-down-machinedeployment-by-selective-deletion-of-machines">How to scale down MachineDeployment by selective deletion of machines?&lt;/h3>
&lt;p>During scale down, triggered via &lt;code>MachineDeployment&lt;/code>/&lt;code>MachineSet&lt;/code>, MCM prefers to delete the &lt;code>machine/s&lt;/code> which have the least priority set.
Each &lt;code>machine&lt;/code> object has an annotation &lt;code>machinepriority.machine.sapcloud.io&lt;/code> set to &lt;code>3&lt;/code> by default. Admin can reduce the priority of the given machines by changing the annotation value to &lt;code>1&lt;/code>. The next scale down by &lt;code>MachineDeployment&lt;/code> shall delete the machines with the least priority first.&lt;/p>
&lt;h3 id="how-to-force-delete-a-machine">How to force delete a machine?&lt;/h3>
&lt;p>A machine can be force deleted by adding the label &lt;code>force-deletion: &amp;quot;True&amp;quot;&lt;/code> on the &lt;code>machine&lt;/code> object before executing the actual delete command. During force deletion, MCM skips the drain function and simply triggers the deletion of the machine. This label should be used with caution as it can violate the PDBs for pods running on the machine.&lt;/p>
&lt;h3 id="how-to-pause-the-ongoing-rolling-update-of-the-machinedeployment">How to pause the ongoing rolling-update of the machinedeployment?&lt;/h3>
&lt;p>An ongoing rolling-update of the machine-deployment can be paused by using &lt;code>spec.paused&lt;/code> field. See the example below:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: machine.sapcloud.io/v1alpha1
kind: MachineDeployment
metadata:
name: test-machine-deployment
spec:
paused: true
&lt;/code>&lt;/pre>&lt;p>It can be unpaused again by removing the &lt;code>Paused&lt;/code> field from the machine-deployment.&lt;/p>
&lt;h3 id="how-to-avoid-garbage-collection-of-your-node">How to avoid garbage collection of your node?&lt;/h3>
&lt;p>MCM provides an in-built safety mechanism to garbage collect VMs which have no corresponding machine object. This is done to save costs and is one of the key features of MCM.
However, sometimes users might like to add nodes directly to the cluster without the help of MCM and would prefer MCM to not garbage collect such VMs.
To do so they should remove/not-use tags on their VMs containing the following strings:&lt;/p>
&lt;ol>
&lt;li>&lt;code>kubernetes.io/cluster/&lt;/code>&lt;/li>
&lt;li>&lt;code>kubernetes.io/role/&lt;/code>&lt;/li>
&lt;li>&lt;code>kubernetes-io-cluster-&lt;/code>&lt;/li>
&lt;li>&lt;code>kubernetes-io-role-&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="internals">Internals&lt;/h1>
&lt;h3 id="what-is-the-high-level-design-of-mcm">What is the high level design of MCM?&lt;/h3>
&lt;p>Please refer the following &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/#design-of-machine-controller-manager">document&lt;/a>.&lt;/p>
&lt;h3 id="what-are-the-different-configuration-options-in-mcm">What are the different configuration options in MCM?&lt;/h3>
&lt;p>MCM allows configuring many knobs to fine-tune its behavior according to the user&amp;rsquo;s need.
Please refer to the &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go">link&lt;/a> to check the exact configuration options.&lt;/p>
&lt;h3 id="what-are-the-different-timeoutsconfigurations-in-a-machines-lifecycle">What are the different timeouts/configurations in a machine&amp;rsquo;s lifecycle?&lt;/h3>
&lt;p>A machine&amp;rsquo;s lifecycle is governed by mainly following timeouts, which can be configured &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/machine_objects/machine-deployment.yaml#L30-L34">here&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>MachineDrainTimeout&lt;/code>: Amount of time after which drain times out and the machine is force deleted. Default ~2 hours.&lt;/li>
&lt;li>&lt;code>MachineHealthTimeout&lt;/code>: Amount of time after which an unhealthy machine is declared &lt;code>Failed&lt;/code> and the machine is replaced by &lt;code>MachineSet&lt;/code> controller.&lt;/li>
&lt;li>&lt;code>MachineCreationTimeout&lt;/code>: Amount of time after which a machine creation is declared &lt;code>Failed&lt;/code> and the machine is replaced by the &lt;code>MachineSet&lt;/code> controller.&lt;/li>
&lt;li>&lt;code>NodeConditions&lt;/code>: List of node conditions which if set to true for &lt;code>MachineHealthTimeout&lt;/code> period, the machine is declared &lt;code>Failed&lt;/code> and replaced by &lt;code>MachineSet&lt;/code> controller.&lt;/li>
&lt;li>&lt;code>MaxEvictRetries&lt;/code>: An integer number depicting the number of times a failed &lt;em>eviction&lt;/em> should be retried on a pod during drain process. A pod is &lt;em>deleted&lt;/em> after &lt;code>max-retries&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h3 id="how-is-the-drain-of-a-machine-implemented">How is the drain of a machine implemented?&lt;/h3>
&lt;p>MCM imports the functionality from the upstream Kubernetes-drain library. Although, few parts have been modified to make it work best in the context of MCM. Drain is executed before machine deletion for graceful migration of the applications.
Drain internally uses the &lt;code>EvictionAPI&lt;/code> to evict the pods and triggers the &lt;code>Deletion&lt;/code> of pods after &lt;code>MachineDrainTimeout&lt;/code>. Please note:&lt;/p>
&lt;ul>
&lt;li>Stateless pods are evicted in parallel.&lt;/li>
&lt;li>Stateful applications (with PVCs) are serially evicted. Please find more info in this &lt;a href="#how-are-the-stateful-applications-drained-during-machine-deletion">answer below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h3 id="how-are-the-stateful-applications-drained-during-machine-deletion">How are the stateful applications drained during machine deletion?&lt;/h3>
&lt;p>Drain function serially evicts the stateful-pods. It is observed that serial eviction of stateful pods yields better overall availability of pods as the underlying cloud in most cases detaches and reattaches disks serially anyways.
It is implemented in the following manner:&lt;/p>
&lt;ul>
&lt;li>Drain lists all the pods with attached volumes. It evicts very first stateful-pod and waits for its related entry in Node object&amp;rsquo;s &lt;code>.status.volumesAttached&lt;/code> to be removed by KCM. It does the same for all the stateful-pods.&lt;/li>
&lt;li>It waits for &lt;code>PvDetachTimeout&lt;/code> (default 2 minutes) for a given pod&amp;rsquo;s PVC to be removed, else moves forward.&lt;/li>
&lt;/ul>
&lt;h3 id="how-does-maxevictretries-configuration-work-with-draintimeout-configuration">How does &lt;code>maxEvictRetries&lt;/code> configuration work with &lt;code>drainTimeout&lt;/code> configuration?&lt;/h3>
&lt;p>It is recommended to only set &lt;code>MachineDrainTimeout&lt;/code>. It satisfies the related requirements. &lt;code>MaxEvictRetries&lt;/code> is auto-calculated based on &lt;code>MachineDrainTimeout&lt;/code>, if &lt;code>maxEvictRetries&lt;/code> is not provided. Following will be the overall behavior of both configurations together:&lt;/p>
&lt;ul>
&lt;li>If &lt;code>maxEvictRetries&lt;/code> isn&amp;rsquo;t set and only &lt;code>maxDrainTimeout&lt;/code> is set:
&lt;ul>
&lt;li>MCM auto calculates the &lt;code>maxEvictRetries&lt;/code> based on the &lt;code>drainTimeout&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If &lt;code>drainTimeout&lt;/code> isn&amp;rsquo;t set and only &lt;code>maxEvictRetries&lt;/code> is set:
&lt;ul>
&lt;li>Default &lt;code>drainTimeout&lt;/code> and user provided &lt;code>maxEvictRetries&lt;/code> for each pod is considered.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If both &lt;code>maxEvictRetries&lt;/code> and &lt;code>drainTimoeut&lt;/code> are set:
&lt;ul>
&lt;li>Then both will be respected.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If none are set:
&lt;ul>
&lt;li>Defaults are respected.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="what-are-the-different-phases-of-a-machine">What are the different phases of a machine?&lt;/h3>
&lt;p>A phase of a &lt;code>machine&lt;/code> can be identified with &lt;code>Machine.Status.CurrentStatus.Phase&lt;/code>. Following are the possible phases of a &lt;code>machine&lt;/code> object:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Pending&lt;/code>: Machine creation call has succeeded. MCM is waiting for machine to join the cluster.&lt;/li>
&lt;li>&lt;code>CrashLoopBackOff&lt;/code>: Machine creation call has failed. MCM will retry the operation after a minor delay.&lt;/li>
&lt;li>&lt;code>Running&lt;/code>: Machine creation call has succeeded. Machine has joined the cluster successfully.&lt;/li>
&lt;li>&lt;code>Unknown&lt;/code>: Machine health checks are failing, eg &lt;code>kubelet&lt;/code> has stopped posting the status.&lt;/li>
&lt;li>&lt;code>Failed&lt;/code>: Machine health checks have failed for a prolonged time. Hence it is declared failed. &lt;code>MachineSet&lt;/code> controller will replace such machines immediately.&lt;/li>
&lt;li>&lt;code>Terminating&lt;/code>: Machine is being terminated. Terminating state is set immediately when the deletion is triggered for the &lt;code>machine&lt;/code> object. It also includes time when it&amp;rsquo;s being drained.&lt;/li>
&lt;/ul>
&lt;h1 id="troubleshooting">Troubleshooting&lt;/h1>
&lt;h3 id="my-machine-is-stuck-in-deletion-for-1-hr-why">My machine is stuck in deletion for 1 hr, why?&lt;/h3>
&lt;p>In most cases, the &lt;code>Machine.Status.LastOperation&lt;/code> provides information around why a machine can&amp;rsquo;t be deleted.
Though following could be the reasons but not limited to:&lt;/p>
&lt;ul>
&lt;li>Pod/s with misconfigured PDBs block the drain operation. PDBs with &lt;code>maxUnavailable&lt;/code> set to 0, doesn&amp;rsquo;t allow the eviction of the pods. Hence, drain/eviction is retried till &lt;code>MachineDrainTimeout&lt;/code>. Default &lt;code>MachineDrainTimeout&lt;/code> could be as large as ~2hours. Hence, blocking the machine deletion.
&lt;ul>
&lt;li>Short term: User can manually delete the pod in the question, &lt;em>with caution&lt;/em>.&lt;/li>
&lt;li>Long term: Please set more appropriate PDBs which allow disruption of at least one pod.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Expired cloud credentials can block the deletion of the machine from infrastructure.&lt;/li>
&lt;li>Cloud provider can&amp;rsquo;t delete the machine due to internal errors. Such situations are best debugged by using cloud provider specific CLI or cloud console.&lt;/li>
&lt;/ul>
&lt;h3 id="my-machine-is-not-joining-the-cluster-why">My machine is not joining the cluster, why?&lt;/h3>
&lt;p>In most cases, the &lt;code>Machine.Status.LastOperation&lt;/code> provides information around why a machine can&amp;rsquo;t be created.
It could possibly be debugged with following steps:&lt;/p>
&lt;ul>
&lt;li>Verify if the machine is actually created in the cloud. User can use the &lt;code>Machine.Spec.ProviderId&lt;/code> to query the machine in cloud.&lt;/li>
&lt;li>A Kubernetes node is generally bootstrapped with the cloud-config. Please verify, if &lt;code>MachineDeployment&lt;/code> is pointing the correct &lt;code>MachineClass&lt;/code>, and &lt;code>MachineClass&lt;/code> is pointing to the correct &lt;code>Secret&lt;/code>. The secret object contains the actual cloud-config in &lt;code>base64&lt;/code> format which will be used to boot the machine.&lt;/li>
&lt;li>User must also check the logs of the MCM pod to understand any broken logical flow of reconciliation.&lt;/li>
&lt;/ul>
&lt;h1 id="developer">Developer&lt;/h1>
&lt;h3 id="how-should-i-test-my-code-before-submitting-a-pr">How should I test my code before submitting a PR?&lt;/h3>
&lt;ul>
&lt;li>Developer can locally setup the MCM using following &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/docs/development/local_setup/">guide&lt;/a>&lt;/li>
&lt;li>Developer must also enhance the unit tests related to the incoming changes.&lt;/li>
&lt;li>Developer can locally run the unit test by executing:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>make test-unit
&lt;/code>&lt;/pre>&lt;h3 id="i-need-to-change-the-apis-what-are-the-recommended-steps">I need to change the APIs, what are the recommended steps?&lt;/h3>
&lt;p>Developer should add/update the API fields at both of the following places:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/types.go">https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/types.go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/pkg/apis/machine/v1alpha1">https://github.com/gardener/machine-controller-manager/tree/master/pkg/apis/machine/v1alpha1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Once API changes are done, auto-generate the code using following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>./hack/generate-code
&lt;/code>&lt;/pre>&lt;p>Please ignore the API-violation errors for now.&lt;/p>
&lt;h3 id="how-can-i-update-the-dependencies-of-mcm">How can I update the dependencies of MCM?&lt;/h3>
&lt;p>MCM uses &lt;code>gomod&lt;/code> for depedency management.
Developer should add/udpate depedency in the go.mod file. Please run following command to automatically revendor the dependencies.&lt;/p>
&lt;pre tabindex="0">&lt;code>make revendor
&lt;/code>&lt;/pre>&lt;h1 id="in-the-context-of-gardener">In the context of Gardener&lt;/h1>
&lt;h3 id="how-can-i-configure-mcm-using-shoot-resource">How can I configure MCM using Shoot resource?&lt;/h3>
&lt;p>All of the knobs of MCM can be configured by the &lt;code>workers&lt;/code> &lt;a href="https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L29-L126">section&lt;/a> of the shoot resource.&lt;/p>
&lt;ul>
&lt;li>Gardener creates a &lt;code>MachineDeployment&lt;/code> per zone for each worker-pool under &lt;code>workers&lt;/code> section.&lt;/li>
&lt;li>&lt;code>workers.dataVolumes&lt;/code> allows to attach multiple disks to a machine during creation. Refer the &lt;a href="https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L29-L126">link&lt;/a>.&lt;/li>
&lt;li>&lt;code>workers.machineControllerManager&lt;/code> allows configuration of multiple knobs of the &lt;code>MachineDeployment&lt;/code> from the shoot resource.&lt;/li>
&lt;/ul>
&lt;h3 id="how-is-my-worker-pool-spread-across-zones">How is my worker-pool spread across zones?&lt;/h3>
&lt;p>Shoot resource allows the worker-pool to spread across multiple zones using the field &lt;code>workers.zones&lt;/code>. Refer &lt;a href="https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L115">link&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Gardener creates one &lt;code>MachineDeployment&lt;/code> per zone. Each &lt;code>MachineDeployment&lt;/code> is initiated with the following replica:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>MachineDeployment.Spec.Replicas = (Workers.Minimum)/(Number of availibility zones)
&lt;/code>&lt;/pre></description></item><item><title>Docs: Outline</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/todo/outline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/todo/outline/</guid><description>
&lt;h1 id="machine-controller-manager">Machine Controller Manager&lt;/h1>
&lt;p>CORE &amp;ndash; ./machine-controller-manager(provider independent)
Out of tree : Machine controller (provider specific)
MCM is a set controllers:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Machine Deployment Controller&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Machine Set Controller&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Machine Controller&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Machine Safety Controller&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="questions-and-refactoring-suggestions">Questions and refactoring Suggestions&lt;/h2>
&lt;h3 id="refactoring">Refactoring&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Statement&lt;/th>
&lt;th>FilePath&lt;/th>
&lt;th>Status&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ConcurrentNodeSyncs” bad name - nothing to do with node syncs actually. &lt;br /> If its value is ’10’ then it will start 10 goroutines (workers) per resource type (machine, machinist, machinedeployment, provider-specific-class, node - study the different resource types.&lt;/td>
&lt;td>cmd/machine-controller-manager/app/options/options.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>LeaderElectionConfiguration is very similar to the one present in “client-go/tools/leaderelection/leaderelection.go” - can we simply used the one in client-go instead of defining again?&lt;/td>
&lt;td>pkg/options/types.go - MachineControllerManagerConfiguration&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Have all userAgents as constant. Right now there is just one.&lt;/td>
&lt;td>cmd/app/controllermanager.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Shouldn’t run function be defined on MCMServer struct itself?&lt;/td>
&lt;td>cmd/app/controllermanager.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>clientcmd.BuildConfigFromFlags fallsback to inClusterConfig which will surely not work as that is not the target. Should it not check and exit early?&lt;/td>
&lt;td>cmd/app/controllermanager.go - run Function&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A more direct way to create an in cluster config is using &lt;code>k8s.io/client-go/rest&lt;/code> -&amp;gt; rest.InClusterConfig instead of using clientcmd.BuildConfigFromFlags passing empty arguments and depending upon the implementation to fallback to creating a inClusterConfig. If they change the implementation that you get affected.&lt;/td>
&lt;td>cmd/app/controllermanager.go - run Function&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Introduce a method on MCMServer which gets a target KubeConfig and controlKubeConfig or alternatively which creates respective clients.&lt;/td>
&lt;td>cmd/app/controllermanager.go - run Function&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why can’t we use Kubernetes.NewConfigOrDie also for kubeClientControl?&lt;/td>
&lt;td>cmd/app/controllermanager.go - run Function&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>I do not see any benefit of client builders actually. All you need to do is pass in a config and then directly use client-go functions to create a client.&lt;/td>
&lt;td>cmd/app/controllermanager.go - run Function&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Function: getAvailableResources - rename this to getApiServerResources&lt;/td>
&lt;td>cmd/app/controllermanager.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Move the method which waits for API server to up and ready to a separate method which returns a discoveryClient when the API server is ready.&lt;/td>
&lt;td>cmd/app/controllermanager.go - getAvailableResources function&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Many methods in client-go used are now deprecated. Switch to the ones that are now recommended to be used instead.&lt;/td>
&lt;td>cmd/app/controllermanager.go - startControllers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>This method needs a general overhaul&lt;/td>
&lt;td>cmd/app/controllermanager.go - startControllers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>If the design is influenced/copied from KCM then its very different. There are different controller structs defined for deployment, replicaset etc which makes the code much more clearer. You can see “kubernetes/cmd/kube-controller-manager/apps.go” and then follow the trail from there. - agreed needs to be changed in future (if time permits)&lt;/td>
&lt;td>pkg/controller/controller.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>I am not sure why “MachineSetControlInterface”, “RevisionControlInterface”, “MachineControlInterface”, “FakeMachineControl” are defined in this file?&lt;/td>
&lt;td>pkg/controller/controller_util.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>IsMachineActive&lt;/code> - combine the first 2 conditions into one with OR.&lt;/td>
&lt;td>pkg/controller/controller_util.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Minor change - correct the comment, first word should always be the method name. Currently none of the comments have correct names.&lt;/td>
&lt;td>pkg/controller/controller_util.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>There are too many deep copies made. What is the need to make another deep copy in this method? You are not really changing anything here.&lt;/td>
&lt;td>pkg/controller/deployment.go - updateMachineDeploymentFinalizers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why can&amp;rsquo;t these validations be done as part of a validating webhook?&lt;/td>
&lt;td>pkg/controller/machineset.go - reconcileClusterMachineSet&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Small change to the following &lt;code>if&lt;/code> condition. &lt;code>else if&lt;/code> is not required a simple &lt;code>else&lt;/code> is sufficient. &lt;a href="#1.1-code1">Code1&lt;/a>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pkg/controller/machineset.go - reconcileClusterMachineSet&lt;/td>
&lt;td>pending&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why call these &lt;code>inactiveMachines&lt;/code>, these are live and running and therefore active.&lt;/td>
&lt;td>pkg/controller/machineset.go - terminateMachines&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="clarification">Clarification&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Statement&lt;/th>
&lt;th>FilePath&lt;/th>
&lt;th>Status&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Why are there 2 versions - internal and external versions?&lt;/td>
&lt;td>General&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Safety controller freezes MCM controllers in the following cases: &lt;br /> * Num replicas go beyond a threshold (above the defined replicas) &lt;br /> * Target API service is not reachable &lt;br /> There seems to be an overlap between DWD and MCM Safety controller. In the meltdown scenario why is MCM being added to DWD, you could have used Safety controller for that.&lt;/td>
&lt;td>General&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>All machine resources are v1alpha1 - should we not promote it to beta. V1alpha1 has a different semantic and does not give any confidence to the consumers.&lt;/td>
&lt;td>cmd/app/controllermanager.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Shouldn’t controller manager use context.Context instead of creating a stop channel? - Check if signals (&lt;code>os.Interrupt&lt;/code> and &lt;code>SIGTERM&lt;/code> are handled properly. Do not see code where this is handled currently.)&lt;/td>
&lt;td>cmd/app/controllermanager.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>What is the rationale behind a timeout of 10s? If the API server is not up, should this not just block as it can anyways not do anything. Also, if there is an error returned then you exit the MCM which does not make much sense actually as it will be started again and you will again do the poll for the API server to come back up. Forcing an exit of MCM will not have any impact on the reachability of the API server in anyway so why exit?&lt;/td>
&lt;td>cmd/app/controllermanager.go - getAvailableResources&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>There is a very weird check - &lt;code> availableResources[machineGVR] || availableResources[machineSetGVR] || availableResources[machineDeploymentGVR] &lt;/code> &lt;br> Shouldn’t this be conjunction instead of disjunction? &lt;br />* What happens if you do not find one or all of these resources? &lt;br /> Currently an error log is printed and nothing else is done. MCM can be used outside gardener context where consumers can directly create MachineClass and Machine and not create MachineSet / Maching Deployment. There is no distinction made between context (gardener or outside-gardener). &lt;br />&lt;/td>
&lt;td>cmd/app/controllermanager.go - StartControllers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Instead of having an empty select {} to block forever, isn’t it better to wait on the stop channel?&lt;/td>
&lt;td>cmd/app/controllermanager.go - StartControllers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Do we need provider specific queues and syncs and listers&lt;/td>
&lt;td>pkg/controller/controller.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why are resource types prefixed with “Cluster”? - not sure , check PR&lt;/td>
&lt;td>pkg/controller/controller.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>When will forgetAfterSuccess be false and why? - as per the current code this is never the case. - Himanshu will check&lt;/td>
&lt;td>cmd/app/controllermanager.go - createWorker&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>What is the use of “ExpectationsInterface” and “UIDTrackingContExpectations”? &lt;br />* All expectations related code should be in its own file “expectations.go” and not in this file.&lt;/td>
&lt;td>pkg/controller/controller_util.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why do we not use lister but directly use the controlMachingClient to get the deployment? Is it because you want to avoid any potential delays caused by update of the local cache held by the informer and accessed by the lister? What is the load on API server due to this?&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineDeployment&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why is this conversion needed? &lt;a href="#1.2-code2">code2&lt;/a>&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineDeployment&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>A deep copy of &lt;code>machineDeployment&lt;/code> is already passed and within the function another deepCopy is made. Any reason for it?&lt;/td>
&lt;td>pkg/controller/deployment.go - addMachineDeploymentFinalizers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>What is an &lt;code>Status.ObservedGeneration&lt;/code>? &lt;br /> *&lt;em>Read more about generations and observedGeneration at: &lt;br /> &lt;a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata&lt;/a> &lt;br />&lt;/em> &lt;a href="https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792">https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792&lt;/a> &lt;br /> Ideally the update to the &lt;code>ObservedGeneration&lt;/code> should only be made after successful reconciliation and not before. I see that this is just copied from &lt;code>deployment_controller.go&lt;/code> as is&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineDeployment&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Why and when will a &lt;code>MachineDeployment&lt;/code> be marked as frozen and when will it be un-frozen?&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineDeployment&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Shoudn&amp;rsquo;t the validation of the machine deployment be done during the creation via a validating webhook instead of allowing it to be stored in etcd and then failing the validation during sync? I saw the checks and these can be done via validation webhook.&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineDeployment&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RollbackTo has been marked as deprecated. What is the replacement? &lt;a href="#1.3-code3">code3&lt;/a>&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineDeployment&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>What is the max machineSet deletions that you could process in a single run? The reason for asking this question is that for every machineSetDeletion a new goroutine spawned. &lt;br />* Is the &lt;code>Delete&lt;/code> call a synchrounous call? Which means it blocks till the machineset deletion is triggered which then also deletes the machines (due to cascade-delete and blockOwnerDeletion= true)?&lt;/td>
&lt;td>pkg/controller/deployment.go - terminateMachineSets&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>If there are validation errors or error when creating label selector then a nil is returned. In the worker reconcile loop if the return value is nil then it will remove it from the queue (forget + done). What is the way to see any errors? Typically when we describe a resource the errors are displayed. Will these be displayed when we discribe a &lt;code>MachineDeployment&lt;/code>?&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineSet&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>If an error is returned by &lt;code>updateMachineSetStatus&lt;/code> and it is &lt;code>IsNotFound&lt;/code> error then returning an error will again queue the &lt;code>MachineSet&lt;/code>. Is this desired as &lt;code>IsNotFound&lt;/code> indicates the &lt;code>MachineSet&lt;/code> has been deleted and is no longer there?&lt;/td>
&lt;td>pkg/controller/deployment.go - reconcileClusterMachineSet&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>is &lt;code>machineControl.DeleteMachine&lt;/code> a synchronous operation which will wait till the machine has been deleted? Also where is the &lt;code>DeletionTimestamp&lt;/code> set on the &lt;code>Machine&lt;/code>? Will it be automatically done by the API server?&lt;/td>
&lt;td>pkg/controller/deployment.go - prepareMachineForDeletion&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="bugsenhancements">Bugs/Enhancements&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Statement + TODO&lt;/th>
&lt;th>FilePath&lt;/th>
&lt;th>Status&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>This defines QPS and Burst for its requests to the KAPI. Check if it would make sense to explicitly define a FlowSchema and PriorityLevelConfiguration to ensure that the requests from this controller are given a well-defined preference. What is the rational behind deciding these values?&lt;/td>
&lt;td>pkg/options/types.go - MachineControllerManagerConfiguration&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>In function “validateMachineSpec” fldPath func parameter is never used.&lt;/td>
&lt;td>pkg/apis/machine/validation/machine.go&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>If there is an update failure then this method recursively calls itself without any sort of delays which could lead to a LOT of load on the API server. (opened: &lt;a href="https://github.com/gardener/machine-controller-manager/issues/686">https://github.com/gardener/machine-controller-manager/issues/686&lt;/a>)&lt;/td>
&lt;td>pkg/controller/deployment.go - updateMachineDeploymentFinalizers&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>We are updating &lt;code>filteredMachines&lt;/code> by invoking &lt;code>syncMachinesNodeTemplates&lt;/code>, &lt;code>syncMachinesConfig&lt;/code> and &lt;code>syncMachinesClassKind&lt;/code> but we do not create any deepCopy here. Everywhere else the general principle is when you mutate always make a deepCopy and then mutate the copy instead of the original as a lister is used and that changes the cached copy. &lt;br /> &lt;code>Fix&lt;/code>: &lt;code>SatisfiedExpectations&lt;/code> check has been commented and there is a TODO there to fix it. Is there a PR for this?&lt;/td>
&lt;td>pkg/controller/machineset.go - reconcileClusterMachineSet&lt;/td>
&lt;td>pending&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Code references&lt;/p>
&lt;h1 id="11-code1">1.1 code1&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">if&lt;/span> machineSet.DeletionTimestamp == &lt;span style="color:#00f">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// manageReplicas is the core machineSet method where scale up/down occurs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// It is not called when deletion timestamp is set
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> manageReplicasErr = c.manageReplicas(ctx, filteredMachines, machineSet)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">​&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#00f">else&lt;/span> &lt;span style="color:#00f">if&lt;/span> machineSet.DeletionTimestamp != &lt;span style="color:#00f">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">//FIX: change this to simple else without the if
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="12-code2">1.2 code2&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">defer&lt;/span> dc.enqueueMachineDeploymentAfter(deployment, 10*time.Minute)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> * &lt;span style="color:#a31515">`Clarification`&lt;/span>: Why is this conversion needed&lt;span style="">?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = v1alpha1.Convert_v1alpha1_MachineDeployment_To_machine_MachineDeployment(deployment, internalMachineDeployment, &lt;span style="color:#00f">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="13-code3">1.3 code3&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// rollback is not re-entrant in case the underlying machine sets are updated with a new
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// revision so we should ensure that we won&amp;#39;t proceed to update machine sets until we
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// make sure that the deployment has cleaned up its rollback spec in subsequent enqueues.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">if&lt;/span> d.Spec.RollbackTo != &lt;span style="color:#00f">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">return&lt;/span> dc.rollback(ctx, d, machineSets, machineMap)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>