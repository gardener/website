<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener – Machine Controller Manager</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/</link><description>Recent content in Machine Controller Manager on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/other-components/machine-controller-manager/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Documents</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/documents/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/documents/</guid><description/></item><item><title>Docs: Proposals</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/proposals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/proposals/</guid><description/></item><item><title>Docs: ToDo</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/todo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/todo/</guid><description/></item><item><title>Docs: FAQ</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/faq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/faq/</guid><description>
&lt;h1 id="frequently-asked-questions">Frequently Asked Questions&lt;/h1>
&lt;p>The answers in this FAQ apply to the newest (HEAD) version of Machine Controller Manager. If
you&amp;rsquo;re using an older version of MCM please refer to corresponding version of
this document. Few of the answers assume that the MCM being used is in conjuction with &lt;a href="https://github.com/gardener/autoscaler">cluster-autoscaler&lt;/a>:&lt;/p>
&lt;h1 id="table-of-contents">Table of Contents:&lt;/h1>
&lt;!--- TOC BEGIN -->
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#basics">Basics&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#what-is-machine-controller-manager">What is Machine Controller Manager?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#Why-is-my-machine-deleted">Why is my machine deleted?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#What-are-the-different-sub-controllers-in-MCM">What are the different sub-controllers in MCM?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#What-is-safety-controller-in-MCM">What is Safety Controller in MCM?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-to">How to?&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-to-install-MCM-in-a-kubernetes-cluster">How to install MCM in a Kubernetes cluster?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-to-better-control-the-rollout-process-of-the-worker-nodes">How to better control the rollout process of the worker nodes?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-to-scale-down-machinedeployment-by-selective-deletion-of-machines">How to scale down MachineDeployment by selective deletion of machines?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-to-force-delete-a-machine">How to force delete a machine?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-to-pause-the-ongoing-rolling-update-of-the-machinedeployment">How to pause the ongoing rolling-update of the machinedeployment?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-to-delete-machine-object-immedietly-if-i-dont-have-access-to-it">How to delete machine object immedietly if I don&amp;rsquo;t have access to it?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-to-avoid-garbage-collection-of-your-node">How to avoid garbage collection of your node?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#internals">Internals&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#What-is-the-high-level-design-of-MCM">What is the high level design of MCM?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#What-are-the-different-configuration-options-in-MCM">What are the different configuration options in MCM?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#What-are-the-different-timeoutsconfigurations-in-a-machines-lifecycle">What are the different timeouts/configurations in a machine&amp;rsquo;s lifecycle?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-is-the-drain-of-a-machine-implemented">How is the drain of a machine implemented?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-are-the-stateful-applications-drained-during-machine-deletion">How are the stateful applications drained during machine deletion?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-does-maxEvictRetries-configuration-work-with-drainTimeout-configuration">How does maxEvictRetries configuration work with drainTimeout configuration?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#What-are-the-different-phases-of-a-machine">What are the different phases of a machine?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#what-health-checks-are-performed-on-a-machine">What health checks are performed on a machine?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-does-rate-limiting-replacement-of-machine-work-in-mcm-how-is-it-related-to-meltdown-protection">How does rate limiting replacement of machine work in MCM ? How is it related to meltdown protection?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-mcm-responds-when-scale-outscale-in-is-done-during-rolling-update-of-a-machinedeployment">How MCM responds when scale-out/scale-in is done during rolling update of a machinedeployment?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-some-unhealthy-machines-are-drained-quickly-">How some unhealthy machines are drained quickly?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#troubleshooting">Troubleshooting&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#My-machine-is-stuck-in-deletion-for-1-hr-why">My machine is stuck in deletion for 1 hr, why?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#My-machine-is-not-joining-the-cluster-why">My machine is not joining the cluster, why?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#developer">Developer&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-should-I-test-my-code-before-submitting-a-PR">How should I test my code before submitting a PR?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#I-need-to-change-the-APIs-what-are-the-recommended-steps">I need to change the APIs, what are the recommended steps?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-can-I-update-the-dependencies-of-MCM">How can I update the dependencies of MCM?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#in-the-context-of-gardener">In the context of Gardener&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-can-I-configure-MCM-using-Shoot-resource">How can I configure MCM using Shoot resource?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#How-is-my-worker-pool-spread-across-zones">How is my worker-pool spread across zones?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--- TOC END -->
&lt;h1 id="basics">Basics&lt;/h1>
&lt;h3 id="what-is-machine-controller-manager">What is Machine Controller Manager?&lt;/h3>
&lt;p>Machine Controller Manager aka MCM is a bunch of controllers used for the lifecycle management of the worker machines. It reconciles a set of CRDs such as &lt;code>Machine&lt;/code>, &lt;code>MachineSet&lt;/code>, &lt;code>MachineDeployment&lt;/code> which depicts the functionality of &lt;code>Pod&lt;/code>, &lt;code>Replicaset&lt;/code>, &lt;code>Deployment&lt;/code> of the core Kubernetes respectively. Read more about it at &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/docs">README&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Gardener uses MCM to manage its Kubernetes nodes of the shoot cluster. However, by design, MCM can be used independent of Gardener.&lt;/li>
&lt;/ul>
&lt;h3 id="why-is-my-machine-deleted">Why is my machine deleted?&lt;/h3>
&lt;p>A machine is deleted by MCM generally for 2 reasons-&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Machine is unhealthy for at least &lt;code>MachineHealthTimeout&lt;/code> period. The default &lt;code>MachineHealthTimeout&lt;/code> is 10 minutes.&lt;/p>
&lt;ul>
&lt;li>By default, a machine is considered unhealthy if any of the following node conditions - &lt;code>DiskPressure&lt;/code>, &lt;code>KernelDeadlock&lt;/code>, &lt;code>FileSystem&lt;/code>, &lt;code>Readonly&lt;/code> is set to &lt;code>true&lt;/code>, or &lt;code>KubeletReady&lt;/code> is set to &lt;code>false&lt;/code>. However, this is something that is configurable using the following &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/deployment/out-of-tree/deployment.yaml#L30">flag&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Machine is scaled down by the &lt;code>MachineDeployment&lt;/code> resource.&lt;/p>
&lt;ul>
&lt;li>This is very usual when an external controller cluster-autoscaler (aka CA) is used with MCM. CA deletes the under-utilized machines by scaling down the &lt;code>MachineDeployment&lt;/code>. Read more about cluster-autoscaler&amp;rsquo;s scale down behavior &lt;a href="https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md#how-does-scale-down-work">here&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="what-are-the-different-sub-controllers-in-mcm">What are the different sub-controllers in MCM?&lt;/h3>
&lt;p>MCM mainly contains the following sub-controllers:&lt;/p>
&lt;ul>
&lt;li>&lt;code>MachineDeployment Controller&lt;/code>: Responsible for reconciling the &lt;code>MachineDeployment&lt;/code> objects. It manages the lifecycle of the &lt;code>MachineSet&lt;/code> objects.&lt;/li>
&lt;li>&lt;code>MachineSet Controller&lt;/code>: Responsible for reconciling the &lt;code>MachineSet&lt;/code> objects. It manages the lifecycle of the &lt;code>Machine&lt;/code> objects.&lt;/li>
&lt;li>&lt;code>Machine Controller&lt;/code>: responsible for reconciling the &lt;code>Machine&lt;/code> objects. It manages the lifecycle of the actual VMs/machines created in cloud/on-prem. This controller has been moved out of tree. Please refer an AWS machine controller for more info - &lt;a href="https://github.com/gardener/machine-controller-manager-provider-gcp">link&lt;/a>.&lt;/li>
&lt;li>Safety-controller: Responsible for handling the unidentified/unknown behaviors from the cloud providers. Please read more about its functionality &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#what-is-safety-controller">below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h3 id="what-is-safety-controller-in-mcm">What is Safety Controller in MCM?&lt;/h3>
&lt;p>&lt;code>Safety Controller&lt;/code> contains following functions:&lt;/p>
&lt;ul>
&lt;li>Orphan VM handler:
&lt;ul>
&lt;li>It lists all the VMs in the cloud matching the &lt;code>tag&lt;/code> of given cluster name and maps the VMs with the &lt;code>machine&lt;/code> objects using the &lt;code>ProviderID&lt;/code> field. VMs without any backing &lt;code>machine&lt;/code> objects are logged and deleted after confirmation.&lt;/li>
&lt;li>This handler runs every 30 minutes and is configurable via &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go#L112">machine-safety-orphan-vms-period&lt;/a> flag.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Freeze mechanism:
&lt;ul>
&lt;li>&lt;code>Safety Controller&lt;/code> freezes the &lt;code>MachineDeployment&lt;/code> and &lt;code>MachineSet&lt;/code> controller if the number of &lt;code>machine&lt;/code> objects goes beyond a certain threshold on top of &lt;code>Spec.Replicas&lt;/code>. It can be configured by the flag &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go#L102-L103">&amp;ndash;safety-up or &amp;ndash;safety-down&lt;/a> and also &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go#L113">machine-safety-overshooting-period&lt;/a>.&lt;/li>
&lt;li>&lt;code>Safety Controller&lt;/code> freezes the functionality of the MCM if either of the &lt;code>target-apiserver&lt;/code> or the &lt;code>control-apiserver&lt;/code> is not reachable.&lt;/li>
&lt;li>&lt;code>Safety Controller&lt;/code> unfreezes the MCM automatically once situation is resolved to normal. A &lt;code>freeze&lt;/code> label is applied on &lt;code>MachineDeployment&lt;/code>/&lt;code>MachineSet&lt;/code> to enforce the freeze condition.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="how-to">How to?&lt;/h1>
&lt;h3 id="how-to-install-mcm-in-a-kubernetes-cluster">How to install MCM in a Kubernetes cluster?&lt;/h3>
&lt;p>MCM can be installed in a cluster with following steps:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Apply all the CRDs from &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/kubernetes/crds">here&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Apply all the deployment, role-related objects from &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/kubernetes/deployment/out-of-tree">here&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Control cluster is the one where the &lt;code>machine-*&lt;/code> objects are stored. Target cluster is where all the node objects are registered.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="how-to-better-control-the-rollout-process-of-the-worker-nodes">How to better control the rollout process of the worker nodes?&lt;/h3>
&lt;p>MCM allows configuring the rollout of the worker machines using &lt;code>maxSurge&lt;/code> and &lt;code>maxUnavailable&lt;/code> fields. These fields are applicable only during the rollout process and means nothing in general scale up/down scenarios.
The overall process is very similar to how the &lt;code>Deployment Controller&lt;/code> manages pods during &lt;code>RollingUpdate&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>maxSurge&lt;/code> refers to the number of additional machines that can be added on top of the &lt;code>Spec.Replicas&lt;/code> of MachineDeployment &lt;em>during rollout process&lt;/em>.&lt;/li>
&lt;li>&lt;code>maxUnavailable&lt;/code> refers to the number of machines that can be deleted from &lt;code>Spec.Replicas&lt;/code> field of the MachineDeployment &lt;em>during rollout process&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h3 id="how-to-scale-down-machinedeployment-by-selective-deletion-of-machines">How to scale down MachineDeployment by selective deletion of machines?&lt;/h3>
&lt;p>During scale down, triggered via &lt;code>MachineDeployment&lt;/code>/&lt;code>MachineSet&lt;/code>, MCM prefers to delete the &lt;code>machine/s&lt;/code> which have the least priority set.
Each &lt;code>machine&lt;/code> object has an annotation &lt;code>machinepriority.machine.sapcloud.io&lt;/code> set to &lt;code>3&lt;/code> by default. Admin can reduce the priority of the given machines by changing the annotation value to &lt;code>1&lt;/code>. The next scale down by &lt;code>MachineDeployment&lt;/code> shall delete the machines with the least priority first.&lt;/p>
&lt;h3 id="how-to-force-delete-a-machine">How to force delete a machine?&lt;/h3>
&lt;p>A machine can be force deleted by adding the label &lt;code>force-deletion: &amp;quot;True&amp;quot;&lt;/code> on the &lt;code>machine&lt;/code> object before executing the actual delete command. During force deletion, MCM skips the drain function and simply triggers the deletion of the machine. This label should be used with caution as it can violate the PDBs for pods running on the machine.&lt;/p>
&lt;h3 id="how-to-pause-the-ongoing-rolling-update-of-the-machinedeployment">How to pause the ongoing rolling-update of the machinedeployment?&lt;/h3>
&lt;p>An ongoing rolling-update of the machine-deployment can be paused by using &lt;code>spec.paused&lt;/code> field. See the example below:&lt;/p>
&lt;pre tabindex="0">&lt;code>apiVersion: machine.sapcloud.io/v1alpha1
kind: MachineDeployment
metadata:
name: test-machine-deployment
spec:
paused: true
&lt;/code>&lt;/pre>&lt;p>It can be unpaused again by removing the &lt;code>Paused&lt;/code> field from the machine-deployment.&lt;/p>
&lt;h3 id="how-to-delete-machine-object-immedietly-if-i-dont-have-access-to-it">How to delete machine object immedietly if I don&amp;rsquo;t have access to it?&lt;/h3>
&lt;p>If the user doesn&amp;rsquo;t have access to the machine objects (like in case of Gardener clusters) and they would like to replace a node immedietly then they can place the annotation &lt;code>node.machine.sapcloud.io/trigger-deletion-by-mcm: &amp;quot;true&amp;quot;&lt;/code> on their node. This will start the replacement of the machine with a new node.&lt;/p>
&lt;p>On the other hand if the user deletes the node object immedietly then replacement will start only after &lt;code>MachineHealthTimeout&lt;/code>.&lt;/p>
&lt;p>This annotation can also be used if the user wants to expedite the &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-does-rate-limiting-replacement-of-machine-work-in-mcm-how-is-it-related-to-meltdown-protection">replacement of unhealthy nodes&lt;/a>&lt;/p>
&lt;p>&lt;code>NOTE&lt;/code>:&lt;/p>
&lt;ul>
&lt;li>&lt;code>node.machine.sapcloud.io/trigger-deletion-by-mcm: &amp;quot;false&amp;quot;&lt;/code> annotation is NOT acted upon by MCM , neither does it mean that MCM will not replace this machine.&lt;/li>
&lt;li>this annotation would delete the desired machine but another machine would be created to maintain &lt;code>desired replicas&lt;/code> specified for the machineDeployment/machineSet. Currently if the user doesn&amp;rsquo;t have access to machineDeployment/machineSet then they cannot remove a machine without replacement.&lt;/li>
&lt;/ul>
&lt;h3 id="how-to-avoid-garbage-collection-of-your-node">How to avoid garbage collection of your node?&lt;/h3>
&lt;p>MCM provides an in-built safety mechanism to garbage collect VMs which have no corresponding machine object. This is done to save costs and is one of the key features of MCM.
However, sometimes users might like to add nodes directly to the cluster without the help of MCM and would prefer MCM to not garbage collect such VMs.
To do so they should remove/not-use tags on their VMs containing the following strings:&lt;/p>
&lt;ol>
&lt;li>&lt;code>kubernetes.io/cluster/&lt;/code>&lt;/li>
&lt;li>&lt;code>kubernetes.io/role/&lt;/code>&lt;/li>
&lt;li>&lt;code>kubernetes-io-cluster-&lt;/code>&lt;/li>
&lt;li>&lt;code>kubernetes-io-role-&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="internals">Internals&lt;/h1>
&lt;h3 id="what-is-the-high-level-design-of-mcm">What is the high level design of MCM?&lt;/h3>
&lt;p>Please refer the following &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/#design-of-machine-controller-manager">document&lt;/a>.&lt;/p>
&lt;h3 id="what-are-the-different-configuration-options-in-mcm">What are the different configuration options in MCM?&lt;/h3>
&lt;p>MCM allows configuring many knobs to fine-tune its behavior according to the user&amp;rsquo;s need.
Please refer to the &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/cmd/machine-controller-manager/app/options/options.go">link&lt;/a> to check the exact configuration options.&lt;/p>
&lt;h3 id="what-are-the-different-timeoutsconfigurations-in-a-machines-lifecycle">What are the different timeouts/configurations in a machine&amp;rsquo;s lifecycle?&lt;/h3>
&lt;p>A machine&amp;rsquo;s lifecycle is governed by mainly following timeouts, which can be configured &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/machine_objects/machine-deployment.yaml#L30-L34">here&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>MachineDrainTimeout&lt;/code>: Amount of time after which drain times out and the machine is force deleted. Default ~2 hours.&lt;/li>
&lt;li>&lt;code>MachineHealthTimeout&lt;/code>: Amount of time after which an unhealthy machine is declared &lt;code>Failed&lt;/code> and the machine is replaced by &lt;code>MachineSet&lt;/code> controller.&lt;/li>
&lt;li>&lt;code>MachineCreationTimeout&lt;/code>: Amount of time after which a machine creation is declared &lt;code>Failed&lt;/code> and the machine is replaced by the &lt;code>MachineSet&lt;/code> controller.&lt;/li>
&lt;li>&lt;code>NodeConditions&lt;/code>: List of node conditions which if set to true for &lt;code>MachineHealthTimeout&lt;/code> period, the machine is declared &lt;code>Failed&lt;/code> and replaced by &lt;code>MachineSet&lt;/code> controller.&lt;/li>
&lt;li>&lt;code>MaxEvictRetries&lt;/code>: An integer number depicting the number of times a failed &lt;em>eviction&lt;/em> should be retried on a pod during drain process. A pod is &lt;em>deleted&lt;/em> after &lt;code>max-retries&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h3 id="how-is-the-drain-of-a-machine-implemented">How is the drain of a machine implemented?&lt;/h3>
&lt;p>MCM imports the functionality from the upstream Kubernetes-drain library. Although, few parts have been modified to make it work best in the context of MCM. Drain is executed before machine deletion for graceful migration of the applications.
Drain internally uses the &lt;code>EvictionAPI&lt;/code> to evict the pods and triggers the &lt;code>Deletion&lt;/code> of pods after &lt;code>MachineDrainTimeout&lt;/code>. Please note:&lt;/p>
&lt;ul>
&lt;li>Stateless pods are evicted in parallel.&lt;/li>
&lt;li>Stateful applications (with PVCs) are serially evicted. Please find more info in this &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-are-the-stateful-applications-drained-during-machine-deletion">answer below&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h3 id="how-are-the-stateful-applications-drained-during-machine-deletion">How are the stateful applications drained during machine deletion?&lt;/h3>
&lt;p>Drain function serially evicts the stateful-pods. It is observed that serial eviction of stateful pods yields better overall availability of pods as the underlying cloud in most cases detaches and reattaches disks serially anyways.
It is implemented in the following manner:&lt;/p>
&lt;ul>
&lt;li>Drain lists all the pods with attached volumes. It evicts very first stateful-pod and waits for its related entry in Node object&amp;rsquo;s &lt;code>.status.volumesAttached&lt;/code> to be removed by KCM. It does the same for all the stateful-pods.&lt;/li>
&lt;li>It waits for &lt;code>PvDetachTimeout&lt;/code> (default 2 minutes) for a given pod&amp;rsquo;s PVC to be removed, else moves forward.&lt;/li>
&lt;/ul>
&lt;h3 id="how-does-maxevictretries-configuration-work-with-draintimeout-configuration">How does &lt;code>maxEvictRetries&lt;/code> configuration work with &lt;code>drainTimeout&lt;/code> configuration?&lt;/h3>
&lt;p>It is recommended to only set &lt;code>MachineDrainTimeout&lt;/code>. It satisfies the related requirements. &lt;code>MaxEvictRetries&lt;/code> is auto-calculated based on &lt;code>MachineDrainTimeout&lt;/code>, if &lt;code>maxEvictRetries&lt;/code> is not provided. Following will be the overall behavior of both configurations together:&lt;/p>
&lt;ul>
&lt;li>If &lt;code>maxEvictRetries&lt;/code> isn&amp;rsquo;t set and only &lt;code>maxDrainTimeout&lt;/code> is set:
&lt;ul>
&lt;li>MCM auto calculates the &lt;code>maxEvictRetries&lt;/code> based on the &lt;code>drainTimeout&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If &lt;code>drainTimeout&lt;/code> isn&amp;rsquo;t set and only &lt;code>maxEvictRetries&lt;/code> is set:
&lt;ul>
&lt;li>Default &lt;code>drainTimeout&lt;/code> and user provided &lt;code>maxEvictRetries&lt;/code> for each pod is considered.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If both &lt;code>maxEvictRetries&lt;/code> and &lt;code>drainTimoeut&lt;/code> are set:
&lt;ul>
&lt;li>Then both will be respected.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>If none are set:
&lt;ul>
&lt;li>Defaults are respected.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="what-are-the-different-phases-of-a-machine">What are the different phases of a machine?&lt;/h3>
&lt;p>A phase of a &lt;code>machine&lt;/code> can be identified with &lt;code>Machine.Status.CurrentStatus.Phase&lt;/code>. Following are the possible phases of a &lt;code>machine&lt;/code> object:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>Pending&lt;/code>: Machine creation call has succeeded. MCM is waiting for machine to join the cluster.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>CrashLoopBackOff&lt;/code>: Machine creation call has failed. MCM will retry the operation after a minor delay.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Running&lt;/code>: Machine creation call has succeeded. Machine has joined the cluster successfully and corresponding node doesn&amp;rsquo;t have &lt;code>node.gardener.cloud/critical-components-not-ready&lt;/code> taint.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Unknown&lt;/code>: Machine &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#what-health-checks-are-performed-on-a-machine">health checks&lt;/a> are failing, eg &lt;code>kubelet&lt;/code> has stopped posting the status.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Failed&lt;/code>: Machine health checks have failed for a prolonged time. Hence it is declared failed by &lt;code>Machine&lt;/code> controller in a &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#how-does-rate-limiting-replacement-of-machine-work-in-mcm-how-is-it-related-to-meltdown-protection">rate limited fashion&lt;/a>. &lt;code>Failed&lt;/code> machines get replaced immediately.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Terminating&lt;/code>: Machine is being terminated. Terminating state is set immediately when the deletion is triggered for the &lt;code>machine&lt;/code> object. It also includes time when it&amp;rsquo;s being drained.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;code>NOTE&lt;/code>: No phase means the machine is being created on the cloud-provider.&lt;/p>
&lt;h3 id="what-health-checks-are-performed-on-a-machine">What health checks are performed on a machine?&lt;/h3>
&lt;p>Health check performed on a machine are:&lt;/p>
&lt;ul>
&lt;li>Existense of corresponding node obj&lt;/li>
&lt;li>Status of certain user-configurable node conditions.
&lt;ul>
&lt;li>These conditions can be specified using the flag &lt;code>--node-conditions&lt;/code> for OOT MCM provider or can be specified per machine object.&lt;/li>
&lt;li>The default user configurable node conditions can be found &lt;a href="https://github.com/gardener/machine-controller-manager/blob/91eec24516b8339767db5a40e82698f9fe0daacd/pkg/util/provider/app/options/options.go#L60">here&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>True&lt;/code> status of &lt;code>NodeReady&lt;/code> condition . This condition shows kubelet&amp;rsquo;s status&lt;/li>
&lt;/ul>
&lt;p>If any of the above checks fails , the machine turns to &lt;code>Unknown&lt;/code> phase.&lt;/p>
&lt;h3 id="how-does-rate-limiting-replacement-of-machine-work-in-mcm-how-is-it-related-to-meltdown-protection">How does rate limiting replacement of machine work in MCM? How is it related to meltdown protection?&lt;/h3>
&lt;p>Currently MCM replaces only &lt;code>1&lt;/code> &lt;code>Unkown&lt;/code> machine at a time per machinedeployment. This means until the particular &lt;code>Unknown&lt;/code> machine get terminated and its replacement joins, no other &lt;code>Unknown&lt;/code> machine would be removed.&lt;/p>
&lt;p>The above is achieved by enabling &lt;code>Machine&lt;/code> controller to turn machine from &lt;code>Unknown&lt;/code> -&amp;gt; &lt;code>Failed&lt;/code> only if the above condition is met. &lt;code>MachineSet&lt;/code> controller on the other hand marks &lt;code>Failed&lt;/code> machine as &lt;code>Terminating&lt;/code> immediately.&lt;/p>
&lt;p>One reason for this rate limited replacement was to ensure that in case of network failures , where node&amp;rsquo;s kubelet can&amp;rsquo;t reach out to kube-apiserver , all nodes are not removed together i.e. &lt;code>meltdown protection&lt;/code>.
In gardener context however, &lt;a href="https://github.com/gardener/dependency-watchdog/blob/master/docs/concepts/prober.md#origin">DWD&lt;/a> is deployed to deal with this scenario, but to stay protected from corner cases , this mechanism has been introduced in MCM.&lt;/p>
&lt;p>&lt;code>NOTE&lt;/code>: Rate limiting replacement is not yet configurable&lt;/p>
&lt;h3 id="how-mcm-responds-when-scale-outscale-in-is-done-during-rolling-update-of-a-machinedeployment">How MCM responds when scale-out/scale-in is done during rolling update of a machinedeployment?&lt;/h3>
&lt;p>&lt;code>Machinedeployment&lt;/code> controller executes the logic of &lt;code>scaling&lt;/code> BEFORE logic of &lt;code>rollout&lt;/code>. It identifies &lt;code>scaling&lt;/code> by comparing the &lt;code>deployment.kubernetes.io/desired-replicas&lt;/code> of each machineset under the machinedeployment with machinedeployment&amp;rsquo;s &lt;code>.spec.replicas&lt;/code>. If the difference is found for any machineSet, a scaling event is detected.&lt;/p>
&lt;p>Case &lt;code>scale-out&lt;/code> -&amp;gt; ONLY New machineSet is scaled out &lt;br>
Case &lt;code>scale-in&lt;/code> -&amp;gt; ALL machineSets(new or old) are scaled in , in proportion to their replica count , any leftover is adjusted in the largest machineSet.&lt;/p>
&lt;p>During update for scaling event, a machineSet is updated if any of the below is true for it:&lt;/p>
&lt;ul>
&lt;li>&lt;code>.spec.Replicas&lt;/code> needs update&lt;/li>
&lt;li>&lt;code>deployment.kubernetes.io/desired-replicas&lt;/code> needs update&lt;/li>
&lt;/ul>
&lt;p>Once scaling is achieved, rollout continues.&lt;/p>
&lt;h2 id="how-some-unhealthy-machines-are-drained-quickly-">How some unhealthy machines are drained quickly ?&lt;/h2>
&lt;p>If a node is unhealthy for more than the &lt;code>machine-health-timeout&lt;/code> specified for the &lt;code>machine-controller&lt;/code>, the controller
health-check moves the machine phase to &lt;code>Failed&lt;/code>. By default, the &lt;code>machine-health-timeout&lt;/code> is 10` minutes.&lt;/p>
&lt;p>&lt;code>Failed&lt;/code> machines have their deletion timestamp set and the machine then moves to the &lt;code>Terminating&lt;/code> phase. The node
drain process is initiated. The drain process is invoked either &lt;em>gracefully&lt;/em> or &lt;em>forcefully&lt;/em>.&lt;/p>
&lt;p>The usual drain process is graceful. Pods are evicted from the node and the drain process waits until any existing
attached volumes are mounted on new node. However, if the node &lt;code>Ready&lt;/code> is &lt;code>False&lt;/code> or the &lt;code>ReadonlyFilesystem&lt;/code> is &lt;code>True&lt;/code>
for greater than &lt;code>5&lt;/code> minutes (non-configurable), then a forceful drain is initiated. In a forceful drain, pods are deleted
and &lt;code>VolumeAttachment&lt;/code> objects associated with the old node are also marked for deletion. This is followed by the deletion of the
cloud provider VM associated with the &lt;code>Machine&lt;/code> and then finally ending with the &lt;code>Node&lt;/code> object deletion.&lt;/p>
&lt;p>During the deletion of the VM we only delete the local data disks and boot disks associated with the VM. The disks associated
with persistent volumes are left un-touched as their attach/de-detach, mount/unmount processes are handled by k8s
attach-detach controller in conjunction with the CSI driver.&lt;/p>
&lt;h1 id="troubleshooting">Troubleshooting&lt;/h1>
&lt;h3 id="my-machine-is-stuck-in-deletion-for-1-hr-why">My machine is stuck in deletion for 1 hr, why?&lt;/h3>
&lt;p>In most cases, the &lt;code>Machine.Status.LastOperation&lt;/code> provides information around why a machine can&amp;rsquo;t be deleted.
Though following could be the reasons but not limited to:&lt;/p>
&lt;ul>
&lt;li>Pod/s with misconfigured PDBs block the drain operation. PDBs with &lt;code>maxUnavailable&lt;/code> set to 0, doesn&amp;rsquo;t allow the eviction of the pods. Hence, drain/eviction is retried till &lt;code>MachineDrainTimeout&lt;/code>. Default &lt;code>MachineDrainTimeout&lt;/code> could be as large as ~2hours. Hence, blocking the machine deletion.
&lt;ul>
&lt;li>Short term: User can manually delete the pod in the question, &lt;em>with caution&lt;/em>.&lt;/li>
&lt;li>Long term: Please set more appropriate PDBs which allow disruption of at least one pod.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Expired cloud credentials can block the deletion of the machine from infrastructure.&lt;/li>
&lt;li>Cloud provider can&amp;rsquo;t delete the machine due to internal errors. Such situations are best debugged by using cloud provider specific CLI or cloud console.&lt;/li>
&lt;/ul>
&lt;h3 id="my-machine-is-not-joining-the-cluster-why">My machine is not joining the cluster, why?&lt;/h3>
&lt;p>In most cases, the &lt;code>Machine.Status.LastOperation&lt;/code> provides information around why a machine can&amp;rsquo;t be created.
It could possibly be debugged with following steps:&lt;/p>
&lt;ul>
&lt;li>Firstly make sure all the relevant controllers like &lt;code>kube-controller-manager&lt;/code> , &lt;code>cloud-controller-manager&lt;/code> are running.&lt;/li>
&lt;li>Verify if the machine is actually created in the cloud. User can use the &lt;code>Machine.Spec.ProviderId&lt;/code> to query the machine in cloud.&lt;/li>
&lt;li>A Kubernetes node is generally bootstrapped with the cloud-config. Please verify, if &lt;code>MachineDeployment&lt;/code> is pointing the correct &lt;code>MachineClass&lt;/code>, and &lt;code>MachineClass&lt;/code> is pointing to the correct &lt;code>Secret&lt;/code>. The secret object contains the actual cloud-config in &lt;code>base64&lt;/code> format which will be used to boot the machine.&lt;/li>
&lt;li>User must also check the logs of the MCM pod to understand any broken logical flow of reconciliation.&lt;/li>
&lt;/ul>
&lt;h3 id="my-rolling-update-is-stuck--why">My rolling update is stuck , why?&lt;/h3>
&lt;p>The following can be the reason:&lt;/p>
&lt;ul>
&lt;li>Insufficient capacity for the new instance type the machineClass mentions.&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/faq/#my-machine-is-stuck-in-deletion-for-1-hr-why">Old machines are stuck in deletion&lt;/a>&lt;/li>
&lt;li>If you are using Gardener for setting up kubernetes cluster, then machine object won&amp;rsquo;t turn to &lt;code>Running&lt;/code> state until &lt;code>node-critical-components&lt;/code> are ready. Refer &lt;a href="https://gardener.cloud/docs/gardener/node-readiness/">this&lt;/a> for more details.&lt;/li>
&lt;/ul>
&lt;h1 id="developer">Developer&lt;/h1>
&lt;h3 id="how-should-i-test-my-code-before-submitting-a-pr">How should I test my code before submitting a PR?&lt;/h3>
&lt;ul>
&lt;li>Developer can locally setup the MCM using following &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/">guide&lt;/a>&lt;/li>
&lt;li>Developer must also enhance the unit tests related to the incoming changes.&lt;/li>
&lt;li>Developer can locally run the unit test by executing:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>make test-unit
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>Developer can locally run &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/integration_tests/">integration tests&lt;/a> to ensure basic functionality of MCM is not altered.&lt;/li>
&lt;/ul>
&lt;h3 id="i-need-to-change-the-apis-what-are-the-recommended-steps">I need to change the APIs, what are the recommended steps?&lt;/h3>
&lt;p>Developer should add/update the API fields at both of the following places:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/types.go">https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/types.go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/pkg/apis/machine/v1alpha1">https://github.com/gardener/machine-controller-manager/tree/master/pkg/apis/machine/v1alpha1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Once API changes are done, auto-generate the code using following command:&lt;/p>
&lt;pre tabindex="0">&lt;code>make generate
&lt;/code>&lt;/pre>&lt;p>Please ignore the API-violation errors for now.&lt;/p>
&lt;h3 id="how-can-i-update-the-dependencies-of-mcm">How can I update the dependencies of MCM?&lt;/h3>
&lt;p>MCM uses &lt;code>gomod&lt;/code> for depedency management.
Developer should add/udpate depedency in the go.mod file. Please run following command to automatically revendor the dependencies.&lt;/p>
&lt;pre tabindex="0">&lt;code>make revendor
&lt;/code>&lt;/pre>&lt;h1 id="in-the-context-of-gardener">In the context of Gardener&lt;/h1>
&lt;h3 id="how-can-i-configure-mcm-using-shoot-resource">How can I configure MCM using Shoot resource?&lt;/h3>
&lt;p>All of the knobs of MCM can be configured by the &lt;code>workers&lt;/code> &lt;a href="https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L29-L126">section&lt;/a> of the shoot resource.&lt;/p>
&lt;ul>
&lt;li>Gardener creates a &lt;code>MachineDeployment&lt;/code> per zone for each worker-pool under &lt;code>workers&lt;/code> section.&lt;/li>
&lt;li>&lt;code>workers.dataVolumes&lt;/code> allows to attach multiple disks to a machine during creation. Refer the &lt;a href="https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L29-L126">link&lt;/a>.&lt;/li>
&lt;li>&lt;code>workers.machineControllerManager&lt;/code> allows configuration of multiple knobs of the &lt;code>MachineDeployment&lt;/code> from the shoot resource.&lt;/li>
&lt;/ul>
&lt;h3 id="how-is-my-worker-pool-spread-across-zones">How is my worker-pool spread across zones?&lt;/h3>
&lt;p>Shoot resource allows the worker-pool to spread across multiple zones using the field &lt;code>workers.zones&lt;/code>. Refer &lt;a href="https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L115">link&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Gardener creates one &lt;code>MachineDeployment&lt;/code> per zone. Each &lt;code>MachineDeployment&lt;/code> is initiated with the following replica:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>MachineDeployment.Spec.Replicas = (Workers.Minimum)/(Number of availibility zones)
&lt;/code>&lt;/pre></description></item><item><title>Docs: Adding Support for a Cloud Provider</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/cp_support_new/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/cp_support_new/</guid><description>
&lt;h1 id="adding-support-for-a-new-provider">Adding support for a new provider&lt;/h1>
&lt;p>Steps to be followed while implementing a new (hyperscale) provider are mentioned below. This is the easiest way to add new provider support using a blueprint code.&lt;/p>
&lt;p>However, you may also develop your machine controller from scratch, which would provide you with more flexibility. First, however, make sure that your custom machine controller adheres to the &lt;code>Machine.Status&lt;/code> struct defined in the &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/types.go">MachineAPIs&lt;/a>. This will make sure the MCM can act with higher-level controllers like MachineSet and MachineDeployment controller. The key is the &lt;code>Machine.Status.CurrentStatus.Phase&lt;/code> key that indicates the status of the machine object.&lt;/p>
&lt;p>Our strong recommendation would be to follow the steps below. This provides the most flexibility required to support machine management for adding new providers. And if you feel to extend the functionality, feel free to update our &lt;a href="https://github.com/gardener/machine-controller-manager/tree/master/pkg/util/provider">machine controller libraries&lt;/a>.&lt;/p>
&lt;h2 id="setting-up-your-repository">Setting up your repository&lt;/h2>
&lt;ol>
&lt;li>Create a new empty repository named &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code> on GitHub username/project. Do not initialize this repository with a README.&lt;/li>
&lt;li>Copy the remote repository &lt;code>URL&lt;/code> (HTTPS/SSH) to this repository displayed once you create this repository.&lt;/li>
&lt;li>Now, on your local system, create directories as required. {your-github-username} given below could also be {github-project} depending on where you have created the new repository.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mkdir -p $GOPATH/src/github.com/{your-github-username}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Navigate to this created directory.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd $GOPATH/src/github.com/{your-github-username}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Clone &lt;a href="https://github.com/gardener/machine-controller-manager-provider-sampleprovider">this repository&lt;/a> on your local machine.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone git@github.com:gardener/machine-controller-manager-provider-sampleprovider.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Rename the directory from &lt;code>machine-controller-manager-provider-sampleprovider&lt;/code> to &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code>.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mv machine-controller-manager-provider-sampleprovider machine-controller-manager-provider-{provider-name}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Navigate into the newly-created directory.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd machine-controller-manager-provider-{provider-name}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Update the remote &lt;code>origin&lt;/code> URL to the newly created repository&amp;rsquo;s URL you had copied above.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git remote set-url origin git@github.com:{your-github-username}/machine-controller-manager-provider-{provider-name}.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Rename GitHub project from &lt;code>gardener&lt;/code> to &lt;code>{github-org/your-github-username}&lt;/code> wherever you have cloned the repository above. Also, edit all occurrences of the word &lt;code>sampleprovider&lt;/code> to &lt;code>{provider-name}&lt;/code> in the code. Then, use the hack script given below to do the same.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make rename-project PROJECT_NAME={github-org/your-github-username} PROVIDER_NAME={provider-name}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>eg:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> make rename-project PROJECT_NAME=gardener PROVIDER_NAME=AmazonWebServices (or)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> make rename-project PROJECT_NAME=githubusername PROVIDER_NAME=AWS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Now, commit your changes and push them upstream.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git add -A
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#a31515">&amp;#34;Renamed SampleProvide to {provider-name}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="code-changes-required">Code changes required&lt;/h2>
&lt;p>The contract between the Machine Controller Manager (MCM) and the Machine Controller (MC) AKA driver has been &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_error_codes/">documented here&lt;/a> and the &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/machinecodes/codes/codes.go">machine error codes can be found here&lt;/a>. You may refer to them for any queries.&lt;/p>
&lt;p>⚠️&lt;/p>
&lt;ul>
&lt;li>Keep in mind that &lt;strong>there should be a unique way to map between machine objects and VMs&lt;/strong>. This can be done by mapping machine object names with VM-Name/ tags/ other metadata.&lt;/li>
&lt;li>Optionally, there should also be a unique way to map a VM to its machine class object. This can be done by tagging VM objects with tags/resource groups associated with the machine class.&lt;/li>
&lt;/ul>
&lt;h4 id="steps-to-integrate">Steps to integrate&lt;/h4>
&lt;ol>
&lt;li>Update the &lt;code>pkg/provider/apis/provider_spec.go&lt;/code> specification file to reflect the structure of the &lt;code>ProviderSpec&lt;/code> blob. It typically contains the machine template details in the &lt;code>MachineClass&lt;/code> object. Follow the sample spec provided already in the file. A sample provider specification can be found &lt;a href="https://github.com/gardener/machine-controller-manager-provider-aws/blob/master/pkg/aws/apis/aws_provider_spec.go">here&lt;/a>.&lt;/li>
&lt;li>Fill in the methods described at &lt;code>pkg/provider/core.go&lt;/code> to manage VMs on your cloud provider. Comments are provided above each method to help you fill them up with desired &lt;code>REQUEST&lt;/code> and &lt;code>RESPONSE&lt;/code> parameters.
&lt;ul>
&lt;li>A sample provider implementation for these methods can be found &lt;a href="https://github.com/gardener/machine-controller-manager-provider-aws/blob/master/pkg/aws/core.go">here&lt;/a>.&lt;/li>
&lt;li>Fill in the required methods &lt;code>CreateMachine()&lt;/code>, and &lt;code>DeleteMachine()&lt;/code> methods.&lt;/li>
&lt;li>Optionally fill in methods like &lt;code>GetMachineStatus()&lt;/code>, &lt;code>ListMachines()&lt;/code>, and &lt;code>GetVolumeIDs()&lt;/code>. You may choose to fill these once the working of the required methods seems to be working.&lt;/li>
&lt;li>&lt;code>GetVolumeIDs()&lt;/code> expects VolumeIDs to be decoded from the volumeSpec based on the cloud provider.&lt;/li>
&lt;li>There is also an OPTIONAL method &lt;code>GenerateMachineClassForMigration()&lt;/code> that helps in migration of &lt;code>{ProviderSpecific}MachineClass&lt;/code> to &lt;code>MachineClass&lt;/code> CR (custom resource). This only makes sense if you have an existing implementation (in-tree) acting on different CRD types. You would like to migrate this. If not, you MUST return an error (machine error UNIMPLEMENTED) to avoid processing this step.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Perform validation of APIs that you have described and make it a part of your methods as required at each request.&lt;/li>
&lt;li>Write unit tests to make it work with your implementation by running &lt;code>make test&lt;/code>.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make test
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Re-generate the vendors to update any new vendors imported.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make revendor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Update the sample YAML files on the &lt;code>kubernetes/&lt;/code> directory to provide sample files through which the working of the machine controller can be tested.&lt;/li>
&lt;li>Update &lt;code>README.md&lt;/code> to reflect any additional changes&lt;/li>
&lt;/ol>
&lt;h2 id="testing-your-code-changes">Testing your code changes&lt;/h2>
&lt;p>Make sure &lt;code>$TARGET_KUBECONFIG&lt;/code> points to the cluster where you wish to manage machines. Likewise, &lt;code>$CONTROL_NAMESPACE&lt;/code> represents the namespaces where MCM is looking for machine CR objects, and &lt;code>$CONTROL_KUBECONFIG&lt;/code> points to the cluster that holds these machine CRs.&lt;/p>
&lt;ol>
&lt;li>On the first terminal running at &lt;code>$GOPATH/src/github.com/{github-org/your-github-username}/machine-controller-manager-provider-{provider-name}&lt;/code>,
&lt;ul>
&lt;li>Run the machine controller (driver) using the command below.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>On the second terminal pointing to &lt;code>$GOPATH/src/github.com/gardener&lt;/code>,
&lt;ul>
&lt;li>Clone the &lt;a href="https://github.com/gardener/machine-controller-manager">latest MCM code&lt;/a>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone git@github.com:gardener/machine-controller-manager.git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Navigate to the newly-created directory.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd machine-controller-manager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Deploy the required CRDs from the machine-controller-manager repo,
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f kubernetes/crds
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Run the machine-controller-manager in the &lt;code>master&lt;/code> branch
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>On the third terminal pointing to &lt;code>$GOPATH/src/github.com/{github-org/your-github-username}/machine-controller-manager-provider-{provider-name}&lt;/code>
&lt;ul>
&lt;li>Fill in the object files given below and deploy them as described below.&lt;/li>
&lt;li>Deploy the &lt;code>machine-class&lt;/code>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f kubernetes/machine-class.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Deploy the &lt;code>kubernetes secret&lt;/code> if required.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f kubernetes/secret.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Deploy the &lt;code>machine&lt;/code> object and make sure it joins the cluster successfully.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f kubernetes/machine.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Once the machine joins, you can test by deploying a machine-deployment.&lt;/li>
&lt;li>Deploy the &lt;code>machine-deployment&lt;/code> object and make sure it joins the cluster successfully.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f kubernetes/machine-deployment.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Make sure to delete both the &lt;code>machine&lt;/code> and &lt;code>machine-deployment&lt;/code> objects after use.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl delete -f kubernetes/machine.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kubectl delete -f kubernetes/machine-deployment.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="releasing-your-docker-image">Releasing your docker image&lt;/h2>
&lt;ol>
&lt;li>Make sure you have logged into gcloud/docker using the CLI.&lt;/li>
&lt;li>To release your docker image, run the following.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> make release IMAGE_REPOSITORY=&amp;lt;link-to-image-repo&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>A sample kubernetes deploy file can be found at &lt;code>kubernetes/deployment.yaml&lt;/code>. Update the same (with your desired MCM and MC images) to deploy your MCM pod.&lt;/li>
&lt;/ol></description></item><item><title>Docs: Deployment</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/</guid><description>
&lt;h1 id="deploying-the-machine-controller-manager-into-a-kubernetes-cluster">Deploying the Machine Controller Manager into a Kubernetes cluster&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/#deploying-the-machine-controller-manager-into-a-kubernetes-cluster">Deploying the Machine Controller Manager into a Kubernetes cluster&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/#prepare-the-cluster">Prepare the cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/#build-the-docker-image">Build the Docker image&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/#configuring-optional-parameters-while-deploying">Configuring optional parameters while deploying&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/#usage">Usage&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;p>As already mentioned, the Machine Controller Manager is designed to run as controller in a Kubernetes cluster. The existing source code can be compiled and tested on a local machine as described in &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/">Setting up a local development environment&lt;/a>. You can deploy the Machine Controller Manager using the steps described below.&lt;/p>
&lt;h2 id="prepare-the-cluster">Prepare the cluster&lt;/h2>
&lt;ul>
&lt;li>Connect to the remote kubernetes cluster where you plan to deploy the Machine Controller Manager using the kubectl. Set the environment variable KUBECONFIG to the path of the yaml file containing the cluster info.&lt;/li>
&lt;li>Now, create the required CRDs on the remote cluster using the following command,&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/crds
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="build-the-docker-image">Build the Docker image&lt;/h2>
&lt;blockquote>
&lt;p>⚠️ Modify the &lt;code>Makefile&lt;/code> to refer to your own registry.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Run the build which generates the binary to &lt;code>bin/machine-controller-manager&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Build docker image from latest compiled binary&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make docker-image
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Push the last created docker image onto the online docker registry.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make push
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Now you can deploy this docker image to your cluster. A &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/deployment/out-of-tree/deployment.yaml">sample development file&lt;/a> is provided. By default, the deployment manages the cluster it is running in. Optionally, the kubeconfig could also be passed as a flag as described in &lt;code>/kubernetes/deployment/out-of-tree/deployment.yaml&lt;/code>. This is done when you want your controller running outside the cluster to be managed from.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/deployment/out-of-tree/deployment.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Also deploy the required clusterRole and clusterRoleBindings&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/deployment/out-of-tree/clusterrole.yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/deployment/out-of-tree/clusterrolebinding.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="configuring-optional-parameters-while-deploying">Configuring optional parameters while deploying&lt;/h2>
&lt;p>Machine-controller-manager supports several configurable parameters while deploying. Refer to &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/deployment/out-of-tree/deployment.yaml#L21-L30">the following lines&lt;/a>, to know how each parameter can be configured, and what it&amp;rsquo;s purpose is for.&lt;/p>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>To start using Machine Controller Manager, follow the links given at &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/">usage here&lt;/a>.&lt;/p></description></item><item><title>Docs: Integration Tests</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/integration_tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/integration_tests/</guid><description>
&lt;h1 id="integration-tests">Integration tests&lt;/h1>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;h2 id="general-setup--configurations">General setup &amp;amp; configurations&lt;/h2>
&lt;p>Integration tests for &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code> can be executed manually by following below steps.&lt;/p>
&lt;ol>
&lt;li>Clone the repository &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code> on the local system.&lt;/li>
&lt;li>Navigate to &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code> directory and create a &lt;code>dev&lt;/code> sub-directory in it.&lt;/li>
&lt;li>Create a &lt;code>.env&lt;/code> file at the root of the &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code> project. This file serves as an environments file where all key-value pairs that are used in the &lt;code>Makefile&lt;/code> are defined.&lt;/li>
&lt;li>Copy the kubeconfig of the Control Cluster into &lt;code>dev/control-kubeconfig.yaml&lt;/code> and add an entry in the &lt;code>.env&lt;/code> file with &lt;code>CONTROL_KUBECONFIG=dev/control-kubeconfig.yaml&lt;/code>.&lt;/li>
&lt;li>Add &lt;code>CONTROL_NAMESPACE=&amp;lt;namespace of the control cluster&amp;gt;&lt;/code> to the &lt;code>.env&lt;/code> file. This is the namespace that is used to deploy all resources and run tests.&lt;/li>
&lt;li>(optional) Copy the kubeconfig of the Target Cluster into &lt;code>dev/target-kubeconfig.yaml&lt;/code> and add an entry in the &lt;code>.env&lt;/code> file with &lt;code>TARGET_KUBECONFIG=dev/target-kubeconfig.yaml&lt;/code>.&lt;/li>
&lt;li>If the tags on instances &amp;amp; associated resources on the provider are of &lt;code>String&lt;/code> type (for example, GCP tags on its instances are of type &lt;code>String&lt;/code> and not key-value pair) then add &lt;code>TAGS_ARE_STRINGS := true&lt;/code> in the &lt;code>Makefile&lt;/code> and export it. For GCP this has already been hard coded in the &lt;code>Makefile&lt;/code>.&lt;/li>
&lt;li>If the intention is to run any controllers in the control cluster, then &lt;code>.env&lt;/code> should have at least one of &lt;code>MCM_IMAGE&lt;/code> and &lt;code>MC_IMAGE&lt;/code> defined. These images will be used along with &lt;code>kubernetes/deployment.yaml&lt;/code> to deploy/update controllers in the Control Cluster. If the intention is to run the controllers locally then remove &lt;code>MCM_IMAGE&lt;/code> and &lt;code>MC_IMAGE&lt;/code> key-value pairs defined in &lt;code>.env&lt;/code> and set &lt;code>MACHINE_CONTROLLER_MANAGER_DEPLOYMENT_NAME=machine-controller-manager&lt;/code> in the &lt;code>Makefile&lt;/code> file.&lt;/li>
&lt;li>In order to apply the CRDs when the Control Cluster is a Gardener Shoot or if none of the controller images are specified, &lt;code>machine-controller-manager&lt;/code> repository will be cloned automatically. Incase, this repository already exists in local system, then create a softlink as below which helps to test changes in &lt;code>machine-controller-manager&lt;/code> quickly.
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ln -sf &amp;lt;path-for-machine-controller-manager-repo&amp;gt; dev/mcm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="scenario-based-additional-configurations">Scenario based additional configurations&lt;/h2>
&lt;h3 id="gardener-shoot-as-the-control-cluster">Gardener Shoot as the Control Cluster&lt;/h3>
&lt;p>If the Control Cluster is a Gardener Shoot cluster then,&lt;/p>
&lt;ol>
&lt;li>Deploy a &lt;code>Secret&lt;/code> named &lt;code>test-mc-secret&lt;/code> (that contains the provider secret and cloud-config) in the &lt;code>default&lt;/code> namespace of the Control Cluster.&lt;/li>
&lt;li>Create a &lt;code>dev/machineclassv1.yaml&lt;/code> file in the cloned repository and add an entry in the &lt;code>.env&lt;/code> file with &lt;code>MACHINECLASS_V1=dev/machineclassv1.yaml&lt;/code>. The name of the &lt;code>MachineClass&lt;/code> itself should be &lt;code>test-mc-v1&lt;/code>. The value of &lt;code>providerSpec.secretRef.name&lt;/code> should be &lt;code>test-mc-secret&lt;/code>.&lt;/li>
&lt;li>(Optional) Create an additional &lt;code>dev/machineclassv2.yaml&lt;/code> file similar to above but with a bigger machine type and add an entry in the &lt;code>.env&lt;/code> file with &lt;code>MACHINECLASS_V2=dev/machineclassv2.yaml&lt;/code>.&lt;/li>
&lt;/ol>
&lt;h3 id="gardener-seed-as-the-control-cluster">Gardener Seed as the Control Cluster&lt;/h3>
&lt;p>If the Control Cluster is a Gardener SEED cluster, then the suite ideally employs the already existing &lt;code>MachineClass&lt;/code> and Secrets. However,&lt;/p>
&lt;ol>
&lt;li>Define the variable &lt;code>IS_CONTROL_CLUSTER_SEED&lt;/code> in the &lt;code>.env&lt;/code> file and set it to &lt;code>true&lt;/code>.
&lt;code>Warning:&lt;/code> Make sure to set the &lt;code>CONTROL_NAMESPACE&lt;/code> variable to the shoot namespace where the control plane of the target resides.&lt;/li>
&lt;li>Please pass &lt;code>TARGET_RESOURCE_GROUP&lt;/code> in the &lt;code>.env&lt;/code> file. It will be used for the &lt;code>ResourceGroupName&lt;/code> in Azure clusters. Keep it as target cluster name for gardener shoot clusters.This is compulsory for Azure clusters.&lt;/li>
&lt;li>(Optional) User can employ a custom &lt;code>MachineClass&lt;/code> for the tests using below steps:
&lt;ol>
&lt;li>Deploy a &lt;code>Secret&lt;/code> named &lt;code>test-mc-secret&lt;/code> (that contains the provider secret and cloud-config) in the shoot namespace of the Control Cluster. That is, the value of &lt;code>metadata.namespace&lt;/code> should be &lt;code>technicalID&lt;/code> of the Shoot and it will be of the pattern &lt;code>shoot--&amp;lt;project&amp;gt;--&amp;lt;shoot-name&amp;gt;&lt;/code>.&lt;/li>
&lt;li>Create a &lt;code>dev/machineclassv1.yaml&lt;/code> file and add an entry in the &lt;code>.env&lt;/code> file with &lt;code>MACHINECLASS_V1=dev/machineclassv1.yaml&lt;/code>.
&lt;ol>
&lt;li>&lt;code>providerSpec.secretRef.name&lt;/code> should refer the secret created in the previous step.&lt;/li>
&lt;li>&lt;code>metadata.namespace&lt;/code> and &lt;code>providerSpec.secretRef.namespace&lt;/code> should be &lt;code>technicalID&lt;/code> (&lt;code>shoot--&amp;lt;project&amp;gt;--&amp;lt;shoot-name&amp;gt;&lt;/code>) of the shoot.&lt;/li>
&lt;li>The name of the &lt;code>MachineClass&lt;/code> itself should be &lt;code>test-mc-v1&lt;/code>.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="running-the-tests">Running the tests&lt;/h2>
&lt;ol>
&lt;li>There is a rule &lt;code>test-integration&lt;/code> in the &lt;code>Makefile&lt;/code>, which can be used to start the integration test:
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make test-integration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Starting integration tests...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running Suite: Controller Suite
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>===============================
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>The controllers log files (&lt;code>mcm_process.log&lt;/code> and &lt;code>mc_process.log&lt;/code>) are stored in &lt;code>.ci/controllers-test/logs&lt;/code> repo and can be used later.&lt;/li>
&lt;/ol>
&lt;h2 id="adding-integration-tests-for-new-providers">Adding Integration Tests for new providers&lt;/h2>
&lt;p>For a new provider, Running Integration tests works with no changes. But for the orphan resource test cases to work correctly, the provider-specific API calls and the Resource Tracker Interface (RTI) should be implemented. Please check &lt;a href="https://github.com/gardener/machine-controller-manager-provider-aws/blob/master/test/integration/provider/">&lt;code>machine-controller-manager-provider-aws&lt;/code>&lt;/a> for reference.&lt;/p>
&lt;h2 id="extending-integration-tests">Extending integration tests&lt;/h2>
&lt;ul>
&lt;li>Update &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/test/integration/common/framework.go#L481">ControllerTests&lt;/a> to be extend the testcases for all providers. Common testcases for machine|machineDeployment creation|deletion|scaling are packaged into &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/test/integration/common/framework.go#L481">ControllerTests&lt;/a>.&lt;/li>
&lt;li>To extend the provider specfic test cases, the changes should be done in the &lt;code>machine-controller-manager-provider-{provider-name}&lt;/code> repository. For example, to extended the testcases for &lt;code>machine-controller-manager-provider-aws&lt;/code>, make changes to &lt;code>test/integration/controller/controller_test.go&lt;/code> inside the &lt;code>machine-controller-manager-provider-aws&lt;/code> repository. &lt;code>commons&lt;/code> contains the &lt;code>Cluster&lt;/code> and &lt;code>Clientset&lt;/code> objects that makes it easy to extend the tests.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Local Setup</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/</guid><description>
&lt;h1 id="preparing-the-local-development-setup-mac-os-x">Preparing the Local Development Setup (Mac OS X)&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#preparing-the-local-development-setup-mac-os-x">Preparing the Local Development Setup (Mac OS X)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#installing-golang-environment">Installing Golang environment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#installing-docker-optional">Installing &lt;code>Docker&lt;/code> (Optional)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#setup-docker-hub-account-optional">Setup &lt;code>Docker Hub&lt;/code> account (Optional)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#local-development">Local development&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#installing-the-machine-controller-manager-locally">Installing the Machine Controller Manager locally&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#prepare-the-cluster">Prepare the cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#getting-started">Getting started&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#testing-machine-classes">Testing Machine Classes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/#usage">Usage&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;p>Conceptionally, the Machine Controller Manager is designed to run in a container within a Pod inside a Kubernetes cluster. For development purposes, you can run the Machine Controller Manager as a Go process on your local machine. This process connects to your remote cluster to manage VMs for that cluster. That means that the Machine Controller Manager runs outside a Kubernetes cluster which requires providing a &lt;a href="https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/">Kubeconfig&lt;/a> in your local filesystem and point the Machine Controller Manager to it when running it (see below).&lt;/p>
&lt;p>Although the following installation instructions are for Mac OS X, similar alternate commands could be found for any Linux distribution.&lt;/p>
&lt;h2 id="installing-golang-environment">Installing Golang environment&lt;/h2>
&lt;p>Install the latest version of Golang (at least &lt;code>v1.8.3&lt;/code> is required) by using &lt;a href="https://brew.sh/">Homebrew&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ brew install golang
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In order to perform linting on the Go source code, install &lt;a href="https://github.com/golang/lint">Golint&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go get -u golang.org/x/lint/golint
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="installing-docker-optional">Installing &lt;code>Docker&lt;/code> (Optional)&lt;/h2>
&lt;p>In case you want to build Docker images for the Machine Controller Manager you have to install Docker itself. We recommend using &lt;a href="https://docs.docker.com/docker-for-mac/">Docker for Mac OS X&lt;/a> which can be downloaded from &lt;a href="https://download.docker.com/mac/stable/Docker.dmg">here&lt;/a>.&lt;/p>
&lt;h2 id="setup-docker-hub-account-optional">Setup &lt;code>Docker Hub&lt;/code> account (Optional)&lt;/h2>
&lt;p>Create a Docker hub account at &lt;a href="https://hub.docker.com/">Docker Hub&lt;/a> if you don&amp;rsquo;t already have one.&lt;/p>
&lt;h2 id="local-development">Local development&lt;/h2>
&lt;p>⚠️ Before you start developing, please ensure to comply with the following requirements:&lt;/p>
&lt;ol>
&lt;li>You have understood the &lt;a href="https://kubernetes.io/docs/concepts/">principles of Kubernetes&lt;/a>, and its &lt;a href="https://kubernetes.io/docs/concepts/overview/components/">components&lt;/a>, what their purpose is and how they interact with each other.&lt;/li>
&lt;li>You have understood the &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/#design-of-machine-controller-manager">architecture of the Machine Controller Manager&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>The development of the Machine Controller Manager could happen by targeting any cluster. You basically need a Kubernetes cluster running on a set of machines. You just need the &lt;a href="https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/">Kubeconfig&lt;/a> file with the required access permissions attached to it.&lt;/p>
&lt;h3 id="installing-the-machine-controller-manager-locally">Installing the Machine Controller Manager locally&lt;/h3>
&lt;p>Clone the repository from GitHub.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git clone git@github.com:gardener/machine-controller-manager.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd machine-controller-manager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="prepare-the-cluster">Prepare the cluster&lt;/h2>
&lt;ul>
&lt;li>Connect to the remote kubernetes cluster where you plan to deploy the Machine Controller Manager using kubectl. Set the environment variable KUBECONFIG to the path of the yaml file containing your cluster info&lt;/li>
&lt;li>Now, create the required CRDs on the remote cluster using the following command,&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/crds.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>&lt;strong>Setup and Restore with Gardener&lt;/strong>&lt;/p>
&lt;p>&lt;em>Setup&lt;/em>&lt;/p>
&lt;p>In gardener access to static kubeconfig files is no longer supported due to security reasons. One needs to generate short-lived (max TTL = 1 day) admin kube configs for target and control clusters.
A convenience script/Makefile target has been provided to do the required initial setup which includes:&lt;/p>
&lt;ul>
&lt;li>Creating a temporary directory where target and control kubeconfigs will be stored.&lt;/li>
&lt;li>Create a request to generate the short lived admin kubeconfigs. These are downloaded and stored in the temporary folder created above.&lt;/li>
&lt;li>In gardener clusters &lt;code>DWD (Dependency Watchdog)&lt;/code> runs as an additional component which can interfere when MCM/CA is scaled down. To prevent that an annotation &lt;code>dependency-watchdog.gardener.cloud/ignore-scaling&lt;/code> is added to &lt;code>machine-controller-manager&lt;/code> deployment which prevents &lt;code>DWD&lt;/code> from scaling up the deployment replicas.&lt;/li>
&lt;li>Scales down &lt;code>machine-controller-manager&lt;/code> deployment in the control cluster to 0 replica.&lt;/li>
&lt;li>Creates the required &lt;code>.env&lt;/code> file and populates required environment variables which are then used by the &lt;code>Makefile&lt;/code> in both &lt;code>machine-controller-manager&lt;/code> and in &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> projects.&lt;/li>
&lt;li>Copies the generated and downloaded kubeconfig files for the target and control clusters to &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> project as well.&lt;/li>
&lt;/ul>
&lt;p>To do the above you can either invoke &lt;code>make gardener-setup&lt;/code> or you can directly invoke the script &lt;code>./hack/gardener_local_setup.sh&lt;/code>. If you invoke the script with &lt;code>-h or --help&lt;/code> option then it will give you all CLI options that one can pass.&lt;/p>
&lt;p>&lt;em>Restore&lt;/em>&lt;/p>
&lt;p>Once the testing is over you can invoke a convenience script/Makefile target which does the following:&lt;/p>
&lt;ul>
&lt;li>Removes all generated admin kubeconfig files from both &lt;code>machine-controller-manager&lt;/code> and in &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> projects.&lt;/li>
&lt;li>Removes the &lt;code>.env&lt;/code> file that was generated as part of the setup from both &lt;code>machine-controller-manager&lt;/code> and in &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> projects.&lt;/li>
&lt;li>Scales up &lt;code>machine-controller-manager&lt;/code> deployment in the control cluster back to 1 replica.&lt;/li>
&lt;li>Removes the annotation &lt;code>dependency-watchdog.gardener.cloud/ignore-scaling&lt;/code> that was added to prevent &lt;code>DWD&lt;/code> to scale up MCM.&lt;/li>
&lt;/ul>
&lt;p>To do the above you can either invoke &lt;code>make gardener-restore&lt;/code> or you can directly invoke the script &lt;code>./hack/gardener_local_restore.sh&lt;/code>. If you invoke the script with &lt;code>-h or --help&lt;/code> option then it will give you all CLI options that one can pass.&lt;/p>
&lt;p>&lt;strong>Setup and Restore without Gardener&lt;/strong>&lt;/p>
&lt;p>&lt;em>Setup&lt;/em>&lt;/p>
&lt;p>If you are not running MCM components in a gardener cluster, then it is assumed that there is not going to be any &lt;code>DWD (Dependency Watchdog)&lt;/code> component.
A convenience script/Makefile target has been provided to the required initial setup which includes:&lt;/p>
&lt;ul>
&lt;li>Copies the provided control and target kubeconfig files to &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> project.&lt;/li>
&lt;li>Scales down &lt;code>machine-controller-manager&lt;/code> deployment in the control cluster to 0 replica.&lt;/li>
&lt;li>Creates the required &lt;code>.env&lt;/code> file and populates required environment variables which are then used by the &lt;code>Makefile&lt;/code> in both &lt;code>machine-controller-manager&lt;/code> and in &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> projects.&lt;/li>
&lt;/ul>
&lt;p>To do the above you can either invoke &lt;code>make non-gardener-setup&lt;/code> or you can directly invoke the script &lt;code>./hack/non_gardener_local_setup.sh&lt;/code>. If you invoke the script with &lt;code>-h or --help&lt;/code> option then it will give you all CLI options that one can pass.&lt;/p>
&lt;p>&lt;em>Restore&lt;/em>&lt;/p>
&lt;p>Once the testing is over you can invoke a convenience script/Makefile target which does the following:&lt;/p>
&lt;ul>
&lt;li>Removes all provided kubeconfig files from both &lt;code>machine-controller-manager&lt;/code> and in &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> projects.&lt;/li>
&lt;li>Removes the &lt;code>.env&lt;/code> file that was generated as part of the setup from both &lt;code>machine-controller-manager&lt;/code> and in &lt;code>machine-controller-manager-provider-&amp;lt;provider-name&amp;gt;&lt;/code> projects.&lt;/li>
&lt;li>Scales up &lt;code>machine-controller-manager&lt;/code> deployment in the control cluster back to 1 replica.&lt;/li>
&lt;/ul>
&lt;p>To do the above you can either invoke &lt;code>make non-gardener-restore&lt;/code> or you can directly invoke the script &lt;code>./hack/non_gardener_local_restore.sh&lt;/code>. If you invoke the script with &lt;code>-h or --help&lt;/code> option then it will give you all CLI options that one can pass.&lt;/p>
&lt;p>Once the setup is done then you can start the &lt;code>machine-controller-manager&lt;/code> as a local process using the following &lt;code>Makefile&lt;/code> target:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I1227 11:08:19.963638 55523 controllermanager.go:204] Starting shared informers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I1227 11:08:20.766085 55523 controller.go:247] Starting machine-controller-manager
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>⚠️ The file &lt;code>dev/target-kubeconfig.yaml&lt;/code> points to the cluster whose nodes you want to manage. &lt;code>dev/control-kubeconfig.yaml&lt;/code> points to the cluster from where you want to manage the nodes from. However, &lt;code>dev/control-kubeconfig.yaml&lt;/code> is optional.&lt;/p>
&lt;p>The Machine Controller Manager should now be ready to manage the VMs in your kubernetes cluster.&lt;/p>
&lt;p>⚠️ This is assuming that your MCM is built to manage machines for any in-tree supported providers. There is a new way to deploy and manage out of tree (external) support for providers whose development can be &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/cp_support_new/">found here&lt;/a>&lt;/p>
&lt;h2 id="testing-machine-classes">Testing Machine Classes&lt;/h2>
&lt;p>To test the creation/deletion of a single instance for one particular machine class you can use the &lt;code>managevm&lt;/code> cli. The corresponding &lt;code>INFRASTRUCTURE-machine-class.yaml&lt;/code> and the &lt;code>INFRASTRUCTURE-secret.yaml&lt;/code> need to be defined upfront. To build and run it&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>GO111MODULE=on go build -mod=vendor -o managevm cmd/machine-controller-manager-cli/main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000"># create machine&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./managevm --secret PATH_TO/INFRASTRUCTURE-secret.yaml --machineclass PATH_TO/INFRASTRUCTURE-machine-class.yaml --classkind INFRASTRUCTURE --machinename test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000"># delete machine&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./managevm --secret PATH_TO/INFRASTRUCTURE-secret.yaml --machineclass PATH_TO/INFRASTRUCTURE-machine-class.yaml --classkind INFRASTRUCTURE --machinename test --machineid INFRASTRUCTURE:///REGION/INSTANCE_ID
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>To start using Machine Controller Manager, follow the links given at &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/">usage here&lt;/a>.&lt;/p></description></item><item><title>Docs: Machine</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/machine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/machine/</guid><description>
&lt;h1 id="creatingdeleting-machines-vm">Creating/Deleting machines (VM)&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine/#creatingdeleting-machines-vm">Creating/Deleting machines (VM)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine/#setting-up-your-usage-environment">Setting up your usage environment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine/#important">Important :&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine/#creating-machine">Creating machine&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine/#inspect-status-of-machine">Inspect status of machine&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine/#delete-machine">Delete machine&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="setting-up-your-usage-environment">Setting up your usage environment&lt;/h2>
&lt;ul>
&lt;li>Follow the &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/">steps described here&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="important-">Important :&lt;/h2>
&lt;blockquote>
&lt;p>Make sure that the &lt;code>kubernetes/machine_objects/machine.yaml&lt;/code> points to the same class name as the &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Similarly &lt;code>kubernetes/machine_objects/aws-machine-class.yaml&lt;/code> secret name and namespace should be same as that mentioned in &lt;code>kubernetes/secrets/aws-secret.yaml&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h2 id="creating-machine">Creating machine&lt;/h2>
&lt;ul>
&lt;li>Modify &lt;code>kubernetes/machine_objects/machine.yaml&lt;/code> as per your requirement and create the VM as shown below:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/machine_objects/machine.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You should notice that the Machine Controller Manager has immediately picked up your manifest and started to create a new machine by talking to the cloud provider.&lt;/p>
&lt;ul>
&lt;li>Check Machine Controller Manager machines in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine Running 5m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A new machine is created with the name provided in the &lt;code>kubernetes/machine_objects/machine.yaml&lt;/code> file.&lt;/p>
&lt;ul>
&lt;li>After a few minutes (~3 minutes for AWS), you should notice a new node joining the cluster. You can verify this by running:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE VERSION
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-14-52.eu-east-1.compute.internal. Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This shows that a new node has successfully joined the cluster.&lt;/p>
&lt;h2 id="inspect-status-of-machine">Inspect status of machine&lt;/h2>
&lt;p>To inspect the status of any created machine, run the command given below.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machine test-machine -o yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: machine.sapcloud.io/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubectl.kubernetes.io/last-applied-configuration: |&lt;span style="color:#a31515">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &lt;/span> {&lt;span style="color:#a31515">&amp;#34;apiVersion&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;machine.sapcloud.io/v1alpha1&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;kind&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;Machine&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;metadata&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;annotations&amp;#34;&lt;/span>:{},&lt;span style="color:#a31515">&amp;#34;labels&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>},&lt;span style="color:#a31515">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-machine&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;namespace&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>},&lt;span style="color:#a31515">&amp;#34;spec&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;class&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;kind&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;AWSMachineClass&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-aws&amp;#34;&lt;/span>}}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusterName: &lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creationTimestamp: 2017-12-27T06:58:21Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> finalizers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - machine.sapcloud.io/operator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> generation: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializers: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node: ip-10-250-14-52.eu-east-1.compute.internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test-label: test-label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: test-machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceVersion: &lt;span style="color:#a31515">&amp;#34;12616948&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selfLink: /apis/machine.sapcloud.io/v1alpha1/test-machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uid: 535e596c-ead3-11e7-a6c0-828f843e4186
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: AWSMachineClass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: test-aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerID: aws:///eu-east-1/i-00bef3f2618ffef23
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastHeartbeatTime: 2017-12-27T07:00:46Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastTransitionTime: 2017-12-27T06:59:16Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: kubelet has sufficient disk space available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: KubeletHasSufficientDisk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: OutOfDisk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastHeartbeatTime: 2017-12-27T07:00:46Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastTransitionTime: 2017-12-27T06:59:16Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: kubelet has sufficient memory available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: KubeletHasSufficientMemory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: MemoryPressure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastHeartbeatTime: 2017-12-27T07:00:46Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastTransitionTime: 2017-12-27T06:59:16Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: kubelet has no disk pressure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: KubeletHasNoDiskPressure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: DiskPressure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastHeartbeatTime: 2017-12-27T07:00:46Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastTransitionTime: 2017-12-27T07:00:06Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: kubelet is posting ready status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: KubeletReady
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Ready
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> currentStatus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: 2017-12-27T07:00:06Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phase: Running
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastOperation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description: Machine is now ready
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: 2017-12-27T07:00:06Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: Successful
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Create
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> node: ip-10-250-14-52.eu-west-1.compute.internal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="delete-machine">Delete machine&lt;/h2>
&lt;p>To delete the VM using the &lt;code>kubernetes/machine_objects/machine.yaml&lt;/code> as shown below&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl delete -f kubernetes/machine_objects/machine.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the Machine Controller Manager picks up the manifest immediately and starts to delete the existing VM by talking to the cloud provider. The node should be detached from the cluster in a few minutes (~1min for AWS).&lt;/p></description></item><item><title>Docs: Machine Deployment</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/</guid><description>
&lt;h1 id="maintaining-machine-replicas-using-machines-deployments">Maintaining machine replicas using machines-deployments&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#maintaining-machine-replicas-using-machines-deployments">Maintaining machine replicas using machines-deployments&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#setting-up-your-usage-environment">Setting up your usage environment&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#important-warning">Important ⚠️&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#creating-machine-deployment">Creating machine-deployment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#inspect-status-of-machine-deployment">Inspect status of machine-deployment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#health-monitoring">Health monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#update-your-machines">Update your machines&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#inspect-existing-cluster-configuration">Inspect existing cluster configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#perform-a-rolling-update">Perform a rolling update&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#re-check-cluster-configuration">Re-check cluster configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#more-variants-of-updates">More variants of updates&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#undo-an-update">Undo an update&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#pause-an-update">Pause an update&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_deployment/#delete-machine-deployment">Delete machine-deployment&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="setting-up-your-usage-environment">Setting up your usage environment&lt;/h2>
&lt;p>Follow the &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/">steps described here&lt;/a>&lt;/p>
&lt;h3 id="important-">Important ⚠️&lt;/h3>
&lt;blockquote>
&lt;p>Make sure that the &lt;code>kubernetes/machine_objects/machine-deployment.yaml&lt;/code> points to the same class name as the &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Similarly &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code> secret name and namespace should be same as that mentioned in &lt;code>kubernetes/secrets/aws-secret.yaml&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h2 id="creating-machine-deployment">Creating machine-deployment&lt;/h2>
&lt;ul>
&lt;li>Modify &lt;code>kubernetes/machine_objects/machine-deployment.yaml&lt;/code> as per your requirement. Modify the number of replicas to the desired number of machines. Then, create an machine-deployment.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/machine_objects/machine-deployment.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the Machine Controller Manager picks up the manifest immediately and starts to create a new machines based on the number of replicas you have provided in the manifest.&lt;/p>
&lt;ul>
&lt;li>Check Machine Controller Manager machine-deployments in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machinedeployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME READY DESIRED UP-TO-DATE AVAILABLE AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment 3 3 3 0 10m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will notice a new machine-deployment with your given name&lt;/p>
&lt;ul>
&lt;li>Check Machine Controller Manager machine-sets in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machineset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME DESIRED CURRENT READY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-5bc6dd7c8f 3 3 0 10m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will notice a new machine-set backing your machine-deployment&lt;/p>
&lt;ul>
&lt;li>Check Machine Controller Manager machines in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-5bc6dd7c8f-5d24b Pending 5m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-5bc6dd7c8f-6mpn4 Pending 5m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-5bc6dd7c8f-dpt2q Pending 5m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now you will notice N (number of replicas specified in the manifest) new machines whose name are prefixed with the machine-deployment object name that you created.&lt;/p>
&lt;ul>
&lt;li>After a few minutes (~3 minutes for AWS), you would see that new nodes have joined the cluster. You can see this using&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE VERSION
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-20-19.eu-west-1.compute.internal Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-27-123.eu-west-1.compute.internal Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-31-80.eu-west-1.compute.internal Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This shows how new nodes have joined your cluster&lt;/p>
&lt;h2 id="inspect-status-of-machine-deployment">Inspect status of machine-deployment&lt;/h2>
&lt;p>To inspect the status of any created machine-deployment run the command below,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machinedeployment test-machine-deployment -o yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You should get the following output.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: machine.sapcloud.io/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: MachineDeployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deployment.kubernetes.io/revision: &lt;span style="color:#a31515">&amp;#34;1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubectl.kubernetes.io/last-applied-configuration: |&lt;span style="color:#a31515">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &lt;/span> {&lt;span style="color:#a31515">&amp;#34;apiVersion&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;machine.sapcloud.io/v1alpha1&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;kind&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;MachineDeployment&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;metadata&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;annotations&amp;#34;&lt;/span>:{},&lt;span style="color:#a31515">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-machine-deployment&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;namespace&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>},&lt;span style="color:#a31515">&amp;#34;spec&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;minReadySeconds&amp;#34;&lt;/span>:200,&lt;span style="color:#a31515">&amp;#34;replicas&amp;#34;&lt;/span>:3,&lt;span style="color:#a31515">&amp;#34;selector&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;matchLabels&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>}},&lt;span style="color:#a31515">&amp;#34;strategy&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;rollingUpdate&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;maxSurge&amp;#34;&lt;/span>:1,&lt;span style="color:#a31515">&amp;#34;maxUnavailable&amp;#34;&lt;/span>:1},&lt;span style="color:#a31515">&amp;#34;type&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;RollingUpdate&amp;#34;&lt;/span>},&lt;span style="color:#a31515">&amp;#34;template&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;metadata&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;labels&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>}},&lt;span style="color:#a31515">&amp;#34;spec&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;class&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;kind&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;AWSMachineClass&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-aws&amp;#34;&lt;/span>}}}}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusterName: &lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creationTimestamp: 2017-12-27T08:55:56Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> generation: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializers: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: test-machine-deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceVersion: &lt;span style="color:#a31515">&amp;#34;12634168&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selfLink: /apis/machine.sapcloud.io/v1alpha1/test-machine-deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uid: c0b488f7-eae3-11e7-a6c0-828f843e4186
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> minReadySeconds: 200
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test-label: test-label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rollingUpdate:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxSurge: 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maxUnavailable: 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: RollingUpdate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creationTimestamp: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test-label: test-label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: AWSMachineClass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: test-aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> availableReplicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: 2017-12-27T08:57:22Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: 2017-12-27T08:57:22Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: Deployment has minimum availability.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: MinimumReplicasAvailable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> readyReplicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatedReplicas: 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="health-monitoring">Health monitoring&lt;/h2>
&lt;p>Health monitor is also applied similar to how it&amp;rsquo;s described for &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/">machine-sets&lt;/a>&lt;/p>
&lt;h2 id="update-your-machines">Update your machines&lt;/h2>
&lt;p>Let us consider the scenario where you wish to update all nodes of your cluster from t2.xlarge machines to m5.xlarge machines. Assume that your current &lt;em>test-aws&lt;/em> has its &lt;strong>spec.machineType: t2.xlarge&lt;/strong> and your deployment &lt;em>test-machine-deployment&lt;/em> points to this AWSMachineClass.&lt;/p>
&lt;h4 id="inspect-existing-cluster-configuration">Inspect existing cluster configuration&lt;/h4>
&lt;ul>
&lt;li>Check Nodes present in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE VERSION
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-20-19.eu-west-1.compute.internal Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-27-123.eu-west-1.compute.internal Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-31-80.eu-west-1.compute.internal Ready 1m v1.8.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Check Machine Controller Manager machine-sets in the cluster. You will notice one machine-set backing your machine-deployment&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machineset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME DESIRED CURRENT READY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-5bc6dd7c8f 3 3 3 10m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Login to your cloud provider (AWS). In the VM management console, you will find N VMs created of type t2.xlarge.&lt;/li>
&lt;/ul>
&lt;h4 id="perform-a-rolling-update">Perform a rolling update&lt;/h4>
&lt;p>To update this machine-deployment VMs to &lt;code>m5.xlarge&lt;/code>, we would do the following:&lt;/p>
&lt;ul>
&lt;li>Copy your existing aws-machine-class.yaml&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cp kubernetes/machine_classes/aws-machine-class.yaml kubernetes/machine_classes/aws-machine-class-new.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Modify aws-machine-class-new.yaml, and update its &lt;em>metadata.name: test-aws2&lt;/em> and &lt;em>spec.machineType: m5.xlarge&lt;/em>&lt;/li>
&lt;li>Now create this modified MachineClass&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl apply -f kubernetes/machine_classes/aws-machine-class-new.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Edit your existing machine-deployment&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl edit machinedeployment test-machine-deployment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Update from &lt;em>spec.template.spec.class.name: test-aws&lt;/em> to &lt;em>spec.template.spec.class.name: test-aws2&lt;/em>&lt;/li>
&lt;/ul>
&lt;h4 id="re-check-cluster-configuration">Re-check cluster configuration&lt;/h4>
&lt;p>After a few minutes (~3mins)&lt;/p>
&lt;ul>
&lt;li>Check nodes present in cluster now. They are different nodes.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE VERSION
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-11-171.eu-west-1.compute.internal Ready 4m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-17-213.eu-west-1.compute.internal Ready 5m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-31-81.eu-west-1.compute.internal Ready 5m v1.8.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Check Machine Controller Manager machine-sets in the cluster. You will notice two machine-sets backing your machine-deployment&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machineset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME DESIRED CURRENT READY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-5bc6dd7c8f 0 0 0 1h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-deployment-86ff45cc5 3 3 3 20m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Login to your cloud provider (AWS). In the VM management console, you will find N VMs created of type t2.xlarge in terminated state, and N new VMs of type m5.xlarge in running state.&lt;/li>
&lt;/ul>
&lt;p>This shows how a rolling update of a cluster from nodes with t2.xlarge to m5.xlarge went through.&lt;/p>
&lt;h4 id="more-variants-of-updates">More variants of updates&lt;/h4>
&lt;ul>
&lt;li>The above demonstration was a simple use case. This could be more complex like - updating the system disk image versions/ kubelet versions/ security patches etc.&lt;/li>
&lt;li>You can also play around with the maxSurge and maxUnavailable fields in machine-deployment.yaml&lt;/li>
&lt;li>You can also change the update strategy from rollingupdate to recreate&lt;/li>
&lt;/ul>
&lt;h2 id="undo-an-update">Undo an update&lt;/h2>
&lt;ul>
&lt;li>Edit the existing machine-deployment&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl edit machinedeployment test-machine-deployment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Edit the deployment to have this new field of &lt;em>spec.rollbackTo.revision: 0&lt;/em> as shown as comments in &lt;code>kubernetes/machine_objects/machine-deployment.yaml&lt;/code>&lt;/li>
&lt;li>This will undo your update to the previous version.&lt;/li>
&lt;/ul>
&lt;h2 id="pause-an-update">Pause an update&lt;/h2>
&lt;ul>
&lt;li>You can also pause the update while update is going on by editing the existing machine-deployment&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl edit machinedeployment test-machine-deployment
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>Edit the deployment to have this new field of &lt;em>spec.paused: true&lt;/em> as shown as comments in &lt;code>kubernetes/machine_objects/machine-deployment.yaml&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This will pause the rollingUpdate if it&amp;rsquo;s in process&lt;/p>
&lt;/li>
&lt;li>
&lt;p>To resume the update, edit the deployment as mentioned above and remove the field &lt;em>spec.paused: true&lt;/em> updated earlier&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="delete-machine-deployment">Delete machine-deployment&lt;/h2>
&lt;ul>
&lt;li>To delete the VM using the &lt;code>kubernetes/machine_objects/machine-deployment.yaml&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl delete -f kubernetes/machine_objects/machine-deployment.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The Machine Controller Manager picks up the manifest and starts to delete the existing VMs by talking to the cloud provider. The nodes should be detached from the cluster in a few minutes (~1min for AWS).&lt;/p></description></item><item><title>Docs: Machine Error Codes</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/machine_error_codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/machine_error_codes/</guid><description>
&lt;h1 id="machine-error-code-handling">Machine Error code handling&lt;/h1>
&lt;h2 id="notational-conventions">Notational Conventions&lt;/h2>
&lt;p>The keywords &amp;ldquo;MUST&amp;rdquo;, &amp;ldquo;MUST NOT&amp;rdquo;, &amp;ldquo;REQUIRED&amp;rdquo;, &amp;ldquo;SHALL&amp;rdquo;, &amp;ldquo;SHALL NOT&amp;rdquo;, &amp;ldquo;SHOULD&amp;rdquo;, &amp;ldquo;SHOULD NOT&amp;rdquo;, &amp;ldquo;RECOMMENDED&amp;rdquo;, &amp;ldquo;NOT RECOMMENDED&amp;rdquo;, &amp;ldquo;MAY&amp;rdquo;, and &amp;ldquo;OPTIONAL&amp;rdquo; are to be interpreted as described in &lt;a href="https://datatracker.ietf.org/doc/html/rfc2119">RFC 2119&lt;/a> (Bradner, S., &amp;ldquo;Key words for use in RFCs to Indicate Requirement Levels&amp;rdquo;, BCP 14, RFC 2119, March 1997).&lt;/p>
&lt;p>The key words &amp;ldquo;unspecified&amp;rdquo;, &amp;ldquo;undefined&amp;rdquo;, and &amp;ldquo;implementation-defined&amp;rdquo; are to be interpreted as described in the &lt;a href="https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf#page=18">rationale for the C99 standard&lt;/a>.&lt;/p>
&lt;p>An implementation is not compliant if it fails to satisfy one or more of the MUST, REQUIRED, or SHALL requirements for the protocols it implements.
An implementation is compliant if it satisfies all the MUST, REQUIRED, and SHALL requirements for the protocols it implements.&lt;/p>
&lt;h2 id="terminology">Terminology&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Term&lt;/th>
&lt;th>Definition&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CR&lt;/td>
&lt;td>Custom Resource (CR) is defined by a cluster admin using the Kubernetes Custom Resource Definition primitive.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>VM&lt;/td>
&lt;td>A Virtual Machine (VM) provisioned and managed by a provider. It could also refer to a physical machine in case of a bare metal provider.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Machine&lt;/td>
&lt;td>Machine refers to a VM that is provisioned/managed by MCM. It typically describes the metadata used to store/represent a Virtual Machine&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Node&lt;/td>
&lt;td>Native kubernetes &lt;code>Node&lt;/code> object. The objects you get to see when you do a &amp;ldquo;kubectl get nodes&amp;rdquo;. Although nodes can be either physical/virtual machines, for the purposes of our discussions it refers to a VM.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MCM&lt;/td>
&lt;td>&lt;a href="https://github.com/gardener/machine-controller-manager">Machine Controller Manager (MCM)&lt;/a> is the controller used to manage higher level Machine Custom Resource (CR) such as machine-set and machine-deployment CRs.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Provider/Driver/MC&lt;/td>
&lt;td>&lt;code>Provider&lt;/code> (or) &lt;code>Driver&lt;/code> (or) &lt;code>Machine Controller (MC)&lt;/code> is the driver responsible for managing machine objects present in the cluster from whom it manages these machines. A simple example could be creation/deletion of VM on the provider.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="pre-requisite">Pre-requisite&lt;/h2>
&lt;h3 id="machineclass-resources">MachineClass Resources&lt;/h3>
&lt;p>MCM introduces the CRD &lt;code>MachineClass&lt;/code>. This is a blueprint for creating machines that join a certain cluster as nodes in a certain role. The provider only works with &lt;code>MachineClass&lt;/code> resources that have the structure described here.&lt;/p>
&lt;h4 id="providerspec">ProviderSpec&lt;/h4>
&lt;p>The &lt;code>MachineClass&lt;/code> resource contains a &lt;code>providerSpec&lt;/code> field that is passed in the &lt;code>ProviderSpec&lt;/code> request field to CMI methods such as &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_error_codes/#createmachine">CreateMachine&lt;/a>. The &lt;code>ProviderSpec&lt;/code> can be thought of as a machine template from which the VM specification must be adopted. It can contain key-value pairs of these specs. An example for these key-value pairs are given below.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameter&lt;/th>
&lt;th>Mandatory&lt;/th>
&lt;th>Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>vmPool&lt;/code>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>&lt;code>string&lt;/code>&lt;/td>
&lt;td>VM pool name, e.g. &lt;code>TEST-WOKER-POOL&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>size&lt;/code>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>&lt;code>string&lt;/code>&lt;/td>
&lt;td>VM size, e.g. &lt;code>xsmall&lt;/code>, &lt;code>small&lt;/code>, etc. Each size maps to a number of CPUs and memory size.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>rootFsSize&lt;/code>&lt;/td>
&lt;td>No&lt;/td>
&lt;td>&lt;code>int&lt;/code>&lt;/td>
&lt;td>Root (&lt;code>/&lt;/code>) filesystem size in GB&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tags&lt;/code>&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>&lt;code>map&lt;/code>&lt;/td>
&lt;td>Tags to be put on the created VM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Most of the &lt;code>ProviderSpec&lt;/code> fields are not mandatory. If not specified, the provider passes an empty value in the respective &lt;code>Create VM&lt;/code> parameter.&lt;/p>
&lt;p>The &lt;code>tags&lt;/code> can be used to map a VM to its corresponding machine object&amp;rsquo;s Name&lt;/p>
&lt;p>The &lt;code>ProviderSpec&lt;/code> is validated by methods that receive it as a request field for presence of all mandatory parameters and tags, and for validity of all parameters.&lt;/p>
&lt;h4 id="secrets">Secrets&lt;/h4>
&lt;p>The &lt;code>MachineClass&lt;/code> resource also contains a &lt;code>secretRef&lt;/code> field that contains a reference to a secret. The keys of this secret are passed in the &lt;code>Secrets&lt;/code> request field to CMI methods.&lt;/p>
&lt;p>The secret can contain sensitive data such as&lt;/p>
&lt;ul>
&lt;li>&lt;code>cloud-credentials&lt;/code> secret data used to authenticate at the provider&lt;/li>
&lt;li>&lt;code>cloud-init&lt;/code> scripts used to initialize a new VM. The cloud-init script is expected to contain scripts to initialize the Kubelet and make it join the cluster.&lt;/li>
&lt;/ul>
&lt;h4 id="identifying-cluster-machines">Identifying Cluster Machines&lt;/h4>
&lt;p>To implement certain methods, the provider should be able to identify all machines associated with a particular Kubernetes cluster. This can be achieved using one/more of the below mentioned ways:&lt;/p>
&lt;ul>
&lt;li>Names of VMs created by the provider are prefixed by the cluster ID specified in the ProviderSpec.&lt;/li>
&lt;li>VMs created by the provider are tagged with the special tags like &lt;code>kubernetes.io/cluster&lt;/code> (for the cluster ID) and &lt;code>kubernetes.io/role&lt;/code> (for the role), specified in the ProviderSpec.&lt;/li>
&lt;li>Mapping &lt;code>Resource Groups&lt;/code> to individual cluster.&lt;/li>
&lt;/ul>
&lt;h3 id="error-scheme">Error Scheme&lt;/h3>
&lt;p>All provider API calls defined in this spec MUST return a &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/machinecodes/codes/codes.go">machine error status&lt;/a>, which is very similar to &lt;a href="https://github.com/grpc/grpc/blob/master/src/proto/grpc/status/status.proto">standard machine status&lt;/a>.&lt;/p>
&lt;h3 id="machine-provider-interface">Machine Provider Interface&lt;/h3>
&lt;ul>
&lt;li>The provider MUST have a unique way to map a &lt;code>machine object&lt;/code> to a &lt;code>VM&lt;/code> which triggers the deletion for the corresponding VM backing the machine object.&lt;/li>
&lt;li>The provider SHOULD have a unique way to map the &lt;code>ProviderSpec&lt;/code> of a machine-class to a unique &lt;code>Cluster&lt;/code>. This avoids deletion of other machines, not backed by the MCM.&lt;/li>
&lt;/ul>
&lt;h4 id="createmachine">&lt;code>CreateMachine&lt;/code>&lt;/h4>
&lt;p>A Provider is REQUIRED to implement this interface method.
This interface method will be called by the MCM to provision a new VM on behalf of the requesting machine object.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>This call requests the provider to create a VM backing the machine-object.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If VM backing the &lt;code>Machine.Name&lt;/code> already exists, and is compatible with the specified &lt;code>Machine&lt;/code> object in the &lt;code>CreateMachineRequest&lt;/code>, the Provider MUST reply &lt;code>0 OK&lt;/code> with the corresponding &lt;code>CreateMachineResponse&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider can OPTIONALLY make use of the MachineClass supplied in the &lt;code>MachineClass&lt;/code> in the &lt;code>CreateMachineRequest&lt;/code> to communicate with the provider.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider can OPTIONALLY make use of the secrets supplied in the &lt;code>Secret&lt;/code> in the &lt;code>CreateMachineRequest&lt;/code> to communicate with the provider.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider can OPTIONALLY make use of the &lt;code>Status.LastKnownState&lt;/code> in the &lt;code>Machine&lt;/code> object to decode the state of the VM operation based on the last known state of the VM. This can be useful to restart/continue an operations which are mean&amp;rsquo;t to be atomic.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider MUST have a unique way to map a &lt;code>machine object&lt;/code> to a &lt;code>VM&lt;/code>. This could be implicitly provided by the provider by letting you set VM-names (or) could be explicitly specified by the provider using appropriate tags to map the same.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This operation SHOULD be idempotent.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;code>CreateMachineResponse&lt;/code> returned by this method is expected to return&lt;/p>
&lt;ul>
&lt;li>&lt;code>ProviderID&lt;/code> that uniquely identifys the VM at the provider. This is expected to match with the node.Spec.ProviderID on the node object.&lt;/li>
&lt;li>&lt;code>NodeName&lt;/code> that is the expected name of the machine when it joins the cluster. It must match with the node name.&lt;/li>
&lt;li>&lt;code>LastKnownState&lt;/code> is an OPTIONAL field that can store details of the last known state of the VM. It can be used by future operation calls to determine current infrastucture state. This state is saved on the machine object.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// CreateMachine call is responsible for VM creation on the provider
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>CreateMachine(context.Context, &lt;span style="">*&lt;/span>CreateMachineRequest) (&lt;span style="">*&lt;/span>CreateMachineResponse, error)&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// CreateMachineRequest is the create request for VM creation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type CreateMachineRequest struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Machine object from whom VM is to be created
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Machine &lt;span style="">*&lt;/span>v1alpha1.Machine&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// MachineClass backing the machine object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> MachineClass &lt;span style="">*&lt;/span>v1alpha1.MachineClass&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Secret backing the machineClass object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Secret &lt;span style="">*&lt;/span>corev1.Secret&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// CreateMachineResponse is the create response for VM creation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type CreateMachineResponse struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// ProviderID is the unique identification of the VM at the cloud provider.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#008000">// ProviderID typically matches with the node.Spec.ProviderID on the node object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#008000">// Eg: gce://project-name/region/vm-ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> ProviderID &lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// NodeName is the name of the node-object registered to kubernetes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> NodeName &lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// LastKnownState represents the last state of the VM during an creation/deletion error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> LastKnownState &lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="createmachine-errors">CreateMachine Errors&lt;/h5>
&lt;p>If the provider is unable to complete the CreateMachine call successfully, it MUST return a non-ok ginterface method code in the machine status.
If the conditions defined below are encountered, the provider MUST return the specified machine error code.
The MCM MUST implement the specified error recovery behavior when it encounters the machine error code.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>machine Code&lt;/th>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Recovery Behavior&lt;/th>
&lt;th>Auto Retry Required&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 OK&lt;/td>
&lt;td>Successful&lt;/td>
&lt;td>The call was successful in creating/adopting a VM that matches supplied creation request. The &lt;code>CreateMachineResponse&lt;/code> is returned with desired values&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 CANCELED&lt;/td>
&lt;td>Cancelled&lt;/td>
&lt;td>Call was cancelled. Perform any pending clean-up tasks and return the call&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2 UNKNOWN&lt;/td>
&lt;td>Something went wrong&lt;/td>
&lt;td>Not enough information on what went wrong&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3 INVALID_ARGUMENT&lt;/td>
&lt;td>Re-check supplied parameters&lt;/td>
&lt;td>Re-check the supplied &lt;code>Machine.Name&lt;/code> and &lt;code>ProviderSpec&lt;/code>. Make sure all parameters are in permitted range of values. Exact issue to be given in &lt;code>.message&lt;/code>&lt;/td>
&lt;td>Update providerSpec to fix issues.&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4 DEADLINE_EXCEEDED&lt;/td>
&lt;td>Timeout&lt;/td>
&lt;td>The call processing exceeded supplied deadline&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6 ALREADY_EXISTS&lt;/td>
&lt;td>Already exists but desired parameters doesn&amp;rsquo;t match&lt;/td>
&lt;td>Parameters of the existing VM don&amp;rsquo;t match the ProviderSpec&lt;/td>
&lt;td>Create machine with a different name&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7 PERMISSION_DENIED&lt;/td>
&lt;td>Insufficent permissions&lt;/td>
&lt;td>The requestor doesn&amp;rsquo;t have enough permissions to create an VM and it&amp;rsquo;s required dependencies&lt;/td>
&lt;td>Update requestor permissions to grant the same&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8 RESOURCE_EXHAUSTED&lt;/td>
&lt;td>Resource limits have been reached&lt;/td>
&lt;td>The requestor doesn&amp;rsquo;t have enough resource limits to process this creation request&lt;/td>
&lt;td>Enhance resource limits associated with the user/account to process this&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9 PRECONDITION_FAILED&lt;/td>
&lt;td>VM is in inconsistent state&lt;/td>
&lt;td>The VM is in a state that is invalid for this operation&lt;/td>
&lt;td>Manual intervention might be needed to fix the state of the VM&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10 ABORTED&lt;/td>
&lt;td>Operation is pending&lt;/td>
&lt;td>Indicates that there is already an operation pending for the specified machine&lt;/td>
&lt;td>Wait until previous pending operation is processed&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11 OUT_OF_RANGE&lt;/td>
&lt;td>Resources were out of range&lt;/td>
&lt;td>The requested number of CPUs, memory size, of FS size in ProviderSpec falls outside of the corresponding valid range&lt;/td>
&lt;td>Update request paramaters to request valid resource requests&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12 UNIMPLEMENTED&lt;/td>
&lt;td>Not implemented&lt;/td>
&lt;td>Unimplemented indicates operation is not implemented or not supported/enabled in this service.&lt;/td>
&lt;td>Retry with an alternate logic or implement this method at the provider. Most methods by default are in this state&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13 INTERNAL&lt;/td>
&lt;td>Major error&lt;/td>
&lt;td>Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.&lt;/td>
&lt;td>Needs manual intervension to fix this&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14 UNAVAILABLE&lt;/td>
&lt;td>Not Available&lt;/td>
&lt;td>Unavailable indicates the service is currently unavailable.&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16 UNAUTHENTICATED&lt;/td>
&lt;td>Missing provider credentials&lt;/td>
&lt;td>Request does not have valid authentication credentials for the operation&lt;/td>
&lt;td>Fix the provider credentials&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The status &lt;code>message&lt;/code> MUST contain a human readable description of error, if the status &lt;code>code&lt;/code> is not &lt;code>OK&lt;/code>.
This string MAY be surfaced by MCM to end users.&lt;/p>
&lt;h4 id="deletemachine">&lt;code>DeleteMachine&lt;/code>&lt;/h4>
&lt;p>A Provider is REQUIRED to implement this driver call.
This driver call will be called by the MCM to deprovision/delete/terminate a VM backed by the requesting machine object.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>If a VM corresponding to the specified machine-object&amp;rsquo;s name does not exist or the artifacts associated with the VM do not exist anymore (after deletion), the Provider MUST reply &lt;code>0 OK&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider SHALL only act on machines belonging to the cluster-id/cluster-name obtained from the &lt;code>ProviderSpec&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider can OPTIONALY make use of the secrets supplied in the &lt;code>Secrets&lt;/code> map in the &lt;code>DeleteMachineRequest&lt;/code> to communicate with the provider.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider can OPTIONALY make use of the &lt;code>Spec.ProviderID&lt;/code> map in the &lt;code>Machine&lt;/code> object.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider can OPTIONALLY make use of the &lt;code>Status.LastKnownState&lt;/code> in the &lt;code>Machine&lt;/code> object to decode the state of the VM operation based on the last known state of the VM. This can be useful to restart/continue an operations which are mean&amp;rsquo;t to be atomic.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>This operation SHOULD be idempotent.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The provider must have a unique way to map a &lt;code>machine object&lt;/code> to a &lt;code>VM&lt;/code> which triggers the deletion for the corresponding VM backing the machine object.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;code>DeleteMachineResponse&lt;/code> returned by this method is expected to return&lt;/p>
&lt;ul>
&lt;li>&lt;code>LastKnownState&lt;/code> is an OPTIONAL field that can store details of the last known state of the VM. It can be used by future operation calls to determine current infrastucture state. This state is saved on the machine object.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// DeleteMachine call is responsible for VM deletion/termination on the provider
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>DeleteMachine(context.Context, &lt;span style="">*&lt;/span>DeleteMachineRequest) (&lt;span style="">*&lt;/span>DeleteMachineResponse, error)&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// DeleteMachineRequest is the delete request for VM deletion
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type DeleteMachineRequest struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Machine object from whom VM is to be deleted
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Machine &lt;span style="">*&lt;/span>v1alpha1.Machine&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// MachineClass backing the machine object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> MachineClass &lt;span style="">*&lt;/span>v1alpha1.MachineClass&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Secret backing the machineClass object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Secret &lt;span style="">*&lt;/span>corev1.Secret&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// DeleteMachineResponse is the delete response for VM deletion
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type DeleteMachineResponse struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// LastKnownState represents the last state of the VM during an creation/deletion error
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> LastKnownState &lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="deletemachine-errors">DeleteMachine Errors&lt;/h5>
&lt;p>If the provider is unable to complete the DeleteMachine call successfully, it MUST return a non-ok machine code in the machine status.
If the conditions defined below are encountered, the provider MUST return the specified machine error code.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>machine Code&lt;/th>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Recovery Behavior&lt;/th>
&lt;th>Auto Retry Required&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 OK&lt;/td>
&lt;td>Successful&lt;/td>
&lt;td>The call was successful in deleting a VM that matches supplied deletion request.&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 CANCELED&lt;/td>
&lt;td>Cancelled&lt;/td>
&lt;td>Call was cancelled. Perform any pending clean-up tasks and return the call&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2 UNKNOWN&lt;/td>
&lt;td>Something went wrong&lt;/td>
&lt;td>Not enough information on what went wrong&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3 INVALID_ARGUMENT&lt;/td>
&lt;td>Re-check supplied parameters&lt;/td>
&lt;td>Re-check the supplied &lt;code>Machine.Name&lt;/code> and make sure that it is in the desired format and not a blank value. Exact issue to be given in &lt;code>.message&lt;/code>&lt;/td>
&lt;td>Update &lt;code>Machine.Name&lt;/code> to fix issues.&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4 DEADLINE_EXCEEDED&lt;/td>
&lt;td>Timeout&lt;/td>
&lt;td>The call processing exceeded supplied deadline&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7 PERMISSION_DENIED&lt;/td>
&lt;td>Insufficent permissions&lt;/td>
&lt;td>The requestor doesn&amp;rsquo;t have enough permissions to delete an VM and it&amp;rsquo;s required dependencies&lt;/td>
&lt;td>Update requestor permissions to grant the same&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9 PRECONDITION_FAILED&lt;/td>
&lt;td>VM is in inconsistent state&lt;/td>
&lt;td>The VM is in a state that is invalid for this operation&lt;/td>
&lt;td>Manual intervention might be needed to fix the state of the VM&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10 ABORTED&lt;/td>
&lt;td>Operation is pending&lt;/td>
&lt;td>Indicates that there is already an operation pending for the specified machine&lt;/td>
&lt;td>Wait until previous pending operation is processed&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12 UNIMPLEMENTED&lt;/td>
&lt;td>Not implemented&lt;/td>
&lt;td>Unimplemented indicates operation is not implemented or not supported/enabled in this service.&lt;/td>
&lt;td>Retry with an alternate logic or implement this method at the provider. Most methods by default are in this state&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13 INTERNAL&lt;/td>
&lt;td>Major error&lt;/td>
&lt;td>Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.&lt;/td>
&lt;td>Needs manual intervension to fix this&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14 UNAVAILABLE&lt;/td>
&lt;td>Not Available&lt;/td>
&lt;td>Unavailable indicates the service is currently unavailable.&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16 UNAUTHENTICATED&lt;/td>
&lt;td>Missing provider credentials&lt;/td>
&lt;td>Request does not have valid authentication credentials for the operation&lt;/td>
&lt;td>Fix the provider credentials&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The status &lt;code>message&lt;/code> MUST contain a human readable description of error, if the status &lt;code>code&lt;/code> is not &lt;code>OK&lt;/code>.
This string MAY be surfaced by MCM to end users.&lt;/p>
&lt;h4 id="getmachinestatus">&lt;code>GetMachineStatus&lt;/code>&lt;/h4>
&lt;p>A Provider can OPTIONALLY implement this driver call. Else should return a &lt;code>UNIMPLEMENTED&lt;/code> status in error.
This call will be invoked by the MC to get the status of a machine.
This optional driver call helps in optimizing the working of the provider by avoiding unwanted calls to &lt;code>CreateMachine()&lt;/code> and &lt;code>DeleteMachine()&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>If a VM corresponding to the specified machine object&amp;rsquo;s &lt;code>Machine.Name&lt;/code> exists on provider the &lt;code>GetMachineStatusResponse&lt;/code> fields are to be filled similar to the &lt;code>CreateMachineResponse&lt;/code>.&lt;/li>
&lt;li>The provider SHALL only act on machines belonging to the cluster-id/cluster-name obtained from the &lt;code>ProviderSpec&lt;/code>.&lt;/li>
&lt;li>The provider can OPTIONALY make use of the secrets supplied in the &lt;code>Secrets&lt;/code> map in the &lt;code>GetMachineStatusRequest&lt;/code> to communicate with the provider.&lt;/li>
&lt;li>The provider can OPTIONALY make use of the VM unique ID (returned by the provider on machine creation) passed in the &lt;code>ProviderID&lt;/code> map in the &lt;code>GetMachineStatusRequest&lt;/code>.&lt;/li>
&lt;li>This operation MUST be idempotent.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// GetMachineStatus call get&amp;#39;s the status of the VM backing the machine object on the provider
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>GetMachineStatus(context.Context, &lt;span style="">*&lt;/span>GetMachineStatusRequest) (&lt;span style="">*&lt;/span>GetMachineStatusResponse, error)&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// GetMachineStatusRequest is the get request for VM info
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type GetMachineStatusRequest struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Machine object from whom VM status is to be fetched
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Machine &lt;span style="">*&lt;/span>v1alpha1.Machine&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// MachineClass backing the machine object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> MachineClass &lt;span style="">*&lt;/span>v1alpha1.MachineClass&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Secret backing the machineClass object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Secret &lt;span style="">*&lt;/span>corev1.Secret&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// GetMachineStatusResponse is the get response for VM info
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type GetMachineStatusResponse struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// ProviderID is the unique identification of the VM at the cloud provider.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#008000">// ProviderID typically matches with the node.Spec.ProviderID on the node object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#008000">// Eg: gce://project-name/region/vm-ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> ProviderID &lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// NodeName is the name of the node-object registered to kubernetes.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> NodeName &lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="getmachinestatus-errors">GetMachineStatus Errors&lt;/h5>
&lt;p>If the provider is unable to complete the GetMachineStatus call successfully, it MUST return a non-ok machine code in the machine status.
If the conditions defined below are encountered, the provider MUST return the specified machine error code.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>machine Code&lt;/th>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Recovery Behavior&lt;/th>
&lt;th>Auto Retry Required&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 OK&lt;/td>
&lt;td>Successful&lt;/td>
&lt;td>The call was successful in getting machine details for given machine &lt;code>Machine.Name&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 CANCELED&lt;/td>
&lt;td>Cancelled&lt;/td>
&lt;td>Call was cancelled. Perform any pending clean-up tasks and return the call&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2 UNKNOWN&lt;/td>
&lt;td>Something went wrong&lt;/td>
&lt;td>Not enough information on what went wrong&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3 INVALID_ARGUMENT&lt;/td>
&lt;td>Re-check supplied parameters&lt;/td>
&lt;td>Re-check the supplied &lt;code>Machine.Name&lt;/code> and make sure that it is in the desired format and not a blank value. Exact issue to be given in &lt;code>.message&lt;/code>&lt;/td>
&lt;td>Update &lt;code>Machine.Name&lt;/code> to fix issues.&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4 DEADLINE_EXCEEDED&lt;/td>
&lt;td>Timeout&lt;/td>
&lt;td>The call processing exceeded supplied deadline&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5 NOT_FOUND&lt;/td>
&lt;td>Machine isn&amp;rsquo;t found at provider&lt;/td>
&lt;td>The machine could not be found at provider&lt;/td>
&lt;td>Not required&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7 PERMISSION_DENIED&lt;/td>
&lt;td>Insufficent permissions&lt;/td>
&lt;td>The requestor doesn&amp;rsquo;t have enough permissions to get details for the VM and it&amp;rsquo;s required dependencies&lt;/td>
&lt;td>Update requestor permissions to grant the same&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9 PRECONDITION_FAILED&lt;/td>
&lt;td>VM is in inconsistent state&lt;/td>
&lt;td>The VM is in a state that is invalid for this operation&lt;/td>
&lt;td>Manual intervention might be needed to fix the state of the VM&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11 OUT_OF_RANGE&lt;/td>
&lt;td>Multiple VMs found&lt;/td>
&lt;td>Multiple VMs found with matching machine object names&lt;/td>
&lt;td>Orphan VM handler to cleanup orphan VMs / Manual intervention maybe required if orphan VM handler isn&amp;rsquo;t enabled.&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12 UNIMPLEMENTED&lt;/td>
&lt;td>Not implemented&lt;/td>
&lt;td>Unimplemented indicates operation is not implemented or not supported/enabled in this service.&lt;/td>
&lt;td>Retry with an alternate logic or implement this method at the provider. Most methods by default are in this state&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13 INTERNAL&lt;/td>
&lt;td>Major error&lt;/td>
&lt;td>Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.&lt;/td>
&lt;td>Needs manual intervension to fix this&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14 UNAVAILABLE&lt;/td>
&lt;td>Not Available&lt;/td>
&lt;td>Unavailable indicates the service is currently unavailable.&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16 UNAUTHENTICATED&lt;/td>
&lt;td>Missing provider credentials&lt;/td>
&lt;td>Request does not have valid authentication credentials for the operation&lt;/td>
&lt;td>Fix the provider credentials&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The status &lt;code>message&lt;/code> MUST contain a human readable description of error, if the status &lt;code>code&lt;/code> is not &lt;code>OK&lt;/code>.
This string MAY be surfaced by MCM to end users.&lt;/p>
&lt;h4 id="listmachines">&lt;code>ListMachines&lt;/code>&lt;/h4>
&lt;p>A Provider can OPTIONALLY implement this driver call. Else should return a &lt;code>UNIMPLEMENTED&lt;/code> status in error.
The Provider SHALL return the information about all the machines associated with the &lt;code>MachineClass&lt;/code>.
Make sure to use appropriate filters to achieve the same to avoid data transfer overheads.
This optional driver call helps in cleaning up orphan VMs present in the cluster. If not implemented, any orphan VM that might have been created incorrectly by the MCM/Provider (due to bugs in code/infra) might require manual clean up.&lt;/p>
&lt;ul>
&lt;li>If the Provider succeeded in returning a list of &lt;code>Machine.Name&lt;/code> with their corresponding &lt;code>ProviderID&lt;/code>, then return &lt;code>0 OK&lt;/code>.&lt;/li>
&lt;li>The &lt;code>ListMachineResponse&lt;/code> contains a map of &lt;code>MachineList&lt;/code> whose
&lt;ul>
&lt;li>Key is expected to contain the &lt;code>ProviderID&lt;/code> &amp;amp;&lt;/li>
&lt;li>Value is expected to contain the &lt;code>Machine.Name&lt;/code> corresponding to it&amp;rsquo;s kubernetes machine CR object&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The provider can OPTIONALY make use of the secrets supplied in the &lt;code>Secrets&lt;/code> map in the &lt;code>ListMachinesRequest&lt;/code> to communicate with the provider.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// ListMachines lists all the machines that might have been created by the supplied machineClass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>ListMachines(context.Context, &lt;span style="">*&lt;/span>ListMachinesRequest) (&lt;span style="">*&lt;/span>ListMachinesResponse, error)&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// ListMachinesRequest is the request object to get a list of VMs belonging to a machineClass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type ListMachinesRequest struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// MachineClass object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> MachineClass &lt;span style="">*&lt;/span>v1alpha1.MachineClass&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// Secret backing the machineClass object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Secret &lt;span style="">*&lt;/span>corev1.Secret&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// ListMachinesResponse is the response object of the list of VMs belonging to a machineClass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type ListMachinesResponse struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// MachineList is the map of list of machines. Format for the map should be &amp;lt;ProviderID, MachineName&amp;gt;.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> MachineList map[&lt;span style="color:#2b91af">string&lt;/span>]&lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="listmachines-errors">ListMachines Errors&lt;/h5>
&lt;p>If the provider is unable to complete the ListMachines call successfully, it MUST return a non-ok machine code in the machine status.
If the conditions defined below are encountered, the provider MUST return the specified machine error code.
The MCM MUST implement the specified error recovery behavior when it encounters the machine error code.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>machine Code&lt;/th>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Recovery Behavior&lt;/th>
&lt;th>Auto Retry Required&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 OK&lt;/td>
&lt;td>Successful&lt;/td>
&lt;td>The call for listing all VMs associated with &lt;code>ProviderSpec&lt;/code> was successful.&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 CANCELED&lt;/td>
&lt;td>Cancelled&lt;/td>
&lt;td>Call was cancelled. Perform any pending clean-up tasks and return the call&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2 UNKNOWN&lt;/td>
&lt;td>Something went wrong&lt;/td>
&lt;td>Not enough information on what went wrong&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3 INVALID_ARGUMENT&lt;/td>
&lt;td>Re-check supplied parameters&lt;/td>
&lt;td>Re-check the supplied &lt;code>ProviderSpec&lt;/code> and make sure that all required fields are present in their desired value format. Exact issue to be given in &lt;code>.message&lt;/code>&lt;/td>
&lt;td>Update &lt;code>ProviderSpec&lt;/code> to fix issues.&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4 DEADLINE_EXCEEDED&lt;/td>
&lt;td>Timeout&lt;/td>
&lt;td>The call processing exceeded supplied deadline&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7 PERMISSION_DENIED&lt;/td>
&lt;td>Insufficent permissions&lt;/td>
&lt;td>The requestor doesn&amp;rsquo;t have enough permissions to list VMs and it&amp;rsquo;s required dependencies&lt;/td>
&lt;td>Update requestor permissions to grant the same&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12 UNIMPLEMENTED&lt;/td>
&lt;td>Not implemented&lt;/td>
&lt;td>Unimplemented indicates operation is not implemented or not supported/enabled in this service.&lt;/td>
&lt;td>Retry with an alternate logic or implement this method at the provider. Most methods by default are in this state&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13 INTERNAL&lt;/td>
&lt;td>Major error&lt;/td>
&lt;td>Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.&lt;/td>
&lt;td>Needs manual intervension to fix this&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14 UNAVAILABLE&lt;/td>
&lt;td>Not Available&lt;/td>
&lt;td>Unavailable indicates the service is currently unavailable.&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>16 UNAUTHENTICATED&lt;/td>
&lt;td>Missing provider credentials&lt;/td>
&lt;td>Request does not have valid authentication credentials for the operation&lt;/td>
&lt;td>Fix the provider credentials&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The status &lt;code>message&lt;/code> MUST contain a human readable description of error, if the status &lt;code>code&lt;/code> is not &lt;code>OK&lt;/code>.
This string MAY be surfaced by MCM to end users.&lt;/p>
&lt;h4 id="getvolumeids">&lt;code>GetVolumeIDs&lt;/code>&lt;/h4>
&lt;p>A Provider can OPTIONALLY implement this driver call. Else should return a &lt;code>UNIMPLEMENTED&lt;/code> status in error.
This driver call will be called by the MCM to get the &lt;code>VolumeIDs&lt;/code> for the list of &lt;code>PersistentVolumes (PVs)&lt;/code> supplied.
This OPTIONAL (but recommended) driver call helps in serailzied eviction of pods with PVs while draining of machines. This implies applications backed by PVs would be evicted one by one, leading to shorter application downtimes.&lt;/p>
&lt;ul>
&lt;li>On succesful returnal of a list of &lt;code>Volume-IDs&lt;/code> for all supplied &lt;code>PVSpecs&lt;/code>, the Provider MUST reply &lt;code>0 OK&lt;/code>.&lt;/li>
&lt;li>The &lt;code>GetVolumeIDsResponse&lt;/code> is expected to return a repeated list of &lt;code>strings&lt;/code> consisting of the &lt;code>VolumeIDs&lt;/code> for &lt;code>PVSpec&lt;/code> that could be extracted.&lt;/li>
&lt;li>If for any &lt;code>PV&lt;/code> the Provider wasn&amp;rsquo;t able to identify the &lt;code>Volume-ID&lt;/code>, the provider MAY chose to ignore it and return the &lt;code>Volume-IDs&lt;/code> for the rest of the &lt;code>PVs&lt;/code> for whom the &lt;code>Volume-ID&lt;/code> was found.&lt;/li>
&lt;li>Getting the &lt;code>VolumeID&lt;/code> from the &lt;code>PVSpec&lt;/code> depends on the Cloud-provider. You can extract this information by parsing the &lt;code>PVSpec&lt;/code> based on the &lt;code>ProviderType&lt;/code>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kubernetes/api/blob/release-1.15/core/v1/types.go#L297-L339">https://github.com/kubernetes/api/blob/release-1.15/core/v1/types.go#L297-L339&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kubernetes/api/blob/release-1.15//core/v1/types.go#L175-L257">https://github.com/kubernetes/api/blob/release-1.15//core/v1/types.go#L175-L257&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>This operation MUST be idempotent.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// GetVolumeIDsRequest is the request object to get a list of VolumeIDs for a PVSpec
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type GetVolumeIDsRequest struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// PVSpecsList is a list of PV specs for whom volume-IDs are required
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#008000">// Plugin should parse this raw data into pre-defined list of PVSpecs
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> PVSpecs []&lt;span style="">*&lt;/span>corev1.PersistentVolumeSpec&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// GetVolumeIDsResponse is the response object of the list of VolumeIDs for a PVSpec
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type GetVolumeIDsResponse struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// VolumeIDs is a list of VolumeIDs.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> VolumeIDs []&lt;span style="color:#2b91af">string&lt;/span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="getvolumeids-errors">GetVolumeIDs Errors&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>machine Code&lt;/th>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Recovery Behavior&lt;/th>
&lt;th>Auto Retry Required&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 OK&lt;/td>
&lt;td>Successful&lt;/td>
&lt;td>The call getting list of &lt;code>VolumeIDs&lt;/code> for the list of &lt;code>PersistentVolumes&lt;/code> was successful.&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 CANCELED&lt;/td>
&lt;td>Cancelled&lt;/td>
&lt;td>Call was cancelled. Perform any pending clean-up tasks and return the call&lt;/td>
&lt;td>&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2 UNKNOWN&lt;/td>
&lt;td>Something went wrong&lt;/td>
&lt;td>Not enough information on what went wrong&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3 INVALID_ARGUMENT&lt;/td>
&lt;td>Re-check supplied parameters&lt;/td>
&lt;td>Re-check the supplied &lt;code>PVSpecList&lt;/code> and make sure that it is in the desired format. Exact issue to be given in &lt;code>.message&lt;/code>&lt;/td>
&lt;td>Update &lt;code>PVSpecList&lt;/code> to fix issues.&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4 DEADLINE_EXCEEDED&lt;/td>
&lt;td>Timeout&lt;/td>
&lt;td>The call processing exceeded supplied deadline&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12 UNIMPLEMENTED&lt;/td>
&lt;td>Not implemented&lt;/td>
&lt;td>Unimplemented indicates operation is not implemented or not supported/enabled in this service.&lt;/td>
&lt;td>Retry with an alternate logic or implement this method at the provider. Most methods by default are in this state&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13 INTERNAL&lt;/td>
&lt;td>Major error&lt;/td>
&lt;td>Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.&lt;/td>
&lt;td>Needs manual intervension to fix this&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14 UNAVAILABLE&lt;/td>
&lt;td>Not Available&lt;/td>
&lt;td>Unavailable indicates the service is currently unavailable.&lt;/td>
&lt;td>Retry operation after sometime&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The status &lt;code>message&lt;/code> MUST contain a human readable description of error, if the status &lt;code>code&lt;/code> is not &lt;code>OK&lt;/code>.
This string MAY be surfaced by MCM to end users.&lt;/p>
&lt;h4 id="generatemachineclassformigration">&lt;code>GenerateMachineClassForMigration&lt;/code>&lt;/h4>
&lt;p>A Provider SHOULD implement this driver call, else it MUST return a &lt;code>UNIMPLEMENTED&lt;/code> status in error.
This driver call will be called by the Machine Controller to try to perform a machineClass migration for an unknown machineClass Kind. This helps in migration of one kind of machineClass to another kind. For instance an machineClass custom resource of &lt;code>AWSMachineClass&lt;/code> to &lt;code>MachineClass&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>On successful generation of machine class the Provider MUST reply &lt;code>0 OK&lt;/code> (or) &lt;code>nil&lt;/code> error.&lt;/li>
&lt;li>&lt;code>GenerateMachineClassForMigrationRequest&lt;/code> expects the provider-specific machine class (eg. AWSMachineClass)
to be supplied as the &lt;code>ProviderSpecificMachineClass&lt;/code>. The provider is responsible for unmarshalling the golang struct. It also passes a reference to an existing &lt;code>MachineClass&lt;/code> object.&lt;/li>
&lt;li>The provider is expected to fill in this&lt;code>MachineClass&lt;/code> object based on the conversions.&lt;/li>
&lt;li>An optional &lt;code>ClassSpec&lt;/code> containing the &lt;code>type ClassSpec struct&lt;/code> is also provided to decode the provider info.&lt;/li>
&lt;li>&lt;code>GenerateMachineClassForMigration&lt;/code> is only responsible for filling up the passed &lt;code>MachineClass&lt;/code> object.&lt;/li>
&lt;li>The task of creating the new &lt;code>CR&lt;/code> of the new kind (MachineClass) with the same name as the previous one and also annotating the old machineClass CR with a migrated annotation and migrating existing references is done by the calling library implicitly.&lt;/li>
&lt;li>This operation MUST be idempotent.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// GenerateMachineClassForMigrationRequest is the request for generating the generic machineClass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// for the provider specific machine class
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type GenerateMachineClassForMigrationRequest struct {&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// ProviderSpecificMachineClass is provider specfic machine class object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#008000">// E.g. AWSMachineClass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> ProviderSpecificMachineClass interface{}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// MachineClass is the machine class object generated that is to be filled up
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> MachineClass &lt;span style="">*&lt;/span>v1alpha1.MachineClass&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span> &lt;span style="color:#008000">// ClassSpec contains the class spec object to determine the machineClass kind
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> ClassSpec &lt;span style="">*&lt;/span>v1alpha1.ClassSpec&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">&lt;/span>&lt;span style="color:#008000">// GenerateMachineClassForMigrationResponse is the response for generating the generic machineClass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">// for the provider specific machine class
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span>type GenerateMachineClassForMigrationResponse struct{}&lt;span style="">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="migratemachineclass-errors">MigrateMachineClass Errors&lt;/h5>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>machine Code&lt;/th>
&lt;th>Condition&lt;/th>
&lt;th>Description&lt;/th>
&lt;th>Recovery Behavior&lt;/th>
&lt;th>Auto Retry Required&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0 OK&lt;/td>
&lt;td>Successful&lt;/td>
&lt;td>Migration of provider specific machine class was successful&lt;/td>
&lt;td>Machine reconcilation is retried once the new class has been created&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12 UNIMPLEMENTED&lt;/td>
&lt;td>Not implemented&lt;/td>
&lt;td>Unimplemented indicates operation is not implemented or not supported/enabled in this provider.&lt;/td>
&lt;td>None&lt;/td>
&lt;td>N&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13 INTERNAL&lt;/td>
&lt;td>Major error&lt;/td>
&lt;td>Means some invariants expected by underlying system has been broken. If you see one of these errors, something is very broken.&lt;/td>
&lt;td>Might need manual intervension to fix this&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The status &lt;code>message&lt;/code> MUST contain a human readable description of error, if the status &lt;code>code&lt;/code> is not &lt;code>OK&lt;/code>.
This string MAY be surfaced by MCM to end users.&lt;/p>
&lt;h2 id="configuration-and-operation">Configuration and Operation&lt;/h2>
&lt;h3 id="supervised-lifecycle-management">Supervised Lifecycle Management&lt;/h3>
&lt;ul>
&lt;li>For Providers packaged in software form:
&lt;ul>
&lt;li>Provider Packages SHOULD use a well-documented container image format (e.g., Docker, OCI).&lt;/li>
&lt;li>The chosen package image format MAY expose configurable Provider properties as environment variables, unless otherwise indicated in the section below.
Variables so exposed SHOULD be assigned default values in the image manifest.&lt;/li>
&lt;li>A Provider Supervisor MAY programmatically evaluate or otherwise scan a Provider Package’s image manifest in order to discover configurable environment variables.&lt;/li>
&lt;li>A Provider SHALL NOT assume that an operator or Provider Supervisor will scan an image manifest for environment variables.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="environment-variables">Environment Variables&lt;/h4>
&lt;ul>
&lt;li>Variables defined by this specification SHALL be identifiable by their &lt;code>MC_&lt;/code> name prefix.&lt;/li>
&lt;li>Configuration properties not defined by the MC specification SHALL NOT use the same &lt;code>MC_&lt;/code> name prefix; this prefix is reserved for common configuration properties defined by the MC specification.&lt;/li>
&lt;li>The Provider Supervisor SHOULD supply all RECOMMENDED MC environment variables to a Provider.&lt;/li>
&lt;li>The Provider Supervisor SHALL supply all REQUIRED MC environment variables to a Provider.&lt;/li>
&lt;/ul>
&lt;h5 id="logging">Logging&lt;/h5>
&lt;ul>
&lt;li>Providers SHOULD generate log messages to ONLY standard output and/or standard error.
&lt;ul>
&lt;li>In this case the Provider Supervisor SHALL assume responsibility for all log lifecycle management.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Provider implementations that deviate from the above recommendation SHALL clearly and unambiguously document the following:
&lt;ul>
&lt;li>Logging configuration flags and/or variables, including working sample configurations.&lt;/li>
&lt;li>Default log destination(s) (where do the logs go if no configuration is specified?)&lt;/li>
&lt;li>Log lifecycle management ownership and related guidance (size limits, rate limits, rolling, archiving, expunging, etc.) applicable to the logging mechanism embedded within the Provider.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Providers SHOULD NOT write potentially sensitive data to logs (e.g. secrets).&lt;/li>
&lt;/ul>
&lt;h5 id="available-services">Available Services&lt;/h5>
&lt;ul>
&lt;li>Provider Packages MAY support all or a subset of CMI services; service combinations MAY be configurable at runtime by the Provider Supervisor.
&lt;ul>
&lt;li>This specification does not dictate the mechanism by which mode of operation MUST be discovered, and instead places that burden upon the VM Provider.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Misconfigured provider software SHOULD fail-fast with an OS-appropriate error code.&lt;/li>
&lt;/ul>
&lt;h5 id="linux-capabilities">Linux Capabilities&lt;/h5>
&lt;ul>
&lt;li>Providers SHOULD clearly document any additionally required capabilities and/or security context.&lt;/li>
&lt;/ul>
&lt;h5 id="cgroup-isolation">Cgroup Isolation&lt;/h5>
&lt;ul>
&lt;li>A Provider MAY be constrained by cgroups.&lt;/li>
&lt;/ul>
&lt;h5 id="resource-requirements">Resource Requirements&lt;/h5>
&lt;ul>
&lt;li>VM Providers SHOULD unambiguously document all of a Provider’s resource requirements.&lt;/li>
&lt;/ul>
&lt;h3 id="deploying">Deploying&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Recommended:&lt;/strong> The MCM and Provider are typically expected to run as two containers inside a common &lt;code>Pod&lt;/code>.&lt;/li>
&lt;li>However, for the security reasons they could execute on seperate Pods provided they have a secure way to exchange data between them.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Machine Set</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/</guid><description>
&lt;h1 id="maintaining-machine-replicas-using-machines-sets">Maintaining machine replicas using machines-sets&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#maintaining-machine-replicas-using-machines-sets">Maintaining machine replicas using machines-sets&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#setting-up-your-usage-environment">Setting up your usage environment&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#important-warning">Important ⚠️&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#creating-machine-set">Creating machine-set&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#inspect-status-of-machine-set">Inspect status of machine-set&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#health-monitoring">Health monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/machine_set/#delete-machine-set">Delete machine-set&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="setting-up-your-usage-environment">Setting up your usage environment&lt;/h2>
&lt;ul>
&lt;li>Follow the &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/">steps described here&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="important-">Important ⚠️&lt;/h2>
&lt;blockquote>
&lt;p>Make sure that the &lt;code>kubernetes/machines_objects/machine-set.yaml&lt;/code> points to the same class name as the &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Similarly &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code> secret name and namespace should be same as that mentioned in &lt;code>kubernetes/secrets/aws-secret.yaml&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h2 id="creating-machine-set">Creating machine-set&lt;/h2>
&lt;ul>
&lt;li>Modify &lt;code>kubernetes/machine_objects/machine-set.yaml&lt;/code> as per your requirement. You can modify the number of replicas to the desired number of machines. Then, create an machine-set:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/machine_objects/machine-set.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You should notice that the Machine Controller Manager has immediately picked up your manifest and started to create a new machines based on the number of replicas you have provided in the manifest.&lt;/p>
&lt;ul>
&lt;li>Check Machine Controller Manager machine-sets in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machineset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME DESIRED CURRENT READY AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-set 3 3 0 1m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will see a new machine-set with your given name&lt;/p>
&lt;ul>
&lt;li>Check Machine Controller Manager machines in the cluster:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-set-b57zs Pending 5m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-set-c4bg8 Pending 5m
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-machine-set-kvskg Pending 5m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now you will see N (number of replicas specified in the manifest) new machines whose names are prefixed with the machine-set object name that you created.&lt;/p>
&lt;ul>
&lt;li>After a few minutes (~3 minutes for AWS), you should notice new nodes joining the cluster. You can verify this by running:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME STATUS AGE VERSION
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-0-234.eu-west-1.compute.internal Ready 3m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-15-98.eu-west-1.compute.internal Ready 3m v1.8.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ip-10-250-6-21.eu-west-1.compute.internal Ready 2m v1.8.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This shows how new nodes have joined your cluster&lt;/p>
&lt;h2 id="inspect-status-of-machine-set">Inspect status of machine-set&lt;/h2>
&lt;ul>
&lt;li>To inspect the status of any created machine-set run the following command:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machineset test-machine-set -o yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: machine.sapcloud.io/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: MachineSet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubectl.kubernetes.io/last-applied-configuration: |&lt;span style="color:#a31515">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &lt;/span> {&lt;span style="color:#a31515">&amp;#34;apiVersion&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;machine.sapcloud.io/v1alpha1&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;kind&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;MachineSet&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;metadata&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;annotations&amp;#34;&lt;/span>:{},&lt;span style="color:#a31515">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-machine-set&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;namespace&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>},&lt;span style="color:#a31515">&amp;#34;spec&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;minReadySeconds&amp;#34;&lt;/span>:200,&lt;span style="color:#a31515">&amp;#34;replicas&amp;#34;&lt;/span>:3,&lt;span style="color:#a31515">&amp;#34;selector&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;matchLabels&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>}},&lt;span style="color:#a31515">&amp;#34;template&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;metadata&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;labels&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-label&amp;#34;&lt;/span>}},&lt;span style="color:#a31515">&amp;#34;spec&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;class&amp;#34;&lt;/span>:{&lt;span style="color:#a31515">&amp;#34;kind&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;AWSMachineClass&amp;#34;&lt;/span>,&lt;span style="color:#a31515">&amp;#34;name&amp;#34;&lt;/span>:&lt;span style="color:#a31515">&amp;#34;test-aws&amp;#34;&lt;/span>}}}}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusterName: &lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creationTimestamp: 2017-12-27T08:37:42Z
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> finalizers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - machine.sapcloud.io/operator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> generation: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initializers: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: test-machine-set
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &lt;span style="color:#a31515">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceVersion: &lt;span style="color:#a31515">&amp;#34;12630893&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selfLink: /apis/machine.sapcloud.io/v1alpha1/test-machine-set
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uid: 3469faaa-eae1-11e7-a6c0-828f843e4186
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> machineClass: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> minReadySeconds: 200
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test-label: test-label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> creationTimestamp: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test-label: test-label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: AWSMachineClass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: test-aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> availableReplicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fullyLabeledReplicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> machineSetCondition: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastOperation:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#00f">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> observedGeneration: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> readyReplicas: 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replicas: 3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="health-monitoring">Health monitoring&lt;/h2>
&lt;ul>
&lt;li>If you try to delete/terminate any of the machines backing the machine-set by either talking to the Machine Controller Manager or from the cloud provider, the Machine Controller Manager recreates a matching healthy machine to replace the deleted machine.&lt;/li>
&lt;li>Similarly, if any of your machines are unreachable or in an unhealthy state (kubelet not ready / disk pressure) for longer than the configured timeout (~ 5mins), the Machine Controller Manager recreates the nodes to replace the unhealthy nodes.&lt;/li>
&lt;/ul>
&lt;h2 id="delete-machine-set">Delete machine-set&lt;/h2>
&lt;ul>
&lt;li>To delete the VM using the &lt;code>kubernetes/machine_objects/machine-set.yaml&lt;/code>:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl delete -f kubernetes/machine-set.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now the Machine Controller Manager has immediately picked up your manifest and started to delete the existing VMs by talking to the cloud provider. Your nodes should be detached from the cluster in a few minutes (~1min for AWS).&lt;/p></description></item><item><title>Docs: Prerequisite</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/</guid><description>
&lt;h1 id="setting-up-the-usage-environment">Setting up the usage environment&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/#setting-up-the-usage-environment">Setting up the usage environment&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/#important-warning">Important ⚠️&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/#set-kubeconfig">Set KUBECONFIG&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/#replace-provider-credentials-and-desired-vm-configurations">Replace provider credentials and desired VM configurations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/#deploy-required-crds-and-objects">Deploy required CRDs and Objects&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/prerequisite/#check-current-cluster-state">Check current cluster state&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="important-">Important ⚠️&lt;/h2>
&lt;blockquote>
&lt;p>All paths are relative to the root location of this project repository.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Run the Machine Controller Manager either as described in &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/local_setup/">Setting up a local development environment&lt;/a> or &lt;a href="https://gardener.cloud/docs/other-components/machine-controller-manager/deployment/">Deploying the Machine Controller Manager into a Kubernetes cluster&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Make sure that the following steps are run before managing machines/ machine-sets/ machine-deploys.&lt;/p>
&lt;/blockquote>
&lt;h2 id="set-kubeconfig">Set KUBECONFIG&lt;/h2>
&lt;p>Using the existing &lt;a href="https://kubernetes.io/docs/tasks/access-application-cluster/authenticate-across-clusters-kubeconfig/">Kubeconfig&lt;/a>, open another Terminal panel/window with the &lt;code>KUBECONFIG&lt;/code> environment variable pointing to this Kubeconfig file as shown below,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ export KUBECONFIG=&amp;lt;PATH_TO_REPO&amp;gt;/dev/kubeconfig.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="replace-provider-credentials-and-desired-vm-configurations">Replace provider credentials and desired VM configurations&lt;/h2>
&lt;p>Open &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code> and replace required values there with the desired VM configurations.&lt;/p>
&lt;p>Similarily open &lt;code>kubernetes/secrets/aws-secret.yaml&lt;/code> and replace - &lt;em>userData, providerAccessKeyId, providerSecretAccessKey&lt;/em> with base64 encoded values of cloudconfig file, AWS access key id, and AWS secret access key respectively. Use the following command to get the base64 encoded value of your details&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ echo &lt;span style="color:#a31515">&amp;#34;sample-cloud-config&amp;#34;&lt;/span> | base64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>base64-encoded-cloud-config
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Do the same for your access key id and secret access key.&lt;/p>
&lt;h2 id="deploy-required-crds-and-objects">Deploy required CRDs and Objects&lt;/h2>
&lt;p>Create all the required CRDs in the cluster using &lt;code>kubernetes/crds.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/crds.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Create the class template that will be used as an machine template to create VMs using &lt;code>kubernetes/machine_classes/aws-machine-class.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/machine_classes/aws-machine-class.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Create the secret used for the cloud credentials and cloudconfig using &lt;code>kubernetes/secrets/aws-secret.yaml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl apply -f kubernetes/secrets/aws-secret.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="check-current-cluster-state">Check current cluster state&lt;/h2>
&lt;p>Get to know the current cluster state using the following commands,&lt;/p>
&lt;ul>
&lt;li>Checking aws-machine-class in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get awsmachineclass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME MACHINE TYPE AMI AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-aws t2.large ami-123456 5m
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Checking kubernetes secrets in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME TYPE DATA AGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test-secret Opaque 3 21h
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Checking kubernetes nodes in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get nodes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lists the default set of nodes attached to your cluster&lt;/p>
&lt;ul>
&lt;li>Checking Machine Controller Manager machines in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>No resources found.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Checking Machine Controller Manager machine-sets in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machineset
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>No resources found.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Checking Machine Controller Manager machine-deploys in the cluster&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ kubectl get machinedeployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>No resources found.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Testing And Dependencies</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/testing_and_dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/testing_and_dependencies/</guid><description>
&lt;h2 id="dependency-management">Dependency management&lt;/h2>
&lt;p>We use golang modules to manage golang dependencies. In order to add a new package dependency to the project, you can perform &lt;code>go get &amp;lt;PACKAGE&amp;gt;@&amp;lt;VERSION&amp;gt;&lt;/code> or edit the &lt;code>go.mod&lt;/code> file and append the package along with the version you want to use.&lt;/p>
&lt;h3 id="updating-dependencies">Updating dependencies&lt;/h3>
&lt;p>The &lt;code>Makefile&lt;/code> contains a rule called &lt;code>revendor&lt;/code> which performs &lt;code>go mod vendor&lt;/code> and &lt;code>go mod tidy&lt;/code>.&lt;/p>
&lt;p>&lt;code>go mod vendor&lt;/code> resets the main module&amp;rsquo;s vendor directory to include all packages needed to build and test all the main module&amp;rsquo;s packages. It does not include test code for vendored packages.&lt;/p>
&lt;p>&lt;code>go mod tidy&lt;/code> makes sure go.mod matches the source code in the module. It adds any missing modules necessary to build the current module&amp;rsquo;s packages and dependencies, and it removes unused modules that don&amp;rsquo;t provide any relevant packages.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ make revendor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The dependencies are installed into the &lt;code>vendor&lt;/code> folder which &lt;strong>should be added&lt;/strong> to the VCS.&lt;/p>
&lt;p>⚠️ Make sure you test the code after you have updated the dependencies!&lt;/p></description></item></channel></rss>