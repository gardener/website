<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener â€“ Proposals</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/</link><description>Recent content in Proposals on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Excess Reserve Capacity</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/excess_reserve_capacity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/excess_reserve_capacity/</guid><description>
&lt;h1 id="excess-reserve-capacity">Excess Reserve Capacity&lt;/h1>
&lt;!-- TOC -->
&lt;ul>
&lt;li>&lt;a href="#excess-reserve-capacity">Excess Reserve Capacity&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#goal">Goal&lt;/a>&lt;/li>
&lt;li>&lt;a href="#note">Note&lt;/a>&lt;/li>
&lt;li>&lt;a href="#possible-approaches">Possible Approaches&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#approach-1-enhance-machine-controller-manager-to-also-entertain-the-excess-machines">Approach 1: Enhance Machine-controller-manager to also entertain the excess machines&lt;/a>&lt;/li>
&lt;li>&lt;a href="#approach-2-enhance-cluster-autoscaler-by-simulating-fake-pods-in-it">Approach 2: Enhance Cluster-autoscaler by simulating fake pods in it&lt;/a>&lt;/li>
&lt;li>&lt;a href="#approach-3-enhance-cluster-autoscaler-to-support-pluggable-scaling-events">Approach 3: Enhance cluster-autoscaler to support pluggable scaling-events&lt;/a>&lt;/li>
&lt;li>&lt;a href="#approach-4-make-intelligent-use-of-low-priority-pods">Approach 4: Make intelligent use of Low-priority pods&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!-- /TOC -->
&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>Currently, autoscaler optimizes the number of machines for a given application-workload. Along with effective resource utilization, this feature brings concern where, many times, when new application instances are created - they don&amp;rsquo;t find space in existing cluster. This leads the cluster-autoscaler to create new machines via MachineDeployment, which can take from 3-4 minutes to ~10 minutes, for the machine to really come-up and join the cluster. In turn, application-instances have to wait till new machines join the cluster.&lt;/p>
&lt;p>One of the promising solutions to this issue is Excess Reserve Capacity. Idea is to keep a certain number of machines or percent of resources[cpu/memory] always available, so that new workload, in general, can be scheduled immediately unless huge spike in the workload. Also, the user should be given enough flexibility to choose how many resources or how many machines should be kept alive and non-utilized as this affects the Cost directly.&lt;/p>
&lt;h2 id="note">Note&lt;/h2>
&lt;ul>
&lt;li>We decided to go with Approach-4 which is based on low priority pods. Please find more details here: &lt;a href="https://github.com/gardener/gardener/issues/254">https://github.com/gardener/gardener/issues/254&lt;/a>&lt;/li>
&lt;li>Approach-3 looks more promising in long term, we may decide to adopt that in future based on developments/contributions in autoscaler-community.&lt;/li>
&lt;/ul>
&lt;h2 id="possible-approaches">Possible Approaches&lt;/h2>
&lt;p>Following are the possible approaches, we could think of so far.&lt;/p>
&lt;h3 id="approach-1-enhance-machine-controller-manager-to-also-entertain-the-excess-machines">Approach 1: Enhance Machine-controller-manager to also entertain the excess machines&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Machine-controller-manager currently takes care of the machines in the shoot cluster starting from creation-deletion-health check to efficient rolling-update of the machines. From the architecture point of view, MachineSet makes sure that X number of machines are always &lt;strong>running and healthy&lt;/strong>. MachineDeployment controller smartly uses this facility to perform rolling-updates.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We can expand the scope of MachineDeployment controller to maintain excess number of machines by introducing new parallel independent controller named &lt;em>MachineTaint&lt;/em> controller. This will result in MCM to include Machine, MachineSet, MachineDeployment, MachineSafety, MachineTaint controllers. MachineTaint controller does not need to introduce any new CRD - analogy fits where taint-controller also resides into kube-controller-manager.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Only Job of MachineTaint controller will be:&lt;/p>
&lt;ul>
&lt;li>List all the Machines under each MachineDeployment.&lt;/li>
&lt;li>Maintain taints of &lt;a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">&lt;em>noSchedule&lt;/em> and &lt;em>noExecute&lt;/em>&lt;/a> on &lt;code>X&lt;/code> latest MachineObjects.&lt;/li>
&lt;li>There should be an event-based informer mechanism where MachineTaintController gets to know about any Update/Delete/Create event of MachineObjects - in turn, maintains the &lt;em>noSchedule&lt;/em> and &lt;em>noExecute&lt;/em> taints on all the &lt;em>latest&lt;/em> machines.
- Why latest machines?
- Whenever autoscaler decides to add new machines - essentially ScaleUp event - taints from the older machines are removed and newer machines get the taints. This way X number of Machines immediately becomes free for new pods to be scheduled.
- While ScaleDown event, autoscaler specifically mentions which machines should be deleted, and that should not bring any concerns. Though we will have to put proper label/annotation defined by autoscaler on taintedMachines, so that autoscaler does not consider the taintedMachines for deletion while scale-down.
* Annotation on tainted node: &lt;code>&amp;quot;cluster-autoscaler.kubernetes.io/scale-down-disabled&amp;quot;: &amp;quot;true&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Implementation Details:&lt;/p>
&lt;ul>
&lt;li>Expect new &lt;strong>optional field&lt;/strong> &lt;em>ExcessReplicas&lt;/em> in &lt;code>MachineDeployment.Spec&lt;/code>. MachineDeployment controller now adds both &lt;code>Spec.Replicas&lt;/code> and &lt;code>Spec.ExcessReplicas&lt;/code>[if provided], and considers that as a standard desiredReplicas.
- Current working of MCM will not be affected if ExcessReplicas field is kept nil.&lt;/li>
&lt;li>MachineController currently reads the &lt;em>NodeObject&lt;/em> and sets the MachineConditions in MachineObject. Machine-controller will now also read the taints/labels from the MachineObject - and maintains it on the &lt;em>NodeObject&lt;/em>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>We expect cluster-autoscaler to intelligently make use of the provided feature from MCM.&lt;/p>
&lt;ul>
&lt;li>CA gets the input of &lt;em>min:max:excess&lt;/em> from Gardener. CA continues to set the &lt;code>MachineDeployment.Spec.Replicas&lt;/code> as usual based on the application-workload.&lt;/li>
&lt;li>In addition, CA also sets the &lt;code>MachieDeployment.Spec.ExcessReplicas&lt;/code> .&lt;/li>
&lt;li>Corner-case:
* CA should decrement the excessReplicas field accordingly when &lt;em>desiredReplicas+excessReplicas&lt;/em> on MachineDeployment goes beyond &lt;em>max&lt;/em>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="approach-2-enhance-cluster-autoscaler-by-simulating-fake-pods-in-it">Approach 2: Enhance Cluster-autoscaler by simulating fake pods in it&lt;/h3>
&lt;ul>
&lt;li>There was already an attempt by community to support this feature.
&lt;ul>
&lt;li>Refer for details to: &lt;a href="https://github.com/kubernetes/autoscaler/pull/77/files">https://github.com/kubernetes/autoscaler/pull/77/files&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="approach-3-enhance-cluster-autoscaler-to-support-pluggable-scaling-events">Approach 3: Enhance cluster-autoscaler to support pluggable scaling-events&lt;/h3>
&lt;ul>
&lt;li>Forked version of cluster-autoscaler could be improved to plug-in the algorithm for excess-reserve capacity.&lt;/li>
&lt;li>Needs further discussion around upstream support.&lt;/li>
&lt;li>Create golang channel to separate the algorithms to trigger scaling (hard-coded in cluster-autoscaler, currently) from the algorithms about how to to achieve the scaling (already pluggable in cluster-autoscaler). This kind of separation can help us introduce/plug-in new algorithms (such as based node resource utilisation) without affecting existing code-base too much while almost completely re-using the code-base for the actual scaling.&lt;/li>
&lt;li>Also this approach is not specific to our fork of cluster-autoscaler. It can be made upstream eventually as well.&lt;/li>
&lt;/ul>
&lt;h3 id="approach-4-make-intelligent-use-of-low-priority-pods">Approach 4: Make intelligent use of Low-priority pods&lt;/h3>
&lt;ul>
&lt;li>Refer to: &lt;a href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/">pod-priority-preemption&lt;/a>&lt;/li>
&lt;li>TL; DR:
&lt;ul>
&lt;li>High priority pods can preempt the low-priority pods which are already scheduled.&lt;/li>
&lt;li>Pre-create bunch[equivivalent of X shoot-control-planes] of low-priority pods with priority of zero, then start creating the workload pods with better priority which will reschedule the low-priority pods or otherwise keep them in pending state if the limit for max-machines has reached.&lt;/li>
&lt;li>This is still alpha feature.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: GRPC Based Implementation of Cloud Providers</title><link>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/external_providers_grpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/other-components/machine-controller-manager/docs/proposals/external_providers_grpc/</guid><description>
&lt;h1 id="grpc-based-implementation-of-cloud-providers---wip">GRPC based implementation of Cloud Providers - WIP&lt;/h1>
&lt;h2 id="goal">Goal:&lt;/h2>
&lt;p>Currently the Cloud Providers&amp;rsquo; (CP) functionalities ( Create(), Delete(), List() ) are part of the Machine Controller Manager&amp;rsquo;s (MCM)repository. Because of this, adding support for new CPs into MCM requires merging code into MCM which may not be required for core functionalities of MCM itself. Also, for various reasons it may not be feasible for all CPs to merge their code with MCM which is an Open Source project.&lt;/p>
&lt;p>Because of these reasons, it was decided that the CP&amp;rsquo;s code will be moved out in separate repositories so that they can be maintained separately by the respective teams. Idea is to make MCM act as a GRPC server, and CPs as GRPC clients. The CP can register themselves with the MCM using a GRPC service exposed by the MCM. Details of this approach is discussed below.&lt;/p>
&lt;h2 id="how-it-works">How it works:&lt;/h2>
&lt;p>MCM acts as GRPC server and listens on a pre-defined port 5000. It implements below GRPC services. Details of each of these services are mentioned in next section.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Register()&lt;/code>&lt;/li>
&lt;li>&lt;code>GetMachineClass()&lt;/code>&lt;/li>
&lt;li>&lt;code>GetSecret()&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="grpc-services-exposed-by-mcm">GRPC services exposed by MCM:&lt;/h2>
&lt;h3 id="register">Register()&lt;/h3>
&lt;p>&lt;code>rpc Register(stream DriverSide) returns (stream MCMside) {}&lt;/code>&lt;/p>
&lt;p>The CP GRPC client calls this service to register itself with the MCM. The CP passes the &lt;code>kind&lt;/code> and the &lt;code>APIVersion&lt;/code> which it implements, and MCM maintains an internal map for all the registered clients. A GRPC stream is returned in response which is kept open througout the life of both the processes. MCM uses this stream to communicate with the client for machine operations: &lt;code>Create()&lt;/code>, &lt;code>Delete()&lt;/code> or &lt;code>List()&lt;/code>.
The CP client is responsible for reading the incoming messages continuously, and based on the &lt;code>operationType&lt;/code> parameter embedded in the message, it is supposed to take the required action. This part is already handled in the package &lt;code>grpc/infraclient&lt;/code>.
To add a new CP client, import the package, and implement the &lt;code>ExternalDriverProvider&lt;/code> interface:&lt;/p>
&lt;pre tabindex="0">&lt;code>type ExternalDriverProvider interface {
Create(machineclass *MachineClassMeta, credentials, machineID, machineName string) (string, string, error)
Delete(machineclass *MachineClassMeta, credentials, machineID string) error
List(machineclass *MachineClassMeta, credentials, machineID string) (map[string]string, error)
}
&lt;/code>&lt;/pre>&lt;h3 id="getmachineclass">GetMachineClass()&lt;/h3>
&lt;p>&lt;code>rpc GetMachineClass(MachineClassMeta) returns (MachineClass) {}&lt;/code>&lt;/p>
&lt;p>As part of the message from MCM for various machine operations, the name of the machine class is sent instead of the full machine class spec. The CP client is expected to use this GRPC service to get the full spec of the machine class. This optionally enables the client to cache the machine class spec, and make the call only if the machine calass spec is not already cached.&lt;/p>
&lt;h3 id="getsecret">GetSecret()&lt;/h3>
&lt;p>&lt;code>rpc GetSecret(SecretMeta) returns (Secret) {}&lt;/code>&lt;/p>
&lt;p>As part of the message from MCM for various machine operations, the Cloud Config (CC) and CP credentials are not sent. The CP client is expected to use this GRPC service to get the secret which has CC and CP&amp;rsquo;s credentials from MCM. This enables the client to cache the CC and credentials, and to make the call only if the data is not already cached.&lt;/p>
&lt;h2 id="how-to-add-a-new-cloud-providers-support">How to add a new Cloud Provider&amp;rsquo;s support&lt;/h2>
&lt;p>Import the package &lt;code>grpc/infraclient&lt;/code> and &lt;code>grpc/infrapb&lt;/code> from MCM (currently in MCM&amp;rsquo;s &amp;ldquo;grpc-driver&amp;rdquo; branch)&lt;/p>
&lt;ul>
&lt;li>Implement the interface &lt;code>ExternalDriverProvider&lt;/code>
&lt;ul>
&lt;li>&lt;code>Create()&lt;/code>: Creates a new machine&lt;/li>
&lt;li>&lt;code>Delete()&lt;/code>: Deletes a machine&lt;/li>
&lt;li>&lt;code>List()&lt;/code>: Lists machines&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Use the interface &lt;code>MachineClassDataProvider&lt;/code>
&lt;ul>
&lt;li>&lt;code>GetMachineClass()&lt;/code>: Makes the call to MCM to get machine class spec&lt;/li>
&lt;li>&lt;code>GetSecret()&lt;/code>: Makes the call to MCM to get secret containing Cloud Config and CP&amp;rsquo;s credentials&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="example-implementation">Example implementation:&lt;/h3>
&lt;p>Refer GRPC based implementation for AWS client:
&lt;a href="https://github.com/ggaurav10/aws-driver-grpc">https://github.com/ggaurav10/aws-driver-grpc&lt;/a>&lt;/p></description></item></channel></rss>