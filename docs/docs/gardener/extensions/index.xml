<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener – Extensions</title><link>https://gardener.cloud/docs/gardener/extensions/</link><description>Recent content in Extensions on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/gardener/extensions/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Access to the Garden Cluster for Extensions</title><link>https://gardener.cloud/docs/gardener/extensions/garden-api-access/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/garden-api-access/</guid><description>
&lt;h1 id="access-to-the-garden-cluster-for-extensions">Access to the Garden Cluster for Extensions&lt;/h1>
&lt;p>Gardener offers different means to provide or equip registered extensions with a kubeconfig which may be used to connect to the garden cluster.&lt;/p>
&lt;h2 id="admission-controllers">Admission Controllers&lt;/h2>
&lt;p>For extensions with an admission controller deployment, &lt;code>gardener-operator&lt;/code> injects a token-based kubeconfig as a volume and volume mount.
The token is valid for &lt;code>12h&lt;/code>, automatically renewed, and associated with a dedicated &lt;code>ServiceAccount&lt;/code> in the garden cluster.
The path to this kubeconfig is revealed under the &lt;code>GARDEN_KUBECONFIG&lt;/code> environment variable, also added to the pod spec(s).&lt;/p>
&lt;h2 id="extensions-on-seed-clusters">Extensions on &lt;code>Seed&lt;/code> Clusters&lt;/h2>
&lt;p>Extensions that are installed on seed clusters via a &lt;code>ControllerInstallation&lt;/code> can simply read the kubeconfig file specified by the &lt;code>GARDEN_KUBECONFIG&lt;/code> environment variable to create a garden cluster client.
With this, they use a short-lived token (valid for &lt;code>12h&lt;/code>) associated with a dedicated &lt;code>ServiceAccount&lt;/code> in the &lt;code>seed-&amp;lt;seed-name&amp;gt;&lt;/code> namespace to securely access the garden cluster.
The used &lt;code>ServiceAccounts&lt;/code> are granted permissions in the garden cluster similar to gardenlet clients.&lt;/p>
&lt;h3 id="background">Background&lt;/h3>
&lt;p>Historically, &lt;code>gardenlet&lt;/code> has been the only component running in the seed cluster that has access to both the seed cluster and the garden cluster.
Accordingly, extensions running on the seed cluster didn&amp;rsquo;t have access to the garden cluster.&lt;/p>
&lt;p>Starting from Gardener &lt;a href="https://github.com/gardener/gardener/releases/v1.74.0">&lt;code>v1.74.0&lt;/code>&lt;/a>, there is a new mechanism for components running on seed clusters to get access to the garden cluster.
For this, &lt;code>gardenlet&lt;/code> runs an instance of the &lt;a href="https://gardener.cloud/docs/gardener/concepts/gardenlet/#tokenrequestor-controller">&lt;code>TokenRequestor&lt;/code>&lt;/a> for requesting tokens that can be used to communicate with the garden cluster.&lt;/p>
&lt;h3 id="using-gardenlet-managed-garden-access">Using Gardenlet-Managed Garden Access&lt;/h3>
&lt;p>By default, extensions are equipped with secure access to the garden cluster using a dedicated &lt;code>ServiceAccount&lt;/code> without requiring any additional action.
They can simply read the file specified by the &lt;code>GARDEN_KUBECONFIG&lt;/code> and construct a garden client with it.&lt;/p>
&lt;p>When installing a &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/">&lt;code>ControllerInstallation&lt;/code>&lt;/a>, gardenlet creates two secrets in the installation&amp;rsquo;s namespace: a generic garden kubeconfig (&lt;code>generic-garden-kubeconfig-&amp;lt;hash&amp;gt;&lt;/code>) and a garden access secret (&lt;code>garden-access-extension&lt;/code>).
Note that the &lt;code>ServiceAccount&lt;/code> created based on this access secret will be created in the respective &lt;code>seed-*&lt;/code> namespace in the garden cluster and labelled with &lt;code>controllerregistration.core.gardener.cloud/name=&amp;lt;name&amp;gt;&lt;/code>.&lt;/p>
&lt;p>Additionally, gardenlet injects &lt;code>volume&lt;/code>, &lt;code>volumeMounts&lt;/code>, and two environment variables into all (init) containers in all objects in the &lt;code>apps&lt;/code> and &lt;code>batch&lt;/code> API groups:&lt;/p>
&lt;ul>
&lt;li>&lt;code>GARDEN_KUBECONFIG&lt;/code>: points to the path where the generic garden kubeconfig is mounted.&lt;/li>
&lt;li>&lt;code>SEED_NAME&lt;/code>: set to the name of the &lt;code>Seed&lt;/code> where the extension is installed.
This is useful for restricting watches in the garden cluster to relevant objects.&lt;/li>
&lt;/ul>
&lt;p>If an object already contains the &lt;code>GARDEN_KUBECONFIG&lt;/code> environment variable, it is not overwritten and injection of &lt;code>volume&lt;/code> and &lt;code>volumeMounts&lt;/code> is skipped.&lt;/p>
&lt;p>For example, a &lt;code>Deployment&lt;/code> deployed via a &lt;code>ControllerInstallation&lt;/code> will be mutated as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: apps/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: gardener-extension-provider-local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.resources.gardener.cloud/secret-795f7ca6: garden-access-extension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.resources.gardener.cloud/secret-d5f5a834: generic-garden-kubeconfig-81fb3a88
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.resources.gardener.cloud/secret-795f7ca6: garden-access-extension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reference.resources.gardener.cloud/secret-d5f5a834: generic-garden-kubeconfig-81fb3a88
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> containers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: gardener-extension-provider-local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> env:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: GARDEN_KUBECONFIG
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value: /var/run/secrets/gardener.cloud/garden/generic-kubeconfig/kubeconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: SEED_NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value: local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volumeMounts:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - mountPath: /var/run/secrets/gardener.cloud/garden/generic-kubeconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: garden-kubeconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> readOnly: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volumes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: garden-kubeconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> projected:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defaultMode: 420
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - secret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - key: kubeconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path: kubeconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: generic-garden-kubeconfig-81fb3a88
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> optional: &lt;span style="color:#00f">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - secret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - key: token
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path: token
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: garden-access-extension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> optional: &lt;span style="color:#00f">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The generic garden kubeconfig will look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Config
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>clusters:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- cluster:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> certificate-authority-data: LS0t...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> server: https://garden.local.gardener.cloud:6443
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>contexts:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- context:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user: extension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>current-context: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>users:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- name: extension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tokenFile: /var/run/secrets/gardener.cloud/garden/generic-kubeconfig/token
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="manually-requesting-a-token-for-the-garden-cluster">Manually Requesting a Token for the Garden Cluster&lt;/h3>
&lt;p>Seed components that need to communicate with the garden cluster can request a token in the garden cluster by creating a garden access secret.
This secret has to be labelled with &lt;code>resources.gardener.cloud/purpose=token-requestor&lt;/code> and &lt;code>resources.gardener.cloud/class=garden&lt;/code>, e.g.:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: garden-access-example
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: example
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources.gardener.cloud/purpose: token-requestor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources.gardener.cloud/class: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceaccount.resources.gardener.cloud/name: example
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type: Opaque
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will instruct gardenlet to create a new &lt;code>ServiceAccount&lt;/code> named &lt;code>example&lt;/code> in its own &lt;code>seed-&amp;lt;seed-name&amp;gt;&lt;/code> namespace in the garden cluster, request a token for it, and populate the token in the secret&amp;rsquo;s data under the &lt;code>token&lt;/code> key.&lt;/p>
&lt;h3 id="permissions-in-the-garden-cluster">Permissions in the Garden Cluster&lt;/h3>
&lt;p>Both the &lt;a href="https://gardener.cloud/docs/gardener/deployment/gardenlet_api_access/">&lt;code>SeedAuthorizer&lt;/code> and the &lt;code>SeedRestriction&lt;/code> plugin&lt;/a> handle extensions clients and generally grant the same permissions in the garden cluster to them as to gardenlet clients.
With this, extensions are restricted to work with objects in the garden cluster that are related to seed they are running one just like gardenlet.
Note that if the plugins are not enabled, extension clients are only granted read access to global resources like &lt;code>CloudProfiles&lt;/code> (this is granted to all authenticated users).
There are a few exceptions to the granted permissions as documented &lt;a href="https://gardener.cloud/docs/gardener/deployment/gardenlet_api_access/#rule-exceptions-for-extension-clients">here&lt;/a>.&lt;/p>
&lt;h3 id="additional-permissions">Additional Permissions&lt;/h3>
&lt;p>If an extension needs access to additional resources in the garden cluster (e.g., extension-specific custom resources), permissions need to be granted via the usual RBAC means.
Let&amp;rsquo;s consider the following example: An extension requires the privileges to create &lt;a href="https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/subject-access-review-v1/">&lt;code>authorization.k8s.io/v1.SubjectAccessReview&lt;/code>&lt;/a>s (which is not covered by the &amp;ldquo;default&amp;rdquo; permissions mentioned above).
This requires a human Gardener operator to create a &lt;code>ClusterRole&lt;/code> in the garden cluster with the needed rules:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: rbac.authorization.k8s.io/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ClusterRole
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: extension-create-subjectaccessreviews
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorization.gardener.cloud/extensions-serviceaccount-selector: &lt;span style="color:#a31515">&amp;#39;{&amp;#34;matchLabels&amp;#34;:{&amp;#34;controllerregistration.core.gardener.cloud/name&amp;#34;:&amp;#34;&amp;lt;extension-name&amp;gt;&amp;#34;}}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorization.gardener.cloud/custom-extensions-permissions: &lt;span style="color:#a31515">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rules:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- apiGroups:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - authorization.k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - subjectaccessreviews
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> verbs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - create
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note the label &lt;code>authorization.gardener.cloud/extensions-serviceaccount-selector&lt;/code> which contains a label selector for &lt;code>ServiceAccount&lt;/code>s.&lt;/p>
&lt;p>There is a controller part of &lt;code>gardener-controller-manager&lt;/code> which takes care of maintaining the respective &lt;code>ClusterRoleBinding&lt;/code> resources.
It binds all &lt;code>ServiceAccount&lt;/code>s in the seed namespaces in the garden cluster (i.e., all extension clients) whose labels match.
You can read more about this controller &lt;a href="https://gardener.cloud/docs/gardener/concepts/controller-manager/#-extension-clusterrole--reconciler">here&lt;/a>.&lt;/p>
&lt;h4 id="custom-permissions">Custom Permissions&lt;/h4>
&lt;p>If an extension wants to create a dedicated &lt;code>ServiceAccount&lt;/code> for accessing the garden cluster &lt;strong>without&lt;/strong> automatically inheriting all permissions of the gardenlet, it first needs to create a garden access secret in its extension namespace in the seed cluster:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: my-custom-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: &amp;lt;extension-namespace&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources.gardener.cloud/purpose: token-requestor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources.gardener.cloud/class: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceaccount.resources.gardener.cloud/name: my-custom-component-extension-foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> serviceaccount.resources.gardener.cloud/labels: &lt;span style="color:#a31515">&amp;#39;{&amp;#34;foo&amp;#34;:&amp;#34;bar}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type: Opaque
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>❗️&lt;strong>️Do not prefix the service account name with &lt;code>extension-&lt;/code> to prevent inheriting the gardenlet permissions!&lt;/strong> It is still recommended to add the extension name (e.g., as a suffix) for easier identification where this &lt;code>ServiceAccount&lt;/code> comes from.&lt;/p>
&lt;p>Next, you can follow the same approach &lt;a href="https://gardener.cloud/docs/gardener/extensions/garden-api-access/#additional-permissions">described above&lt;/a>.
However, the &lt;code>authorization.gardener.cloud/extensions-serviceaccount-selector&lt;/code> annotation should &lt;strong>not&lt;/strong> contain &lt;code>controllerregistration.core.gardener.cloud/name=&amp;lt;extension-name&amp;gt;&lt;/code> but rather custom labels, e.g. &lt;code>foo=bar&lt;/code>.&lt;/p>
&lt;p>This way, the created &lt;code>ServiceAccount&lt;/code> will only get the permissions of &lt;a href="https://gardener.cloud/docs/gardener/extensions/garden-api-access/#additional-permissions">above &lt;code>ClusterRole&lt;/code>&lt;/a> and nothing else.&lt;/p>
&lt;h3 id="renewing-all-garden-access-secrets">Renewing All Garden Access Secrets&lt;/h3>
&lt;p>Operators can trigger an automatic renewal of all garden access secrets in a given &lt;code>Seed&lt;/code> and their requested &lt;code>ServiceAccount&lt;/code> tokens, e.g., when rotating the garden cluster&amp;rsquo;s &lt;code>ServiceAccount&lt;/code> signing key.
For this, the &lt;code>Seed&lt;/code> has to be annotated with &lt;code>gardener.cloud/operation=renew-garden-access-secrets&lt;/code>.&lt;/p></description></item><item><title>Docs: Admission</title><link>https://gardener.cloud/docs/gardener/extensions/admission/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/admission/</guid><description>
&lt;h1 id="extension-admission">Extension Admission&lt;/h1>
&lt;p>The extensions are expected to validate their respective resources for their extension specific configurations, when the resources are newly created or updated. For example, &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/README.md#infrastructure-provider">provider extensions&lt;/a> would validate &lt;code>spec.provider.infrastructureConfig&lt;/code> and &lt;code>spec.provider.controlPlaneConfig&lt;/code> in the &lt;code>Shoot&lt;/code> resource and &lt;code>spec.providerConfig&lt;/code> in the &lt;code>CloudProfile&lt;/code> resource, &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/README.md#network-plugin">networking extensions&lt;/a> would validate &lt;code>spec.networking.providerConfig&lt;/code> in the &lt;code>Shoot&lt;/code> resource. As best practice, the validation should be performed only if there is a change in the &lt;code>spec&lt;/code> of the resource. Please find an exemplary implementation in the &lt;a href="https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/admission/validator">gardener/gardener-extension-provider-aws&lt;/a> repository.&lt;/p>
&lt;p>When a resource is newly created or updated, Gardener adds an extension label for all the extension types referenced in the &lt;code>spec&lt;/code> of the resource. This label is of the form &lt;code>&amp;lt;extension-type&amp;gt;.extensions.gardener.cloud/&amp;lt;extension-name&amp;gt; : &amp;quot;true&amp;quot;&lt;/code>. For example, an extension label for a provider extension type &lt;code>aws&lt;/code> looks like &lt;code>provider.extensions.gardener.cloud/aws : &amp;quot;true&amp;quot;&lt;/code>. The extensions should add object selectors in their admission webhooks for these labels, to filter out the objects they are responsible for. At present, these labels are added to &lt;code>BackupEntry&lt;/code>s, &lt;code>BackupBucket&lt;/code>s, &lt;code>CloudProfile&lt;/code>s, &lt;code>Seed&lt;/code>s, &lt;code>SecretBinding&lt;/code>s and &lt;code>Shoot&lt;/code>s. Please see the &lt;a href="https://github.com/gardener/gardener/blob/master/pkg/apis/core/v1beta1/constants/types_constants.go">types_constants.go&lt;/a> file for the full list of extension labels.&lt;/p></description></item><item><title>Docs: CA Rotation</title><link>https://gardener.cloud/docs/gardener/extensions/ca-rotation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/ca-rotation/</guid><description>
&lt;h1 id="ca-rotation-in-extensions">CA Rotation in Extensions&lt;/h1>
&lt;p>&lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md">GEP-18&lt;/a> proposes adding support for automated rotation of Shoot cluster certificate authorities (CAs).
This document outlines all the requirements that Gardener extensions need to fulfill in order to support the CA rotation feature.&lt;/p>
&lt;h2 id="requirements-for-shoot-cluster-ca-rotation">Requirements for Shoot Cluster CA Rotation&lt;/h2>
&lt;ul>
&lt;li>Extensions must not rely on static CA &lt;code>Secret&lt;/code> names managed by the gardenlet, because their names are changing during CA rotation.&lt;/li>
&lt;li>Extensions cannot issue or use client certificates for authenticating against shoot API servers. Instead, they should use short-lived auto-rotated &lt;code>ServiceAccount&lt;/code> tokens via gardener-resource-manager&amp;rsquo;s &lt;code>TokenRequestor&lt;/code>. Also see &lt;a href="https://gardener.cloud/docs/gardener/extensions/conventions/">Conventions&lt;/a> and &lt;a href="https://gardener.cloud/docs/gardener/concepts/resource-manager/#tokenrequestor">&lt;code>TokenRequestor&lt;/code>&lt;/a> documents.&lt;/li>
&lt;li>Extensions need to generate dedicated CAs for signing server certificates (e.g. &lt;code>cloud-controller-manager&lt;/code>). There should be one CA per controller and purpose in order to bind the lifecycle to the reconciliation cycle of the respective object for which it is created.&lt;/li>
&lt;li>CAs managed by extensions should be rotated in lock-step with the shoot cluster CA.
When the user triggers a rotation, the gardenlet writes phase and initiation time to &lt;code>Shoot.status.credentials.rotation.certificateAuthorities.{phase,lastInitiationTime}&lt;/code>. See &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md#rotation-sequence-for-cluster-and-client-ca">GEP-18&lt;/a> for a detailed description on what needs to happen in each phase.
Extensions can retrieve this information from &lt;a href="https://gardener.cloud/docs/gardener/extensions/cluster/">&lt;code>Cluster.shoot.status&lt;/code>&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="utilities-for-secrets-management">Utilities for Secrets Management&lt;/h2>
&lt;p>In order to fulfill the requirements listed above, extension controllers can reuse the &lt;a href="https://gardener.cloud/docs/gardener/secrets_management/">&lt;code>SecretsManager&lt;/code>&lt;/a> that the gardenlet uses to manage all shoot cluster CAs, certificates, and other secrets as well.
It implements the core logic for managing secrets that need to be rotated, auto-renewed, etc.&lt;/p>
&lt;p>Additionally, there are utilities for reusing &lt;code>SecretsManager&lt;/code> in extension controllers.
They already implement the above requirements based on the &lt;code>Cluster&lt;/code> resource and allow focusing on the extension controllers&amp;rsquo; business logic.&lt;/p>
&lt;p>For example, a simple &lt;code>SecretsManager&lt;/code> usage in an extension controller could look like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00f">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// identity for SecretsManager instance in ControlPlane controller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> identity = &lt;span style="color:#a31515">&amp;#34;provider-foo-controlplane&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// secret config name of the dedicated CA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> caControlPlaneName = &lt;span style="color:#a31515">&amp;#34;ca-provider-foo-controlplane&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00f">func&lt;/span> Reconcile() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">var&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cluster *extensionscontroller.Cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client client.Client
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// define wanted secrets with options
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> secretConfigs = []extensionssecretsmanager.SecretConfigWithOptions{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// dedicated CA for ControlPlane controller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Config: &amp;amp;secretutils.CertificateSecretConfig{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name: caControlPlaneName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CommonName: &lt;span style="color:#a31515">&amp;#34;ca-provider-foo-controlplane&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CertType: secretutils.CACert,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// persist CA so that it gets restored on control plane migration
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Options: []secretsmanager.GenerateOption{secretsmanager.Persist()},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// server cert for control plane component
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Config: &amp;amp;secretutils.CertificateSecretConfig{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name: &lt;span style="color:#a31515">&amp;#34;cloud-controller-manager&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CommonName: &lt;span style="color:#a31515">&amp;#34;cloud-controller-manager&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DNSNames: kutil.DNSNamesForService(&lt;span style="color:#a31515">&amp;#34;cloud-controller-manager&amp;#34;&lt;/span>, namespace),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CertType: secretutils.ServerCert,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// sign with our dedicated CA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Options: []secretsmanager.GenerateOption{secretsmanager.SignedByCA(caControlPlaneName)},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// initialize SecretsManager based on Cluster object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> sm, err := extensionssecretsmanager.SecretsManagerForCluster(ctx, logger.WithName(&lt;span style="color:#a31515">&amp;#34;secretsmanager&amp;#34;&lt;/span>), clock.RealClock{}, client, cluster, identity, secretConfigs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// generate all wanted secrets (first CAs, then the rest)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> secrets, err := extensionssecretsmanager.GenerateAllSecrets(ctx, sm, secretConfigs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// cleanup any secrets that are not needed any more (e.g. after rotation)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> err = sm.Cleanup(ctx)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please pay attention to the following points:&lt;/p>
&lt;ul>
&lt;li>There should be one &lt;code>SecretsManager&lt;/code> identity per controller (and purpose if applicable) in order to prevent conflicts between different instances.
E.g., there should be different identities for &lt;code>Infrastructrue&lt;/code>, &lt;code>Worker&lt;/code> controller, etc., and the &lt;code>ControlPlane&lt;/code> controller should use dedicated &lt;code>SecretsManager&lt;/code> identities per purpose (e.g. &lt;code>provider-foo-controlplane&lt;/code> and &lt;code>provider-foo-controlplane-exposure&lt;/code>).&lt;/li>
&lt;li>All other points in &lt;a href="https://gardener.cloud/docs/gardener/secrets_management/#reusing-the-secretsmanager-in-other-components">Reusing the SecretsManager in Other Components&lt;/a>.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Cluster</title><link>https://gardener.cloud/docs/gardener/extensions/cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/cluster/</guid><description>
&lt;h1 id="cluster-resource">&lt;code>Cluster&lt;/code> Resource&lt;/h1>
&lt;p>As part of the extensibility epic, a lot of responsibility that was previously taken over by Gardener directly has now been shifted to extension controllers running in the seed clusters.
These extensions often serve a well-defined purpose (e.g., the management of &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/dnsrecord/">DNS records&lt;/a>, &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/infrastructure/">infrastructure&lt;/a>).
We have introduced a couple of extension CRDs in the seeds whose specification is written by Gardener, and which are acted up by the extensions.&lt;/p>
&lt;p>However, the extensions sometimes require more information that is not directly part of the specification.
One example of that is the GCP infrastructure controller which needs to know the shoot&amp;rsquo;s pod and service network.
Another example is the Azure infrastructure controller which requires some information out of the &lt;code>CloudProfile&lt;/code> resource.
The problem is that Gardener does not know which extension requires which information so that it can write it into their specific CRDs.&lt;/p>
&lt;p>In order to deal with this problem we have introduced the &lt;code>Cluster&lt;/code> extension resource.
This CRD is written into the seeds, however, it does not contain a &lt;code>status&lt;/code>, so it is not expected that something acts upon it.
Instead, you can treat it like a &lt;code>ConfigMap&lt;/code> which contains data that might be interesting for you.
In the context of Gardener, seeds and shoots, and extensibility the &lt;code>Cluster&lt;/code> resource contains the &lt;code>CloudProfile&lt;/code>, &lt;code>Seed&lt;/code>, and &lt;code>Shoot&lt;/code> manifest.
Extension controllers can take whatever information they want out of it that might help completing their individual tasks.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cloudProfile:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: CloudProfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seed:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Seed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shoot:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The resource is written by Gardener before it starts the reconciliation flow of the shoot.&lt;/p>
&lt;p>⚠️ All Gardener components use the &lt;code>core.gardener.cloud/v1beta1&lt;/code> version, i.e., the &lt;code>Cluster&lt;/code> resource will contain the objects in this version.&lt;/p>
&lt;h2 id="important-information-that-should-be-taken-into-account">Important Information that Should Be Taken into Account&lt;/h2>
&lt;p>There are some fields in the &lt;code>Shoot&lt;/code> specification that might be interesting to take into account.&lt;/p>
&lt;ul>
&lt;li>&lt;code>.spec.hibernation.enabled={true,false}&lt;/code>: Extension controllers might want to behave differently if the shoot is hibernated or not (probably they might want to scale down their control plane components, for example).&lt;/li>
&lt;li>&lt;code>.status.lastOperation.state=Failed&lt;/code>: If Gardener sets the shoot&amp;rsquo;s last operation state to &lt;code>Failed&lt;/code>, it means that Gardener won&amp;rsquo;t automatically retry to finish the reconciliation/deletion flow because an error occurred that could not be resolved within the last &lt;code>24h&lt;/code> (default). In this case, end-users are expected to manually re-trigger the reconciliation flow in case they want Gardener to try again. Extension controllers are expected to follow the same principle. This means they have to read the shoot state out of the &lt;code>Cluster&lt;/code> resource.&lt;/li>
&lt;/ul>
&lt;h2 id="extension-resources-not-associated-with-a-shoot">Extension Resources Not Associated with a Shoot&lt;/h2>
&lt;p>In some cases, Gardener may create extension resources that are not associated with a shoot, but are needed to support some functionality internal to Gardener. Such resources will be created in the &lt;code>garden&lt;/code> namespace of a seed cluster.&lt;/p>
&lt;p>For example, if the &lt;a href="https://gardener.cloud/docs/gardener/deployment/deploy_gardenlet_manually/">managed ingress controller&lt;/a> is active on the seed, Gardener will create a &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/dnsrecord/">DNSRecord&lt;/a> resource(s) in the &lt;code>garden&lt;/code> namespace of the seed cluster for the ingress DNS record.&lt;/p>
&lt;p>Extension controllers that may be expected to reconcile extension resources in the &lt;code>garden&lt;/code> namespace should make sure that they can tolerate the absence of a cluster resource. This means that they should not attempt to read the cluster resource in such cases, or if they do they should ignore the &amp;ldquo;not found&amp;rdquo; error.&lt;/p>
&lt;h2 id="references-and-additional-resources">References and Additional Resources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_cluster.go">&lt;code>Cluster&lt;/code> API (Golang Specification)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: ControllerRegistration</title><link>https://gardener.cloud/docs/gardener/extensions/controllerregistration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/controllerregistration/</guid><description>
&lt;h1 id="registering-extension-controllers">Registering Extension Controllers&lt;/h1>
&lt;p>Extensions are registered in the garden cluster via &lt;a href="https://github.com/gardener/gardener/blob/master/example/25-controllerregistration.yaml">&lt;code>ControllerRegistration&lt;/code>&lt;/a> resources.
Deployment for respective extensions are specified via &lt;a href="https://github.com/gardener/gardener/blob/master/example/25-controllerdeployment.yaml">&lt;code>ControllerDeployment&lt;/code>&lt;/a> resources.
Gardener evaluates the registrations and deployments and creates &lt;a href="https://github.com/gardener/gardener/blob/master/example/25-controllerinstallation.yaml">&lt;code>ControllerInstallation&lt;/code>&lt;/a> resources which describe the request &amp;ldquo;please install this controller &lt;code>X&lt;/code> to this seed &lt;code>Y&lt;/code>&amp;rdquo;.&lt;/p>
&lt;p>Similar to how &lt;code>CloudProfile&lt;/code> or &lt;code>Seed&lt;/code> resources get into the system, the Gardener administrator must deploy the &lt;code>ControllerRegistration&lt;/code> and &lt;code>ControllerDeployment&lt;/code> resources (this does not happen automatically in any way - the administrator decides which extensions shall be enabled).&lt;/p>
&lt;p>The specification mainly describes which of Gardener&amp;rsquo;s extension CRDs are managed, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ControllerDeployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: os-gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ociRepository:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref: registry.example.com/os-gardenlinux/charts/os-gardenlinux:1.0.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># or a base64-encoded, gzip&amp;#39;ed, tar&amp;#39;ed extension controller chart&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># rawChart: H4sIFAAAAAAA/yk...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo: bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ControllerRegistration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: os-gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deployment:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deploymentRefs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: os-gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - kind: OperatingSystemConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> primary: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This information tells Gardener that there is an extension controller that can handle &lt;code>OperatingSystemConfig&lt;/code> resources of type &lt;code>gardenlinux&lt;/code>.
A reference to the shown &lt;code>ControllerDeployment&lt;/code> specifies how the deployment of the extension controller is accomplished.&lt;/p>
&lt;p>Also, it specifies that this controller is the primary one responsible for the lifecycle of the &lt;code>OperatingSystemConfig&lt;/code> resource.
Setting &lt;code>primary&lt;/code> to &lt;code>false&lt;/code> would allow to register additional, secondary controllers that may also watch/react on the &lt;code>OperatingSystemConfig/coreos&lt;/code> resources, however, only the primary controller may change/update the main &lt;code>status&lt;/code> of the extension object (that are used to &amp;ldquo;communicate&amp;rdquo; with the gardenlet).
Particularly, only the primary controller may set &lt;code>.status.lastOperation&lt;/code>, &lt;code>.status.lastError&lt;/code>, &lt;code>.status.observedGeneration&lt;/code>, and &lt;code>.status.state&lt;/code>.
Secondary controllers may contribute to the &lt;code>.status.conditions[]&lt;/code> if they like, of course.&lt;/p>
&lt;p>Secondary controllers might be helpful in scenarios where additional tasks need to be completed which are not part of the reconciliation logic of the primary controller but separated out into a dedicated extension.&lt;/p>
&lt;p>⚠️ There must be exactly one primary controller for every registered kind/type combination.
Also, please note that the &lt;code>primary&lt;/code> field cannot be changed after creation of the &lt;code>ControllerRegistration&lt;/code>.&lt;/p>
&lt;h2 id="deploying-extension-controllers">Deploying Extension Controllers&lt;/h2>
&lt;p>Submitting the above &lt;code>ControllerDeployment&lt;/code> and &lt;code>ControllerRegistration&lt;/code> will create a &lt;code>ControllerInstallation&lt;/code> resource:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ControllerInstallation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: os-gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deploymentRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: os-gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registrationRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: os-gardenlinux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seedRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: aws-eu1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This resource expresses that Gardener requires the &lt;code>os-gardenlinux&lt;/code> extension controller to run on the &lt;code>aws-eu1&lt;/code> seed cluster.&lt;/p>
&lt;p>gardener-controller-manager automatically determines which extension is required on which seed cluster and will only create &lt;code>ControllerInstallation&lt;/code> objects for those.
Also, it will automatically delete &lt;code>ControllerInstallation&lt;/code>s referencing extension controllers that are no longer required on a seed (e.g., because all shoots on it have been deleted).
There are additional configuration options, please see the &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/#deployment-configuration-options">Deployment Configuration Options section&lt;/a>.
After gardener-controller-manager has written the &lt;code>ControllerInstallation&lt;/code> resource, gardenlet picks it up and installs the controller on the respective &lt;code>Seed&lt;/code> using the referenced &lt;code>ControllerDeployment&lt;/code>.&lt;/p>
&lt;p>It is sufficient to create a Helm chart and deploy it together with some static configuration values.
For this, operators have to provide the deployment information in the &lt;code>ControllerDeployment.helm&lt;/code> section:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rawChart: H4sIFAAAAAAA/yk...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo: bar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can check out &lt;a href="https://github.com/gardener/gardener/blob/master/hack/generate-controller-registration.sh">&lt;code>hack/generate-controller-registration.yaml&lt;/code>&lt;/a> for generating a &lt;code>ControllerDeployment&lt;/code> including a controller helm chart.&lt;/p>
&lt;p>If &lt;code>ControllerDeployment.helm&lt;/code> is specified, gardenlet either decodes the provided Helm chart (&lt;code>.helm.rawChart&lt;/code>) or pulls the chart from the referenced OCI Repository (&lt;code>.helm.ociRepository&lt;/code>).
When referencing an OCI Repository, you have several options in how to specify where to pull the chart:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>helm:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ociRepository:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># full ref with either tag or digest, or both&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref: registry.example.com/foo:1.0.0@sha256:abc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ociRepository:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># repository and tag&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository: registry.example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tag: 1.0.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ociRepository:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># repository and digest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository: registry.example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> digest: sha256:abc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>helm:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ociRepository:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># when specifying both tag and digest, the tag is ignored.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository: registry.example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tag: 1.0.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> digest: sha256:abc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gardenlet caches the downloaded chart in memory. It is recommended to always specify a digest, because if it is not specified, gardenlet needs to fetch the manifest in every reconciliation to compare the digest with the local cache.&lt;/p>
&lt;p>No matter where the chart originates from, gardenlet deploys it with the provided static configuration (&lt;code>.helm.values&lt;/code>).
The chart and the values can be updated at any time - Gardener will recognize it and re-trigger the deployment process.
In order to allow extensions to get information about the garden and the seed cluster, gardenlet mixes in certain properties into the values (root level) of every deployed Helm chart:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>gardener:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version: &amp;lt;gardener-version&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> garden:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusterIdentity: &amp;lt;uuid-of-gardener-installation&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> genericKubeconfigSecretName: &amp;lt;generic-garden-kubeconfig-secret-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seed:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;lt;seed-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clusterIdentity: &amp;lt;seed-cluster-identity&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> annotations: &amp;lt;seed-annotations&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels: &amp;lt;seed-labels&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> provider: &amp;lt;seed-provider-type&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> region: &amp;lt;seed-region&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volumeProvider: &amp;lt;seed-first-volume-provider&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volumeProviders: &amp;lt;seed-volume-providers&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ingressDomain: &amp;lt;seed-ingress-domain&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> protected: &amp;lt;seed-protected-taint&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visible: &amp;lt;seed-visible-setting&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> taints: &amp;lt;seed-taints&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networks: &amp;lt;seed-networks&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> blockCIDRs: &amp;lt;seed-networks-blockCIDRs&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec: &amp;lt;seed-spec&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gardenlet:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> featureGates: &amp;lt;gardenlet-feature-gates&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Extensions can use this information in their Helm chart in case they require knowledge about the garden and the seed environment.
The list might be extended in the future.&lt;/p>
&lt;p>gardenlet reports whether the extension controller has been installed successfully and running in the &lt;code>ControllerInstallation&lt;/code> status:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:04:16Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:04:16Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: The controller running in the seed cluster is healthy.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: ControllerHealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Healthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:04:06Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:04:06Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: The controller was successfully installed in the seed cluster.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: InstallationSuccessful
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Installed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:04:16Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:04:16Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: The controller has been rolled out successfully.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: ControllerRolledOut
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Progressing
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:03:39Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2024-05-16T13:03:39Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: chart could be rendered successfully.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: RegistrationValid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: Valid
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="deployment-configuration-options">Deployment Configuration Options&lt;/h3>
&lt;p>The &lt;code>.spec.deployment&lt;/code> resource allows to configure a deployment &lt;code>policy&lt;/code>.
There are the following policies:&lt;/p>
&lt;ul>
&lt;li>&lt;code>OnDemand&lt;/code> (default): Gardener will demand the deployment and deletion of the extension controller to/from seed clusters dynamically. It will automatically determine (based on other resources like &lt;code>Shoot&lt;/code>s) whether it is required and decide accordingly.&lt;/li>
&lt;li>&lt;code>Always&lt;/code>: Gardener will demand the deployment of the extension controller to seed clusters independent of whether it is actually required or not. This might be helpful if you want to add a new component/controller to all seed clusters by default. Another use-case is to minimize the durations until extension controllers get deployed and ready in case you have highly fluctuating seed clusters.&lt;/li>
&lt;li>&lt;code>AlwaysExceptNoShoots&lt;/code>: Similar to &lt;code>Always&lt;/code>, but if the seed does not have any shoots, then the extension is not being deployed. It will be deleted from a seed after the last shoot has been removed from it.&lt;/li>
&lt;/ul>
&lt;p>Also, the &lt;code>.spec.deployment.seedSelector&lt;/code> allows to specify a label selector for seed clusters.
Only if it matches the labels of a seed, then it will be deployed to it.
Please note that a seed selector can only be specified for secondary controllers (&lt;code>primary=false&lt;/code> for all &lt;code>.spec.resources[]&lt;/code>).&lt;/p>
&lt;h2 id="extensions-in-the-garden-cluster-itself">Extensions in the Garden Cluster Itself&lt;/h2>
&lt;p>The &lt;code>Shoot&lt;/code> resource itself will contain some provider-specific data blobs.
As a result, some extensions might also want to run in the garden cluster, e.g., to provide &lt;code>ValidatingWebhookConfiguration&lt;/code>s for validating the correctness of their provider-specific blobs:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: johndoe-aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cloud:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> region: eu-west-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: aws.cloud.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: InfrastructureConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vpc: &lt;span style="color:#008000"># specify either &amp;#39;id&amp;#39; or &amp;#39;cidr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># id: vpc-123456&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cidr: 10.250.0.0/16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internal:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - 10.250.112.0/22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> public:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - 10.250.96.0/22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - 10.250.0.0/19
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zones:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - eu-west-1a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above example, Gardener itself does not understand the AWS-specific provider configuration for the infrastructure.
However, if this part of the &lt;code>Shoot&lt;/code> resource should be validated, then you should run an AWS-specific component in the garden cluster that registers a webhook. You can do it similarly if you want to default some fields of a resource (by using a &lt;code>MutatingWebhookConfiguration&lt;/code>).&lt;/p>
&lt;p>Again, similar to how Gardener is deployed to the garden cluster, these components must be deployed and managed by the Gardener administrator.&lt;/p>
&lt;h3 id="extension-resource-configurations">&lt;code>Extension&lt;/code> Resource Configurations&lt;/h3>
&lt;p>The &lt;code>Extension&lt;/code> resource allows injecting arbitrary steps into the shoot reconciliation flow that are unknown to Gardener.
Hence, it is slightly special and allows further configuration when registering it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ControllerRegistration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: extension-foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - kind: Extension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> primary: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> globallyEnabled: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reconcileTimeout: 30s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lifecycle:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reconcile: AfterKubeAPIServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delete: BeforeKubeAPIServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> migrate: BeforeKubeAPIServer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>globallyEnabled=true&lt;/code> option specifies that the &lt;code>Extension/foo&lt;/code> object shall be created by default for all shoots (unless they opted out by setting &lt;code>.spec.extensions[].enabled=false&lt;/code> in the &lt;code>Shoot&lt;/code> spec).&lt;/p>
&lt;p>The &lt;code>reconcileTimeout&lt;/code> tells Gardener how long it should wait during its shoot reconciliation flow for the &lt;code>Extension/foo&lt;/code>&amp;rsquo;s reconciliation to finish.&lt;/p>
&lt;h4 id="extension-lifecycle">&lt;code>Extension&lt;/code> Lifecycle&lt;/h4>
&lt;p>The &lt;code>lifecycle&lt;/code> field tells Gardener when to perform a certain action on the &lt;code>Extension&lt;/code> resource during the reconciliation flows. If omitted, then the default behaviour will be applied. Please find more information on the defaults in the explanation below. Possible values for each control flow are &lt;code>AfterKubeAPIServer&lt;/code>, &lt;code>BeforeKubeAPIServer&lt;/code>, and &lt;code>AfterWorker&lt;/code>. Let&amp;rsquo;s take the following configuration and explain it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lifecycle:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reconcile: AfterKubeAPIServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delete: BeforeKubeAPIServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> migrate: BeforeKubeAPIServer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>reconcile: AfterKubeAPIServer&lt;/code> means that the extension resource will be reconciled after the successful reconciliation of the &lt;code>kube-apiserver&lt;/code> during shoot reconciliation. This is also the default behaviour if this value is not specified. During shoot hibernation, the opposite rule is applied, meaning that in this case the reconciliation of the extension will happen before the &lt;code>kube-apiserver&lt;/code> is scaled to 0 replicas. On the other hand, if the extension needs to be reconciled before the &lt;code>kube-apiserver&lt;/code> and scaled down after it, then the value &lt;code>BeforeKubeAPIServer&lt;/code> should be used.&lt;/li>
&lt;li>&lt;code>delete: BeforeKubeAPIServer&lt;/code> means that the extension resource will be deleted before the &lt;code>kube-apiserver&lt;/code> is destroyed during shoot deletion. This is the default behaviour if this value is not specified.&lt;/li>
&lt;li>&lt;code>migrate: BeforeKubeAPIServer&lt;/code> means that the extension resource will be migrated before the &lt;code>kube-apiserver&lt;/code> is destroyed in the source cluster during &lt;a href="https://gardener.cloud/docs/gardener/control_plane_migration/">control plane migration&lt;/a>. This is the default behaviour if this value is not specified. The restoration of the control plane follows the reconciliation control flow.&lt;/li>
&lt;/ul>
&lt;p>The lifecycle value &lt;code>AfterWorker&lt;/code> is only available during &lt;code>reconcile&lt;/code>. When specified, the extension resource will be reconciled after the workers are deployed. This is useful for extensions that want to deploy a workload in the shoot control plane and want to wait for the workload to run and get ready on a node. During shoot creation the extension will start its reconciliation before the first workers have joined the cluster, they will become available at some later point.&lt;/p></description></item><item><title>Docs: ControlPlane Webhooks</title><link>https://gardener.cloud/docs/gardener/extensions/controlplane-webhooks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/controlplane-webhooks/</guid><description>
&lt;h1 id="controlplane-customization-webhooks">ControlPlane Customization Webhooks&lt;/h1>
&lt;p>Gardener creates the Shoot controlplane in several steps of the Shoot flow. At different point of this flow, it:&lt;/p>
&lt;ul>
&lt;li>Deploys standard controlplane components such as kube-apiserver, kube-controller-manager, and kube-scheduler by creating the corresponding deployments, services, and other resources in the Shoot namespace.&lt;/li>
&lt;li>Initiates the deployment of custom controlplane components by &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/controlplane/">ControlPlane controllers&lt;/a> by creating a &lt;code>ControlPlane&lt;/code> resource in the Shoot namespace.&lt;/li>
&lt;/ul>
&lt;p>In order to apply any provider-specific changes to the configuration provided by Gardener for the standard controlplane components, cloud extension providers can install mutating admission webhooks for the resources created by Gardener in the Shoot namespace.&lt;/p>
&lt;h2 id="what-needs-to-be-implemented-to-support-a-new-cloud-provider">What needs to be implemented to support a new cloud provider?&lt;/h2>
&lt;p>In order to support a new cloud provider, you should install &amp;ldquo;controlplane&amp;rdquo; mutating webhooks for any of the following resources:&lt;/p>
&lt;ul>
&lt;li>Deployment with name &lt;code>kube-apiserver&lt;/code>, &lt;code>kube-controller-manager&lt;/code>, or &lt;code>kube-scheduler&lt;/code>&lt;/li>
&lt;li>Service with name &lt;code>kube-apiserver&lt;/code>&lt;/li>
&lt;li>&lt;code>OperatingSystemConfig&lt;/code> with any name, and purpose &lt;code>reconcile&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>See &lt;a href="https://gardener.cloud/docs/gardener/extensions/controlplane-webhooks/#contract-specification">Contract Specification&lt;/a> for more details on the contract that Gardener and webhooks should adhere to regarding the content of the above resources.&lt;/p>
&lt;p>You can install 3 different kinds of controlplane webhooks:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Shoot&lt;/code>, or &lt;code>controlplane&lt;/code> webhooks apply changes needed by the Shoot cloud provider, for example the &lt;code>--cloud-provider&lt;/code> command line flag of &lt;code>kube-apiserver&lt;/code> and &lt;code>kube-controller-manager&lt;/code>. Such webhooks should only operate on Shoot namespaces labeled with &lt;code>shoot.gardener.cloud/provider=&amp;lt;provider&amp;gt;&lt;/code>.&lt;/li>
&lt;li>&lt;code>Seed&lt;/code>, or &lt;code>controlplaneexposure&lt;/code> webhooks apply changes needed by the Seed cloud provider, for example annotations on the &lt;code>kube-apiserver&lt;/code> service to ensure cloud-specific load balancers are correctly provisioned for a service of type &lt;code>LoadBalancer&lt;/code>. Such webhooks should only operate on Shoot namespaces labeled with &lt;code>seed.gardener.cloud/provider=&amp;lt;provider&amp;gt;&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>The labels &lt;code>shoot.gardener.cloud/provider&lt;/code> and &lt;code>seed.gardener.cloud/provider&lt;/code> are added by Gardener when it creates the Shoot namespace.&lt;/p>
&lt;p>The resources mutated by the &amp;ldquo;controlplane&amp;rdquo; mutating webhooks are labeled with &lt;code>provider.extensions.gardener.cloud/mutated-by-controlplane-webhook: true&lt;/code> by gardenlet. The provider extensions can add an object selector to their &amp;ldquo;controlplane&amp;rdquo; mutating webhooks to not intercept requests for unrelated objects.&lt;/p>
&lt;h2 id="contract-specification">Contract Specification&lt;/h2>
&lt;p>This section specifies the contract that Gardener and webhooks should adhere to in order to ensure smooth interoperability. Note that this contract can&amp;rsquo;t be specified formally and is therefore easy to violate, especially by Gardener. The Gardener team will nevertheless do its best to adhere to this contract in the future and to ensure via additional measures (tests, validations) that it&amp;rsquo;s not unintentionally broken. If it needs to be changed intentionally, this can only happen after proper communication has taken place to ensure that the affected provider webhooks could be adapted to work with the new version of the contract.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> The contract described below may not necessarily be what Gardener does currently (as of May 2019). Rather, it reflects the target state after changes for &lt;a href="https://gardener.cloud/docs/gardener/extensions/">Gardener extensibility&lt;/a> have been introduced.&lt;/p>
&lt;/blockquote>
&lt;h3 id="kube-apiserver">kube-apiserver&lt;/h3>
&lt;p>To deploy kube-apiserver, Gardener &lt;strong>shall&lt;/strong> create a deployment and a service both named &lt;code>kube-apiserver&lt;/code> in the Shoot namespace. They can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.&lt;/p>
&lt;p>The pod template of the &lt;code>kube-apiserver&lt;/code> deployment &lt;strong>shall&lt;/strong> contain a container named &lt;code>kube-apiserver&lt;/code>.&lt;/p>
&lt;p>The &lt;code>command&lt;/code> field of the &lt;code>kube-apiserver&lt;/code> container &lt;strong>shall&lt;/strong> contain the &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver command line&lt;/a>. It &lt;strong>shall&lt;/strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:&lt;/p>
&lt;ul>
&lt;li>admission plugins (&lt;code>--enable-admission-plugins&lt;/code>, &lt;code>--disable-admission-plugins&lt;/code>)&lt;/li>
&lt;li>secure communications (&lt;code>--etcd-cafile&lt;/code>, &lt;code>--etcd-certfile&lt;/code>, &lt;code>--etcd-keyfile&lt;/code>, &amp;hellip;)&lt;/li>
&lt;li>audit log (&lt;code>--audit-log-*&lt;/code>)&lt;/li>
&lt;li>ports (&lt;code>--secure-port&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>The kube-apiserver command line &lt;strong>shall not&lt;/strong> contain any provider-specific flags, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--cloud-provider&lt;/code>&lt;/li>
&lt;li>&lt;code>--cloud-config&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These flags can be added by webhooks if needed.&lt;/p>
&lt;p>The &lt;code>kube-apiserver&lt;/code> command line &lt;strong>may&lt;/strong> contain a number of additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-apiserver behavior for the specific provider. Among the flags to be considered are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--endpoint-reconciler-type&lt;/code>&lt;/li>
&lt;li>&lt;code>--advertise-address&lt;/code>&lt;/li>
&lt;li>&lt;code>--feature-gates&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Gardener uses &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/08-shoot-apiserver-via-sni.md">SNI&lt;/a> to expose the apiserver. In this case, Gardener &lt;strong>will&lt;/strong> label the &lt;code>kube-apiserver&lt;/code>&amp;rsquo;s &lt;code>Deployment&lt;/code> with &lt;code>core.gardener.cloud/apiserver-exposure: gardener-managed&lt;/code> label (deprecated, the label will no longer be added as of &lt;code>v1.80&lt;/code>) and expects that the &lt;code>--endpoint-reconciler-type&lt;/code> and &lt;code>--advertise-address&lt;/code> flags are not modified.&lt;/p>
&lt;p>The &lt;code>--enable-admission-plugins&lt;/code> flag &lt;strong>may&lt;/strong> contain admission plugins that are not compatible with CSI plugins such as &lt;code>PersistentVolumeLabel&lt;/code>. Webhooks should therefore ensure that such admission plugins are either explicitly enabled (if CSI plugins are not used) or disabled (otherwise).&lt;/p>
&lt;p>The &lt;code>env&lt;/code> field of the &lt;code>kube-apiserver&lt;/code> container &lt;strong>shall not&lt;/strong> contain any provider-specific environment variables (so it will be empty). If any provider-specific environment variables are needed, they should be added by webhooks.&lt;/p>
&lt;p>The &lt;code>volumes&lt;/code> field of the pod template of the &lt;code>kube-apiserver&lt;/code> deployment, and respectively the &lt;code>volumeMounts&lt;/code> field of the &lt;code>kube-apiserver&lt;/code> container &lt;strong>shall not&lt;/strong> contain any provider-specific &lt;code>Secret&lt;/code> or &lt;code>ConfigMap&lt;/code> resources. If such resources should be mounted as volumes, this should be done by webhooks.&lt;/p>
&lt;p>The &lt;code>kube-apiserver&lt;/code> &lt;code>Service&lt;/code> &lt;strong>may&lt;/strong> be of type &lt;code>LoadBalancer&lt;/code>, but &lt;strong>shall not&lt;/strong> contain any provider-specific annotations that may be needed to actually provision a load balancer resource in the Seed provider&amp;rsquo;s cloud. If any such annotations are needed, they should be added by webhooks (typically &lt;code>controlplaneexposure&lt;/code> webhooks).&lt;/p>
&lt;p>The &lt;code>kube-apiserver&lt;/code> &lt;code>Service&lt;/code> &lt;strong>will&lt;/strong> be of type &lt;code>ClusterIP&lt;/code>. In this case, Gardener &lt;strong>will&lt;/strong> label this &lt;code>Service&lt;/code> with &lt;code>core.gardener.cloud/apiserver-exposure: gardener-managed&lt;/code> label (deprecated, the label will no longer be added as of &lt;code>v1.80&lt;/code>) and expects that no mutations happen.&lt;/p>
&lt;h3 id="kube-controller-manager">kube-controller-manager&lt;/h3>
&lt;p>To deploy kube-controller-manager, Gardener &lt;strong>shall&lt;/strong> create a deployment named &lt;code>kube-controller-manager&lt;/code> in the Shoot namespace. It can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.&lt;/p>
&lt;p>The pod template of the &lt;code>kube-controller-manager&lt;/code> deployment &lt;strong>shall&lt;/strong> contain a container named &lt;code>kube-controller-manager&lt;/code>.&lt;/p>
&lt;p>The &lt;code>command&lt;/code> field of the &lt;code>kube-controller-manager&lt;/code> container &lt;strong>shall&lt;/strong> contain the &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager command line&lt;/a>. It &lt;strong>shall&lt;/strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--kubeconfig&lt;/code>, &lt;code>--authentication-kubeconfig&lt;/code>, &lt;code>--authorization-kubeconfig&lt;/code>&lt;/li>
&lt;li>&lt;code>--leader-elect&lt;/code>&lt;/li>
&lt;li>secure communications (&lt;code>--tls-cert-file&lt;/code>, &lt;code>--tls-private-key-file&lt;/code>, &amp;hellip;)&lt;/li>
&lt;li>cluster CIDR and identity (&lt;code>--cluster-cidr&lt;/code>, &lt;code>--cluster-name&lt;/code>)&lt;/li>
&lt;li>sync settings (&lt;code>--concurrent-deployment-syncs&lt;/code>, &lt;code>--concurrent-replicaset-syncs&lt;/code>)&lt;/li>
&lt;li>horizontal pod autoscaler (&lt;code>--horizontal-pod-autoscaler-*&lt;/code>)&lt;/li>
&lt;li>ports (&lt;code>--port&lt;/code>, &lt;code>--secure-port&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>The kube-controller-manager command line &lt;strong>shall not&lt;/strong> contain any provider-specific flags, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--cloud-provider&lt;/code>&lt;/li>
&lt;li>&lt;code>--cloud-config&lt;/code>&lt;/li>
&lt;li>&lt;code>--configure-cloud-routes&lt;/code>&lt;/li>
&lt;li>&lt;code>--external-cloud-volume-plugin&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These flags can be added by webhooks if needed.&lt;/p>
&lt;p>The kube-controller-manager command line &lt;strong>may&lt;/strong> contain a number of additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-controller-manager behavior for the specific provider. Among the flags to be considered are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--feature-gates&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>env&lt;/code> field of the &lt;code>kube-controller-manager&lt;/code> container &lt;strong>shall not&lt;/strong> contain any provider-specific environment variables (so it will be empty). If any provider-specific environment variables are needed, they should be added by webhooks.&lt;/p>
&lt;p>The &lt;code>volumes&lt;/code> field of the pod template of the &lt;code>kube-controller-manager&lt;/code> deployment, and respectively the &lt;code>volumeMounts&lt;/code> field of the &lt;code>kube-controller-manager&lt;/code> container &lt;strong>shall not&lt;/strong> contain any provider-specific &lt;code>Secret&lt;/code> or &lt;code>ConfigMap&lt;/code> resources. If such resources should be mounted as volumes, this should be done by webhooks.&lt;/p>
&lt;h3 id="kube-scheduler">kube-scheduler&lt;/h3>
&lt;p>To deploy kube-scheduler, Gardener &lt;strong>shall&lt;/strong> create a deployment named &lt;code>kube-scheduler&lt;/code> in the Shoot namespace. It can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.&lt;/p>
&lt;p>The pod template of the &lt;code>kube-scheduler&lt;/code> deployment &lt;strong>shall&lt;/strong> contain a container named &lt;code>kube-scheduler&lt;/code>.&lt;/p>
&lt;p>The &lt;code>command&lt;/code> field of the &lt;code>kube-scheduler&lt;/code> container &lt;strong>shall&lt;/strong> contain the &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/">kube-scheduler command line&lt;/a>. It &lt;strong>shall&lt;/strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--config&lt;/code>&lt;/li>
&lt;li>&lt;code>--authentication-kubeconfig&lt;/code>, &lt;code>--authorization-kubeconfig&lt;/code>&lt;/li>
&lt;li>secure communications (&lt;code>--tls-cert-file&lt;/code>, &lt;code>--tls-private-key-file&lt;/code>, &amp;hellip;)&lt;/li>
&lt;li>ports (&lt;code>--port&lt;/code>, &lt;code>--secure-port&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>The kube-scheduler command line &lt;strong>may&lt;/strong> contain additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-controller-manager behavior for the specific provider. Among the flags to be considered are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--feature-gates&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>The kube-scheduler command line can&amp;rsquo;t contain provider-specific flags, and it makes no sense to specify provider-specific environment variables or mount provider-specific &lt;code>Secret&lt;/code> or &lt;code>ConfigMap&lt;/code> resources as volumes.&lt;/p>
&lt;h3 id="etcd-main-and-etcd-events">etcd-main and etcd-events&lt;/h3>
&lt;p>To deploy etcd, Gardener &lt;strong>shall&lt;/strong> create 2 &lt;a href="https://github.com/gardener/etcd-druid/blob/1d427e9167adac1476d1847c0e265c2c09d6bc62/config/samples/druid_v1alpha1_etcd.yaml">Etcd&lt;/a> named &lt;code>etcd-main&lt;/code> and &lt;code>etcd-events&lt;/code> in the Shoot namespace. They can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.&lt;/p>
&lt;p>Gardener &lt;strong>shall&lt;/strong> configure the &lt;code>Etcd&lt;/code> resource completely to set up an etcd cluster which uses the default storage class of the seed cluster.&lt;/p>
&lt;h3 id="cloud-controller-manager">cloud-controller-manager&lt;/h3>
&lt;p>Gardener &lt;strong>shall not&lt;/strong> deploy a cloud-controller-manager. If it is needed, it should be added by a &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/controlplane/">&lt;code>ControlPlane&lt;/code> controller&lt;/a>&lt;/p>
&lt;h3 id="csi-controllers">CSI Controllers&lt;/h3>
&lt;p>Gardener &lt;strong>shall not&lt;/strong> deploy a CSI controller. If it is needed, it should be added by a &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/controlplane/">&lt;code>ControlPlane&lt;/code> controller&lt;/a>&lt;/p>
&lt;h3 id="kubelet">kubelet&lt;/h3>
&lt;p>To specify the kubelet configuration, Gardener &lt;strong>shall&lt;/strong> create a &lt;a href="https://gardener.cloud/docs/gardener/extensions/resources/operatingsystemconfig/">&lt;code>OperatingSystemConfig&lt;/code> resource&lt;/a> with any name and purpose &lt;code>reconcile&lt;/code> in the Shoot namespace. It can therefore also be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener. Gardener &lt;strong>may&lt;/strong> write multiple such resources with different &lt;code>type&lt;/code> to the same Shoot namespaces if multiple OSs are used.&lt;/p>
&lt;p>The OSC resource &lt;strong>shall&lt;/strong> contain a unit named &lt;code>kubelet.service&lt;/code>, containing the corresponding systemd unit configuration file. The &lt;code>[Service]&lt;/code> section of this file &lt;strong>shall&lt;/strong> contain a single &lt;code>ExecStart&lt;/code> option having the &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">kubelet command line&lt;/a> as its value.&lt;/p>
&lt;p>The OSC resource &lt;strong>shall&lt;/strong> contain a file with path &lt;code>/var/lib/kubelet/config/kubelet&lt;/code>, which contains a &lt;code>KubeletConfiguration&lt;/code> resource in YAML format. Most of the flags that can be specified in the kubelet command line can alternatively be specified as options in this configuration as well.&lt;/p>
&lt;p>The kubelet command line &lt;strong>shall&lt;/strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--config&lt;/code>&lt;/li>
&lt;li>&lt;code>--bootstrap-kubeconfig&lt;/code>, &lt;code>--kubeconfig&lt;/code>&lt;/li>
&lt;li>&lt;code>--network-plugin&lt;/code> (and, if it equals &lt;code>cni&lt;/code>, also &lt;code>--cni-bin-dir&lt;/code> and &lt;code>--cni-conf-dir&lt;/code>)&lt;/li>
&lt;li>&lt;code>--node-labels&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>The kubelet command line &lt;strong>shall not&lt;/strong> contain any provider-specific flags, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--cloud-provider&lt;/code>&lt;/li>
&lt;li>&lt;code>--cloud-config&lt;/code>&lt;/li>
&lt;li>&lt;code>--provider-id&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These flags can be added by webhooks if needed.&lt;/p>
&lt;p>The kubelet command line / configuration &lt;strong>may&lt;/strong> contain a number of additional provider-independent flags / options. In general, webhooks should ignore these unless they are known to interfere with the desired kubelet behavior for the specific provider. Among the flags / options to be considered are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>--enable-controller-attach-detach&lt;/code> (&lt;code>enableControllerAttachDetach&lt;/code>) - should be set to &lt;code>true&lt;/code> if CSI plugins are used, but in general can also be ignored since its default value is also &lt;code>true&lt;/code>, and this should work both with and without CSI plugins.&lt;/li>
&lt;li>&lt;code>--feature-gates&lt;/code> (&lt;code>featureGates&lt;/code>) - should contain a list of specific feature gates if CSI plugins are used. If CSI plugins are not used, the corresponding feature gates can be ignored since enabling them should not harm in any way.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Conventions</title><link>https://gardener.cloud/docs/gardener/extensions/conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/conventions/</guid><description>
&lt;h1 id="general-conventions">General Conventions&lt;/h1>
&lt;p>All the extensions that are registered to Gardener are deployed to the seed clusters on which they are required (also see &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/">ControllerRegistration&lt;/a>).&lt;/p>
&lt;p>Some of these extensions might need to create global resources in the seed (e.g., &lt;code>ClusterRole&lt;/code>s), i.e., it&amp;rsquo;s important to have a naming scheme to avoid conflicts as it cannot be checked or validated upfront that two extensions don&amp;rsquo;t use the same names.&lt;/p>
&lt;p>Consequently, this page should help answering some general questions that might come up when it comes to developing an extension.&lt;/p>
&lt;h2 id="priorityclasses">&lt;code>PriorityClass&lt;/code>es&lt;/h2>
&lt;p>Extensions are not supposed to create and use self-defined &lt;code>PriorityClasses&lt;/code>.
Instead, they can and should rely on well-known &lt;a href="https://gardener.cloud/docs/gardener/priority-classes/">&lt;code>PriorityClasses&lt;/code>&lt;/a> managed by gardenlet.&lt;/p>
&lt;h2 id="high-availability-of-deployed-components">High Availability of Deployed Components&lt;/h2>
&lt;p>Extensions might deploy components via &lt;code>Deployment&lt;/code>s, &lt;code>StatefulSet&lt;/code>s, etc., as part of the shoot control plane, or the seed or shoot system components.
In case a seed or shoot cluster is highly available, there are various failure tolerance types. For more information, see &lt;a href="https://gardener.cloud/docs/gardener/high-availability/shoot_high_availability/">Highly Available Shoot Control Plane&lt;/a>.
Accordingly, the &lt;code>replicas&lt;/code>, &lt;code>topologySpreadConstraints&lt;/code> or &lt;code>affinity&lt;/code> settings of the deployed components might need to be adapted.&lt;/p>
&lt;p>Instead of doing this one-by-one for each and every component, extensions can rely on a mutating webhook provided by Gardener.
Please refer to &lt;a href="https://gardener.cloud/docs/gardener/high-availability-of-components/">High Availability of Deployed Components&lt;/a> for details.&lt;/p>
&lt;p>To reduce costs and to improve the network traffic latency in multi-zone clusters, extensions can make a Service topology-aware.
Please refer to &lt;a href="https://gardener.cloud/docs/gardener/topology_aware_routing/">this document&lt;/a> for details.&lt;/p>
&lt;h2 id="is-there-a-naming-scheme-for-global-resources">Is there a naming scheme for (global) resources?&lt;/h2>
&lt;p>As there is no formal process to validate non-existence of conflicts between two extensions, please follow these naming schemes when creating resources (especially, when creating global resources, but it&amp;rsquo;s in general a good idea for most created resources):&lt;/p>
&lt;p>&lt;em>The resource name should be prefixed with &lt;code>extensions.gardener.cloud:&amp;lt;extension-type&amp;gt;-&amp;lt;extension-name&amp;gt;:&amp;lt;resource-name&amp;gt;&lt;/code>&lt;/em>, for example:&lt;/p>
&lt;ul>
&lt;li>&lt;code>extensions.gardener.cloud:provider-aws:some-controller-manager&lt;/code>&lt;/li>
&lt;li>&lt;code>extensions.gardener.cloud:extension-certificate-service:cert-broker&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="how-to-create-resources-in-the-shoot-cluster">How to create resources in the shoot cluster?&lt;/h2>
&lt;p>Some extensions might not only create resources in the seed cluster itself but also in the shoot cluster. Usually, every extension comes with a &lt;code>ServiceAccount&lt;/code> and the required RBAC permissions when it gets installed to the seed.
However, there are no credentials for the shoot for every extension.&lt;/p>
&lt;p>Extensions are supposed to use &lt;a href="https://gardener.cloud/docs/gardener/concepts/resource-manager/#ManagedResource-controller">&lt;code>ManagedResources&lt;/code>&lt;/a> to manage resources in shoot clusters.
gardenlet deploys gardener-resource-manager instances into all shoot control planes, that will reconcile &lt;code>ManagedResources&lt;/code> without a specified class (&lt;code>spec.class=null&lt;/code>) in shoot clusters. Mind that Gardener acts on &lt;code>ManagedResources&lt;/code> with the &lt;code>origin=gardener&lt;/code> label. In order to prevent unwanted behavior, extensions should omit the &lt;code>origin&lt;/code> label or provide their own unique value for it when creating such resources.&lt;/p>
&lt;p>If you need to deploy a non-DaemonSet resource, Gardener automatically ensures that it only runs on nodes that are allowed to host system components and extensions. For more information, see &lt;a href="https://gardener.cloud/docs/gardener/concepts/resource-manager/#System-Components-Webhook">System Components Webhook&lt;/a>.&lt;/p>
&lt;h2 id="how-to-create-kubeconfigs-for-the-shoot-cluster">How to create kubeconfigs for the shoot cluster?&lt;/h2>
&lt;p>Historically, Gardener extensions used to generate kubeconfigs with client certificates for components they deploy into the shoot control plane.
For this, they reused the shoot cluster CA secret (&lt;code>ca&lt;/code>) to issue new client certificates.
With &lt;a href="https://github.com/gardener/gardener/issues/4661">gardener/gardener#4661&lt;/a> we moved away from using client certificates in favor of short-lived, auto-rotated &lt;code>ServiceAccount&lt;/code> tokens. These tokens are managed by gardener-resource-manager&amp;rsquo;s &lt;a href="https://gardener.cloud/docs/gardener/concepts/resource-manager/#tokenrequestor">&lt;code>TokenRequestor&lt;/code>&lt;/a>.
Extensions are supposed to reuse this mechanism for requesting tokens and a &lt;code>generic-token-kubeconfig&lt;/code> for authenticating against shoot clusters.&lt;/p>
&lt;p>With &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md">GEP-18&lt;/a> (Shoot cluster CA rotation), a dedicated CA will be used for signing client certificates (&lt;a href="https://github.com/gardener/gardener/pull/5779">gardener/gardener#5779&lt;/a>) which will be rotated when triggered by the shoot owner.
With this, extensions cannot reuse the &lt;code>ca&lt;/code> secret anymore to issue client certificates.
Hence, extensions must switch to short-lived &lt;code>ServiceAccount&lt;/code> tokens in order to support the CA rotation feature.&lt;/p>
&lt;p>The &lt;code>generic-token-kubeconfig&lt;/code> secret contains the CA bundle for establishing trust to shoot API servers. However, as the secret is immutable, its name changes with the rotation of the cluster CA.
Extensions need to look up the &lt;code>generic-token-kubeconfig.secret.gardener.cloud/name&lt;/code> annotation on the respective &lt;a href="https://gardener.cloud/docs/gardener/extensions/cluster/">&lt;code>Cluster&lt;/code>&lt;/a> object in order to determine which secret contains the current CA bundle.
The helper function &lt;code>extensionscontroller.GenericTokenKubeconfigSecretNameFromCluster&lt;/code> can be used for this task.&lt;/p>
&lt;p>You can take a look at &lt;a href="https://gardener.cloud/docs/gardener/extensions/ca-rotation/">CA Rotation in Extensions&lt;/a> for more details on the CA rotation feature in regard to extensions.&lt;/p>
&lt;h2 id="how-to-create-certificates-for-the-shoot-cluster">How to create certificates for the shoot cluster?&lt;/h2>
&lt;p>Gardener creates several certificate authorities (CA) that are used to create server certificates for various components.
For example, the shoot&amp;rsquo;s etcd has its own CA, the kube-aggregator has its own CA as well, and both are different to the actual cluster&amp;rsquo;s CA.&lt;/p>
&lt;p>With &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md">GEP-18&lt;/a> (Shoot cluster CA rotation), extensions are required to do the same and generate dedicated CAs for their components (e.g. for signing a server certificate for cloud-controller-manager). They must not depend on the CA secrets managed by gardenlet.&lt;/p>
&lt;p>Please see &lt;a href="https://gardener.cloud/docs/gardener/extensions/ca-rotation/">CA Rotation in Extensions&lt;/a> for the exact requirements that extensions need to fulfill in order to support the CA rotation feature.&lt;/p>
&lt;h2 id="how-to-enforce-a-pod-security-standard-for-extension-namespaces">How to enforce a Pod Security Standard for extension namespaces?&lt;/h2>
&lt;p>The &lt;code>pod-security.kubernetes.io/enforce&lt;/code> namespace label enforces the &lt;a href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod Security Standards&lt;/a>.&lt;/p>
&lt;p>You can set the &lt;code>pod-security.kubernetes.io/enforce&lt;/code> label for extension namespace by adding the &lt;code>security.gardener.cloud/pod-security-enforce&lt;/code> annotation to your &lt;code>ControllerRegistration&lt;/code>. The value of the annotation would be the value set for the &lt;code>pod-security.kubernetes.io/enforce&lt;/code> label. It is advised to set the annotation with the most restrictive pod security standard that your extension pods comply with.&lt;/p>
&lt;p>If you are using the &lt;code>./hack/generate-controller-registration.sh&lt;/code> script to generate your &lt;code>ControllerRegistration&lt;/code> you can use the -e, &amp;ndash;pod-security-enforce option to set the &lt;code>security.gardener.cloud/pod-security-enforce&lt;/code> annotation. If the option is not set, it defaults to &lt;code>baseline&lt;/code>.&lt;/p></description></item><item><title>Docs: Force Deletion</title><link>https://gardener.cloud/docs/gardener/extensions/force-deletion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/force-deletion/</guid><description>
&lt;h1 id="force-deletion">Force Deletion&lt;/h1>
&lt;p>From &lt;code>v1.81&lt;/code>, Gardener supports &lt;a href="https://gardener.cloud/docs/gardener/shoot-operations/shoot_operations/#force-deletion">Shoot Force Deletion&lt;/a>. All extension controllers should also properly support it. This document outlines some important points that extension maintainers should keep in mind to support force deletion in their extensions.&lt;/p>
&lt;h2 id="overall-principles">Overall Principles&lt;/h2>
&lt;p>The following principles should always be upheld:&lt;/p>
&lt;ul>
&lt;li>All resources pertaining to the extension and managed by it should be appropriately handled and cleaned up by the extension when force deletion is initiated.&lt;/li>
&lt;/ul>
&lt;h2 id="implementation-details">Implementation Details&lt;/h2>
&lt;h3 id="forcedelete-actuator-methods">ForceDelete Actuator Methods&lt;/h3>
&lt;p>Most extension controller implementations follow a common pattern where a generic &lt;code>Reconciler&lt;/code> implementation delegates to an &lt;code>Actuator&lt;/code> interface that contains the methods &lt;code>Reconcile&lt;/code>, &lt;code>Delete&lt;/code>, &lt;code>Migrate&lt;/code> and &lt;code>Restore&lt;/code> provided by the extension. A new method, &lt;code>ForceDelete&lt;/code> has been added to all such &lt;code>Actuator&lt;/code> interfaces; see &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go">the infrastructure &lt;code>Actuator&lt;/code> interface&lt;/a> as an example. The generic reconcilers call this method if the Shoot has annotation &lt;code>confirmation.gardener.cloud/force-deletion=true&lt;/code>. Thus, it should be implemented by the extension controller to forcefully delete resources if not possible to delete them gracefully. If graceful deletion is possible, then in the &lt;code>ForceDelete&lt;/code>, they can simply call the &lt;code>Delete&lt;/code> method.&lt;/p>
&lt;h3 id="extension-controllers-based-on-generic-actuators">Extension Controllers Based on Generic Actuators&lt;/h3>
&lt;p>In practice, the implementation of many extension controllers (for example, the controlplane and worker controllers in most provider extensions) are based on a &lt;em>generic &lt;code>Actuator&lt;/code> implementation&lt;/em> that only delegates to extension methods for behavior that is truly provider-specific. In all such cases, the &lt;code>ForceDelete&lt;/code> method has already been implemented with a method that should suit most of the extensions. If it doesn&amp;rsquo;t suit your extension, then the &lt;code>ForceDelete&lt;/code> method needs to be overridden; see the &lt;a href="https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/controlplane">Azure controlplane controller&lt;/a> as an example.&lt;/p>
&lt;h3 id="extension-controllers-not-based-on-generic-actuators">Extension Controllers Not Based on Generic Actuators&lt;/h3>
&lt;p>The implementation of some extension controllers (for example, the infrastructure controllers in all provider extensions) are not based on a generic &lt;code>Actuator&lt;/code> implementation. Such extension controllers must always provide a proper implementation of the &lt;code>ForceDelete&lt;/code> method according to the above guidelines; see the &lt;a href="https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure">AWS infrastructure controller&lt;/a> as an example. In practice, this might result in code duplication between the different extensions, since the &lt;code>ForceDelete&lt;/code> code is usually not OS-specific.&lt;/p>
&lt;h3 id="some-general-implementation-examples">Some General Implementation Examples&lt;/h3>
&lt;ul>
&lt;li>If the extension deploys only resources in the shoot cluster not backed by infrastructure in third-party systems, then performing the regular deletion code (&lt;code>actuator.Delete&lt;/code>) will suffice in the majority of cases. (e.g - &lt;a href="https://github.com/gardener/gardener-extension-shoot-networking-filter/blob/1d95a483d803874e8aa3b1de89431e221a7d574e/pkg/controller/lifecycle/actuator.go#L175-L178">https://github.com/gardener/gardener-extension-shoot-networking-filter/blob/1d95a483d803874e8aa3b1de89431e221a7d574e/pkg/controller/lifecycle/actuator.go#L175-L178&lt;/a>)&lt;/li>
&lt;li>If the extension deploys resources which are backed by infrastructure in third-party systems:
&lt;ul>
&lt;li>If the resource is in the Seed cluster, the extension should remove the finalizers and delete the resource. This is needed especially if the resource is a custom resource since &lt;code>gardenlet&lt;/code> will not be aware of this resource and cannot take action.&lt;/li>
&lt;li>If the resource is in the Shoot and if it&amp;rsquo;s deployed by a &lt;code>ManagedResource&lt;/code>, then &lt;code>gardenlet&lt;/code> will take care to forcefully delete it in a later step of force-deletion. If the resource is not deployed via a &lt;code>ManagedResource&lt;/code>, then it wouldn&amp;rsquo;t block the deletion flow anyway since it is in the Shoot cluster. In both cases, the extension controller can ignore the resource and return &lt;code>nil&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Healthcheck Library</title><link>https://gardener.cloud/docs/gardener/extensions/healthcheck-library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/healthcheck-library/</guid><description>
&lt;h1 id="health-check-library">Health Check Library&lt;/h1>
&lt;h2 id="goal">Goal&lt;/h2>
&lt;p>Typically, an extension reconciles a specific resource (Custom Resource Definitions (CRDs)) and creates / modifies resources in the cluster (via helm, managed resources, kubectl, &amp;hellip;).
We call these API Objects &amp;lsquo;dependent objects&amp;rsquo; - as they are bound to the lifecycle of the extension.&lt;/p>
&lt;p>The goal of this library is to enable extensions to setup health checks for their &amp;lsquo;dependent objects&amp;rsquo; with minimal effort.&lt;/p>
&lt;h2 id="usage">Usage&lt;/h2>
&lt;p>The library provides a generic controller with the ability to register any resource that satisfies the &lt;a href="https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types.go">extension object interface&lt;/a>.
An example is &lt;a href="https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_worker.go">the &lt;code>Worker&lt;/code> CRD&lt;/a>.&lt;/p>
&lt;p>Health check functions for commonly used dependent objects can be reused and registered with the controller, such as:&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>DaemonSet&lt;/li>
&lt;li>StatefulSet&lt;/li>
&lt;li>ManagedResource (Gardener specific)&lt;/li>
&lt;/ul>
&lt;p>See the below example &lt;a href="https://github.com/gardener/gardener-extension-provider-aws/blob/master/pkg/controller/healthcheck/add.go">taken from the provider-aws&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>health.DefaultRegisterExtensionForHealthCheck(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aws.Type,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensionsv1alpha1.SchemeGroupVersion.WithKind(extensionsv1alpha1.WorkerResource),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">func&lt;/span>() runtime.Object { &lt;span style="color:#00f">return&lt;/span> &amp;amp;extensionsv1alpha1.Worker{} },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mgr, &lt;span style="color:#008000">// controller runtime manager
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> opts, &lt;span style="color:#008000">// options for the health check controller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#00f">nil&lt;/span>, &lt;span style="color:#008000">// custom predicates
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> &lt;span style="color:#00f">map&lt;/span>[extensionshealthcheckcontroller.HealthCheck]&lt;span style="color:#2b91af">string&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> general.CheckManagedResource(genericactuator.McmShootResourceName): string(gardencorev1beta1.ShootSystemComponentsHealthy),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> general.CheckSeedDeployment(aws.MachineControllerManagerName): string(gardencorev1beta1.ShootEveryNodeReady),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> worker.SufficientNodesAvailable(): string(gardencorev1beta1.ShootEveryNodeReady),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This creates a health check controller that reconciles the &lt;code>extensions.gardener.cloud/v1alpha1.Worker&lt;/code> resource with the spec.type &amp;lsquo;aws&amp;rsquo;.
Three health check functions are registered that are executed during reconciliation.
Each health check is mapped to a single &lt;code>HealthConditionType&lt;/code> that results in conditions with the same &lt;code>condition.type&lt;/code> (see below).
To contribute to the Shoot&amp;rsquo;s health, the following conditions can be used: &lt;code>SystemComponentsHealthy&lt;/code>, &lt;code>EveryNodeReady&lt;/code>, &lt;code>ControlPlaneHealthy&lt;/code>, &lt;code>ObservabilityComponentsHealthy&lt;/code>. In case of workerless &lt;code>Shoot&lt;/code> the &lt;code>EveryNodeReady&lt;/code> condition is not present, so it can&amp;rsquo;t be used.&lt;/p>
&lt;p>The Gardener/Gardenlet checks each extension for conditions matching these types.
However, extensions are free to choose any &lt;code>HealthConditionType&lt;/code>.
For more information, see &lt;a href="https://gardener.cloud/docs/gardener/extensions/shoot-health-status-conditions/">Contributing to Shoot Health Status Conditions&lt;/a>.&lt;/p>
&lt;p>A health check has to &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/healthcheck/actuator.go">satisfy the below interface&lt;/a>.
You can find implementation examples in the &lt;a href="https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/healthcheck/general">healtcheck folder&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00f">type&lt;/span> HealthCheck &lt;span style="color:#00f">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// Check is the function that executes the actual health check
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> Check(context.Context, types.NamespacedName) (*SingleCheckResult, &lt;span style="color:#2b91af">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// InjectSeedClient injects the seed client
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> InjectSeedClient(client.Client)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// InjectShootClient injects the shoot client
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> InjectShootClient(client.Client)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// SetLoggerSuffix injects the logger
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> SetLoggerSuffix(&lt;span style="color:#2b91af">string&lt;/span>, &lt;span style="color:#2b91af">string&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// DeepCopy clones the healthCheck
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> DeepCopy() HealthCheck
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The health check controller regularly (default: &lt;code>30s&lt;/code>) reconciles the extension resource and executes the registered health checks for the dependent objects.
As a result, the controller writes condition(s) to the status of the extension containing the health check result.
In our example, two checks are mapped to &lt;code>ShootEveryNodeReady&lt;/code> and one to &lt;code>ShootSystemComponentsHealthy&lt;/code>, leading to conditions with two distinct &lt;code>HealthConditionTypes&lt;/code> (condition.type):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;20XX-10-28T08:17:21Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;20XX-11-28T08:17:21Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: (1/1) Health checks successful
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: HealthCheckSuccessful
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: SystemComponentsHealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;20XX-10-28T08:17:21Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;20XX-11-28T08:17:21Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: (2/2) Health checks successful
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: HealthCheckSuccessful
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: EveryNodeReady
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please note that there are four statuses: &lt;code>True&lt;/code>, &lt;code>False&lt;/code>, &lt;code>Unknown&lt;/code>, and &lt;code>Progressing&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>&lt;code>True&lt;/code> should be used for successful health checks.&lt;/li>
&lt;li>&lt;code>False&lt;/code> should be used for unsuccessful/failing health checks.&lt;/li>
&lt;li>&lt;code>Unknown&lt;/code> should be used when there was an error trying to determine the health status.&lt;/li>
&lt;li>&lt;code>Progressing&lt;/code> should be used to indicate that the health status did not succeed but for expected reasons (e.g., a cluster scale up/down could make the standard health check fail because something is wrong with the &lt;code>Machines&lt;/code>, however, it&amp;rsquo;s actually an expected situation and known to be completed within a few minutes.)&lt;/li>
&lt;/ul>
&lt;p>Health checks that report &lt;code>Progressing&lt;/code> should also provide a timeout, after which this &amp;ldquo;progressing situation&amp;rdquo; is expected to be completed.
The health check library will automatically transition the status to &lt;code>False&lt;/code> if the timeout was exceeded.&lt;/p>
&lt;h2 id="additional-considerations">Additional Considerations&lt;/h2>
&lt;p>It is up to the extension to decide how to conduct health checks, though it is recommended to make use of the build-in health check functionality of &lt;code>managedresources&lt;/code> for trivial checks.
By &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/worker/genericactuator/machine_controller_manager.go">deploying the depending resources via managed resources&lt;/a>, the &lt;a href="https://github.com/gardener/gardener-resource-manager">gardener resource manager&lt;/a> conducts basic checks for different API objects out-of-the-box (e.g &lt;code>Deployments&lt;/code>, &lt;code>DaemonSets&lt;/code>, &amp;hellip;) - and writes health conditions.&lt;/p>
&lt;p>By default, Gardener performs health checks for all the &lt;code>ManagedResource&lt;/code>s created in the shoot namespaces.
Their status will be aggregated to the &lt;code>Shoot&lt;/code> conditions according to the following rules:&lt;/p>
&lt;ul>
&lt;li>Health checks of &lt;code>ManagedResource&lt;/code> with &lt;code>.spec.class=nil&lt;/code> are aggregated to the &lt;code>SystemComponentsHealthy&lt;/code> condition&lt;/li>
&lt;li>Health checks of &lt;code>ManagedResource&lt;/code> with &lt;code>.spec.class!=nil&lt;/code> are aggregated to the &lt;code>ControlPlaneHealthy&lt;/code> condition unless the &lt;code>ManagedResource&lt;/code> is labeled with &lt;code>care.gardener.cloud/condition-type=&amp;lt;other-condition-type&amp;gt;&lt;/code>. In such case, it is aggregated to the &lt;code>&amp;lt;other-condition-type&amp;gt;&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>More sophisticated health checks should be implemented by the extension controller itself (implementing the &lt;code>HealthCheck&lt;/code> interface).&lt;/p></description></item><item><title>Docs: Heartbeat</title><link>https://gardener.cloud/docs/gardener/extensions/heartbeat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/heartbeat/</guid><description>
&lt;h1 id="heartbeat-controller">Heartbeat Controller&lt;/h1>
&lt;p>The heartbeat controller renews a dedicated &lt;code>Lease&lt;/code> object named &lt;code>gardener-extension-heartbeat&lt;/code> at regular 30 second intervals by default. This &lt;code>Lease&lt;/code> is used for heartbeats similar to how &lt;code>gardenlet&lt;/code> uses &lt;code>Lease&lt;/code> objects for seed heartbeats (see &lt;a href="https://gardener.cloud/docs/gardener/concepts/gardenlet/#heartbeats">gardenlet heartbeats&lt;/a>).&lt;/p>
&lt;p>The &lt;code>gardener-extension-heartbeat&lt;/code> &lt;code>Lease&lt;/code> can be checked by other controllers to verify that the corresponding extension controller is still running. Currently, &lt;code>gardenlet&lt;/code> checks this &lt;code>Lease&lt;/code> when performing shoot health checks and expects to find the &lt;code>Lease&lt;/code> inside the namespace where the extension controller is deployed by the corresponding &lt;code>ControllerInstallation&lt;/code>. For each extension resource deployed in the Shoot control plane, &lt;code>gardenlet&lt;/code> finds the corresponding &lt;code>gardener-extension-heartbeat&lt;/code> &lt;code>Lease&lt;/code> resource and checks whether the &lt;code>Lease&lt;/code>&amp;rsquo;s &lt;code>.spec.renewTime&lt;/code> is older than the allowed threshold for stale extension health checks - in this case, &lt;code>gardenlet&lt;/code> considers the health check report for an extension resource as &amp;ldquo;outdated&amp;rdquo; and reflects this in the &lt;code>Shoot&lt;/code> status.&lt;/p></description></item><item><title>Docs: Logging And Monitoring</title><link>https://gardener.cloud/docs/gardener/extensions/logging-and-monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/logging-and-monitoring/</guid><description>
&lt;h1 id="logging-and-monitoring-for-extensions">Logging and Monitoring for Extensions&lt;/h1>
&lt;p>Gardener provides an integrated logging and monitoring stack for alerting, monitoring, and troubleshooting of its managed components by operators or end users. For further information how to make use of it in these roles, refer to the corresponding guides for &lt;a href="https://github.com/gardener/logging/tree/master/docs/usage/README.md">exploring logs&lt;/a> and for &lt;a href="https://github.com/credativ/plutono">monitoring with Plutono&lt;/a>.&lt;/p>
&lt;p>The components that constitute the logging and monitoring stack are managed by Gardener. By default, it deploys &lt;a href="https://prometheus.io/">Prometheus&lt;/a> and &lt;a href="https://prometheus.io/docs/alerting/latest/alertmanager/">Alertmanager&lt;/a> (managed via &lt;a href="https://github.com/prometheus-operator/prometheus-operator">&lt;code>prometheus-operator&lt;/code>&lt;/a>, and &lt;a href="https://github.com/credativ/plutono">Plutono&lt;/a> into the &lt;code>garden&lt;/code> namespace of all seed clusters. If the logging is enabled in the &lt;code>gardenlet&lt;/code> configuration (&lt;code>logging.enabled&lt;/code>), it will deploy &lt;a href="https://github.com/fluent/fluent-operator">fluent-operator&lt;/a> and &lt;a href="https://github.com/credativ/plutono">Vali&lt;/a> in the &lt;code>garden&lt;/code> namespace too.&lt;/p>
&lt;p>Each shoot namespace hosts managed logging and monitoring components. As part of the shoot reconciliation flow, Gardener deploys a shoot-specific Prometheus, blackbox-exporter, Plutono, and, if configured, an Alertmanager into the shoot namespace, next to the other control plane components. If the logging is enabled in the &lt;code>gardenlet&lt;/code> configuration (&lt;code>logging.enabled&lt;/code>) and the &lt;a href="https://gardener.cloud/docs/gardener/shoot/shoot_purposes/#behavioral-differences">shoot purpose&lt;/a> is not &lt;code>testing&lt;/code>, it deploys a shoot-specific Vali in the shoot namespace too.&lt;/p>
&lt;p>The logging and monitoring stack is extensible by configuration. Gardener extensions can take advantage of that and contribute monitoring configurations encoded in &lt;code>ConfigMap&lt;/code>s for their own, specific dashboards, alerts and other supported assets and integrate with it. As with other Gardener resources, they will be continuously reconciled. The extensions can also deploy directly fluent-operator custom resources which will be created in the seed cluster and plugged into the fluent-bit instance.&lt;/p>
&lt;p>This guide is about the roles and extensibility options of the logging and monitoring stack components, and how to integrate extensions with:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gardener.cloud/docs/gardener/extensions/logging-and-monitoring/#monitoring">Monitoring&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gardener.cloud/docs/gardener/extensions/logging-and-monitoring/#logging">Logging&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="monitoring">Monitoring&lt;/h2>
&lt;h3 id="seed-cluster">Seed Cluster&lt;/h3>
&lt;h4 id="cache-prometheus">Cache Prometheus&lt;/h4>
&lt;p>The central Prometheus instance in the &lt;code>garden&lt;/code> namespace (called &amp;ldquo;cache Prometheus&amp;rdquo;) fetches metrics and data from all seed cluster nodes and all seed cluster pods.
It uses the &lt;a href="https://prometheus.io/docs/prometheus/latest/federation/">federation&lt;/a> concept to allow the shoot-specific instances to scrape only the metrics for the pods of the control plane they are responsible for.
This mechanism allows to scrape the metrics for the nodes/pods once for the whole cluster, and to have them distributed afterwards.
For more details, continue reading &lt;a href="https://gardener.cloud/docs/gardener/monitoring/#prometheus">here&lt;/a>.&lt;/p>
&lt;p>Typically, this is not necessary, but in case an extension wants to extend the configuration for this cache Prometheus, they can create the &lt;a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions">&lt;code>prometheus-operator&lt;/code>&amp;rsquo;s custom resources&lt;/a> and label them with &lt;code>prometheus=cache&lt;/code>, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: monitoring.coreos.com/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ServiceMonitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prometheus: cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: cache-my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoints:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - metricRelabelings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: ^(metric1|metric2|...)$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - __name__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port: metrics
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="seed-prometheus">Seed Prometheus&lt;/h4>
&lt;p>Another Prometheus instance in the &lt;code>garden&lt;/code> namespace (called &amp;ldquo;seed Prometheus&amp;rdquo;) fetches metrics and data from seed system components, kubelets, cAdvisors, and extensions.
If you want your extension pods to be scraped then they must be annotated with &lt;code>prometheus.io/scrape=true&lt;/code> and &lt;code>prometheus.io/port=&amp;lt;metrics-port&amp;gt;&lt;/code>.
For more details, continue reading &lt;a href="https://gardener.cloud/docs/gardener/monitoring/#seed-prometheus">here&lt;/a>.&lt;/p>
&lt;p>Typically, this is not necessary, but in case an extension wants to extend the configuration for this seed Prometheus, they can create the &lt;a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions">&lt;code>prometheus-operator&lt;/code>&amp;rsquo;s custom resources&lt;/a> and label them with &lt;code>prometheus=seed&lt;/code>, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: monitoring.coreos.com/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ServiceMonitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prometheus: seed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: seed-my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoints:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - metricRelabelings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: ^(metric1|metric2|...)$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - __name__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port: metrics
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="aggregate-prometheus">Aggregate Prometheus&lt;/h4>
&lt;p>Another Prometheus instance in the &lt;code>garden&lt;/code> namespace (called &amp;ldquo;aggregate Prometheus&amp;rdquo;) stores pre-aggregated data from the cache Prometheus and shoot Prometheus.
An ingress exposes this Prometheus instance allowing it to be scraped from another cluster.
For more details, continue reading &lt;a href="https://gardener.cloud/docs/gardener/monitoring/#aggregate-prometheus">here&lt;/a>.&lt;/p>
&lt;p>Typically, this is not necessary, but in case an extension wants to extend the configuration for this aggregate Prometheus, they can create the &lt;a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions">&lt;code>prometheus-operator&lt;/code>&amp;rsquo;s custom resources&lt;/a> and label them with &lt;code>prometheus=aggregate&lt;/code>, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: monitoring.coreos.com/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ServiceMonitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prometheus: aggregate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: aggregate-my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoints:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - metricRelabelings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: ^(metric1|metric2|...)$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - __name__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port: metrics
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="plutono">Plutono&lt;/h4>
&lt;p>A &lt;a href="https://github.com/credativ/plutono">Plutono&lt;/a> instance is deployed by &lt;code>gardenlet&lt;/code> into the seed cluster&amp;rsquo;s &lt;code>garden&lt;/code> namespace for visualizing monitoring metrics and logs via dashboards.
In order to provide custom dashboards, create a &lt;code>ConfigMap&lt;/code> in the &lt;code>garden&lt;/code> namespace labelled with &lt;code>dashboard.monitoring.gardener.cloud/seed=true&lt;/code> that contains the respective JSON documents, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ConfigMap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dashboard.monitoring.gardener.cloud/seed: &lt;span style="color:#a31515">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: extension-foo-my-custom-dashboard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> my-custom-dashboard.json: &amp;lt;dashboard-JSON-document&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="shoot-cluster">Shoot Cluster&lt;/h3>
&lt;h4 id="shoot-prometheus">Shoot Prometheus&lt;/h4>
&lt;p>The shoot-specific metrics are then made available to operators and users in the shoot Plutono, using the shoot Prometheus as data source.&lt;/p>
&lt;p>Extension controllers might deploy components as part of their reconciliation next to the shoot&amp;rsquo;s control plane.
Examples for this would be a cloud-controller-manager or CSI controller deployments. Extensions that want to have their managed control plane components integrated with monitoring can contribute their per-shoot configuration for scraping Prometheus metrics, Alertmanager alerts or Plutono dashboards.&lt;/p>
&lt;h4 id="extensions-monitoring-integration">Extensions Monitoring Integration&lt;/h4>
&lt;p>In case an extension wants to extend the configuration for the shoot Prometheus, they can create the &lt;a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions">&lt;code>prometheus-operator&lt;/code>&amp;rsquo;s custom resources&lt;/a> and label them with &lt;code>prometheus=shoot&lt;/code>.&lt;/p>
&lt;h5 id="servicemonitor">&lt;code>ServiceMonitor&lt;/code>&lt;/h5>
&lt;p>When the component runs in the seed cluster (e.g., as part of the shoot control plane), &lt;code>ServiceMonitor&lt;/code> resources should be used:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: monitoring.coreos.com/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ServiceMonitor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prometheus: shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot-my-controlplane-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app: my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endpoints:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - metricRelabelings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: ^(metric1|metric2|...)$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - __name__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port: metrics
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In case &lt;code>HTTPS&lt;/code> scheme is used, the CA certificate should be provided like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme: HTTPS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tlsConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ca:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;lt;name-of-ca-bundle-secret&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: bundle.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In case the component requires credentials when contacting its metrics endpoint, provide them like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorization:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;lt;name-of-secret-containing-credentials&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: &amp;lt;data-keyin-secret&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If the component delegates authorization to the &lt;code>kube-apiserver&lt;/code> of the shoot cluster, you can use the &lt;code>shoot-access-prometheus-shoot&lt;/code> secret:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorization:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot-access-prometheus-shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: token
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># in case the component&amp;#39;s server certificate is signed by the cluster CA:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme: HTTPS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tlsConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ca:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;lt;name-of-ca-bundle-secret&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: bundle.crt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="scrapeconfigs">&lt;code>ScrapeConfig&lt;/code>s&lt;/h5>
&lt;p>If the component runs in the shoot cluster itself, metrics are scraped via the &lt;code>kube-apiserver&lt;/code> proxy.
In this case, Prometheus needs to authenticate itself with the API server.
This can be done like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: monitoring.coreos.com/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ScrapeConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prometheus: shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot-my-cluster-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorization:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot-access-prometheus-shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: token
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheme: HTTPS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tlsConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ca:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;lt;name-of-ca-bundle-secret&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: bundle.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kubernetesSDConfigs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - apiServer: https://kube-apiserver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorization:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> credentials:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot-access-prometheus-shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: token
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> followRedirects: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespaces:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> names:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - kube-system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role: endpoints
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tlsConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ca:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &amp;lt;name-of-ca-bundle-secret&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: bundle.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cert: {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> metricRelabelings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sourceLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - __name__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: ^(metric1|metric2)$
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sourceLabels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - namespace
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: kube-system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> relabelings:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - action: replace
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replacement: my-cluster-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetLabel: job
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sourceLabels: [__meta_kubernetes_service_name, __meta_kubernetes_pod_container_port_name]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> separator: ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: my-component-service;metrics
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replacement: $1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action: keep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sourceLabels: [__meta_kubernetes_endpoint_node_name]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> separator: ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: (.*)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetLabel: node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replacement: $1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action: replace
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sourceLabels: [__meta_kubernetes_pod_name]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> separator: ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: (.*)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetLabel: pod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replacement: $1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action: replace
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - targetLabel: __address__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replacement: kube-apiserver:443
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - sourceLabels: [__meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> separator: ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> regex: (.+);(.+)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetLabel: __metrics_path__
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replacement: /api/v1/namespaces/kube-system/pods/${1}:${2}/proxy/metrics
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action: replace
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>[!TIP]
Developers can make use of the &lt;code>pkg/component/observability/monitoring/prometheus/shoot.ClusterComponentScrapeConfigSpec&lt;/code> function in order to generate a &lt;code>ScrapeConfig&lt;/code> like above.&lt;/p>
&lt;/blockquote>
&lt;h5 id="prometheusrule">&lt;code>PrometheusRule&lt;/code>&lt;/h5>
&lt;p>Similar to &lt;code>ServiceMonitor&lt;/code>s, &lt;code>PrometheusRule&lt;/code>s can be created with the &lt;code>prometheus=shoot&lt;/code> label:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: monitoring.coreos.com/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: PrometheusRule
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prometheus: shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: shoot-my-component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> groups:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: my.rules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rules:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="plutono-dashboards">Plutono Dashboards&lt;/h5>
&lt;p>A &lt;a href="https://github.com/credativ/plutono">Plutono&lt;/a> instance is deployed by &lt;code>gardenlet&lt;/code> into the shoot cluster&amp;rsquo;s namespace for visualizing monitoring metrics and logs via dashboards.
In order to provide custom dashboards, create a &lt;code>ConfigMap&lt;/code> in the shoot cluster&amp;rsquo;s namespace labelled with &lt;code>dashboard.monitoring.gardener.cloud/shoot=true&lt;/code> that contains the respective JSON documents, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ConfigMap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dashboard.monitoring.gardener.cloud/shoot: &lt;span style="color:#a31515">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: extension-foo-my-custom-dashboard
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--project--name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> my-custom-dashboard.json: &amp;lt;dashboard-JSON-document&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="logging">Logging&lt;/h2>
&lt;p>In Kubernetes clusters, container logs are non-persistent and do not survive stopped and destroyed containers. Gardener addresses this problem for the components hosted in a seed cluster by introducing its own managed logging solution. It is integrated with the Gardener monitoring stack to have all troubleshooting context in one place.&lt;/p>
&lt;p>&lt;img src="https://gardener.cloud/__resources/logging-architecture_8711a9.png" alt="&amp;amp;ldquo;Cluster Logging Topology&amp;amp;rdquo;" title="Cluster Logging Topology">&lt;/p>
&lt;p>Gardener logging consists of components in three roles - log collectors and forwarders, log persistency and exploration/consumption interfaces. All of them live in the seed clusters in multiple instances:&lt;/p>
&lt;ul>
&lt;li>Logs are persisted by Vali instances deployed as StatefulSets - one per shoot namespace, if the logging is enabled in the &lt;code>gardenlet&lt;/code> configuration (&lt;code>logging.enabled&lt;/code>) and the &lt;a href="https://gardener.cloud/docs/gardener/shoot/shoot_purposes/#behavioral-differences">shoot purpose&lt;/a> is not &lt;code>testing&lt;/code>, and one in the &lt;code>garden&lt;/code> namespace. The shoot instances store logs from the control plane components hosted there. The &lt;code>garden&lt;/code> Vali instance is responsible for logs from the rest of the seed namespaces - &lt;code>kube-system&lt;/code>, &lt;code>garden&lt;/code>, &lt;code>extension-*&lt;/code>, and others.&lt;/li>
&lt;li>Fluent-bit DaemonSets deployed by the fluent-operator on each seed node collect logs from it. A custom plugin takes care to distribute the collected log messages to the Vali instances that they are intended for. This allows to fetch the logs once for the whole cluster, and to distribute them afterwards.&lt;/li>
&lt;li>Plutono is the UI component used to explore monitoring and log data together for easier troubleshooting and in context. Plutono instances are configured to use the corresponding Vali instances, sharing the same namespace as data providers. There is one Plutono Deployment in the &lt;code>garden&lt;/code> namespace and one Deployment per shoot namespace (exposed to the end users and to the operators).&lt;/li>
&lt;/ul>
&lt;p>Logs can be produced from various sources, such as containers or systemd, and in different formats. The fluent-bit design supports configurable &lt;a href="https://docs.fluentbit.io/manual/concepts/data-pipeline">data pipeline&lt;/a> to address that problem. Gardener provides such &lt;a href="https://github.com/gardener/gardener/blob/master/pkg/component/kubernetes/apiserver/logging.go">configuration&lt;/a> for logs produced by all its core managed components as &lt;code>ClusterFilters&lt;/code> and &lt;code>ClusterParsers&lt;/code> . Extensions can contribute their own, specific configurations as fluent-operator custom resources too. See for example the &lt;a href="https://github.com/gardener/gardener-extension-provider-aws/blob/master/charts/gardener-extension-provider-aws/templates/clusterfilters-logging.yaml">logging configuration&lt;/a> for the Gardener AWS provider extension.&lt;/p>
&lt;h3 id="fluent-bit-log-parsers-and-filters">Fluent-bit Log Parsers and Filters&lt;/h3>
&lt;p>To integrate with Gardener logging, extensions can and &lt;em>should&lt;/em> specify how fluent-bit will handle the logs produced by the managed components that they contribute to Gardener. Normally, that would require to configure a &lt;em>parser&lt;/em> for the specific logging format, if none of the available is applicable, and a &lt;em>filter&lt;/em> defining how to apply it. For a complete reference for the configuration options, refer to fluent-bit&amp;rsquo;s &lt;a href="https://docs.fluentbit.io/manual/">documentation&lt;/a>.&lt;/p>
&lt;p>To contribute its own configuration to the fluent-bit agents data pipelines, an extension must deploy a &lt;code>fluent-operator&lt;/code> custom resource labeled with &lt;code>fluentbit.gardener/type: seed&lt;/code> in the seed cluster.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> Take care to provide the correct data pipeline elements in the corresponding fields and not to mix them.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Example:&lt;/strong> Logging configuration for provider-specific &lt;code>cloud-controller-manager&lt;/code> deployed into shoot namespaces that reuses the &lt;code>kube-apiserver-parser&lt;/code> defined in &lt;a href="https://github.com/gardener/gardener/blob/master/pkg/component/kubernetes/apiserver/logging.go">logging.go&lt;/a> to parse the component logs:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: fluentbit.fluent.io/v1alpha2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ClusterFilter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fluentbit.gardener/type: &lt;span style="color:#a31515">&amp;#34;seed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: cloud-controller-manager-aws-cloud-controller-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filters:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - parser:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyName: log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser: kube-apiserver-parser
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reserveData: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> match: kubernetes.*cloud-controller-manager*aws-cloud-controller-manager*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Further details how to define parsers and use them with examples can be found in the following &lt;a href="https://gardener.cloud/docs/gardener/log_parsers/">guide&lt;/a>.&lt;/p>
&lt;h3 id="plutono-1">Plutono&lt;/h3>
&lt;p>The two types of Plutono instances found in a seed cluster are configured to expose logs of different origin in their dashboards:&lt;/p>
&lt;ul>
&lt;li>Garden Plutono dashboards expose logs from non-shoot namespaces of the seed clusters
&lt;ul>
&lt;li>&lt;a href="https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/seed/pod-logs.json">Pod Logs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/seed/extensions-dashboard.json">Extensions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/seed/systemd-logs.json">Systemd Logs&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Shoot Plutono dashboards expose logs from the shoot cluster namespace where they belong
&lt;ul>
&lt;li>Kube Apiserver&lt;/li>
&lt;li>Kube Controller Manager&lt;/li>
&lt;li>Kube Scheduler&lt;/li>
&lt;li>Cluster Autoscaler&lt;/li>
&lt;li>VPA components&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/shoot/owners/kubernetes-pods-dashboard.json">Kubernetes Pods&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>If the type of logs exposed in the Plutono instances needs to be changed, it is necessary to update the corresponding instance dashboard configurations.&lt;/p>
&lt;h2 id="tips">Tips&lt;/h2>
&lt;ul>
&lt;li>Be careful to create &lt;code>ClusterFilters&lt;/code> and &lt;code>ClusterParsers&lt;/code> with unique names because they are not namespaced. We use &lt;code>pod_name&lt;/code> for filters with one container and &lt;code>pod_name--container_name&lt;/code> for pods with multiple containers.&lt;/li>
&lt;li>Be careful to match exactly the log names that you need for a particular parser in your filters configuration. The regular expression you will supply will match names in the form &lt;code>kubernetes.pod_name.&amp;lt;metadata&amp;gt;.container_name&lt;/code>. If there are extensions with the same container and pod names, they will all match the same parser in a filter. That may be a desired effect, if they all share the same log format. But it will be a problem if they don&amp;rsquo;t. To solve it, either the pod or container names must be unique, and the regular expression in the filter has to match that unique pattern. A recommended approach is to prefix containers with the extension name and tune the regular expression to match it. For example, using &lt;code>myextension-container&lt;/code> as container name and a regular expression &lt;code>kubernetes.mypod.*myextension-container&lt;/code> will guarantee match of the right log name. Make sure that the regular expression does not match more than you expect. For example, &lt;code>kubernetes.systemd.*systemd.*&lt;/code> will match both &lt;code>systemd-service&lt;/code> and &lt;code>systemd-monitor-service&lt;/code>. You will want to be as specific as possible.&lt;/li>
&lt;li>It&amp;rsquo;s a good idea to put the logging configuration into the Helm chart that also deploys the extension &lt;em>controller&lt;/em>, while the monitoring configuration can be part of the Helm chart/deployment routine that deploys the &lt;em>component&lt;/em> managed by the controller.&lt;/li>
&lt;/ul>
&lt;h2 id="references-and-additional-resources">References and Additional Resources&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gardener/gardener/issues/1351">GitHub Issue Describing the Concept&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/gardener-extension-provider-gcp/blob/master/charts/internal/seed-controlplane/charts/cloud-controller-manager/templates/configmap-observability.yaml">Exemplary Implementation (Monitoring) for the GCP Provider&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/gardener-extension-provider-aws/blob/master/charts/gardener-extension-provider-aws/templates/clusterfilters-logging.yaml">Exemplary Implementation (ClusterFilter) for the AWS Provider&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/gardener-extension-shoot-dns-service/blob/master/charts/gardener-extension-shoot-dns-service/templates/clusterparsers-logging.yaml">Exemplary Implementation (ClusterParser) for the Shoot DNS Service&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Docs: Machine Controller Provider Local</title><link>https://gardener.cloud/docs/gardener/extensions/machine-controller-provider-local/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/machine-controller-provider-local/</guid><description>
&lt;h1 id="machine-controller-manager-provider-local">machine-controller-manager-provider-local&lt;/h1>
&lt;p>Out of tree (controller-based) implementation for &lt;code>local&lt;/code> as a new provider.
The local out-of-tree provider implements the interface defined at &lt;a href="https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/driver/driver.go">MCM OOT driver&lt;/a>.&lt;/p>
&lt;h2 id="fundamental-design-principles">Fundamental Design Principles&lt;/h2>
&lt;p>Following are the basic principles kept in mind while developing the external plugin.&lt;/p>
&lt;ul>
&lt;li>Communication between this Machine Controller (MC) and Machine Controller Manager (MCM) is achieved using the Kubernetes native declarative approach.&lt;/li>
&lt;li>Machine Controller (MC) behaves as the controller used to interact with the &lt;code>local&lt;/code> provider and manage the VMs corresponding to the machine objects.&lt;/li>
&lt;li>Machine Controller Manager (MCM) deals with higher level objects such as machine-set and machine-deployment objects.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Managedresources</title><link>https://gardener.cloud/docs/gardener/extensions/managedresources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/managedresources/</guid><description>
&lt;h1 id="deploy-resources-to-the-shoot-cluster">Deploy Resources to the Shoot Cluster&lt;/h1>
&lt;p>We have introduced a component called &lt;a href="https://gardener.cloud/docs/gardener/concepts/resource-manager/">&lt;code>gardener-resource-manager&lt;/code>&lt;/a> that is deployed as part of every shoot control plane in the seed.
One of its tasks is to manage CRDs, so called &lt;code>ManagedResource&lt;/code>s.
Managed resources contain Kubernetes resources that shall be created, reconciled, updated, and deleted by the gardener-resource-manager.&lt;/p>
&lt;p>Extension controllers may create these &lt;code>ManagedResource&lt;/code>s in the shoot namespace if they need to create any resource in the shoot cluster itself, for example RBAC roles (or anything else).&lt;/p>
&lt;h2 id="where-can-i-find-more-examples-and-more-information-how-to-use-managedresources">Where can I find more examples and more information how to use &lt;code>ManagedResource&lt;/code>s?&lt;/h2>
&lt;p>Please take a look at the &lt;a href="https://gardener.cloud/docs/gardener/concepts/resource-manager/">respective documentation&lt;/a>.&lt;/p></description></item><item><title>Docs: Migration</title><link>https://gardener.cloud/docs/gardener/extensions/migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/migration/</guid><description>
&lt;h1 id="control-plane-migration">Control Plane Migration&lt;/h1>
&lt;p>&lt;em>Control Plane Migration&lt;/em> is a new Gardener feature that has been recently implemented as proposed in &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/07-shoot-control-plane-migration.md">GEP-7 Shoot Control Plane Migration&lt;/a>. It should be properly supported by all extensions controllers. This document outlines some important points that extension maintainers should keep in mind to properly support migration in their extensions.&lt;/p>
&lt;h2 id="overall-principles">Overall Principles&lt;/h2>
&lt;p>The following principles should always be upheld:&lt;/p>
&lt;ul>
&lt;li>All states maintained by the extension that is external from the seed cluster, for example infrastructure resources in a cloud provider, DNS entries, etc., should be kept during the migration. No such state should be deleted and then recreated, as this might cause disruption in the availability of the shoot cluster.&lt;/li>
&lt;li>All Kubernetes resources maintained by the extension in the shoot cluster itself should also be kept during the migration. No such resources should be deleted and then recreated.&lt;/li>
&lt;/ul>
&lt;h2 id="migrate-and-restore-operations">Migrate and Restore Operations&lt;/h2>
&lt;p>Two new operations have been introduced in Gardener. They can be specified as values of the &lt;code>gardener.cloud/operation&lt;/code> annotation on an extension resource to indicate that an operation different from a normal &lt;code>reconcile&lt;/code> should be performed by the corresponding extension controller:&lt;/p>
&lt;ul>
&lt;li>The &lt;code>migrate&lt;/code> operation is used to ask the extension controller in the source seed to stop reconciling extension resources (in case they are requeued due to errors) and perform cleanup activities, if such are required. These cleanup activities might involve removing finalizers on resources in the shoot namespace that have been previously created by the extension controller and deleting them without actually deleting any resources external to the seed cluster. This is also the last opportunity for extensions to persist their state into the &lt;code>.status.state&lt;/code> field of the reconciled extension resource before its restored in the new destination seed cluster.&lt;/li>
&lt;li>The &lt;code>restore&lt;/code> operation is used to ask the extension controller in the destination seed to restore any state saved in the extension resource &lt;code>status&lt;/code>, before performing the actual reconciliation.&lt;/li>
&lt;/ul>
&lt;p>Unlike the &lt;a href="https://gardener.cloud/docs/gardener/extensions/reconcile-trigger/">reconcile operation&lt;/a>, extension controllers must remove the &lt;code>gardener.cloud/operation&lt;/code> annotation at the end of a successful reconciliation when the current operation is &lt;code>migrate&lt;/code> or &lt;code>restore&lt;/code>, not at the beginning of a reconciliation.&lt;/p>
&lt;h2 id="cleaning-up-source-seed-resources">Cleaning-Up Source Seed Resources&lt;/h2>
&lt;p>All resources in the source seed that have been created by an extension controller, for example secrets, config maps, &lt;a href="https://gardener.cloud/docs/gardener/extensions/managedresources/">managed resources&lt;/a>, etc., should be properly cleaned up by the extension controller when the current operation is &lt;code>migrate&lt;/code>. As mentioned above, such resources should be deleted without actually deleting any resources external to the seed cluster.&lt;/p>
&lt;p>There is one exception to this: &lt;code>Secret&lt;/code>s labeled with &lt;code>persist=true&lt;/code> created via the &lt;a href="https://gardener.cloud/docs/gardener/secrets_management/">secrets manager&lt;/a>. They should be kept (i.e., the &lt;code>Cleanup&lt;/code> function of secrets manager should not be called) and will be garbage collected automatically at the end of the &lt;code>migrate&lt;/code> operation. This ensures that they can be properly persisted in the &lt;code>ShootState&lt;/code> resource and get restored on the new destination seed cluster.&lt;/p>
&lt;p>For many custom resources, for example MCM resources, the above requirement means in practice that any finalizers should be removed before deleting the resource, in addition to ensuring that the resource deletion is not reconciled by its respective controller if there is no finalizer. For managed resources, the above requirement means in practice that the &lt;code>spec.keepObjects&lt;/code> field should be set to &lt;code>true&lt;/code> before deleting the extension resource.&lt;/p>
&lt;p>Here it is assumed that any resources that contain state needed by the extension controller can be safely deleted, since any such state has been saved as described in &lt;a href="https://gardener.cloud/docs/gardener/extensions/migration/#saving-and-restoring-extension-states">Saving and Restoring Extension States&lt;/a> at the end of the last successful reconciliation.&lt;/p>
&lt;h2 id="saving-and-restoring-extension-states">Saving and Restoring Extension States&lt;/h2>
&lt;p>Some extension controllers create and maintain their own state when reconciling extension resources. For example, most infrastructure controllers use Terraform and maintain the terraform state in a special config map in the shoot namespace. This state must be properly migrated to the new seed cluster during control plane migration, so that subsequent reconciliations in the new seed could find and use it appropriately.&lt;/p>
&lt;p>All extension controllers that require such state migration must save their state in the &lt;code>status.state&lt;/code> field of their extension resource at the end of a successful reconciliation. They must also restore their state from that same field upon reconciling an extension resource when the current operation is &lt;code>restore&lt;/code>, as specified by the &lt;code>gardener.cloud/operation&lt;/code> annotation, before performing the actual reconciliation.&lt;/p>
&lt;p>As an example, an infrastructure controller that uses Terraform must save the terraform state in the &lt;code>status.state&lt;/code> field of the &lt;code>Infrastructure&lt;/code> resource. An &lt;code>Infrastructure&lt;/code> resource with a properly saved state might look as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Infrastructure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: infrastructure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: azure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> region: eu-west-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: cloudprovider
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: InfrastructureConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceGroup:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: mygroup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: |&lt;span style="color:#a31515">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &amp;#34;version&amp;#34;: 3,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &amp;#34;terraform_version&amp;#34;: &amp;#34;0.11.14&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &amp;#34;serial&amp;#34;: 2,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &amp;#34;lineage&amp;#34;: &amp;#34;3a1e2faa-e7b6-f5f0-5043-368dd8ea6c10&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Extension controllers that do not use a saved state and therefore do not require state migration could leave the &lt;code>status.state&lt;/code> field as &lt;code>nil&lt;/code> at the end of a successful reconciliation, and just perform a normal reconciliation when the current operation is &lt;code>restore&lt;/code>.&lt;/p>
&lt;p>In addition, extension controllers that use &lt;a href="https://gardener.cloud/docs/gardener/extensions/referenced-resources/">referenced resources&lt;/a> (usually secrets) must also make sure that these resources are added to the &lt;code>status.resources&lt;/code> field of their extension resource at the end of a successful reconciliation, so they could be properly migrated by Gardener to the destination seed.&lt;/p>
&lt;h2 id="implementation-details">Implementation Details&lt;/h2>
&lt;h3 id="migrate-and-restore-actuator-methods">Migrate and Restore Actuator Methods&lt;/h3>
&lt;p>Most extension controller implementations follow a common pattern where a generic &lt;code>Reconciler&lt;/code> implementation delegates to an &lt;code>Actuator&lt;/code> interface that contains the methods &lt;code>Reconcile&lt;/code> and &lt;code>Delete&lt;/code>, provided by the extension.
Two methods &lt;code>Migrate&lt;/code> and &lt;code>Restore&lt;/code> are available in all such &lt;code>Actuator&lt;/code> interfaces, see &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go">the infrastructure &lt;code>Actuator&lt;/code> interface&lt;/a> as an example.
These methods are called by the generic reconcilers for the &lt;a href="https://gardener.cloud/docs/gardener/extensions/migration/#migrate-and-restore-operations">migrate and restore operations&lt;/a> respectively, and should be implemented by the extension according to the above guidelines.&lt;/p>
&lt;h3 id="extension-controllers-based-on-generic-actuators">Extension Controllers Based on Generic Actuators&lt;/h3>
&lt;p>In practice, the implementation of many extension controllers (for example, the &lt;code>ControlPlane&lt;/code> and &lt;code>Worker&lt;/code> controllers in most provider extensions) are based on a &lt;em>generic &lt;code>Actuator&lt;/code> implementation&lt;/em> that only delegates to extension methods for behavior that is truly provider specific.
In all such cases, the &lt;code>Migrate&lt;/code> and &lt;code>Restore&lt;/code> methods have already been implemented properly in the generic actuators and there is nothing more to do in the extension itself.&lt;/p>
&lt;p>In some rare cases, extension controllers based on a generic actuator might still introduce a custom &lt;code>Actuator&lt;/code> implementation to override some of the generic actuator methods in order to enhance or change their behavior in a certain way.
In such cases, the &lt;code>Migrate&lt;/code> and &lt;code>Restore&lt;/code> methods might need to be overridden as well, see the &lt;a href="https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/controlplane">Azure controlplane controller&lt;/a> as an example.&lt;/p>
&lt;h4 id="worker-state">&lt;code>Worker&lt;/code> State&lt;/h4>
&lt;p>Note that the machine state is handled specially by &lt;code>gardenlet&lt;/code> (i.e., all relevant objects in the &lt;code>machine.sapcloud.io/v1alpha1&lt;/code> API are directly persisted by &lt;code>gardenlet&lt;/code> and &lt;strong>NOT&lt;/strong> by the generic actuators).
In the past, they were persisted to the &lt;code>Worker&lt;/code>&amp;rsquo;s &lt;code>.status.state&lt;/code> field by the so-called &amp;ldquo;worker state reconciler&amp;rdquo;, however, this reconciler was dropped and changed as part of &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/22-improved-usage-of-shootstate-api.md#eliminating-the-worker-state-reconciler">GEP-22&lt;/a>.
Nowadays, &lt;code>gardenlet&lt;/code> directly writes the state to the &lt;code>ShootState&lt;/code> resource during the &lt;code>Migrate&lt;/code> phase of a &lt;code>Shoot&lt;/code> (without the detour of the &lt;code>Worker&lt;/code>&amp;rsquo;s &lt;code>.status.state&lt;/code> field).
On restoration, unlike for other extension kinds, &lt;code>gardenlet&lt;/code> no longer populates the machine state into the &lt;code>Worker&lt;/code>&amp;rsquo;s &lt;code>.status.state&lt;/code> field.
Instead, the extension controller should read the machine state directly from the &lt;code>ShootState&lt;/code> in the garden cluster (see &lt;a href="https://gardener.cloud/docs/gardener/extensions/garden-api-access/">this document&lt;/a> for information how to access the garden cluster) and use it to subsequently restore the relevant &lt;code>machine.sapcloud.io/v1alpha1&lt;/code> resources.
This flow is implemented in the &lt;a href="https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/worker/genericactuator/actuator_restore.go">generic &lt;code>Worker&lt;/code> actuator&lt;/a>.
As a result, Extension controllers using this generic actuator do not need to implement any custom logic.&lt;/p>
&lt;h3 id="extension-controllers-not-based-on-generic-actuators">Extension Controllers Not Based on Generic Actuators&lt;/h3>
&lt;p>The implementation of some extension controllers (for example, the infrastructure controllers in all provider extensions) are not based on a generic &lt;code>Actuator&lt;/code> implementation.
Such extension controllers must always provide a proper implementation of the &lt;code>Migrate&lt;/code> and &lt;code>Restore&lt;/code> methods according to the above guidelines, see the &lt;a href="https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure">AWS infrastructure controller&lt;/a> as an example.
In practice, this might result in code duplication between the different extensions, since the &lt;code>Migrate&lt;/code> and &lt;code>Restore&lt;/code> code is usually not provider or OS-specific.&lt;/p>
&lt;blockquote>
&lt;p>If you do not use the generic &lt;code>Worker&lt;/code> actuator, see &lt;a href="https://gardener.cloud/docs/gardener/extensions/migration/#worker-state">this section&lt;/a> for information how to handle the machine state related to the &lt;code>Worker&lt;/code> resource.&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Overview</title><link>https://gardener.cloud/docs/gardener/extensions/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/overview/</guid><description>
&lt;h1 id="extensibility-overview">Extensibility Overview&lt;/h1>
&lt;p>Initially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself.
But as the project grew, it got more and more difficult to add new providers and maintain the existing code base.
As a consequence and in order to become agile and flexible again, we proposed &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/01-extensibility.md">GEP-1&lt;/a> (Gardener Enhancement Proposal).
The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with &lt;a href="https://github.com/kubernetes/enhancements/issues/88">out-of-tree cloud providers&lt;/a> or with &lt;a href="https://github.com/kubernetes/community/pull/1258">CSI volume plugins&lt;/a>).&lt;/p>
&lt;h2 id="basic-concepts">Basic Concepts&lt;/h2>
&lt;p>Gardener keeps running in the &amp;ldquo;garden cluster&amp;rdquo; and implements the core logic of shoot cluster reconciliation / deletion.
Extensions are Kubernetes controllers themselves (like Gardener) and run in the seed clusters.
As usual, we try to use Kubernetes wherever applicable.
We rely on Kubernetes extension concepts in order to enable extensibility for Gardener.
The main ideas of GEP-1 are the following:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>During the shoot reconciliation process, Gardener will write CRDs into the seed cluster that are watched and managed by the extension controllers. They will reconcile (based on the &lt;code>.spec&lt;/code>) and report whether everything went well or errors occurred in the CRD&amp;rsquo;s &lt;code>.status&lt;/code> field.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Gardener keeps deploying the provider-independent control plane components (etcd, kube-apiserver, etc.). However, some of these components might still need little customization by providers, e.g., additional configuration, flags, etc. In this case, the extension controllers register webhooks in order to manipulate the manifests.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>Example 1&lt;/strong>:&lt;/p>
&lt;p>Gardener creates a new AWS shoot cluster and requires the preparation of infrastructure in order to proceed (networks, security groups, etc.).
It writes the following CRD into the seed cluster:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Infrastructure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: infrastructure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--core--aws-01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type: aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: InfrastructureConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> networks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vpc:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cidr: 10.250.0.0/16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> internal:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - 10.250.112.0/22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> public:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - 10.250.96.0/22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> workers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - 10.250.0.0/19
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zones:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - eu-west-1a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dns:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiserver: api.aws-01.core.example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> region: eu-west-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: my-aws-credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sshPublicKey: |&lt;span style="color:#a31515">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> &lt;/span> base64(key)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Please note that the &lt;code>.spec.providerConfig&lt;/code> is a raw blob and not evaluated or known in any way by Gardener.
Instead, it was specified by the user (in the &lt;code>Shoot&lt;/code> resource) and just &amp;ldquo;forwarded&amp;rdquo; to the extension controller.
Only the AWS controller understands this configuration and will now start provisioning/reconciling the infrastructure.
It reports in the &lt;code>.status&lt;/code> field the result:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> observedGeneration: ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastError: ..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastOperation: ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerStatus:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: InfrastructureStatus
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vpc:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id: vpc-1234
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> subnets:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - id: subnet-acbd1234
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: workers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zone: eu-west-1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> securityGroups:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - id: sg-xyz12345
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: workers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iam:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodesRoleARN: &amp;lt;some-arn&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instanceProfileName: foo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ec2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyName: bar
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gardener waits until the &lt;code>.status.lastOperation&lt;/code> / &lt;code>.status.lastError&lt;/code> indicates that the operation reached a final state and either continuous with the next step, or stops and reports the potential error.
The extension-specific output in &lt;code>.status.providerStatus&lt;/code> is - similar to &lt;code>.spec.providerConfig&lt;/code> - not evaluated, and simply forwarded to CRDs in subsequent steps.&lt;/p>
&lt;p>&lt;strong>Example 2&lt;/strong>:&lt;/p>
&lt;p>Gardener deploys the control plane components into the seed cluster, e.g. the &lt;code>kube-controller-manager&lt;/code> deployment with the following flags:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: apps/v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> containers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - command:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - /usr/local/bin/kube-controller-manager
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --allocate-node-cidrs=true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --attach-detach-reconcile-sync-period=1m0s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --controllers=*,bootstrapsigner,tokencleaner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --cluster-cidr=100.96.0.0/11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --cluster-name=shoot--core--aws-01
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --cluster-signing-cert-file=/srv/kubernetes/ca/ca.crt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --cluster-signing-key-file=/srv/kubernetes/ca/ca.key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --concurrent-deployment-syncs=10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --concurrent-replicaset-syncs=10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The AWS controller requires some additional flags in order to make the cluster functional.
It needs to provide a Kubernetes cloud-config and also some cloud-specific flags.
Consequently, it registers a &lt;code>MutatingWebhookConfiguration&lt;/code> on &lt;code>Deployment&lt;/code>s and adds these flags to the container:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> - --cloud-provider=external
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --external-cloud-volume-plugin=aws
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --cloud-config=/etc/kubernetes/cloudprovider/cloudprovider.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course, it would have needed to create a &lt;code>ConfigMap&lt;/code> containing the cloud config and to add the proper &lt;code>volume&lt;/code> and &lt;code>volumeMounts&lt;/code> to the manifest as well.&lt;/p>
&lt;p>(Please note for this special example: The Kubernetes community is also working on making the &lt;code>kube-controller-manager&lt;/code> provider-independent.
However, there will most probably be still components other than the &lt;code>kube-controller-manager&lt;/code> which need to be adapted by extensions.)&lt;/p>
&lt;p>If you are interested in writing an extension, or generally in digging deeper to find out the nitty-gritty details of the extension concepts, please read &lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/01-extensibility.md">GEP-1&lt;/a>.
We are truly looking forward to your feedback!&lt;/p>
&lt;h2 id="current-status">Current Status&lt;/h2>
&lt;p>Meanwhile, the out-of-tree extension architecture of Gardener is in place and has been productively validated. We are tracking all internal and external extensions of Gardener in the &lt;a href="https://github.com/gardener/gardener/tree/master/extensions#known-extension-implementations">Gardener Extensions Library&lt;/a> repo.&lt;/p></description></item><item><title>Docs: Project Roles</title><link>https://gardener.cloud/docs/gardener/extensions/project-roles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/project-roles/</guid><description>
&lt;h1 id="extending-project-roles">Extending Project Roles&lt;/h1>
&lt;p>The &lt;code>Project&lt;/code> resource allows to specify a list of roles for every member (&lt;code>.spec.members[*].roles&lt;/code>).
There are a few standard roles defined by Gardener itself.
Please consult &lt;a href="https://gardener.cloud/docs/gardener/project/projects/">Projects&lt;/a> for further information.&lt;/p>
&lt;p>However, extension controllers running in the garden cluster may also create &lt;code>CustomResourceDefinition&lt;/code>s that project members might be able to CRUD.
For this purpose, Gardener also allows to specify extension roles.&lt;/p>
&lt;p>An extension role is prefixed with &lt;code>extension:&lt;/code>, e.g.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Project
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> members:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - apiGroup: rbac.authorization.k8s.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: User
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: alice.doe@example.com
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role: admin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> roles:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - owner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - extension:foo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The project controller will, for every extension role, create a &lt;code>ClusterRole&lt;/code> with name &lt;code>gardener.cloud:extension:project:&amp;lt;projectName&amp;gt;:&amp;lt;roleName&amp;gt;&lt;/code>, i.e., for the above example: &lt;code>gardener.cloud:extension:project:dev:foo&lt;/code>.
This &lt;code>ClusterRole&lt;/code> aggregates other &lt;code>ClusterRole&lt;/code>s that are labeled with &lt;code>rbac.gardener.cloud/aggregate-to-extension-role=foo&lt;/code> which might be created by extension controllers.&lt;/p>
&lt;p>An extension that might want to contribute to the core &lt;code>admin&lt;/code> or &lt;code>viewer&lt;/code> roles can use the labels &lt;code>rbac.gardener.cloud/aggregate-to-project-member=true&lt;/code> or &lt;code>rbac.gardener.cloud/aggregate-to-project-viewer=true&lt;/code>, respectively.&lt;/p>
&lt;p>Please note that the names of the extension roles are restricted to 20 characters!&lt;/p>
&lt;p>Moreover, the project controller will also create a corresponding &lt;code>RoleBinding&lt;/code> with the same name in the project namespace.
It will automatically assign all members that are assigned to this extension role.&lt;/p></description></item><item><title>Docs: Provider Local</title><link>https://gardener.cloud/docs/gardener/extensions/provider-local/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/provider-local/</guid><description>
&lt;h1 id="local-provider-extension">Local Provider Extension&lt;/h1>
&lt;p>The &amp;ldquo;local provider&amp;rdquo; extension is used to allow the usage of seed and shoot clusters which run entirely locally without any real infrastructure or cloud provider involved.
It implements Gardener&amp;rsquo;s extension contract (&lt;a href="https://github.com/gardener/gardener/blob/master/docs/proposals/01-extensibility.md">GEP-1&lt;/a>) and thus comprises several controllers and webhooks acting on resources in seed and shoot clusters.&lt;/p>
&lt;p>The code is maintained in &lt;a href="https://github.com/gardener/gardener/tree/master/pkg/provider-local">&lt;code>pkg/provider-local&lt;/code>&lt;/a>.&lt;/p>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>The motivation for maintaining such extension is the following:&lt;/p>
&lt;ul>
&lt;li>🛡 Output Qualification: Run fast and cost-efficient end-to-end tests, locally and in CI systems (increased confidence ⛑ before merging pull requests)&lt;/li>
&lt;li>⚙️ Development Experience: Develop Gardener entirely on a local machine without any external resources involved (improved costs 💰 and productivity 🚀)&lt;/li>
&lt;li>🤝 Open Source: Quick and easy setup for a first evaluation of Gardener and a good basis for first contributions&lt;/li>
&lt;/ul>
&lt;h2 id="current-limitations">Current Limitations&lt;/h2>
&lt;p>The following enlists the current limitations of the implementation.
Please note that all of them are not technical limitations/blockers, but simply advanced scenarios that we haven&amp;rsquo;t had invested yet into.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>No load balancers for Shoot clusters.&lt;/p>
&lt;p>&lt;em>We have not yet developed a &lt;code>cloud-controller-manager&lt;/code> which could reconcile load balancer &lt;code>Service&lt;/code>s in the shoot cluster.&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>In case a seed cluster with multiple availability zones, i.e. multiple entries in &lt;code>.spec.provider.zones&lt;/code>, is used in conjunction with a single-zone shoot control plane, i.e. a shoot cluster without &lt;code>.spec.controlPlane.highAvailability&lt;/code> or with &lt;code>.spec.controlPlane.highAvailability.failureTolerance.type&lt;/code> set to &lt;code>node&lt;/code>, the local address of the API server endpoint needs to be determined manually or via the in-cluster &lt;code>coredns&lt;/code>.&lt;/p>
&lt;p>&lt;em>As the different istio ingress gateway loadbalancers have individual external IP addresses, single-zone shoot control planes can end up in a random availability zone. Having the local host use the &lt;code>coredns&lt;/code> in the cluster as name resolver would form a name resolution cycle. The tests mitigate the issue by adapting the DNS configuration inside the affected test.&lt;/em>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="managedseeds">&lt;code>ManagedSeed&lt;/code>s&lt;/h2>
&lt;p>It is possible to deploy &lt;a href="https://gardener.cloud/docs/gardener/managed_seed/">&lt;code>ManagedSeed&lt;/code>s&lt;/a> with &lt;code>provider-local&lt;/code> by first creating a &lt;a href="https://github.com/gardener/gardener/blob/master/example/provider-local/managedseeds/shoot-managedseed.yaml">&lt;code>Shoot&lt;/code> in the &lt;code>garden&lt;/code> namespace&lt;/a> and then creating a referencing &lt;a href="https://github.com/gardener/gardener/blob/master/example/provider-local/managedseeds/managedseed.yaml">&lt;code>ManagedSeed&lt;/code> object&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>Please note that this is only supported by the &lt;a href="https://gardener.cloud/docs/gardener/deployment/getting_started_locally/">&lt;code>Skaffold&lt;/code>-based setup&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>The corresponding e2e test can be run via:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./hack/test-e2e-local.sh --label-filter &lt;span style="color:#a31515">&amp;#34;ManagedSeed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="implementation-details">Implementation Details&lt;/h3>
&lt;p>The images locally built by &lt;code>Skaffold&lt;/code> for the Gardener components which are deployed to this shoot cluster are managed by a container registry in the &lt;code>registry&lt;/code> namespace in the kind cluster.
&lt;code>provider-local&lt;/code> configures this registry as mirror for the shoot by mutating the &lt;code>OperatingSystemConfig&lt;/code> and using the &lt;a href="https://gardener.cloud/docs/gardener/advanced/custom-containerd-config/">default contract for extending the &lt;code>containerd&lt;/code> configuration&lt;/a>.&lt;/p>
&lt;p>In order to bootstrap a seed cluster, the &lt;code>gardenlet&lt;/code> deploys &lt;code>PersistentVolumeClaim&lt;/code>s and &lt;code>Service&lt;/code>s of type &lt;code>LoadBalancer&lt;/code>.
While storage is supported in shoot clusters by using the &lt;a href="https://github.com/rancher/local-path-provisioner">&lt;code>local-path-provisioner&lt;/code>&lt;/a>, load balancers are not supported yet.
However, &lt;code>provider-local&lt;/code> runs a &lt;code>Service&lt;/code> controller which specifically reconciles the seed-related &lt;code>Service&lt;/code>s of type &lt;code>LoadBalancer&lt;/code>.
This way, they get an IP and &lt;code>gardenlet&lt;/code> can finish its bootstrapping process.
Note that these IPs are not reachable, however for the sake of developing &lt;code>ManagedSeed&lt;/code>s this is sufficient for now.&lt;/p>
&lt;p>Also, please note that the &lt;code>provider-local&lt;/code> extension only gets deployed because of the &lt;code>Always&lt;/code> deployment policy in its corresponding &lt;code>ControllerRegistration&lt;/code> and because the DNS provider type of the seed is set to &lt;code>local&lt;/code>.&lt;/p>
&lt;h2 id="implementation-details-1">Implementation Details&lt;/h2>
&lt;p>This section contains information about how the respective controllers and webhooks in &lt;code>provider-local&lt;/code> are implemented and what their purpose is.&lt;/p>
&lt;h3 id="bootstrapping">Bootstrapping&lt;/h3>
&lt;p>The Helm chart of the &lt;code>provider-local&lt;/code> extension defined in its &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/">&lt;code>ControllerDeployment&lt;/code>&lt;/a> contains a special deployment for a &lt;a href="https://coredns.io/">CoreDNS&lt;/a> instance in a &lt;code>gardener-extension-provider-local-coredns&lt;/code> namespace in the seed cluster.&lt;/p>
&lt;p>This CoreDNS instance is responsible for enabling the components running in the shoot clusters to be able to resolve the DNS names when they communicate with their &lt;code>kube-apiserver&lt;/code>s.&lt;/p>
&lt;p>It contains a static configuration to resolve the DNS names based on &lt;code>local.gardener.cloud&lt;/code> to &lt;code>istio-ingressgateway.istio-ingress.svc&lt;/code>.&lt;/p>
&lt;h3 id="controllers">Controllers&lt;/h3>
&lt;p>There are controllers for all resources in the &lt;code>extensions.gardener.cloud/v1alpha1&lt;/code> API group except for &lt;code>BackupBucket&lt;/code> and &lt;code>BackupEntry&lt;/code>s.&lt;/p>
&lt;h4 id="controlplane">&lt;code>ControlPlane&lt;/code>&lt;/h4>
&lt;p>This controller is deploying the &lt;a href="https://github.com/rancher/local-path-provisioner">local-path-provisioner&lt;/a> as well as a related &lt;code>StorageClass&lt;/code> in order to support &lt;code>PersistentVolumeClaim&lt;/code>s in the local shoot cluster.
Additionally, it creates a few (currently unused) dummy secrets (CA, server and client certificate, basic auth credentials) for the sake of testing the secrets manager integration in the extensions library.&lt;/p>
&lt;h4 id="dnsrecord">&lt;code>DNSRecord&lt;/code>&lt;/h4>
&lt;p>The controller adapts the cluster internal DNS configuration by extending the &lt;code>coredns&lt;/code> configuration for every observed &lt;code>DNSRecord&lt;/code>. It will add two corresponding entries in the custom DNS configuration per shoot cluster:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> api.local.local.external.local.gardener.cloud.override: |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rewrite stop name regex api.local.local.external.local.gardener.cloud istio-ingressgateway.istio-ingress.svc.cluster.local answer auto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> api.local.local.internal.local.gardener.cloud.override: |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rewrite stop name regex api.local.local.internal.local.gardener.cloud istio-ingressgateway.istio-ingress.svc.cluster.local answer auto
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="infrastructure">&lt;code>Infrastructure&lt;/code>&lt;/h4>
&lt;p>This controller generates a &lt;code>NetworkPolicy&lt;/code> which allows the control plane pods (like &lt;code>kube-apiserver&lt;/code>) to communicate with the worker machine pods (see &lt;a href="https://gardener.cloud/docs/gardener/extensions/provider-local/#worker">&lt;code>Worker&lt;/code> section&lt;/a>).&lt;/p>
&lt;h4 id="network">&lt;code>Network&lt;/code>&lt;/h4>
&lt;p>This controller is not implemented anymore. In the initial version of &lt;code>provider-local&lt;/code>, there was a &lt;code>Network&lt;/code> controller deploying &lt;a href="https://github.com/kubernetes-sigs/kind/blob/main/images/kindnetd/README.md">kindnetd&lt;/a> (see &lt;a href="https://github.com/gardener/gardener/tree/v1.44.1/pkg/provider-local/controller/network">release v1.44.1&lt;/a>).
However, we decided to drop it because this setup prevented us from using &lt;code>NetworkPolicy&lt;/code>s (kindnetd does not ship a &lt;code>NetworkPolicy&lt;/code> controller).
In addition, we had issues with shoot clusters having more than one node (hence, we couldn&amp;rsquo;t support rolling updates, see &lt;a href="https://github.com/gardener/gardener/pull/5666/commits/491b3cd16e40e5c20ef02367fda93a34ff9465eb">PR #5666&lt;/a>).&lt;/p>
&lt;h4 id="operatingsystemconfig">&lt;code>OperatingSystemConfig&lt;/code>&lt;/h4>
&lt;p>This controller renders a simple cloud-init template which can later be executed by the shoot worker nodes.&lt;/p>
&lt;p>The shoot worker nodes are &lt;code>Pod&lt;/code>s with a container based on the &lt;code>kindest/node&lt;/code> image. This is maintained in the &lt;a href="https://github.com/gardener/machine-controller-manager-provider-local/tree/master/node">gardener/machine-controller-manager-provider-local repository&lt;/a> and has a special &lt;code>run-userdata&lt;/code> systemd service which executes the cloud-init generated earlier by the &lt;code>OperatingSystemConfig&lt;/code> controller.&lt;/p>
&lt;h4 id="worker">&lt;code>Worker&lt;/code>&lt;/h4>
&lt;p>This controller leverages the standard &lt;a href="https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker/genericactuator">generic &lt;code>Worker&lt;/code> actuator&lt;/a> in order to deploy the &lt;a href="https://github.com/gardener/machine-controller-manager">&lt;code>machine-controller-manager&lt;/code>&lt;/a> as well as the &lt;a href="https://github.com/gardener/machine-controller-manager-provider-local">&lt;code>machine-controller-manager-provider-local&lt;/code>&lt;/a>.&lt;/p>
&lt;p>Additionally, it generates the &lt;a href="https://github.com/gardener/machine-controller-manager-provider-local/blob/master/kubernetes/machine-class.yaml">&lt;code>MachineClass&lt;/code>es&lt;/a> and the &lt;code>MachineDeployment&lt;/code>s based on the specification of the &lt;code>Worker&lt;/code> resources.&lt;/p>
&lt;h4 id="ingress">&lt;code>Ingress&lt;/code>&lt;/h4>
&lt;p>The gardenlet creates a wildcard DNS record for the Seed&amp;rsquo;s ingress domain pointing to the &lt;code>nginx-ingress-controller&lt;/code>&amp;rsquo;s LoadBalancer.
This domain is commonly used by all &lt;code>Ingress&lt;/code> objects created in the Seed for Seed and Shoot components.
As provider-local implements the &lt;code>DNSRecord&lt;/code> extension API (see the &lt;a href="https://gardener.cloud/docs/gardener/extensions/provider-local/#dnsrecord">&lt;code>DNSRecord&lt;/code>section&lt;/a>), this controller reconciles all &lt;code>Ingress&lt;/code>s and creates &lt;code>DNSRecord&lt;/code>s of type &lt;code>local&lt;/code> for each host included in &lt;code>spec.rules&lt;/code>.
This only happens for shoot namespaces (&lt;code>gardener.cloud/role=shoot&lt;/code> label) to make &lt;code>Ingress&lt;/code> domains resolvable on the machine pods.&lt;/p>
&lt;h4 id="service">&lt;code>Service&lt;/code>&lt;/h4>
&lt;p>This controller reconciles &lt;code>Services&lt;/code> of type &lt;code>LoadBalancer&lt;/code> in the local &lt;code>Seed&lt;/code> cluster.
Since the local Kubernetes clusters used as Seed clusters typically don&amp;rsquo;t support such services, this controller sets the &lt;code>.status.ingress.loadBalancer.ip[0]&lt;/code> to the IP of the host.
It makes important LoadBalancer Services (e.g. &lt;code>istio-ingress/istio-ingressgateway&lt;/code> and &lt;code>garden/nginx-ingress-controller&lt;/code>) available to the host by setting &lt;code>spec.ports[].nodePort&lt;/code> to well-known ports that are mapped to &lt;code>hostPorts&lt;/code> in the kind cluster configuration.&lt;/p>
&lt;p>&lt;code>istio-ingress/istio-ingressgateway&lt;/code> is set to be exposed on &lt;code>nodePort&lt;/code> &lt;code>30433&lt;/code> by this controller.&lt;/p>
&lt;p>In case the seed has multiple availability zones (&lt;code>.spec.provider.zones&lt;/code>) and it uses SNI, the different zone-specific &lt;code>istio-ingressgateway&lt;/code> loadbalancers are exposed via different IP addresses. Per default, IP addresses &lt;code>172.18.255.10&lt;/code>, &lt;code>172.18.255.11&lt;/code>, and &lt;code>172.18.255.12&lt;/code> are used for the zones &lt;code>0&lt;/code>, &lt;code>1&lt;/code>, and &lt;code>2&lt;/code> respectively.&lt;/p>
&lt;h4 id="etcd-backups">ETCD Backups&lt;/h4>
&lt;p>This controller reconciles the &lt;code>BackupBucket&lt;/code> and &lt;code>BackupEntry&lt;/code> of the shoot allowing the &lt;code>etcd-backup-restore&lt;/code> to create and copy backups using the &lt;code>local&lt;/code> provider functionality. The backups are stored on the host file system. This is achieved by mounting that directory to the &lt;code>etcd-backup-restore&lt;/code> container.&lt;/p>
&lt;h4 id="extension-seed">Extension Seed&lt;/h4>
&lt;p>This controller reconciles &lt;code>Extensions&lt;/code> of type &lt;code>local-ext-seed&lt;/code>. It creates a single &lt;code>serviceaccount&lt;/code> named &lt;code>local-ext-seed&lt;/code> in the shoot&amp;rsquo;s namespace in the seed. The extension is reconciled before the &lt;code>kube-apiserver&lt;/code>. More on extension lifecycle strategies can be read in &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/#extension-lifecycle">Registering Extension Controllers&lt;/a>.&lt;/p>
&lt;h4 id="extension-shoot">Extension Shoot&lt;/h4>
&lt;p>This controller reconciles &lt;code>Extensions&lt;/code> of type &lt;code>local-ext-shoot&lt;/code>. It creates a single &lt;code>serviceaccount&lt;/code> named &lt;code>local-ext-shoot&lt;/code> in the &lt;code>kube-system&lt;/code> namespace of the shoot. The extension is reconciled after the &lt;code>kube-apiserver&lt;/code>. More on extension lifecycle strategies can be read &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/#extension-lifecycle">Registering Extension Controllers&lt;/a>.&lt;/p>
&lt;h4 id="extension-shoot-after-worker">Extension Shoot After Worker&lt;/h4>
&lt;p>This controller reconciles &lt;code>Extensions&lt;/code> of type &lt;code>local-ext-shoot-after-worker&lt;/code>. It creates a &lt;code>deployment&lt;/code> named &lt;code>local-ext-shoot-after-worker&lt;/code> in the &lt;code>kube-system&lt;/code> namespace of the shoot. The extension is reconciled after the workers and waits until the deployment is ready. More on extension lifecycle strategies can be read &lt;a href="https://gardener.cloud/docs/gardener/extensions/controllerregistration/#extension-lifecycle">Registering Extension Controllers&lt;/a>.&lt;/p>
&lt;h4 id="health-checks">Health Checks&lt;/h4>
&lt;p>The health check controller leverages the &lt;a href="https://gardener.cloud/docs/gardener/extensions/healthcheck-library/">health check library&lt;/a> in order to:&lt;/p>
&lt;ul>
&lt;li>check the health of the &lt;code>ManagedResource/extension-controlplane-shoot-webhooks&lt;/code> and populate the &lt;code>SystemComponentsHealthy&lt;/code> condition in the &lt;code>ControlPlane&lt;/code> resource.&lt;/li>
&lt;li>check the health of the &lt;code>ManagedResource/extension-networking-local&lt;/code> and populate the &lt;code>SystemComponentsHealthy&lt;/code> condition in the &lt;code>Network&lt;/code> resource.&lt;/li>
&lt;li>check the health of the &lt;code>ManagedResource/extension-worker-mcm-shoot&lt;/code> and populate the &lt;code>SystemComponentsHealthy&lt;/code> condition in the &lt;code>Worker&lt;/code> resource.&lt;/li>
&lt;li>check the health of the &lt;code>Deployment/machine-controller-manager&lt;/code> and populate the &lt;code>ControlPlaneHealthy&lt;/code> condition in the &lt;code>Worker&lt;/code> resource.&lt;/li>
&lt;li>check the health of the &lt;code>Node&lt;/code>s and populate the &lt;code>EveryNodeReady&lt;/code> condition in the &lt;code>Worker&lt;/code> resource.&lt;/li>
&lt;/ul>
&lt;h3 id="webhooks">Webhooks&lt;/h3>
&lt;h4 id="control-plane">Control Plane&lt;/h4>
&lt;p>This webhook reacts on the &lt;code>OperatingSystemConfig&lt;/code> containing the configuration of the kubelet and sets the &lt;code>failSwapOn&lt;/code> to &lt;code>false&lt;/code> (independent of what is configured in the &lt;code>Shoot&lt;/code> spec) (&lt;a href="https://github.com/kubernetes-sigs/kind/blob/b6bc112522651d98c81823df56b7afa511459a3b/site/content/docs/design/node-image.md#design">ref&lt;/a>).&lt;/p>
&lt;h4 id="dns-config">DNS Config&lt;/h4>
&lt;p>This webhook reacts on events for the &lt;code>dependency-watchdog-probe&lt;/code> &lt;code>Deployment&lt;/code>, the &lt;code>blackbox-exporter&lt;/code> &lt;code>Deployment&lt;/code>, as well as on events for &lt;code>Pod&lt;/code>s created when the &lt;code>machine-controller-manager&lt;/code> reconciles &lt;code>Machine&lt;/code>s.
All these pods need to be able to resolve the DNS names for shoot clusters.
It sets the &lt;code>.spec.dnsPolicy=None&lt;/code> and &lt;code>.spec.dnsConfig.nameServers&lt;/code> to the cluster IP of the &lt;code>coredns&lt;/code> &lt;code>Service&lt;/code> created in the &lt;code>gardener-extension-provider-local-coredns&lt;/code> namespaces so that these pods can resolve the DNS records for shoot clusters (see the &lt;a href="https://gardener.cloud/docs/gardener/extensions/provider-local/#bootstrapping">Bootstrapping section&lt;/a> for more details).&lt;/p>
&lt;h4 id="machine-controller-manager">Machine Controller Manager&lt;/h4>
&lt;p>This webhook mutates the global &lt;code>ClusterRole&lt;/code> related to &lt;code>machine-controller-manager&lt;/code> and injects permissions for &lt;code>Service&lt;/code> resources.
The &lt;code>machine-controller-manager-provider-local&lt;/code> deploys &lt;code>Pod&lt;/code>s for each &lt;code>Machine&lt;/code> (while real infrastructure provider obviously deploy VMs, so no Kubernetes resources directly).
It also deploys a &lt;code>Service&lt;/code> for these machine pods, and in order to do so, the &lt;code>ClusterRole&lt;/code> must allow the needed permissions for &lt;code>Service&lt;/code> resources.&lt;/p>
&lt;h4 id="node">Node&lt;/h4>
&lt;p>This webhook reacts on updates to &lt;code>nodes/status&lt;/code> in both seed and shoot clusters and sets the &lt;code>.status.{allocatable,capacity}.cpu=&amp;quot;100&amp;quot;&lt;/code> and &lt;code>.status.{allocatable,capacity}.memory=&amp;quot;100Gi&amp;quot;&lt;/code> fields.&lt;/p>
&lt;p>Background: Typically, the &lt;code>.status.{capacity,allocatable}&lt;/code> values are determined by the resources configured for the Docker daemon (see for example the &lt;a href="https://docs.docker.com/desktop/mac/#resources">docker Quick Start Guide&lt;/a> for Mac).
Since many of the &lt;code>Pod&lt;/code>s deployed by Gardener have quite high &lt;code>.spec.resources.requests&lt;/code>, the &lt;code>Node&lt;/code>s easily get filled up and only a few &lt;code>Pod&lt;/code>s can be scheduled (even if they barely consume any of their reserved resources).
In order to improve the user experience, on startup/leader election the provider-local extension submits an empty patch which triggers the &amp;ldquo;node webhook&amp;rdquo; (see the below section) for the seed cluster.
The webhook will increase the capacity of the &lt;code>Node&lt;/code>s to allow all &lt;code>Pod&lt;/code>s to be scheduled.
For the shoot clusters, this empty patch trigger is not needed since the &lt;code>MutatingWebhookConfiguration&lt;/code> is reconciled by the &lt;code>ControlPlane&lt;/code> controller and exists before the &lt;code>Node&lt;/code> object gets registered.&lt;/p>
&lt;h4 id="shoot">Shoot&lt;/h4>
&lt;p>This webhook reacts on the &lt;code>ConfigMap&lt;/code> used by the &lt;code>kube-proxy&lt;/code> and sets the &lt;code>maxPerCore&lt;/code> field to &lt;code>0&lt;/code> since other values don&amp;rsquo;t work well in conjunction with the &lt;code>kindest/node&lt;/code> image which is used as base for the shoot worker machine pods (&lt;a href="https://github.com/kubernetes-sigs/kind/blob/fa7d86470f4c0e924fc4c2e767ec8491c45f4304/pkg/cluster/internal/kubeadm/config.go#L283-L285">ref&lt;/a>).&lt;/p>
&lt;h3 id="dns-configuration-for-multi-zonal-seeds">DNS Configuration for Multi-Zonal Seeds&lt;/h3>
&lt;p>In case a seed cluster has multiple availability zones as specified in &lt;code>.spec.provider.zones&lt;/code>, multiple istio ingress gateways are deployed, one per availability zone in addition to the default deployment. The result is that single-zone shoot control planes, i.e. shoot clusters with &lt;code>.spec.controlPlane.highAvailability&lt;/code> set or with &lt;code>.spec.controlPlane.highAvailability.failureTolerance.type&lt;/code> set to &lt;code>node&lt;/code>, may be exposed via any of the zone-specific istio ingress gateways. Previously, the endpoints were statically mapped via &lt;code>/etc/hosts&lt;/code>. Unfortunately, this is no longer possible due to the aforementioned dynamic in the endpoint selection.&lt;/p>
&lt;p>For multi-zonal seed clusters, there is an additional configuration following &lt;code>coredns&lt;/code>&amp;rsquo;s &lt;a href="https://github.com/coredns/coredns/tree/master/plugin/view">view plugin&lt;/a> mapping the external IP addresses of the zone-specific loadbalancers to the corresponding internal istio ingress gateway domain names. This configuration is only in place for requests from outside of the seed cluster. Those requests are currently being identified by the protocol. UDP requests are interpreted as originating from within the seed cluster while TCP requests are assumed to come from outside the cluster via the docker hostport mapping.&lt;/p>
&lt;p>The corresponding test sets the DNS configuration accordingly so that the name resolution during the test use &lt;code>coredns&lt;/code> in the cluster.&lt;/p>
&lt;h2 id="future-work">Future Work&lt;/h2>
&lt;p>Future work could mostly focus on resolving the above listed &lt;a href="https://gardener.cloud/docs/gardener/extensions/provider-local/#limitations">limitations&lt;/a>, i.e.:&lt;/p>
&lt;ul>
&lt;li>Implement a &lt;code>cloud-controller-manager&lt;/code> and deploy it via the &lt;a href="https://gardener.cloud/docs/gardener/extensions/provider-local/#controlplane">&lt;code>ControlPlane&lt;/code> controller&lt;/a>.&lt;/li>
&lt;li>Properly implement &lt;code>.spec.machineTypes&lt;/code> in the &lt;code>CloudProfile&lt;/code>s (i.e., configure &lt;code>.spec.resources&lt;/code> properly for the created shoot worker machine pods).&lt;/li>
&lt;/ul></description></item><item><title>Docs: Reconcile Trigger</title><link>https://gardener.cloud/docs/gardener/extensions/reconcile-trigger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/reconcile-trigger/</guid><description>
&lt;h1 id="reconcile-trigger">Reconcile Trigger&lt;/h1>
&lt;p>Gardener dictates the time of reconciliation for resources of the API group &lt;code>extensions.gardener.cloud&lt;/code>.
It does that by annotating the respected resource with &lt;code>gardener.cloud/operation=reconcile&lt;/code>.
Extension controllers shall react to this annotation and start reconciling the resource.
They have to remove this annotation as soon as they begin with their reconcile operation and maintain the &lt;code>status&lt;/code> of the extension resource accordingly.&lt;/p>
&lt;p>The reason for this behaviour is that it is possible to configure Gardener to reconcile only in the shoots&amp;rsquo; maintenance time windows.
In order to avoid that, extension controllers reconcile outside of the shoot&amp;rsquo;s maintenance time window we have introduced this contract.
This way extension controllers don&amp;rsquo;t need to care about when the shoot maintenance time window happens.
Gardener keeps control and decides when the shoot shall be reconciled/updated.&lt;/p>
&lt;p>Our &lt;a href="https://github.com/gardener/gardener/tree/master/extensions">extension controller library&lt;/a> provides all the required utilities to conveniently implement this behaviour.&lt;/p></description></item><item><title>Docs: Referenced Resources</title><link>https://gardener.cloud/docs/gardener/extensions/referenced-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/referenced-resources/</guid><description>
&lt;h1 id="referenced-resources">Referenced Resources&lt;/h1>
&lt;p>The Shoot resource can include a list of resources (usually secrets) that can be referenced by name in the extension &lt;code>providerConfig&lt;/code> and other Shoot sections, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: crazy-botany
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: foobar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: foobar.extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: FooBarConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foo: bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretRef: foobar-secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: foobar-secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: my-foobar-secret
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gardener expects to find these referenced resources in the project namespace (e.g., &lt;code>garden-dev&lt;/code>) and will copy them to the Shoot namespace in the Seed cluster when reconciling a Shoot, adding a prefix to their names to avoid naming collisions with Gardener&amp;rsquo;s own resources.&lt;/p>
&lt;p>Extension controllers can resolve the references to these resources by accessing the Shoot via the &lt;code>Cluster&lt;/code> resource. To properly read a referenced resources, extension controllers should use the utility function &lt;code>GetObjectByReference&lt;/code> from the &lt;code>extensions/pkg/controller&lt;/code> package, for example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref = &amp;amp;autoscalingv1.CrossVersionObjectReference{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> APIVersion: &lt;span style="color:#a31515">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Kind: &lt;span style="color:#a31515">&amp;#34;Secret&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name: &lt;span style="color:#a31515">&amp;#34;foo&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secret := &amp;amp;corev1.Secret{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">if&lt;/span> err := controller.GetObjectByReference(ctx, client, ref, &lt;span style="color:#a31515">&amp;#34;shoot--test--foo&amp;#34;&lt;/span>, secret); err != &lt;span style="color:#00f">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00f">return&lt;/span> err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000">// Use secret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000">&lt;/span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Resources</title><link>https://gardener.cloud/docs/gardener/extensions/resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/resources/</guid><description/></item><item><title>Docs: Shoot Health Status Conditions</title><link>https://gardener.cloud/docs/gardener/extensions/shoot-health-status-conditions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/shoot-health-status-conditions/</guid><description>
&lt;h1 id="contributing-to-shoot-health-status-conditions">Contributing to Shoot Health Status Conditions&lt;/h1>
&lt;p>Gardener checks regularly (every minute by default) the health status of all shoot clusters.
It categorizes its checks into five different types:&lt;/p>
&lt;ul>
&lt;li>&lt;code>APIServerAvailable&lt;/code>: This type indicates whether the shoot&amp;rsquo;s kube-apiserver is available or not.&lt;/li>
&lt;li>&lt;code>ControlPlaneHealthy&lt;/code>: This type indicates whether the core components of the Shoot controlplane (ETCD, KAPI, KCM..) are healthy.&lt;/li>
&lt;li>&lt;code>EveryNodeReady&lt;/code>: This type indicates whether all &lt;code>Node&lt;/code>s and all &lt;code>Machine&lt;/code> objects report healthiness.&lt;/li>
&lt;li>&lt;code>ObservabilityComponentsHealthy&lt;/code>: This type indicates whether the observability components of the Shoot control plane (Prometheus, Vali, Plutono..) are healthy.&lt;/li>
&lt;li>&lt;code>SystemComponentsHealthy&lt;/code>: This type indicates whether all system components deployed to the &lt;code>kube-system&lt;/code> namespace in the shoot do exist and are running fine.&lt;/li>
&lt;/ul>
&lt;p>In case of workerless &lt;code>Shoot&lt;/code>, &lt;code>EveryNodeReady&lt;/code> condition is not present in the &lt;code>Shoot&lt;/code>&amp;rsquo;s conditions since there are no nodes in the cluster.&lt;/p>
&lt;p>Every &lt;code>Shoot&lt;/code> resource has a &lt;code>status.conditions[]&lt;/code> list that contains the mentioned types, together with a &lt;code>status&lt;/code> (&lt;code>True&lt;/code>/&lt;code>False&lt;/code>) and a descriptive message/explanation of the &lt;code>status&lt;/code>.&lt;/p>
&lt;p>Most extension controllers are deploying components and resources as part of their reconciliation flows into the seed or shoot cluster.
A prominent example for this is the &lt;code>ControlPlane&lt;/code> controller that usually deploys a cloud-controller-manager or CSI controllers as part of the shoot control plane.
Now that the extensions deploy resources into the cluster, especially resources that are essential for the functionality of the cluster, they might want to contribute to Gardener&amp;rsquo;s checks mentioned above.&lt;/p>
&lt;h2 id="what-can-extensions-do-to-contribute-to-gardeners-health-checks">What can extensions do to contribute to Gardener&amp;rsquo;s health checks?&lt;/h2>
&lt;p>Every extension resource in Gardener&amp;rsquo;s &lt;code>extensions.gardener.cloud/v1alpha1&lt;/code> API group also has a &lt;code>status.conditions[]&lt;/code> list (like the &lt;code>Shoot&lt;/code>).
Extension controllers can write conditions to the resource they are acting on and use a type that also exists in the shoot&amp;rsquo;s conditions.
One exception is that &lt;code>APIServerAvailable&lt;/code> can&amp;rsquo;t be used, as Gardener clearly can identify the status of this condition and it doesn&amp;rsquo;t make sense for extensions to try to contribute/modify it.&lt;/p>
&lt;p>As an example for the &lt;code>ControlPlane&lt;/code> controller, let&amp;rsquo;s take a look at the following resource:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: ControlPlane
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: control-plane
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: shoot--foo--bar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: ControlPlaneHealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: DeploymentUnhealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: &amp;#39;Deployment cloud-controller-manager is unhealthy: condition &amp;#34;Available&amp;#34; has
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> does not have minimum availability.&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2014-05-25T12:44:27Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: ConfigComputedSuccessfully
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: ConfigCreated
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: The cloud-provider-config has been successfully computed.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2014-05-25T12:43:27Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The extension controller has declared in its extension resource that one of the deployments it is responsible for is unhealthy.
Also, it has written a second condition using a type that is unknown by Gardener.&lt;/p>
&lt;p>Gardener will pick the list of conditions and recognize that there is one with a type &lt;code>ControlPlaneHealthy&lt;/code>.
It will merge it with its own &lt;code>ControlPlaneHealthy&lt;/code> condition and report it back to the &lt;code>Shoot&lt;/code>&amp;rsquo;s status:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shoot.gardener.cloud/status: unhealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: some-shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden-core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: APIServerAvailable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;True&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: HealthzRequestSucceeded
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: API server /healthz endpoint responded with success status code. [response_time:31ms]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2014-05-23T08:26:52Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;2014-05-25T12:45:13Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: ControlPlaneHealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: ControlPlaneUnhealthyReport
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: &amp;#39;Deployment cloud-controller-manager is unhealthy: condition &amp;#34;Available&amp;#34; has
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> does not have minimum availability.&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2014-05-25T12:45:13Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastTransitionTime: &lt;span style="color:#a31515">&amp;#34;2014-05-25T12:45:13Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hence, the only duty extensions have is to maintain the health status of their components in the extension resource they are managing.
This can be accomplished using the &lt;a href="https://gardener.cloud/docs/gardener/extensions/healthcheck-library/">health check library for extensions&lt;/a>.&lt;/p>
&lt;h2 id="error-codes">Error Codes&lt;/h2>
&lt;p>The Gardener API includes some well-defined error codes, e.g., &lt;code>ERR_INFRA_UNAUTHORIZED&lt;/code>, &lt;code>ERR_INFRA_DEPENDENCIES&lt;/code>, etc.
Extension may set these error codes in the &lt;code>.status.conditions[].codes[]&lt;/code> list in case it makes sense.
Gardener will pick them up and will similarly merge them into the &lt;code>.status.conditions[].codes[]&lt;/code> list in the &lt;code>Shoot&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>status:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conditions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: ControlPlaneHealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status: &lt;span style="color:#a31515">&amp;#34;False&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason: DeploymentUnhealthy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message: &amp;#39;Deployment cloud-controller-manager is unhealthy: condition &amp;#34;Available&amp;#34; has
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> does not have minimum availability.&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lastUpdateTime: &lt;span style="color:#a31515">&amp;#34;2014-05-25T12:44:27Z&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> codes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - ERR_INFRA_UNAUTHORIZED
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Shoot Maintenance</title><link>https://gardener.cloud/docs/gardener/extensions/shoot-maintenance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/shoot-maintenance/</guid><description>
&lt;h1 id="shoot-maintenance">Shoot Maintenance&lt;/h1>
&lt;p>There is a general &lt;a href="https://gardener.cloud/docs/gardener/shoot/shoot_maintenance/">document about shoot maintenance&lt;/a> that you might want to read.
Here, we describe how you can influence certain operations that happen during a shoot maintenance.&lt;/p>
&lt;h2 id="restart-control-plane-controllers">Restart Control Plane Controllers&lt;/h2>
&lt;p>As outlined in the above linked document, Gardener offers to restart certain control plane controllers running in the seed during a shoot maintenance.&lt;/p>
&lt;p>Extension controllers can extend the amount of pods being affected by these restarts.
If your Gardener extension manages pods of a shoot&amp;rsquo;s control plane (shoot namespace in seed) and it could potentially profit from a regular restart, please consider labeling it with &lt;code>maintenance.gardener.cloud/restart=true&lt;/code>.&lt;/p></description></item><item><title>Docs: Shoot Webhooks</title><link>https://gardener.cloud/docs/gardener/extensions/shoot-webhooks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/gardener/extensions/shoot-webhooks/</guid><description>
&lt;h1 id="shoot-resource-customization-webhooks">Shoot Resource Customization Webhooks&lt;/h1>
&lt;p>Gardener deploys several components/resources into the shoot cluster.
Some of these resources are essential (like the &lt;code>kube-proxy&lt;/code>), others are optional addons (like the &lt;code>kubernetes-dashboard&lt;/code> or the &lt;code>nginx-ingress-controller&lt;/code>).
In either case, some provider extensions might need to mutate these resources and inject provider-specific bits into it.&lt;/p>
&lt;h2 id="whats-the-approach-to-implement-such-mutations">What&amp;rsquo;s the approach to implement such mutations?&lt;/h2>
&lt;p>Similar to how &lt;a href="https://gardener.cloud/docs/gardener/extensions/controlplane-webhooks/">control plane components in the seed&lt;/a> are modified, we are using &lt;code>MutatingWebhookConfiguration&lt;/code>s to achieve the same for resources in the shoot.
Both the provider extension and the kube-apiserver of the shoot cluster are running in the same seed.
Consequently, the kube-apiserver can talk cluster-internally to the provider extension webhook, which makes such operations even faster.&lt;/p>
&lt;h2 id="how-is-the-mutatingwebhookconfiguration-object-created-in-the-shoot">How is the &lt;code>MutatingWebhookConfiguration&lt;/code> object created in the shoot?&lt;/h2>
&lt;p>The preferred approach is to use a &lt;code>ManagedResource&lt;/code> (see also &lt;a href="https://gardener.cloud/docs/gardener/extensions/managedresources/">Deploy Resources to the Shoot Cluster&lt;/a>) in the seed cluster.
This way the &lt;code>gardener-resource-manager&lt;/code> ensures that end-users cannot delete/modify the webhook configuration.
The provider extension doesn&amp;rsquo;t need to care about the same.&lt;/p>
&lt;h2 id="what-else-is-needed">What else is needed?&lt;/h2>
&lt;p>The shoot&amp;rsquo;s kube-apiserver must be allowed to talk to the provider extension.
To achieve this, you need to make sure that the relevant &lt;code>NetworkPolicy&lt;/code> get created for allowing the network traffic.
Please refer to &lt;a href="https://gardener.cloud/docs/gardener/network_policies/#webhook-servers">this guide&lt;/a> for more information.&lt;/p></description></item></channel></rss>