<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.95.0"><link rel=canonical type=text/html href=https://gardener.cloud/docs/getting-started/><link rel=alternate type=application/rss+xml href=https://gardener.cloud/docs/getting-started/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Getting Started | Gardener</title><meta name=description content="Gardener onboarding materials"><meta property="og:title" content="Getting Started"><meta property="og:description" content="Gardener onboarding materials"><meta property="og:type" content="website"><meta property="og:url" content="https://gardener.cloud/docs/getting-started/"><meta property="og:image" content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta itemprop=name content="Getting Started"><meta itemprop=description content="Gardener onboarding materials"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta name=twitter:title content="Getting Started"><meta name=twitter:description content="Gardener onboarding materials"><link rel=preload href=/scss/main.min.52b703b92d167c14e82f904cd88f9dbe92798d607a8949235304e48c7cd0a116.css as=style><link href=/scss/main.min.52b703b92d167c14e82f904cd88f9dbe92798d607a8949235304e48c7cd0a116.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg width="90" height="90" viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>logo</title><desc>Created with Sketch.</desc><defs><path d="M41.8864954.994901575c.996545099999999-.479910833 2.6164002-.477918931 3.6088091.0L76.8159138 16.0781121C77.8124589 16.5580229 78.8208647 17.8257185 79.0659694 18.8995926l7.7355517 33.8916663C87.0476474 53.8696088 86.6852538 55.4484075 85.9984855 56.3095876L64.3239514 83.4885938C63.6343208 84.3533632 62.1740175 85.0543973 61.0725268 85.0543973H26.3092731c-1.1060816.0-2.5646564-.704623400000003-3.2514246-1.5658035L1.38331434 56.3095876C.693683723 55.4448182.335174016 53.865133.580278769 52.7912589L8.31583044 18.8995926C8.56195675 17.8212428 9.57347722 16.556031 10.5658861 16.0781121L41.8864954.994901575z" id="path-1"/><linearGradient x1="12.7542673%" y1="-18.6617048%" x2="88.2666158%" y2="84.6075483%" id="linearGradient-3"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="50%" y1="4.93673768%" x2="148.756007%" y2="175.514523%" id="linearGradient-4"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="19.1574381%" y1="-9.04800713%" x2="82.2203149%" y2="77.9084293%" id="linearGradient-5"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="57.4403751%" y1="26.3148481%" x2="137.966711%" y2="158.080556%" id="linearGradient-6"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><g id="Rectangle-2" transform="translate(1.000000, 0.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Mask" fill="#009f76" xlink:href="#path-1"/><polygon fill="#000" opacity=".289628623" mask="url(#mask-2)" points="-17.6484375 54.5224609 30.8242188 25.0791016 63.4726562 58.5 24.7324219 92.6689453"/></g><path d="M56.8508631 39.260019C56.4193519 40.443987 55.6088085 41.581593 54.6736295 42.1938694l-8.0738997 5.2861089c-1.3854671.907087099999998-3.6247515.9116711-5.0172201.0L33.50861 42.1938694C32.123143 41.2867823 31 39.206345 31 37.545932V26.4150304c0-.725313.2131118-1.5301454.569268099999999-2.2825772L56.8508631 39.260019z" id="Combined-Shape" fill="url(#linearGradient-3)" transform="translate(43.925432, 36.147233) scale(-1, 1) translate(-43.925432, -36.147233)"/><path d="M56.0774672 25.1412464C56.4306829 25.8903325 56.6425556 26.6907345 56.6425556 27.4119019V38.5428034c0 1.6598979-1.1161415 3.73626640000001-2.50861 4.6479374l-8.0738997 5.286109c-1.3854671.907087000000004-3.6247516.911671000000005-5.0172201.0L32.9689261 43.1907408C32.2918101 42.7474223 31.6773514 42.0238435 31.2260376 41.206007L56.0774672 25.1412464z" id="Combined-Shape" fill="url(#linearGradient-4)" transform="translate(43.821278, 37.246598) scale(-1, 1) translate(-43.821278, -37.246598)"/><path d="M65.0702134 57.1846889C64.5985426 58.2007851 63.8367404 59.1236871 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.1597438 58.7930183 24 56.7816693 24 55.1323495V37.1145303C24 36.3487436 24.249712 35.5060005 24.6599102 34.7400631L65.0702134 57.1846889z" id="Combined-Shape" fill="url(#linearGradient-5)"/><path d="M65.0189476 34.954538C65.3636909 35.6617313 65.5692194 36.42021 65.5692194 37.1145303V55.1323495C65.5692194 56.7842831 64.4072119 58.7943252 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.9237304 59.2341061 25.3159155 58.5918431 24.8568495 57.8487596L65.0189476 34.954538z" id="Combined-Shape" fill="url(#linearGradient-6)"/></g></g></svg></span><span class=text-capitalize>Gardener</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/adopter><span>Adopters</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs><span>Documentation</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/blog><span>Blogs</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community><span>Community</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this siteâ€¦" aria-label="Search this siteâ€¦" autocomplete=off data-offline-search-index-json-src=/offline-search-index.57b06af89c2098b7ff71be0cbb194f14.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/getting-started/>Return to the regular view of this page</a>.</p></div><h1 class=title>Getting Started</h1><div class=lead>Gardener onboarding materials</div><div class=content><p>Welcome to the Gardener Getting Started section! Here you will be able to get accustomed to the way Gardener functions and learn how its components work together in order to seamlessly run Kubernetes clusters on various hyperscalers.</p><p>The following topics aim to be useful to both complete beginners and those already somewhat familiar with Gardener. While the content is structured, with <a href=/docs/getting-started/introduction/>Introduction</a> serving as the starting point, if you&rsquo;re feeling confident in your knowledge, feel free to skip to a topic you&rsquo;re more interested in.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-6db90024ece8554ff84305ba1ad8cd1a>1 - Introduction to Gardener</h1><h2 id=problem-space>Problem Space</h2><p>Let&rsquo;s discuss the problem space first. Why does anyone need something like Gardener?</p><h3 id=running-software>Running Software</h3><p>The starting point is this rather simple question: Why would you want to run some software?</p><p>Typically, software is run with a purpose and not just for the sake of running it. Whether it is a digital ledger, a company&rsquo;s inventory or a blog - software provides a service to its user.</p><p>Which brings us to the way this software is being consumed. Traditionally, software has been shipped on physical / digital media to the customer or end user. There, someone had to install, configure, and operate it. In recent times, the pattern has shifted. More and more solutions are operated by the vendor or a hosting partner and sold as a service ready to be used.</p><p>But still, someone needs to install, configure, and maintain it - regardless of where it is installed. And of course, it will run forever once started and is generally resilient to any kind of failures.</p><p>For smaller installations things like maintenance, scaling, debugging or configuration can be done in a semi-automatic way. It&rsquo;s probably no fun and most importantly, only a limited amount of instances can be taken care of - similar to how one would take care of a pet.</p><p>But when hosting services at scale, there is no way someone can do all this manually at acceptable costs. So we need some vehicle to easily spin up new instances, do lifecycle operations, get some basic failure resilience, and more. How can we achieve that?</p><h2 id=solution-space-1---kubernetes>Solution Space 1 - Kubernetes</h2><p>Let&rsquo;s start solving some of the problems described earlier with Container technology and Kubernetes.</p><h3 id=containers>Containers</h3><p>Container technology is at the core of the solution space. A container forms a vehicle that is shippable, can easily run in any supported environment and generally adds a powerful abstraction layer to the infrastructure.</p><p>However, plain containers do not help with resilience or scaling. Therefore, we need another system for orchestration.</p><h3 id=orchestration>Orchestration</h3><p>&ldquo;Classical&rdquo; orchestration that just follows the &ldquo;notes&rdquo; and moves from <code>state A</code> to <code>state B</code> doesn&rsquo;t solve all of our problems. We need something else.</p><p>Kubernetes operates on the principle of &ldquo;desired state&rdquo;. With it, you write a construction plan, then have controllers cycle through &ldquo;observe -> analyze -> act&rdquo; and transition the actual to the desired state. Those reconciliations ensure that whatever breaks there is a path back to a healthy state.</p><h3 id=summary>Summary</h3><p>Containers (famously brought to the mainstream as &ldquo;Docker&rdquo;) and Kubernetes are the ingredients of a fundamental shift in IT. Similar to how the Operating System layer enabled the decoupling of software and hardware, container-related technologies provide an abstract interface to any kind of infrastructure platform for the next-generation of applications.</p><h2 id=solution-space-2---gardener>Solution Space 2 - Gardener</h2><p><img src=/__resources/operating-apps_5e49bc.png alt=operating-apps></p><p>So, Kubernetes solves a lot of problems. But how do you get a Kubernetes cluster?</p><p>Either:</p><ul><li>Buy a cluster as a service from an external vendor</li><li>Run a Gardener instance and host yourself a cluster with its help</li></ul><p>Essentially, it was a &ldquo;make or buy&rdquo; decision that led to the founding of Gardener.</p><h3 id=the-reason-why-we-choose-to-make-it>The Reason Why We Choose to &ldquo;Make It&rdquo;</h3><p>Gardener allows to run Kubernetes clusters on various hyperscalers. It offers the same set of basic configuration options independent of the chosen infrastructure. This kind of harmonization supports any multi-vendor strategy while reducing adoption costs for the individual teams. Just imagine having to deal with multiple vendors all offering vastly different Kubernetes clusters.</p><p>Of course, there are plenty more reasons - from acquiring operational knowledge to having influence on the developed features - that made the pendulum swing towards &ldquo;make it&rdquo;.</p><h2 id=what-exactly-is-gardener>What exactly is Gardener?</h2><p><img src=/__resources/universal-kubernetes_194ebc.png alt=universal-kubernetes></p><p>Gardener is a system to manage Kubernetes clusters. It is driven by the same &ldquo;desired state&rdquo; pattern as Kubernetes itself. In fact, it is using Kubernetes to run Kubernetes.</p><p>A user may &ldquo;desire&rdquo; clusters with specific configuration on infrastructures such as GCP, AWS, Azure, Alicloud, Openstack, vsphere, &mldr; and Gardener will make sure to create such a cluster and keep it running.</p><p>If you take this rather simplistic principle of reconciliation and add the feature-richness of Gardener to it, you end up with universal Kubernetes at scale.</p><p>Whether you need fleet management at minimal TCO or to look for a highly customizable control plane - we have it all.</p><p>On top of that, Gardener-managed Kubernetes clusters fulfill the conformance standard set out by the CNCF and we submit our test results for certification.</p><p>Have a look at the <a href="https://cncf.landscape2.io/?item=platform--certified-kubernetes--installer--gardener">CNCF map</a> for more information or dive into the <a href=https://testgrid.k8s.io/conformance-gardener>testgrid</a> directly.</p><p>Gardener itself is open-source. Under the umbrella of <a href=https://github.com/gardener>github.com/gardener</a> we develop the core functionalities as well as the extensions and you are welcome to contribute (by opening issues, feature requests or submitting code).</p><p>Last time we counted, there were already 131 projects. That&rsquo;s actually more projects than members of the organization.</p><p>As of today, Gardener is mainly developed by SAP employees and SAP is an &ldquo;adopter&rdquo; as well, among StackIT, Telekom, Finanz Informatik Technologie Services GmbH and others. For a full list of adopters, see the <a href=/adopter/>Adopters page</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ffc590ea6468143712feda0ba56c1372>2 - Architecture</h1><h2 id=kubeception>Kubeception</h2><p>Kubeception - Kubernetes in Kubernetes in Kubernetes</p><p><img src=/__resources/kubeception_169129.gif alt=kubeception></p><p>In the classic setup, there is a dedicated host / VM to host the master components / control plane of a Kubernetes cluster. However, these are just normal programs that can easily be put into containers. Once in containers, Kubernetes Deployments and StatefulSets (for the etcd) can be made to watch over them. And by putting all that into a separate, dedicated Kubernetes cluster you get Kubernetes on Kubernetes, aka Kubeception (named after the famous movie Inception with Leonardo DiCaprio).</p><p>But what are the advantages of running Kubernetes on Kubernetes? For one, it makes use of resources more reasonably. Instead of providing a dedicated computer or virtual machine for the control plane of a Kubernetes cluster - which will probably never be the right size but either too small or too big - you can dynamically scale the individual control plane components based on demand and maximize resource usage by combining the control planes of multiple Kubernetes clusters.</p><p>In addition to that, it helps introducing a first layer of high availability. What happens if the API server suddenly stops responding to requests? In a traditional setup, someone would have to find out and manually restart the API server. In the Kubeception model, the API server is a Kubernetes Deployment and of course, it has sophisticated liveness- and readiness-probes. Should the API server fail, its liveness-probe will fail too and the pod in question simply gets restarted automatically - sometimes even before anybody would have noticed about the API server being unresponsive.</p><p>In Gardener&rsquo;s terminology, the cluster hosting the control plane components is called a seed cluster. The cluster that end users actually use (and whose control plane is hosted in the seed) is called a shoot cluster.</p><p>The worker nodes of a shoot cluster are plain, simple virtual machines in a hyperscaler (EC2 instances in AWS, GCE instances in GCP or ECS instances in Alibaba Cloud). They run an operating system, a container runtime (e.g., containerd), and the kubelet that gets configured during node bootstrap to connect to the shoot&rsquo;s API server. The API server in turn runs in the seed cluster and is exposed through an ingress. This connection happens over public internet and is - of course - TLS encrypted.</p><p>In other terms: you use Kubernetes to run Kubernetes.</p><h2 id=cluster-hierarchy-in-gardener>Cluster Hierarchy in Gardener</h2><p><img src=/__resources/cluster-hierarchy_5a87a9.png alt=cluster-hierarchy></p><p>Gardener uses many Kubernetes clusters to eventually provide you with your very own shoot cluster.</p><p>At the heart of Gardener&rsquo;s cluster hierarchy is the garden cluster. Since Gardener is 100% Kubernetes native, a Kubernetes cluster is needed to store all Gardener related resources. The garden cluster is actually nodeless - it only consists of a control plane, an API server (actually two), an etcd, and a bunch of controllers. The garden cluster is the central brain of a Gardener landscape and the one you connect to in order to create, modify or delete shoot clusters - either with kubectl and a dedicated kubeconfig or through the Gardener dashboard.</p><p>The seed clusters are next in the hierarchy - they are the clusters which will host the &ldquo;kubeceptioned&rdquo; control planes of the shoot clusters. For every hyperscaler supported in a Gardener landscape, there would be at least one seed cluster. However, to reduce latencies as well as for scaling, Gardener landscapes have several different seeds in different regions across the globe to keep the distance between control planes and actual worker nodes small.</p><p>Finally, there are the shoot clusters - what Gardener is all about. Shoot clusters are the clusters which you create through Gardener and which your workload gets deployed to.</p><h2 id=gardener-components-overview>Gardener Components Overview</h2><p><img src=/__resources/components_1de922.png alt=components></p><p>From a very high level point of view, the important components of Gardener are:</p><h3 id=the-gardener-api-endpoint>The Gardener API Endpoint</h3><p>You can connect to the Gardener API Endpoint (i.e., the API server in the garden cluster) either through the dashboard or with kubectl, given that you have a proper kubeconfig for it.</p><h3 id=the-seeds-running-the-shoot-cluster-control-planes>The Seeds Running the Shoot Cluster Control Planes</h3><p>Inside each seed is one of the most important controllers in Gardener - the gardenlet. It spawns many other controllers, which will eventually create all resources for a shoot cluster, including all resources on the cloud providers such as virtual networks, security groups, and virtual machines.</p><h2 id=gardeners-api-endpoint>Gardener&rsquo;s API Endpoint</h2><p>Kubernetes&rsquo; API can be extended - either by CRDs or by API aggregation.</p><p><img src=/__resources/api-endpoint-1_539e93.png alt=api-endpoint-1></p><p>API aggregation involves setting up a so called extension-API-server and registering it with the main Kubernetes API server. The extension API server will then serve resources of custom-defined API groups on its own. While the main Kubernetes API server is still used to handle RBAC, authorization, namespacing, quotas, limits, etc., all custom resources will be delegated to the extension-API-server. This is done through an APIService resource in the main API server - it specifies that, e.g., the API group <code>core.gardener.cloud</code> is served by a dedicated extension-API-server and all requests concerning this API group should be forwarded the specified IP address or Kubernetes service name. Extension API servers can persist their resources in their very own etcd but they do not have to - instead, they can use the main API servers etcd as well.</p><p><img src=/__resources/api-endpoint-2_93499e.png alt=api-endpoint-2></p><p>Gardener uses its very own extension API server for its resources like Shoot, Seed, CloudProfile, SecretBinding, etc&mldr; However, Gardener does not set up a dedicated etcd for its own extension API server - instead, it reuses the existing etcd of the main Kubernetes API server. This is absolutely possible since the resources of Gardener&rsquo;s API are part of the API group <code>gardener.cloud</code> and thus will not interfere with any resources of the main Kubernetes API in etcd.</p><p>In case you are interested, you can read more on:</p><ul><li><a href=https://kubernetes.io/docs/tasks/extend-kubernetes/setup-extension-api-server/>API Extension</a></li><li><a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation>API Aggregation</a></li><li><a href=https://kubernetes.io/docs/tasks/extend-kubernetes/configure-aggregation-layer/#register-apiservice-objects>APIService Resource</a></li></ul><h2 id=gardener-api-resources>Gardener API Resources</h2><p><img src=/__resources/api-resources_698838.png alt=api-resources></p><p>Since Gardener&rsquo;s API endpoint is a regular Kubernetes cluster, it would theoretically serve all resources from the Kubernetes core API, including Pods, Deployments, etc. However, Gardener implements RBAC rules and disables certain controllers that make these resources inaccessible. Objects like Secrets, Namespaces, and ResourceQuotas are still available, though, as they play a vital role in Gardener.</p><p>In addition, through Gardener&rsquo;s extension API server, the API endpoint also serves Gardener&rsquo;s custom resources like Projects, Shoots, CloudProfiles, Seeds, SecretBindings (those are relevant for users), ControllerRegistrations, ControllerDeployments, BackupBuckets, BackupEntries (those are relevant to an operator), etc.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1e2b5968c0bcaaf882941954f78c237f>3 - Gardener Projects</h1><h2 id=overview>Overview</h2><p><img src=/__resources/overview_b8990e.png alt=overview></p><p>Gardener is all about Kubernetes clusters, which we call shoots. However, Gardener also does user management, delicate permission management and offers technical accounts to integrate its services into other infrastructures. It allows you to create several quotas and it needs credentials to connect to cloud providers. All of these are arranged in multiple fully contained projects, each of which belongs to a dedicated user and / or group.</p><h2 id=projects-on-yaml-level>Projects on YAML Level</h2><p>Projects are a Kubernetes resource which can be expressed by YAML. The resource specification can be found in the <a href=https://github.com/gardener/gardener/blob/master/docs/api-reference/core.md/#core.gardener.cloud/v1beta1.Project>API reference documentation</a>.</p><p>A project&rsquo;s specification defines a name, a description (which is a free-text field), a purpose (again, a free-text field), an owner, and members. In Gardener, user management is done on a project level. Therefore, projects can have different members with certain roles.</p><p>In Gardener, a user can have one of five different roles: <code>owner</code>, <code>admin</code>, <code>viewer</code>, <code>UAM</code>, and <code>service account manager</code>. A member with the <code>viewer</code> role can see and list all clusters but cannot create, delete or modify them. For that, a member would need the <code>admin</code> role. Another important role would be the <code>uam</code> role - members with that role are allowed to manage members and technical users for a project. The <code>owner</code> of a project is allowed to do all of that, regardless of what other roles might be assigned to him.</p><p>Projects are getting reconciled by Gardener&rsquo;s project-controller, a component of Gardener&rsquo;s controller manager. The status of the last reconcilation, along with any potential failures, will be recorded in the project&rsquo;s <code>status</code> field.</p><p>For more information, see <a href=/docs/gardener/projects/>Projects</a>.</p><p>In case you are interested, you can also view the source code for:</p><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/core/types_project.go>The structure of a project API object</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/controllermanager/controller/project/project/reconciler.go>Reconciling a project</a></li></ul><h2 id=gardener-projects-and-kubernetes-namespaces>Gardener Projects and Kubernetes Namespaces</h2><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>Each Gardener project corresponds to a Kubernetes namespace and all project specific resources are placed into it.</div><p>Even though projects are a dedicated Kubernetes resource, every project also corresponds to a dedicated namespace in the garden cluster. All project resources - including shoots - are placed into this namespace.</p><p>You can ask Gardener to use a specific namespace name in the project manifest but usually, this field should be left empty. The namespace then gets created automatically by Gardener&rsquo;s project-controller, with its name getting generated from the project&rsquo;s name, prefixed by &ldquo;garden-&rdquo;.</p><p>ResourceQuotas - if any - will be enforced on the project namespace.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Quotas</h4>Since all Gardener resources are custom Kubernetes resources, the usual and well established concept of <code>resourceQuotas</code> in Kubernetes can also be applied to Gardener resources. With a <code>resourceQuota</code> that sets a hard limit on, e.g., <code>count/shoots.core.gardener.cloud</code>, you can restrict the number of shoot clusters that can be created in a project.</div><h2 id=infrastructure-secrets>Infrastructure Secrets</h2><p>For Gardener to create all relevant infrastructure that a shoot cluster needs inside a cloud provider, it needs to know how to authenticate to the cloud provider&rsquo;s API. This is done through regular secrets.</p><p><img src=/__resources/secret_e359cd.png alt=secret></p><p>Through the Gardener dashboard, secrets can be created for each supported cloud provider (using the dashboard is the preferred way, as it provides interactive help on what information needs to be placed into the secret and how the corresponding user account on the cloud provider should be configured). All of that is stored in a standard, opaque Kubernetes secret.</p><p>Inside of a shoot manifest, a reference to that secret is given so that Gardener knows which secret to use for a given shoot. Consequently, different shoots, even though they are in the same project, can be created on multiple different cloud provider accounts. However, instead of referring to the secret directly, Gardener introduces another layer of indirection called a SecretBinding.</p><p>In the shoot manifest, we refer to a SecretBinding and the SecretBinding in turn refers to the actual secret.</p><h2 id=secretbindings>SecretBindings</h2><p><img src=/__resources/secretbindings_5131d3.png alt=secretbindings></p><p>With SecretBindings, it is possible to reference the same infrastructure secret in different projects across namespaces. This has the following advantages:â€‹</p><ul><li>Infrastructure secrets can be kept in one project (and thus namespace) with limited access. Through SecretsBindings, the secrets can be used in other projects (and thus namespaces) without being able to read their contents.â€‹</li><li>Infrastructure secrets can be kept at one central place (a dedicated project) and be used by many other projects. This way, if a credential rotation is required, they only need to be changed in the secrets at that central place and not in all projects that reference them.</li></ul><h2 id=service-accounts>Service Accounts</h2><p><img src=/__resources/service-account_ad42b7.png alt=service-account></p><p>Since Gardener is 100% Kubernetes, it can be easily used in a programmatic way - by just sending the resource manifest of a Gardener resource to its API server. To do so, a kubeconfig file and a (technical) user that the kubeconfig maps to are required.</p><p>Next to project members, a project can have several service accounts - simple Kubernetes service accounts that are created in a project&rsquo;s namespace. Consequently, every service account will also have its own, dedicated kubeconfig and they can be granted different roles through RoleBindings.</p><p>To integrate Gardener with other infrastructure or CI/CD platforms, one can create a service account, obtain its kubeconfig and then automatically send shoot manifests to the Gardener API server. With that, Kubernetes clusters can be created, modified or deleted on the fly whenever they are needed.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4ef3bb243a7ef74d92acdebc0126e0b4>4 - Gardener Shoots</h1><h2 id=overview>Overview</h2><p><img src=/__resources/k8s-cluster_4daab7.png alt=k8s-cluster></p><p>A Kubernetes cluster consists of a control plane and a data plane. The data plane runs the actual containers on worker nodes (which translate to physical or virtual machines). For the control and data plane to work together properly, lots of components need matching configuration.</p><p>Some configurations are standardized but some are also very specific to the needs of a cluster&rsquo;s user / workload. Ideally, you want a properly configured cluster with the possibility to fine-tune some settings.</p><h2 id=concept-of-a-shoot>Concept of a &ldquo;Shoot&rdquo;</h2><p>In Gardener, Kubernetes clusters (with their control plane and their data plane) are called shoot clusters or simply shoots.
For Gardener, a shoot is just another Kubernetes resource. Gardener components watch it and act upon changes (e.g., creation). It comes with reasonable default settings but also allows fine-tuned configuration. And on top of it, you get a status providing health information, information about ongoing operations, and so on.</p><p>Luckily there is a dashboard to get started.</p><h2 id=basic-configuration-options>Basic Configuration Options</h2><p><img src=/__resources/basic-configurations-1_073f6f.png alt=basic-configurations-1></p><p>Every cluster needs a name - after all, it is a Kubernetes resource and therefore unique within a namespace.</p><p>The Kubernetes version will be used as a starting point. Once a newer version is available, you can always update your existing clusters (but not downgrade, as this is not supported by Kubernetes in general).</p><p>The &ldquo;purpose&rdquo; affects some configuration (like automatic deployment of a monitoring stack or setting up certain alerting rules) and generally indicates the importance of a cluster.</p><p><img src=/__resources/basic-configurations-2_c00454.png alt=basic-configurations-2></p><p>Start by selecting the infrastructure you want to use. The choice will be mapped to a cloud profile that contains provider specific information like the available (actual) OS images, zones and regions or machine types.</p><p>Each data plane runs in an infrastructure account owned by the end user. By selecting the infrastructure secret containing the accounts credentials, you are granting Gardener access to the respective account to create / manage resources.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4><p>Changing the account after the creation of a cluster is not possible. The credentials can be updated with a new key or even user but have to stay within the same account.</p><p>Currently, there is no way to move a single cluster to a different account. You would rather have to re-create a cluster and migrate workloads by different means.</p></div><p>As part of the infrastructure you chose, the region for data plane has to be chosen as well. The Gardener scheduler will try to place the control plane on a seed cluster based on a minimal distance strategy. See <a href=/docs/gardener/concepts/scheduler/>Gardener Scheduler</a> for more details.</p><p><img src=/__resources/basic-configurations-3_184cb7.png alt=basic-configurations-3></p><p>Up next, the networking provider (CNI) for the cluster has to be selected. At the point of writing, it is possible to choose between Calico and Cilium. If not specified in the shoot&rsquo;s manifest, default CIDR ranges for nodes, services, and pods will be used.</p><p>In order to run any workloads in your cluster, you need nodes. The worker section lets you specify the most important configuration options. For beginners, the machine type is probably the most relevant field, together with the machine image (operating system).</p><p>The machine type is provider-specific and configured in the cloud profile. Check your respective cloud profile if you&rsquo;re missing a machine type. Maybe it is available in general but unavailable in your selected region.</p><p>The operating system your machines will run is the next thing to choose. Debian-based <a href=https://github.com/gardenlinux/gardenlinux>GardenLinux</a> is the best choice for most use cases.</p><p>Other specifications for the workers include the volume type and size. These settings affect the root disk of each node. Therefore we would always recommend to use an SSD-based type to avoid i/o issues.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Caveat</h4>Some machine types (e.g., bare-metal machine types on OpenStack) require you to omit the volume type and volume size settings.</div><p>The autoscaler parameter defines the initial elasticity / scalability of your cluster. The cluster-autoscaler will add more nodes up to the maximum defined here when your workload grows and remove nodes in case your workload shrinks. The minimum number of nodes should be equal to or higher than the number of zones. You can distribute the nodes of a worker pool among all zones available to your cluster. This is the first step in running HA workloads.</p><p><img src=/__resources/basic-configurations-4_5b9a86.png alt=basic-configurations-4></p><p>Once per day, all clusters reconcile. This means all controllers will check if there are any updates they have to apply (e.g., new image version for ETCD). The maintenance window defines when this daily operation will be triggered. It is important to understand that there is no opt-out for reconciliation.</p><p>It is also possible to confine updates to the shoot spec to be applied only during this time. This can come in handy when you want to bundle changes or prevent changes to be applied outside a well-known time window.</p><p>You can allow Gardener to automatically update your cluster&rsquo;s Kubernetes patch version and/or OS version (of the nodes). Take this decision consciously! Whenever a new Kubernetes patch version or OS version is set to <code>supported</code> in the respective cloud profile, auto update will upgrade your cluster during the next maintenance window. If you fail to (manually) upgrade the Kubernetes or OS version before they expire, force-upgrades will take place during the maintenance window.</p><h3 id=result>Result</h3><p>The result of your provided inputs and a set of conscious default values is a shoot resource that, once applied, will be acted upon by various Gardener components. The status section represents the intermediate steps / results of these operations. A typical shoot creation flow would look like this:</p><ol><li>Assign control plane to a seed.</li><li>Create infrastructure resources in the data plane account (e.g., VPC, gateways, &mldr;)</li><li>Deploy control plane incl. DNS records.</li><li>Create nodes (VMs) and bootstrap kubelets.</li><li>Deploy kube-system components to nodes.</li></ol><h2 id=how-to-access-a-shoot>How to Access a Shoot</h2><p><img src=/__resources/access-shoot-1_a6af12.png alt=access-shoot-1></p><p>Static credentials for shoots were discontinued in Gardener with Kubernetes v1.27. Short lived credentials need to be used instead. You can create/request tokens directly via Gardener or delegate authentication to an identity provider.</p><p>A short-lived admin kubeconfig can be requested by using kubectl. If this is something you do frequently, consider switching to <a href=https://github.com/gardener/gardenlogin>gardenlogin</a>, which helps you with it.</p><p><img src=/__resources/access-shoot-2_c89c9e.png alt=access-shoot-2></p><p>An alternative is to use an identity provider and issue OIDC tokens.</p><h2 id=what-can-you-configure>What can you configure?</h2><p>With the basic configuration options having been introduced, it is time to discuss more possibilities. Gardener offers a variety of options to tweak the control plane&rsquo;s behavior - like defining an event TTL (default 1h), adding an OIDC configuration or activating some feature gates. You could alter the scheduling profile and define an audit logging policy. In addition, the control plane can be configured to run in HA mode (applied on a node or zone level), but keep in mind that once you enable HA, you cannot go back.</p><p>In case you have specific requirements for the cluster internal DNS, Gardener offers a plugin mechanism for custom core DNS rules or optimization with node-local DNS. For more information, see <a href=/docs/gardener/custom-dns-config/>Custom DNS Configuration</a> and <a href=/docs/gardener/node-local-dns/>NodeLocalDNS Configuration</a>.</p><p>Another category of configuration options is dedicated to the nodes and the infrastructure they are running on. Every provider has their own perks and some of them are exposed. Check the detailed documentation of the relevant extension for your infrastructure provider.</p><p>You can fine-tune the cluster-autoscaler or help the kubelet to cope better with your workload.</p><h2 id=worker-pools>Worker Pools</h2><p>There are a couple of ways to configure a worker pool. One of them is to set everything in the Gardener dashboard. However, only a subset of options is presented there.</p><p><img src=/__resources/worker-pools-1_b5acc0.png alt=worker-pools-1></p><p>A slightly more complex way is to set the configuration through the yaml file itself.</p><p><img src=/__resources/worker-pools-2_5dce7d.png alt=worker-pools-2></p><p>This allows you to configure much more properties of a worker pool, like the timeout after which an unhealthy machine is getting replaced. For more options, see the <a href=/docs/gardener/api-reference/core/#worker>Worker</a> API reference.</p><h2 id=how-to-change-things>How to Change Things</h2><p>Since a shoot is just another Kubernetes resource, changes can be applied via kubectl. For convenience, the basic settings are configurable via the dashboard&rsquo;s UI. It also has a &ldquo;yaml&rdquo; tab where you can alter all of the shoot&rsquo;s specification in your browser. Once applied, the cluster will reconcile eventually and your changes become active (or cause an error).</p><p><img src=/__resources/change-things_7c7ba7.png alt=change-things></p><h2 id=immutability-in-a-shoot>Immutability in a Shoot</h2><p>While Gardener allows you to modify existing shoot clusters, it is important to remember that not all properties of a shoot can be changed after it is created.</p><p>For example, it is not possible to move a shoot to a different infrastructure account. This is mainly rooted in the fact that discs and network resources are bound to your account.</p><p>Another set of options that become immutable are most of the network aspects of a cluster. On an infrastructure level the VPC cannot be changed and on a cluster level things like the pod / service cidr ranges, together with the nodeCIDRmask, are set for the lifetime of the cluster.</p><p>Some other things can be changed, but not reverted. While it is possible to add more zones to a cluster on an infrastructure level (assuming that an appropriate CIDR range is available), removing zones is not supported. Similarly, upgrading Kubernetes versions is comparable to a one-way ticket. As of now, Kubernetes does not support downgrading. Lastly, the HA setting of the control plane is immutable once specified.</p><h2 id=crazy-botany>Crazy Botany</h2><p>Since remembering all these options can be quite challenging, here is very helpful resource - an <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml>example shoot</a> with all the latest options ðŸŽ‰</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1e2d351c2d91b786a4475d9009766f4d>5 - Control Plane Components</h1><h2 id=overview>Overview</h2><p>A cluster has a data plane and a control plane. The data plane is like a space station. It has certain components which keep everyone / everything alive and can operate autonomously to a certain extent. However, without mission control (and the occasional delivery of supplies) it cannot share information or receive new instructions.</p><p>So let&rsquo;s see what the mission control (control plane) of a Kubernetes cluster looks like.</p><h2 id=kubeception>Kubeception</h2><p><a href=/docs/getting-started/architecture/#kubeception>Kubeception - Kubernetes in Kubernetes in Kubernetes</a></p><p><img src=/__resources/kubeception_661793.png alt=kubeception></p><p>In the classic setup, there is a dedicated host / VM to host the master components / control plane of a Kubernetes cluster. However, these are just normal programs that can easily be put into containers. Once in containers, we can make Kubernetes Deployments and StatefulSets (for the etcd) watch over them. And now we put all that into a separate, dedicated Kubernetes cluster - et voilÃ , we have Kubernetes in Kubernetes, aka Kubeception (named after the famous movie Inception with Leonardo DiCaprio).</p><p>In Gardener&rsquo;s terminology, the cluster hosting the control plane components is called a seed cluster. The cluster that end users actually use (and whose control plane is hosted in the seed) is called a shoot cluster.</p><h2 id=control-plane-components-on-the-seed>Control Plane Components on the Seed</h2><p><img src=/__resources/control-plane-components-1_396730.png alt=control-plane-components-1></p><p>All control-plane components of a shoot cluster run in a dedicated namespace on the seed.</p><p><img src=/__resources/control-plane-components-2_d89d1c.png alt=control-plane-components-2></p><p>A control plane has lots of components:</p><ul><li>Everything needed to run vanilla Kubernetes</li><li>etcd main & events (split for performance reasons)</li><li>Kube-.*-manager</li><li>CSI driver</li></ul><p>Additionally, we deploy components needed to manage the cluster:</p><ul><li>Gardener Resource Manager (GRM)</li><li>Machine Controller Manager (MCM)</li><li>DNS Management</li><li>VPN</li></ul><p>There is also a set of components making our life easier (logging, monitoring) or adding additional features (cert manager).</p><h2 id=core-components>Core Components</h2><p><img src=/__resources/core-components-1_19b405.png alt=core-components-1></p><p>Let&rsquo;s take a close look at the API server as well as etcd.</p><p>Secrets are encrypted at rest. When asking etcd for the data, the reply is still encrypted. Decryption is done by the API server which knows the necessary key.</p><p>For non-HA clusters etcd has only 1 replica, while for HA clusters there are 3 replicas.</p><p>One special remark is needed for Gardener&rsquo;s deployment of etcd. The pods coming from the etcd-main StatefulSet contain two containers - one runs etcd, the other runs a program that periodically backs up etcd&rsquo;s contents to an object store that is set up per seed cluster to make sure no data is lost. After all, etcd is the Achilles heel of all Kubernetes clusters. The backup container is also capable of performing a restore from the object store as well as defragment and compact the etcd datastore. For performance reasons, Gardener stores Kubernetes events in a separate etcd instance. By default, events are retained for 1h but can be kept longer if defined in the <code>shoot.spec</code>.</p><p>The kube API server (often called &ldquo;kapi&rdquo;) scales both horizontally and vertically.</p><p>The kube API server is not directly exposed / reachable via its public hostname. Instead, Gardener runs a single LoadBalancer service backed by an istio gateway / envoy, which uses SNI to forward traffic.</p><p><img src=/__resources/core-components-2_527c87.png alt=core-components-2></p><p>The <a href=https://kubernetes.io/docs/concepts/overview/components/#kube-controller-manager>kube-controller-manager</a> (aka <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/>KCM</a>) is the component that contains all the controllers for the core Kubernetes objects such as Deployments, Services, PVCs, etc.</p><p>The <a href=https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/>Kubernetes scheduler</a> will assign pods to nodes.</p><p>The <a href=https://kubernetes.io/docs/concepts/architecture/cloud-controller/>Cloud Controller Manager</a> (aka CCM) is the component that contains all functionality to talk to Cloud environments (e.g., create LoadBalancer services).</p><p>The CSI driver is the storage subsystem of Kubernetes. It provisions and manages anything related to persistence.</p><p>Without the cluster autoscaler, nodes could not be added or removed based on current pressure on the cluster resources. Without the VPA, pods would have fixed resource limits that could not change on demand.</p><h2 id=gardener-specific-components>Gardener-Specific Components</h2><p><img src=/__resources/gardener-specific-components_7b4581.png alt=gardener-specific-components></p><p><strong>Shoot DNS service:</strong> External DNS management for resources within the cluster.</p><p><strong>Machine Controller Manager:</strong> Responsible for managing VMs which will become nodes in the cluster.</p><p><strong>Virtual Private Network deployments</strong> (aka <a href=https://github.com/gardener/vpn>VPN</a>): Almost every communication between Kubernetes controllers and the API server is unidirectional - the controllers are given a kubeconfig and will establish a connection to the API server, which is exposed to all nodes of the cluster through a LoadBalancer. However, there are a few operations that require the API server to connect to the kubelet instead (e.g., for every webhook, when using kubectl exec or kubectl logs). Since every good Kubernetes cluster will have its worker nodes shielded behind firewalls to reduce the attack surface, Gardener establishes a VPN connection from the shoot&rsquo;s internal network to the API server in the seed. For that, every shoot, as well as every control plane namespace in the seed, have openVPN pods in them that connect to each other (with the connection being established from the shoot to the seed).</p><p><strong>Gardener Resource Manager:</strong> Tooling to deploy and manage Kubernetes resources required for cluster functionality.</p><h2 id=machines>Machines</h2><p><img src=/__resources/machines_3a36cd.png alt=machines></p><p><strong>Machine Controller Manager</strong> (aka <a href=https://github.com/gardener/machine-controller-manager>MCM</a>):</p><p>The machine controller manager, which lives on the seed in a shoot&rsquo;s control plane namespace, is the key component responsible for provisioning and removing worker nodes for a Kubernetes cluster. It acts on MachineClass, MachineDeployment, and MachineSet resources in the seed (think of them as the equivalent of Deployments and ReplicaSets) and controls the lifecycle of machine objects. Through a system of plugins, the MCM is the component that phones to the cloud provider&rsquo;s API and bootstraps virtual machines.</p><p>For more information, see <a href=/docs/other-components/machine-controller-manager/faq/>MCM</a> and <a href=https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md>Cluster-autoscaler</a>.</p><h2 id=managedresources>ManagedResources</h2><p><img src=/__resources/managed-resources_5f4933.png alt=managed-resources></p><p><strong>Gardener Resource Manager</strong> (aka <a href=/docs/gardener/concepts/resource-manager/>GRM</a>):</p><p>Gardener not only deploys components into the control plane namespace of the seed but also to the shoot (e.g., the counterpart of the VPN). Together with the components in the seed, Gardener needs to have a way to reconcile them.</p><p>Enter the GRM - it reconciles on ManagedResources objects, which are descriptions of Kubernetes resources which are deployed into the seed or shoot by GRM. If any of these resources are modified or deleted by accident, the usual observe-analyze-act cycle will revert these potentially malicious changes back to the values that Gardener envisioned. In fact, all the components found in a shoot&rsquo;s kube-system namespace are ManagedResources governed by the GRM. The actual resource definition is contained in secrets (as they may contain &ldquo;secret&rdquo; data), while the ManagedResources contain a reference to the secret containing the actual resource to be deployed and reconciled.</p><h2 id=dns-records---internal-and-external>DNS Records - &ldquo;Internal&rdquo; and &ldquo;External&rdquo;</h2><p><img src=/__resources/dns-records_cc6d7e.png alt=dns-records></p><p>The internal domain name is used by all Gardener components to talk to the API server. Even though it is called &ldquo;internal&rdquo;, it is still publicly routable.</p><p>But most importantly, it is pre-defined and not configurable by the end user.</p><p>Therefore, the &ldquo;external&rdquo; domain name exists. It is either a user owned domain or can be pre-defined for a Gardener landscape. It is used by any end user accessing the cluster&rsquo;s API server.</p><p>For more information, see <a href=/docs/gardener/extensions/dnsrecord/>Contract: DNSRecord Resources</a>.</p><h2 id=features-and-observability>Features and Observability</h2><p><img src=/__resources/features-observability_39ead9.png alt=features-observability></p><p>Gardener runs various health checks to ensure that the cluster works properly. The Network Problem Detector gives information about connectivity within the cluster and to the API server.</p><p><strong>Certificate Management:</strong> allows to request certificates via the ACME protocol (e.g., issued by Let&rsquo;s Encrypt) from within the cluster. For detailed information, have a look at the <a href=https://github.com/gardener/cert-management#certificate-management>cert-manager project</a>.</p><p><strong>Observability stack:</strong> Gardener deploys observability components and gathers logs and metrics for the control-plane & kube-system namespace. Also provided out-of-the-box is a UI based on Plutono (fork of Grafana) with pre-defined dashboards to access and query the monitoring data. For more information, see <a href=/docs/getting-started/observability/>Observability</a>.</p><h2 id=ha-control-plane>HA Control Plane</h2><p><img src=/__resources/ha-control-plane_f02ea3.png alt=ha-control-plane></p><p>As the title indicates, the HA control plane feature is only about the control plane. Setting up the data plane to span multiple zones is part of the worker spec of a shoot.</p><p>HA control planes can be configured as part of the shoot&rsquo;s spec. The available types are:</p><ul><li>Node</li><li>Zone</li></ul><p>Both work similarly and just differ in the failure domain the concepts are applied to.</p><p>For detailed guidance and more information, see the <a href=https://gardener.cloud/docs/guides/high-availability/>High Availability Guides</a>.</p><h2 id=zonal-ha-control-planes>Zonal HA Control Planes</h2><p><img src=/__resources/zonal-ha-control-planes_36cef6.png alt=zonal-ha-control-planes></p><p>Zonal HA is the most likely setup for shoots with <code>purpose: production</code>.</p><p>The starting point is a regular (non-HA) control plane. etcd and most controllers are singletons and the kube-apiserver might have been scaled up to several replicas.</p><p>To get to an HA setup we need:</p><ul><li>A minimum of 3 replicas of the API server</li><li>3 replicas for etcd (both main and events)</li><li>A second instance for each controller (e.g., controller manager, csi-driver, scheduler, etc.) that can take over in case of failure (active / passive).</li></ul><p>To distribute those pods across zones, well-known concepts like PodTopologySpreadConstraints or Affinities are applied.</p><h2 id=kube-system-namespace>kube-system Namespace</h2><img src=/__resources/kube-system-namespace-1_c41f6e.png alt=kube-system-namespace-1 width=50%><p>For a fully functional cluster, a few components need to run on the data plane side of the diagram. They all exist in the kube-system namespace. Let&rsquo;s have a closer look at them.</p><h3 id=networking>Networking</h3><p><img src=/__resources/kube-system-namespace-2_5fb502.png alt=kube-system-namespace-2></p><p>On each node we need a CNI (container network interface) plugin. Gardener offers Calico or Cilium as network provider for a shoot. When using Calico, a kube-proxy is deployed. Cilium does not need a kube-proxy, as it takes care of its tasks as well.</p><p>The CNI plugin ensures pod-to-pod communication within the cluster. As part of it, it assigns cluster-internal IP addresses to the pods and manages the network devices associated with them. When an overlay network is enabled, calico will also manage the routing of pod traffic between different nodes.</p><p>On the other hand, kube-proxy implements the actual service routing (cilium can do this as well and no kube-proxy is needed). Whenever packets go to a service&rsquo;s IP address, they are re-routed based on IPtables rules maintained by kube-proxy to reach the actual pods backing the service. kube-proxy operates on endpoint-slices and manages IPtables on EVERY node. In addition, kube-proxy provides a health check endpoint for services with <code>externalTrafficPolicy=local</code>, where traffic only gets to nodes that run a pod matching the selector of the service.</p><p>The egress filter implements basic filtering of outgoing traffic to be compliant with SAP&rsquo;s policies.</p><p>And what happens if the pods crashloop, are missing or otherwise broken?</p><p>Well, in case kube-proxy is broken, service traffic will degrade over time (depending on the pod churn rate and how many kube-proxy pods are broken).</p><p>When calico is failing on a node, no new pods can start there as they don&rsquo;t get any IP address assigned. It might also fail to add routes to newly added nodes. Depending on the error, deleting the pod might help.</p><h3 id=dns-system>DNS System</h3><p><img src=/__resources/kube-system-namespace-3_4f3735.png alt=kube-system-namespace-3></p><p>For a normal service in Kubernetes, a cluster-internal DNS record that resolves to the service&rsquo;s ClusterIP address is being created. In Gardener (similar to most other Kubernetes offerings) CoreDNS takes care of this aspect. To reduce the load when it comes to upstream DNS queries, Gardener deploys a DNS cache to each node by default. It will also forward queries outside the cluster&rsquo;s search domain directly to the upstream DNS server. For more information, see <a href=/docs/gardener/node-local-dns/>NodeLocalDNS Configuration</a> and <a href=/docs/gardener/dns-autoscaling/>DNS autoscaling</a>.</p><p>In addition to this optimization, Gardener allows <a href=/docs/gardener/custom-dns-config/>custom DNS configuration to be added to CoreDNS</a> via a dedicated ConfigMap.</p><p>In case this customization is related to non-Kubernetes entities, you may configure the shoot&rsquo;s NodeLocalDNS to forward to CoreDNS instead of upstream (<code>disableForwardToUpstreamDNS: true</code>).</p><p>A broken DNS system on any level will cause disruption / service degradation for applications within the cluster.</p><h3 id=health-checks-and-metrics>Health Checks and Metrics</h3><p><img src=/__resources/kube-system-namespace-4_a5292e.png alt=kube-system-namespace-4></p><p>Gardener deploys probes checking the health of individual nodes. In a similar fashion, a network health check probes connectivity within the cluster (node to node, pod to pod, pod to api-server, &mldr;).</p><p>They provide the data foundation for Gardener&rsquo;s monitoring stack together with the metrics collecting / exporting components.</p><h3 id=connectivity-components>Connectivity Components</h3><p><img src=/__resources/kube-system-namespace-5_fe8073.png alt=kube-system-namespace-5></p><p>From the perspective of the data plane, the shoot&rsquo;s API server is reachable via the cluster-internal service <code>kubernetes.default.svc.cluster.local</code>. The apiserver-proxy intercepts connections to this destination and changes it so that the traffic is forwarded to the kube-apiserver service in the seed cluster. For more information, see <a href=https://github.com/gardener/gardener/blob/764df0ee5ebc13b2634eba98169b409244f19bfe/docs/usage/control-plane-endpoints-and-ports.md#kube-apiserver-via-apiserver-proxy>kube-apiserver via apiserver-proxy</a>.</p><p>The second component here is the VPN shoot. It initiates a VPN connection to its counterpart in the seed. This way, there is no open port / Loadbalancer needed on the data plane. The VPN connection is used for any traffic flowing from the control plane to the data plane. If the VPN connection is broken, port-forwarding or log querying with kubectl will not work. In addition, webhooks will stop functioning properly.</p><h3 id=csi-driver>csi-driver</h3><p><img src=/__resources/kube-system-namespace-6_d4749d.png alt=kube-system-namespace-6></p><p>The last component to mention here is the csi-driver that is deployed as a Daemonset to all nodes. It registers with the kubelet and takes care of the mounting of volume types it is responsible for.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7f2a8f8d09b2d0790feb27edb6823b16>6 - Shoot Lifecycle</h1><h2 id=reconciliation-in-kubernetes-and-gardener>Reconciliation in Kubernetes and Gardener</h2><p>The starting point of all reconciliation cycles is the constant observation of both the desired and actual state. A component would analyze any differences between the two states and try to converge the actual towards the desired state using appropriate actions. Typically, a component is responsible for a single resource type but it also watches others that have an implication on it.</p><p>As an example, the Kubernetes controller for ReplicaSets will watch pods belonging to it in order to ensure that the specified replica count is fulfilled. If one pod gets deleted, the controller will create a new pod to enforce the desired over the actual state.</p><p>This is all standard behaviour, as Gardener is following the native Kubernetes approach. All elements of a shoot cluster have a representation in Kubernetes resources and controllers are watching / acting upon them.</p><p>If we pick up the example of the ReplicaSet - a user typically creates a <code>deployment</code> resource and the ReplicaSet is implicitly generated on the way to create the pods. Similarly, Gardener takes the user&rsquo;s intent (shoot) and creates lots of domain specific resources on the way. They all reconcile and make sure their actual and desired states match.</p><h2 id=updating-the-desired-state-of-a-shoot>Updating the Desired State of a Shoot</h2><p>Based on the shoot&rsquo;s specifications, Gardener will create network resources on a hyperscaler, backup resources for the ETCD, credentials, and other resources, but also representations of the worker pools. Eventually, this process will result in a fully functional Kubernetes cluster.</p><p>If you change the desired state, Gardener will reconcile the shoot and run through the same cycle to ensure the actual state matches the desired state.</p><p><img src=/__resources/update-shoot-state_0608f2.png alt=update-shoot-state></p><p>For example, the (infrastructure-specific) machine type can be changed within the shoot resource. The following reconciliation will pick up the change and initiate the creation of new nodes with a different machine type and the removal of the old nodes.</p><h2 id=maintenance-window-and-daily-reconciliation>Maintenance Window and Daily Reconciliation</h2><p><img src=/__resources/maintenance-window_e7495f.png alt=maintenance-window></p><p>EVERY shoot cluster reconciles once per day during the so-called &ldquo;maintenance window&rdquo;. You can confine the rollout of spec changes to this window.</p><p>Additionally, the daily reconciliation will help pick up all kind of version changes. When a new Gardener version was rolled out to the landscape, shoot clusters will pick up any changes during their next reconciliation. For example, if a new Calico version is introduced to fix some bug, it will automatically reach all shoots.</p><h2 id=impact-of-a-change>Impact of a Change</h2><p><img src=/__resources/change-impact_6effbf.png alt=change-impact></p><p>It is important to be aware of the impacts that a change can have on a cluster and the workloads within it.</p><p>An operator pushing a new Gardener version with a new calico image to a landscape will cause all calico pods to be re-created. Another example would be the rollout of a new etcd backup-restore image. This would cause etcd pods to be re-created, rendering a non-HA control plane unavailable until etcd is up and running again.</p><p>When you change the shoot spec, it can also have significant impact on the cluster. Imagine that you have changes the machine type of a worker pool. This will cause new machines to be created and old machines to be deleted. Or in other words: all nodes will be drained, the pods will be evicted and then re-created on newly created nodes.</p><h2 id=kubernetes-version-update-minor--patch>Kubernetes Version Update (Minor + Patch)</h2><p><img src=/__resources/k8s-version-update_d3f6f2.png alt=k8s-version-update></p><p>Some operations are rather common and have to be performed on a regular basis. Updating the Kubernetes version is one them. Patch updates cause relatively little disruption, as only the control-plane pods will be re-created with new images and the kubelets on all nodes will restart.</p><p>A minor version update is more impactful - it will cause all nodes to be recreated and rolls components of the control plane.</p><h2 id=os-version-update>OS Version Update</h2><p><img src=/__resources/os-update_06ee1f.png alt=os-update></p><p>The OS version is defined for each worker pool and can be changed per worker pool. You can freely switch back and forth. However, as there is no in-place update, each change will cause the entire worker pool to roll and nodes will be replaced.
For OS versions different update strategies can be configured. Please check the <a href=https://github.com/gardener/gardener/blob/master/docs/usage/shoot_versions.md/#update-path-for-machine-image-versions>documentation</a> for details.</p><h2 id=available-versions>Available Versionsâ€‹</h2><img style=width:80%;height:auto;margin:0,auto alt=available-versions src=/__resources/available-versions_71eae0.png><p>Gardener has a dedicated resource to maintain a list of available versions â€“ the so-called <code>cloudProfile</code>.</p><p>A cloudProfile provides information about supportedâ€‹:</p><ul><li>Kubernetes versionsâ€‹</li><li>OS versions (and where to find those images)â€‹</li><li>Regions (and their zones)â€‹</li><li>Machine typesâ€‹</li></ul><p>Each shoot references a cloudProfile in order to obtain information about available / possible versions and configurations.</p><h2 id=version-classifications>Version Classifications</h2><p><img src=/__resources/version-classifications_35a8c0.png alt=version-classifications></p><p>Gardener has the following classifications for Kubernetes and OS image versions:</p><ul><li><p><code>preview</code>: still in testing phase (several versions can be in preview at the same time)</p></li><li><p><code>supported</code>: recommended version</p></li><li><p><code>deprecated</code>: a new version has been set to &ldquo;supported&rdquo;, updating is recommended (might have an expiration date)</p></li><li><p><code>expired</code>: cannot be used anymore, clusters using this version will be force-upgraded</p></li></ul><p>Version information is maintained in the relevant cloud profile resource. There might be circumstances where a version will never become <code>supported</code> but instead move to <code>deprecated</code> directly. Similarly, a version might be directly introduced as <code>supported</code>.</p><h2 id=autoupdate--forced-updates>AutoUpdate / Forced Updates</h2><p><img src=/__resources/auto-update_2628a4.png alt=auto-update></p><p>AutoUpdate for a machine image version will update all node pools to the latest supported version based on the defined update strategy. Whenever a new version is set to <code>supported</code>, the cluster will pick it up during its next maintenance window.</p><p>For Kubernetes versions the mechanism is the same, but only applied to patch version. This means that the cluster will be kept on the latest supported patch version of a specific minor version.</p><p>In case a version used in a cluster expires, there is a force update during the next maintenance window. In a worst case scenario, 2 minor versions expire simultaneously. Then there will be two consecutive minor updates enforced.</p><p>For more information, see <a href=/docs/gardener/shoot_versions/>Shoot Kubernetes and Operating System Versioning in Gardener</a>.</p><h2 id=applying-changes-to-a-seed>Applying Changes to a Seed</h2><p><img src=/__resources/seeds-change_b8d4ae.png alt=seeds-change></p><p>It is important to keep in mind that a seed is just another Kubernetes cluster. As such, it has its own lifecycle (daily reconciliation, maintenance, etc.) and is also a subject to change.</p><p>From time to time changes need to be applied to the seed as well. Some (like updating the OS version) cause the node pool to roll. In turn, this will cause the eviction of ALL pods running on the affected node. If your etcd is evicted and you don&rsquo;t have a highly available control plane, it will cause downtime for your cluster. Your workloads will continue to run ,of course, but your cluster&rsquo;s API server will not function until the etcd is up and running again.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44d86c33218e27f7ab8c821cef16151c>7 - Observability</h1><h2 id=overview>Overview</h2><p>Gardener offers out-of-the-box observability for the control plane, Gardener managed system-components, and the nodes of a shoot cluster.</p><p>Having your workload survive on day 2 can be a challenge. The goal of this topic is to give you the tools with which to observe, analyze, and alert when the control plane or system components of your cluster become unhealthy. This will let you guide your containers through the storm of operating in a production environment.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6d9554a499343168179e4d308e72e36c>7.1 - Components</h1><h2 id=core-components>Core Components</h2><p><img src=/__resources/core-components_287ae2.png alt=core-components></p><p>The core Observability components which Gardener offers out-of-the-box are:</p><ul><li>Prometheus - for Metrics and Alerting</li><li>Vali - a Loki fork for Logging</li><li>Plutono - a Grafana fork for Dashboard visualization</li></ul><p>Both forks are done from the last version with an Apache license.</p><h3 id=control-plane-components-on-the-seed>Control Plane Components on the Seed</h3><p><img src=/__resources/control-plane-components_1b8262.png alt=control-plane-components></p><p>Prometheus, Plutono, and Vali are all located in the seed cluster. They run next to the control plane of your cluster.</p><p>The next sections will explore those components in detail.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>Gardener only provides monitoring for Gardener-deployed components. If you need logging or monitoring for your workload, then you need to deploy your own monitoring stack into your shoot cluster.</div><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>Gardener only provides a monitoring stack if the cluster is not of <code>purpose: testing</code>. For more information, see <a href=https://gardener.cloud/docs/gardener/shoot_purposes/>Shoot Cluster Purpose</a>.</div><h3 id=logging-into-plutono>Logging into Plutono</h3><p>Let us start by giving some visual hints on how to access Plutono. <a href=https://github.com/credativ/plutono#plutono>Plutono</a> allows us to query logs and metrics and visualise those in form of dashboards. Plutono is shipped ready-to-use with a Gardener shoot cluster.</p><p>In order to access the Gardener provided dashboards, open the <code>Plutono</code> link provided in the Gardener dashboard and use the username and password provided next to it.</p><p>The password you can use to log in can be retrieved as shown below:</p><p><img src=/__resources/access-plutono_07ba1b.png alt=access-plutono></p><h3 id=accessing-the-dashboards>Accessing the Dashboards</h3><p>After logging in, you will be greeted with a Plutono welcome screen. Navigate to <code>General/Home</code>, as depicted with the red arrow in the next picture:</p><p><img src=/__resources/welcome-plutono_6d6c00.png alt=welcome-plutono></p><p>Then you will be able to select the dashboards. Some interesting ones to look at are:</p><ul><li>The <code>Kubernetes Control Plane Status</code> dashboard allows you to check control plane availability during a certain time frame.</li><li>The <code>API Server</code> dashboard gives you an overview on which requests are done towards your apiserver and how long they take.</li><li>With the <code>Node Details</code> dashboard you can analyze CPU/Network pressure or memory usage for nodes.</li><li>The <code>Network Problem Detector</code> dashboard illustrates the results of periodic networking checks between nodes and to the APIServer.</li></ul><p>Here is a picture with the <code>Kubernetes Control Plane Status</code> dashboard.</p><p><img src=/__resources/plutono_855b74.png alt=plutono></p><h3 id=prometheus>Prometheus</h3><p><a href=https://prometheus.io/>Prometheus</a> is a monitoring system and a time series database. It can be queried using PromQL, the so called Prometheus Querying Language.</p><p><img src=/__resources/prometheus_707368.png alt=prometheus></p><p>This example query describes the current uptime status of the kube apiserver.</p><h4 id=prometheus-and-plutono>Prometheus and Plutono</h4><p>Time series data from Prometheus can be made visible with Plutono. Here we see how the query above which describes the uptime of a Kubernetes cluster is visualized with a Plutono dashboard.</p><p><img src=/__resources/prometheus-plutono_662ad5.png alt=prometheus-plutono></p><h3 id=vali-logs-via-plutono>Vali Logs via Plutono</h3><p>Vali is our logging solution. In order to access the logs provided by Vali, you need to:</p><ol><li><p><a href=/docs/getting-started/observability/components/#logging-into-plutono>Log into Plutono</a>.</p></li><li><p>Choose <code>Explore</code>, which is depicted as the little compass symbol:</p></li></ol><p><img src=/__resources/explore-loki_6b28b5.png alt=explore-loki></p><ol><li>Select <code>Vali</code> at the top left, as shown here:</li></ol><p><img src=/__resources/select-vali_c74f45.png alt=select-vali></p><p>There you can browse logs or events of the control plane components.</p><p><img src=/__resources/vali-logs_eb9bd0.png alt=vali-logs></p><p>Here are some examples of helpful queries:</p><ul><li><code>{container_name="cluster-autoscaler" }</code> to get cluster-autoscaler logs and see why certain node groups were scaled up.</li><li><code>{container_name="kube-apiserver"} |~ "error"</code> to get the logs of the kube-apiserver container and filter for errors.</li><li><code>{unit="kubelet.service", nodename="ip-123"}</code> to get the kubelet logs of a specific node.</li><li><code>{unit="containerd.service", nodename="ip-123"}</code> to retrieve the containerd logs for a specific node.</li></ul><p>Choose <code>Help ></code> in order to see what options exist to filter the results.</p><p>For more information on how to retrieve K8s events from the past, see <a href=/docs/gardener/logging-usage/#how-to-access-the-logs>How to Access Logs</a>.</p><h2 id=detailed-view>Detailed View</h2><h3 id=data-flow>Data Flow</h3><p>Our monitoring and logging solutions Vali and Prometheus both run next to the control plane of the shoot cluster.</p><h4 id=data-flow---logging>Data Flow - Logging</h4><p>The following diagram allows a more detailed look at Vali and the data flow.</p><p><img src=/__resources/data-flow-logging_e097b8.png alt=data-flow-logging></p><p>On the very left, we see Plutono as it displays the logs. Vali is aggregating the logs from different sources.</p><p>Valitail and Fluentbit send the logs to Vali, which in turn stores them.</p><p><em>Valitail</em></p><p>Valitail is a systemd service that runs on each node. It scrapes kubelet, containerd, kernel logs, and the logs of the pods in the kube-system namespace.</p><p><em>Fluentbit</em></p><p>Fluentbit runs as a daemonset on each seed node. It scrapes logs of the kubernetes control plane components, like apiserver or etcd.</p><p>It also scrapes logs of the Gardener deployed components which run next to the control plane of the cluster, like the machine-controller-manager or the cluster autoscaler. Debugging those components, for example, would be helpful when finding out why certain worker groups got scaled up or why nodes were replaced.</p><h4 id=data-flow---monitoring>Data Flow - Monitoring</h4><p>Next to each shoot&rsquo;s control plane, we deploy an instance of Prometheus in the seed.</p><p>Gardener uses <a href=https://prometheus.io/>Prometheus</a> for storing and accessing shoot-related metrics and alerting.</p><p>The diagram below shows the data flow of metrics.
Plutono uses PromQL queries to query data from Prometheus. It then visualises those metrics in dashboards.
Prometheus itself scrapes various targets for metrics, as seen in the diagram below by the arrows pointing to the Prometheus instance.</p><p><img src=/__resources/data-flow-monitoring-1_a9b4fd.png alt=data-flow-monitoring-1></p><p>Let us have a look what metrics we scrape for debugging purposes:</p><p><strong>Container performance metrics</strong></p><p>cAdvisor is an open-source agent integrated into the kubelet binary that monitors resource usage and analyzes the performance of containers. It collects statistics about the CPU, memory, file, and network usage for all containers running on a given node. We use it to scrape data for all pods running in the kube-system namespace in the shoot cluster.</p><p><strong>Hardware and kernel-related metrics</strong></p><p>The <a href=https://prometheus.io/docs/guides/node-exporter/>Prometheus Node Exporter</a> runs as a daemonset in the kube-system namespace of your shoot cluster. It exposes a wide variety of hardware and kernel-related metrics. Some of the metrics we scrape are, for example, the current usage of the filesystem (<code>node_filesystem_free_bytes</code>) or current CPU usage (<code>node_cpu_seconds_total</code>). Both can help you identify if nodes are running out of hardware resources, which could lead to your workload experiencing downtimes.</p><p><strong>Control plane component specific metrics</strong></p><p>The different control plane pods (for example, etcd, API server, and kube-controller-manager) emit metrics over the <code>/metrics</code> endpoint. This includes metrics like how long webhooks take, the request count of the apiserver and storage information, like how many and what kind of objects are stored in etcd.</p><p><strong>Metrics about the state of Kubernetes objects</strong></p><p><a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a> is a simple service that listens to the Kubernetes API server and generates metrics about the state of the objects. It is not concerned with metrics about the Kubernetes components, but rather it exposes metrics calculated from the status of Kubernetes objects (for example, resource requests or health of pods).</p><p>In the following image a few example metrics, which are exposed by the various components, are listed:
<img src=/__resources/data-flow-monitoring-2_4e4e76.png alt=data-flow-monitoring-2></p><p>We only store metrics for Gardener deployed components. Those include the Kubernetes control plane, Gardener managed system components (e.g., pods) in the kube-system namespace of the shoot cluster or systemd units on the nodes. We do not gather metrics for workload deployed in the shoot cluster. This is also shown in the picture below.</p><p>This means that for any workload you deploy into your shoot cluster, you need to deploy monitoring and logging yourself.</p><p>Logs or metrics are kept up to 14 days or when a configured space limit is reached.</p><p><img src=/__resources/data-flow-monitoring-3_38a9ab.png alt=data-flow-monitoring-3></p></div><div class=td-content style=page-break-before:always><h1 id=pg-24cc5ce3934851d872baa250cf0fc568>7.2 - Alerts</h1><h2 id=overview>Overview</h2><p>In this overview, we want to present two ways to receive alerts for control plane and Gardener managed system-components:</p><ul><li>Predefined Gardener alerts</li><li>Custom alerts</li></ul><h3 id=predefined-control-plane-alerts>Predefined Control Plane Alerts</h3><p>In the shoot spec it is possible to configure <code>emailReceivers</code>. On this email address you will automatically receive email notifications for predefined alerts of your control plane. Such alerts are deployed in the shoot Prometheus and have visibility <code>owner</code> or <code>all</code>. For more alert details, shoot owners can use this visibility to find these alerts in their shoot Prometheus UI.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  monitoring:
</span></span><span style=display:flex><span>    alerting:
</span></span><span style=display:flex><span>      emailReceivers:
</span></span><span style=display:flex><span>      - john.doe@example.com
</span></span></code></pre></div><p>For more information, see <a href=/docs/gardener/monitoring/alerting/>Alerting</a>.</p><h3 id=custom-alerts---federation>Custom Alerts - Federation</h3><p>If you need more customization for alerts for control plane metrics, you have the option to deploy your own Prometheus into your shoot control plane.</p><p>Then you can use federation, which is a Prometheus feature, to forward the metrics from the Gardener managed Prometheus to your custom deployed Prometheus. Since as a shoot owner you do not have access to the control plane pods, this is the only way to get those metrics.</p><p>The credentials and endpoint for the Gardener managed Prometheus are exposed over the Gardener dashboard or programmatically in the garden project as a secret (<code>&lt;shoot-name>.monitoring</code>).</p><p><img src=/__resources/custom-alerts_653ef2.png alt=custom-alerts></p></div><div class=td-content style=page-break-before:always><h1 id=pg-96a51dca8001a3ebad7d81bd83d00205>7.3 - Shoot Status</h1><h2 id=overview>Overview</h2><p>In this topic you can see various shoot statuses and how you can use them to monitor your shoot cluster.</p><h2 id=shoot-status---conditions>Shoot Status - Conditions</h2><p>You can retrieve the shoot status by using <code>kubectl get shoot -oyaml</code></p><p>It contains conditions, which give you information about the healthiness of your cluster. Those conditions are also forwarded to the Gardener dashboard and show your cluster as healthy or unhealthy.</p><img style=width:60%;height:auto;margin:0,auto alt=shoot-status-1 src=/__resources/shoot-status-1_81dd83.png><h2 id=shoot-status---constraints>Shoot Status - Constraints</h2><p>The shoot status also contains constraints. If these constraints are met, your cluster operations are impaired and the cluster is likely to fail at some point. Please watch them and act accordingly.</p><img style=width:60%;height:auto;margin:0,auto alt=shoot-status-2 src=/__resources/shoot-status-2_afb3ee.png><h2 id=shoot-status---last-operation>Shoot Status - Last Operation</h2><p>The <code>lastOperation</code>, <code>lastErrors</code>, and <code>lastMaintenance</code> give you information on what was last happening in your clusters. This is especially useful when you are facing an error.</p><p>In this example, nodes are being recreated and not all machines have reached the desired state yet.</p><img style=width:60%;height:auto;margin:0,auto alt=shoot-status-3 src=/__resources/shoot-status-3_61cd5c.png><h2 id=shoot-status---credentials-rotation>Shoot Status - Credentials Rotation</h2><p>You can also see the status of the last credentials rotation. Here you can also programmatically derive when the last rotation was down in order to trigger the next rotation.</p><img style=width:60%;height:auto;margin:0,auto alt=shoot-status-4 src=/__resources/shoot-status-4_5f74e6.png></div><div class=td-content style=page-break-before:always><h1 id=pg-eedce225735355fa4c38b06ecd73a71f>8 - Features</h1></div><div class=td-content><h1 id=pg-952455cded4f5cc40bd94f1164ceb348>8.1 - Hibernation</h1><h2 id=hibernation>Hibernation</h2><p>Some clusters need to be up all the time - typically, they would be hosting some kind of production workload. Others might be used for development purposes or testing during business hours only. Keeping them up and running all the time is a waste of money. Gardener can help you here with its &ldquo;hibernation&rdquo; feature. Essentially, hibernation means to shut down all components of a cluster.</p><h2 id=how-hibernation-works>How Hibernation Works</h2><p>The hibernation flow for a shoot attempts to reduce the resources consumed as much as possible. Hence everything not state-related is being decommissioned.</p><p><img src=/__resources/hibernation_21d43d.gif alt=hibernation></p><h3 id=data-plane>Data Plane</h3><p>All nodes will be drained and the VMs will be deleted. As a result, all pods will be &ldquo;stuck&rdquo; in a <code>Pending</code> state since no new nodes are added. Of course, PVC / PV holding data is not deleted.</p><p>Services of type <code>LoadBalancer</code> will keep their external IP addresses.</p><h3 id=control-plane>Control Plane</h3><p>All components will be scaled down and no pods will remain running. ETCD data is kept safe on the disk.</p><p>The DNS records routing traffic for the API server are also destroyed. Trying to connect to a hibernated cluster via kubectl will result in a DNS lookup failure / no-such-host message.</p><p>When waking up a cluster, all control plane components will be scaled up again and the DNS records will be re-created. Nodes will be created again and pods scheduled to run on them.</p><h2 id=how-to-configure--trigger-hibernation>How to Configure / Trigger Hibernation</h2><p>The easiest way to configure hibernation schedules is via the dashboard. Of course, this is reflected in the shoot&rsquo;s spec and can also be maintained there. Before a cluster is hibernated, constraints in the shoot&rsquo;s status will be evaluated. There might be conditions (mostly revolving around mutating / validating webhooks) that would block a successful wake-up. In such a case, the constraint will block hibernation in the first place.</p><p><img src=/__resources/trigger-hibernation_eef81a.png alt=trigger-hibernation></p><p>To wake-up or hibernate a shoot immediately, the dashboard can be used or a patch to the shoot&rsquo;s spec can be applied directly.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-836ec47620586bd0f11b86cda1085b8f>8.2 - Workerless Shoots</h1><h2 id=controlplane-as-a-service>Controlplane as a Service</h2><p><img src=/__resources/workerless-shoots_0af834.png alt=workerless-shoots></p><p>Sometimes, there may be use cases for Kubernetes clusters that don&rsquo;t require pods but only features of the control plane. Gardener can create the so-called &ldquo;workerless&rdquo; shoots, which are exactly that. A Kubernetes cluster without nodes (and without any controller related to them).</p><p>In a scenario where you already have multiple clusters, you can use it for orchestration (leases) or factor out components that require many CRDs.</p><p>As part of the control plane, the following components are deployed in the seed cluster for workerless shoot:</p><ul><li>etcds</li><li>kube-apiserver</li><li>kube-controller-manager</li><li>gardener-resource-manager</li><li>Logging and monitoring components</li><li>Extension components (to find out if they support workerless shoots, see the <a href=/docs/gardener/extensions/extension/#what-is-required-to-register-and-support-an-extension-type>Extensions</a> documentation)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0a262994afd0c0ada2875cae71a8ae6b>8.3 - Credential Rotation</h1><h2 id=keys>Keys</h2><p>There are plenty of keys in Gardener. The ETCD needs one to store resources like secrets encrypted at rest. Gardener generates certificate authorities (CAs) to ensure secured communication between the various components and actors and service account tokens are signed with a dedicated key. There is also an SSH key pair to allow debugging of nodes and the observability stack has its own passwords too.</p><p><img src=/__resources/keys_ef3249.png alt=keys></p><p>All of these keys share a common property: they are managed by Gardener. Rotating them, however, is potentially very disruptive. Hence, Gardener does not do it automatically, but offers you means to perform these tasks easily. For a single cluster, you may conveniently use the dashboard. Of course, it is also possible to do the same by annotating the shoot resource accordingly:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n &lt;shoot-namespace&gt; annotate shoot &lt;shoot-name&gt; gardener.cloud/operation=rotate-credentials-start
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n &lt;shoot-namespace&gt; annotate shoot &lt;shoot-name&gt; gardener.cloud/operation=rotate-credentials-completeâ€‹
</span></span></code></pre></div><p>Where possible, the rotation happens in two phases. Phase 1 introduces new keys while the old ones are still valid. Users can safely exchange keys / CA bundles wherever they are used. Afterwards, phase 2 will invalidate the old keys / CA bundles.</p><h2 id=rotation-phases>Rotation Phases</h2><p><img src=/__resources/rotation-phases_317f9b.png alt=rotation-phases></p><p>At the beginning, only the old set of credentials exists. By triggering the rotation, new credentials are created in phase 1 and both sets are valid. Now, all clients have to update and start using the new credentials. Only afterwards it is safe to trigger phase 2, which invalidates the old credentials.</p><p>The shoot&rsquo;s status will always show the current status / phase of the rotation.</p><p>For more information, see <a href=/docs/gardener/shoot_credentials_rotation/>Credentials Rotation for Shoot Clusters</a>.</p><h2 id=user-provided-credentials>User-Provided Credentials</h2><p><img src=/__resources/user-provided-keys_976909.png alt=user-provided-keys></p><p>You grant Gardener permissions to create resources by handing over cloud provider keys. These keys are stored in a secret and referenced to a shoot via a SecretBinding. Gardener uses the keys to create the network for the cluster resources, routes, VMs, disks, and IP addresses.</p><p>When you rotate credentials, the new keys have to be stored in the same secret and the shoot needs to reconcile successfully to ensure the replication to every controller. Afterwards, the old keys can be deleted safely from Gardener&rsquo;s perspective.</p><p>While the reconciliation can be triggered manually, there is no need for it (if you&rsquo;re not in a hurry). Each shoot reconciles once within 24h and the new keys will be picked up during the next maintenance window.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Note</h4>It is not possible to move a shoot to a different infrastructure account (at all!).</div></div><div class=td-content style=page-break-before:always><h1 id=pg-944e1ccc5fe9231baf62136aece39ae0>8.4 - External DNS Management</h1><h2 id=external-dns-management>External DNS Management</h2><p>When you deploy to Kubernetes, there is no native management of external DNS. Instead, the cloud-controller-manager requests (mostly IPv4) addresses for every service of type LoadBalancer. Of course, the Ingress resource helps here, but how is the external DNS entry for the ingress controller managed?</p><p>Essentially, some sort of automation for DNS management is missing.</p><h2 id=automating-dns-management>Automating DNS Management</h2><p><img src=/__resources/automate-dns-management_f9812b.png alt=automate-dns-management></p><p>From a user&rsquo;s perspective, it is desirable to work with already known resources and concepts. Hence, the DNS management offered by Gardener plugs seamlessly into Kubernetes resources and you do not need to &ldquo;leave&rdquo; the context of the shoot cluster.</p><p>To request a DNS record creation / update, a Service or Ingress resource is annotated accordingly. The shoot-dns-service extension will (if configured) will pick up the request and create a DNSEntry resource + reconcile it to have an actual DNS record created at a configured DNS provider. Gardener supports the following providers:</p><ul><li>aws-route53</li><li>azure-dns</li><li>azure-private-dns</li><li>google-clouddns</li><li>openstack-designate</li><li>alicloud-dns</li><li>cloudflare-dns</li></ul><p>For more information, see <a href=/docs/guides/networking/dns-extension/>DNS Names</a>.</p><h2 id=dns-provider>DNS Provider</h2><p>For the above to work, we need some ingredients. Primarily, this is implemented via a so-called DNSProvider. Every shoot has a default provider that is used to set up the API server&rsquo;s public DNS record. It can be used to request sub-domains as well.</p><p><img src=/__resources/dns-provider_2d18ba.png alt></p><p>In addition, a shoot can reference credentials to a DNS provider. Those can be used to manage custom domains.</p><p>Please have a look at the <a href=https://gardener.cloud/docs/guides/networking/dns-extension/>documentation</a> for further details.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-81911c22231e4d217a0fa66ad4e312b8>8.5 - Certificate Management</h1><h2 id=certificate-management>Certificate Management</h2><p>For proper consumption, any service should present a TLS certificate to its consumers. However, self-signed certificates are not fit for this purpose - the certificate should be signed by a CA trusted by an application&rsquo;s userbase. Luckily, Issuers like Let&rsquo;s Encrypt and others help here by offering a signing service that issues certificates based on the ACME challenge (Automatic Certificate Management Environment).</p><p>There are plenty of tools you can use to perform the challenge. For Kubernetes, cert-manager certainly is the most common, however its configuration is rather cumbersome and error prone. So let&rsquo;s see how a Gardener extension can help here.</p><h2 id=manage-certificates-with-gardener>Manage Certificates with Gardener</h2><p><img src=/__resources/manage-certificates_b8392b.png alt=manage-certificates></p><p>You may annotate a Service or Ingress resource to trigger the cert-manager to request a certificate from the any configured issuer (e.g. Let&rsquo;s Encrypt) and perform the challenge. A Gardener operator can add a default issuer for convenience.
With the DNS extension discussed previously, setting up the DNS TXT record for the ACME challenge is fairly easy. The requested certificate can be customized by the means of several other annotations known to the controller. Most notably, it is possible to specify SANs via <code>cert.gardener.cloud/dnsnames</code> to accommodate domain names that have more than 64 characters (the limit for the CN field).</p><p>The user&rsquo;s request for a certificate manifests as a <code>certificate</code> resource. The status, issuer, and other properties can be checked there.</p><p>Once successful, the resulting certificate will be stored in a secret and is ready for usage.</p><p>With additional configuration, it is also possible to define custom issuers of certificates.</p><p>For more information, see the <a href=/docs/guides/networking/certificate-extension/>Manage certificates with Gardener for public domain</a> topic and the <a href=https://github.com/gardener/cert-management#follow-cname>cert-management repository</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1e39dd927fcf27e5bf07215eb89475f8>8.6 - Vertical Pod Autoscaler</h1><h2 id=vertical-pod-autoscaler>Vertical Pod Autoscaler</h2><p><img src=/__resources/vpa_43b432.gif alt=vpa></p><p>When a pod&rsquo;s resource CPU or memory grows, it will hit a limit eventually. Either the pod has resource limits specified or the node will run short of resources. In both cases, the workload might be throttled or even terminated. When this happens, it is often desirable to increase the request or limits. To do this autonomously within certain boundaries is the goal of the Vertical Pod Autoscaler project.</p><p>Since it is not part of the standard Kubernetes API, you have to install the CRDs and controller manually. With Gardener, you can simply flip the switch in the shoot&rsquo;s spec and start creating your VPA objects.</p><p>Please be aware that VPA and HPA operate in similar domains and might interfere.</p><p>A controller & CRDs for vertical pod auto-scaling can be activated via the shoot&rsquo;s spec.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-136b0a42c1db2a4e7b74214278ca69f8>8.7 - Cluster Autoscaler</h1><h2 id=obtaining-aditional-nodes>Obtaining Aditional Nodes</h2><p><img src=/__resources/additional-nodes_4a5ea7.gif alt=additional-nodes></p><p>The scheduler will assign pods to nodes, as long as they have capacity (CPU, memory, Pod limit, # attachable disks, &mldr;). But what happens when all nodes are fully utilized and the scheduler does not find any suitable target?</p><p><strong>Option 1:</strong> Evict other pods based on priority. However, this has the downside that other workloads with lower priority might become unschedulable.</p><p><strong>Option 2:</strong> Add more nodes. There is an upstream Cluster Autoscaler project that does exactly this. It simulates the scheduling and reacts to pods not being schedulable events. Gardener has forked it to make it work with machine-controller-manager abstraction of how node (groups) are defined in Gardener.
The cluster autoscaler respects the limits (min / max) of any worker pool in a shoot&rsquo;s spec. It can also scale down nodes based on utilization thresholds. For more details, see the <a href=https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md>autoscaler documentation</a>.</p><h2 id=scaling-by-priority>Scaling by Priority</h2><p><img src=/__resources/priority-scaling_a4bb49.gif alt=priority-scaling></p><p>For clusters with more than one node pool, the cluster autoscaler has to decide which group to scale up. By default, it randomly picks from the available / applicable. However, this behavior is customizable by the use of so-called expanders.</p><p>This section will focus on the priority based expander.</p><p>Each worker pool gets a priority and the cluster autoscaler will scale up the one with the highest priority until it reaches its limit.</p><p>To get more information on the current status of the autoscaler, you can check a &ldquo;status&rdquo; configmap in the <code>kube-system</code> namespace with the following command:</p><p><code>kubectl get cm -n kube-system cluster-autoscaler-status -oyaml</code></p><p>To obtain information about the decision making, you can check the logs of the cluster-autoscaler pod by using the shoot&rsquo;s monitoring stack.</p><p>For more information, see the <a href=https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/FAQ.md#what-are-expanders>cluster-autoscaler FAQ</a> and the <a href=https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/expander/priority/readme.md>Priority based expander for cluster-autoscaler</a> topic.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d0bc19b1565aa59ea44d0b600ca2f939>9 - Common Pitfalls</h1><h2 id=architecture>Architecture</h2><h3 id=containers-will-not-fix-a-broken-architecture>Containers will NOT fix a broken architecture!</h3><p><img src=/__resources/microservices_0c3efe.png alt=microservices></p><p>Running a highly distributed system has advantages, but of course, those come at a cost. In order to succeed, one would need:</p><ul><li>Logging</li><li>Tracing</li><li>No singleton</li><li>Tolerance to failure of individual instances</li><li>Automated config / change management</li><li>Kubernetes knowledge</li></ul><h2 id=scalability>Scalability</h2><p>Most scalability dimensions are interconnected with others. If a cluster grows beyond reasonable defaults, it can still function very well. But tuning it comes at the cost of time and can influence stability negatively.</p><p>Take the number of nodes and pods, for example. Both are connected and you cannot grow both towards their individual limits, as you would face issues way before reaching any theoretical limits.</p><p>Reading the <a href=/docs/guides/administer-shoots/scalability/>Scalability of Gardener Managed Kubernetes Clusters</a> guide is strongly recommended in order to understand the topic of scalability within Kubernetes and Gardener.</p><h3 id=a-small-sample-of-things-that-can-grow-beyond-reasonable-limits>A Small Sample of Things That Can Grow Beyond Reasonable Limits</h3><p><img src=/__resources/hibernation-1_fc2e4c.png alt=hibernation-1></p><p>When scaling a cluster, there are plenty of resources that can be exhausted or reach a limit:</p><ul><li>The API server will be scaled horizontally and vertically by Gardener. However, it can still consume too much resources to fit onto a single node on the seed. In this case, you can only reduce the load on the API server. This should not happen with regular usage patterns though.</li><li>ETCD disk space: 8GB is the limit. If you have too many resources or a high churn rate, a cluster can run out of ETCD capacity. In such a scenario it will stop working until defragmented, compacted, and cleaned up.</li><li>The number of nodes is limited by the network configuration (pod cidr range & node cidr mask). Also, there is a reasonable number of nodes (300) that most workloads should not exceed. It is possible to go beyond but doing so requires careful tuning and consideration of connected scaling dimensions (like the number of pods per node).</li></ul><p><strong>The availability of your cluster is directly impacted by the way you use it.</strong></p><h3 id=infrastructure-capacity-and-quotas>Infrastructure Capacity and Quotas</h3><p><img src=/__resources/capacity_85f843.png alt=capacity></p><p>Sometimes requests cannot be fulfilled due to shortages on the infrastructure side. For example, a certain instance type might not be available and new Kubernetes nodes of this type cannot be added. It is a good practice to use the <a href=https://github.com/gardener/autoscaler/blob/machine-controller-manager-provider/cluster-autoscaler/expander/priority/readme.md>cluster-autoscaler&rsquo;s priority expander</a> and have a secondary node pool.</p><p>Sometimes, it is not the physical capacity but exhausted quotas within an infrastructure account that result in limits. Obviously, there should be sufficient quota to create as many VMs as needed. But there are also other resources that are created in the infrastructure that need proper quotas:</p><ul><li>Loadbalancers</li><li>VPC</li><li>Disks</li><li>Routes (often forgotten, but very important for clusters without overlay network; typically defaults to around 50 routes, meaning that 50 nodes is the maximum a cluster can have)</li><li>&mldr;</li></ul><h3 id=nodecidrmasksize>NodeCIDRMaskSize</h3><p><img src=/__resources/mask-size_e0ca8c.png alt=mask-size></p><p>Upon cluster creation, there are several settings that are network related. For example, the address space for Pods has to be defined. In this case, it is a <code>/16</code> subnet that includes a total of 65.536 hosts. However, that does not imply that you can easily use all addresses at the same point in time.</p><p>As part of the Kubernetes network setup, the <code>/16</code> network is divided into smaller subnets and each node gets a distinct subnet. The size of this subnet defaults to <code>/24</code>. It can also be specified (but not changed later).</p><p>Now, as you create more nodes, you have a total of 256 subnets that can be assigned to nodes, thus limiting the total number of nodes of this cluster to 256.</p><p>For more information, see <a href=/docs/gardener/shoot_networking/>Shoot Networking</a>.</p><h2 id=overlapping-vpcs>Overlapping VPCs</h2><h3 id=avoid-overlapping-cidr-ranges-in-vpcs>Avoid Overlapping CIDR Ranges in VPCs</h3><p><img src=/__resources/cidr-ranges_ba59aa.png alt=cidr-ranges></p><p>Gardener can create shoot cluster resources in an existing / user-created VPC. However, you have to make sure that the CIDR ranges used by the shoots nodes or subnets for zones do not overlap with other shoots deployed to the same VPC.</p><p>In case of an overlap, there might be strange routing effects, and packets ending up at a wrong location.</p><h2 id=expired-credentials>Expired Credentials</h2><p><img src=/__resources/expired-credentials_811acc.png alt=expired-credentials></p><p>Credentials expire or get revoked. When this happens to the actively used infrastructure credentials of a shoot, the cluster will stop working after a while. New nodes cannot be added, LoadBalancers cannot be created, and so on.</p><p>You can update the credentials stored in the project namespace and reconcile the cluster to replicate the new keys to all relevant controllers. Similarly, when doing a planned rotation one should wait until the shoot reconciled successfully before invalidating the old credentials.</p><h2 id=autoupdate-breaking-clusters>AutoUpdate Breaking Clusters</h2><p>Gardener can automatically update a shoot&rsquo;s Kubernetes patch version, when a new patch version is labeled as &ldquo;supported&rdquo;. Automatically updating of the OS images works in a similar way. Both are triggered by the &ldquo;supported&rdquo; classification in the respective cloud profile and can be enabled / disabled as part a shoot&rsquo;s spec.</p><p>Additionally, when a minor Kubernetes / OS version expires, Gardener will force-update the shoot to the next supported version.</p><p>Turning on AutoUpdate for a shoot may be convenient but comes at the risk of potentially unwanted changes. While it is possible to switch to another OS version, updates to the Kubernetes version are a one way operation and cannot be reverted.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Recommendation</h4>Control the version lifecycle separately for any cluster that hosts important workload.</div><h2 id=node-draining>Node Draining</h2><h3 id=node-draining-and-pod-disruption-budget>Node Draining and Pod Disruption Budget</h3><p><img src=/__resources/node-draining_18cb25.gif alt=node-draining></p><p>Typically, nodes are drained when:</p><ul><li>There is a update of the OS / Kubernetes minor version</li><li>An Operator cordons & drains a node</li><li>The cluster-autoscaler wants to scale down</li></ul><p>Without a PodDistruptionBudget, pods will be terminated as fast as possible. If an application has 2 out of 2 replicas running on the drained node, this will probably cause availability issues.</p><h3 id=node-draining-with-pdb>Node Draining with PDB</h3><p><img src=/__resources/node-draining-pdb_f95465.gif alt=node-draining-pdb></p><p>PodDisruptionBudgets can help to manage a graceful node drain. However, if no disruptions are allowed there, the node drain will be blocked until it reaches a timeout. Only then will the nodes be terminated but without respecting PDB thresholds.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Recommendation</h4>Configure PDBs and allow disruptions.</div><h2 id=pod-resource-requests-and-limits>Pod Resource Requests and Limits</h2><h3 id=resource-consumption>Resource Consumption</h3><p>Pods consume resources and, of course, there are only so many resources available on a single node. Setting requests will make the scheduling much better, as the scheduler has more information available.</p><p>Specifying limits can help, but can also limit an application in unintended ways. A recommendation to start with:</p><ul><li>Do not set CPU limits (CPU is compressible and throttling is really hard to detect)</li><li>Set memory limits and monitor OOM kills / restarts of workload (typically detectable by container status exit code 137 and corresponding events). This will decrease the likelihood of OOM situations on the node itself. However, for critical workloads it might be better to have uncapped growth and rather risk a node going OOM.</li></ul><p>Next, consider if assigning the workload to quality of service class <code>guaranteed</code> is needed. Again - this can help or be counterproductive. It is important to be aware of its implications. For more information, see <a href=https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/>Pod Quality of Service Classes</a>.</p><p>Tune <code>shoot.spec.Kubernetes.kubeReserved</code> to protect the node (kubelet) in case of a workload pod consuming too much resources. It is very helpful to ensure a high level of stability.</p><p>If the usage profile changes over time, the VPA can help a lot to adapt the resource requests / limits automatically.</p><h2 id=webhooks>Webhooks</h2><h3 id=user-deployed-webhooks-in-kubernetes>User-Deployed Webhooks in Kubernetes</h3><p><img src=/__resources/user-webhook_aed032.gif alt=user-webhook></p><p>By default, any request to the API server will go through a chain of checks. Let&rsquo;s take the example of creating a pod.</p><p>When the resource is submitted to the API server, it will be checked against the following validations:</p><ul><li>Is the user authorized to perform this action?</li><li>Is the pod definitionactually valid?</li><li>Are the specified values allowed?</li></ul><p>Additionally, there is the defaulting - like the injection of the <code>default</code> service account&rsquo;s name, if nothing else is specified.</p><p>This chain of admission control and mutation can be enhanced by the user. Read about <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>dynamic admission control</a> for more details.</p><p><code>ValidatingWebhookConfiguration</code>: allow or deny requests based on custom rules</p><p><code>MutatingWebhookConfiguration</code>: change Ð° resource before it is actually stored in etcd (that is, before any other controller acts upon)</p><p>Both <code>ValidatingWebhookConfiguration</code> as well as <code>MutatingWebhookConfiguration</code> resources:</p><ul><li>specify for which resources and operations these checks should be executed.</li><li>specify how to reach the webhook server (typically a service running on the data plane of a cluster)</li><li>rely on a webhook server performing a review and reply to the <code>admissionReview</code> request</li></ul><p><img src=/__resources/user-webhook-fail_a09a80.gif alt=user-webhook-fail></p><p>What could possibly go wrong?
Due to the separation of control plane and data plane in Gardener&rsquo;s architecture, webhooks have the potential to break a cluster.
If the webhook server is not responding in time with a valid answer, the request should timeout and the failure policy is invoked. Depending on the scope of the webhook, frequent failures may cause downtime for applications.
Common causes for failure are:</p><ul><li>The call to the webhook is made through the VPN tunnel. VPN / connection issues can happen both on the side of the seed as well as the shoot and would render the webhook unavailable from the perspective of the control plane.</li><li>The traffic cannot reach the pod (network issue, pod not available)</li><li>The pod is processing too slow (e.g., because there are too many requests)</li></ul><h3 id=timeout>Timeout</h3><p><img src=/__resources/timeout_fba80a.png alt=timeout></p><p>Webhooks are a very helpful feature of Kubernetes. However, they can easily be configured to break a shoot cluster. Take the timeout, for example. High timeouts (>15s) can lead to blocking requests of control plane components. That&rsquo;s because most control-plane API calls are made with a client-side timeout of 30s, so if a webhook has <code>timeoutSeconds=30</code>, the overall request might still fail as there is overhead in communication with the API server and other potential webhooks.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Recommendation</h4>Webhooks (esp. mutating) may be called sequentially and thus adding up their individual timeouts. Even with a <code>faliurePolicy=ignore</code> the timeout will stop the request.</div><h3 id=recommendations>Recommendations</h3><p>Problematic webhooks are reported as part of a shoot&rsquo;s status. In addition to timeouts, it is crucial to exclude the <code>kube-system</code> namespace and (potentially non-namespaced) resources that are necessary for the cluster to function properly. Those should not be subject to a user-defined webhook.</p><p>In particular, a webhook should not operate on:</p><ul><li>the <code>kube-system</code> namespace</li><li><code>Endpoints</code> or <code>EndpointSlices</code></li><li><code>Nodes</code></li><li><code>PodSecurityPolicies</code></li><li><code>ClusterRoles</code></li><li><code>ClusterRoleBindings</code></li><li><code>CustomResourceDefinitions</code></li><li><code>ApiServices</code></li><li><code>CertificateSigningRequests</code></li><li><code>PriorityClasses</code></li></ul><p><strong>Example:</strong></p><p>A webhook checks node objects upon creation and has a <code>failurePolicy: fail</code>. If the webhook does not answer in time (either due to latency or because there is no pod serving it), new nodes cannot join the cluster.</p><p>For more information, see <a href=/docs/gardener/shoot_status/#constraints>Shoot Status</a>.</p><h2 id=conversion-webhooks>Conversion Webhooks</h2><h3 id=who-installs-a-conversion-webhook>Who installs a conversion webhook?</h3><p>If you have written your own <code>CustomResourceDefinition</code> (CRD) and made a version upgrade, you will also have consciously written & deployed the conversion webhook.</p><p>However, sometimes, you simply use helm or kustomize to install a (third-party) dependency that contains CRDs. Of course, those can contain conversion webhooks as well. As a user of a cluster, please make sure to be aware what you deploy.</p><h3 id=crd-with-a-conversion-webhook>CRD with a Conversion Webhook</h3><p><img src=/__resources/conversion-webhook-crd_42b789.png alt=conversion-webhook-crd></p><p>Conversion webhooks are tricky. Similarly to regular webhooks, they should have a low timeout. However, they cannot be remediated automatically and can cause errors in the control plane. For example, if a webhook is invoked but not available, it can block the garbage collection run by the kube-controller-manager.</p><p>In turn, when deleting something like a <code>deployment</code>, dependent resources like <code>pods</code> will not be deleted automatically.</p><div class="alert alert-info" role=alert><h4 class=alert-heading>Recommendation</h4>Try to avoid conversion webhooks. They are valid and can be used, but should not stay in place forever. Complete the upgrade to a new version of the CRD as soon as possible.</div><p>For more information, see the <a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#webhook-conversion>Webhook Conversion</a>, <a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#upgrade-existing-objects-to-a-new-stored-version>Upgrade Existing Objects to a New Stored Version</a>, and <a href=https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#version-priority>Version Priority</a> topics in the Kubernetes documentation.</p></div></main></div></div><footer class="footer row d-print-none"><div class="container-fluid footer-wrapper"><ul class=nav><li><a href=https://gardener.cloud/blog/>Blogs</a></li><li><a href=https://gardener.cloud/community/>Community</a></li><li><a href=https://gardener.cloud/adopter/>Adopters</a></li><li><a href=/docs/>Documentation</a></li></ul><img src=/images/lp/gardener-logo.svg alt="Logo Gardener" class=logo><ul class=media-wr><li><a target=_blank href=https://kubernetes.slack.com/archives/CB57N0BFG><img src=/images/branding/slack-logo-white.svg class=media-icon><div class=media-text>Slack</div></a></li><li><a target=_blank href=https://github.com/gardener><img src=/images/branding/github-mark-logo.png class=media-icon><div class=media-text>GitHub</div></a></li><li><a target=_blank href=https://www.youtube.com/channel/UCwUhwKFREV8Su0gwAJQX7tw><img src=/images/branding/youtube-logo-dark.svg class=media-icon><div class=media-text>YouTube</div></a></li><li><a target=_blank href=https://twitter.com/GardenerProject><img src=/images/branding/twitter-logo-white.svg class=media-icon><div class=media-text>Twitter</div></a></li></ul><span class=copyright>Copyright 2019-2023 Gardener project authors. <a href=https://www.sap.com/corporate/en/legal/privacy.html>Privacy policy
<i class="fa fa-external-link" aria-hidden=true></i></a></span></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid@8.13.4/dist/mermaid.min.js integrity="sha512-JERecFUBbsm75UpkVheAuDOE8NdHjQBrPACfEQYPwvPG+fjgCpHAz1Jw2ci9EXmd3DdfiWth3O3CQvcfEg8gsA==" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script>
<script src=/js/main.min.11dbee029dba1a98021fb7be4d7405a7392afb38ff5640a21ff4f4c4c5057b2f.js integrity="sha256-EdvuAp26GpgCH7e+TXQFpzkq+zj/VkCiH/T0xMUFey8=" crossorigin=anonymous></script></body></html>