<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener â€“ Registry cache</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/</link><description>Recent content in Registry cache on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Configuration</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/configuration/</guid><description>
&lt;h1 id="configuring-the-registry-cache-extension">Configuring the Registry Cache Extension&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;h3 id="use-case">Use-case&lt;/h3>
&lt;p>For a Shoot cluster, the containerd daemon of every Node goes to the internet and fetches an image that it doesn&amp;rsquo;t have locally in the Node&amp;rsquo;s image cache. New Nodes are often created due to events such as auto-scaling (scale up), rolling update, or replacement of unhealthy Node. Such a new Node would need to pull all of the images of the Pods running on it from the internet because the Node&amp;rsquo;s cache is initially empty. Pulling an image from a registry produces network traffic and registry costs. To avoid these network traffic and registry costs, you can use the registry-cache extension to run a registry as pull-through cache.&lt;/p>
&lt;p>The following diagram shows a rough outline of how image pull looks like for a Shoot cluster &lt;strong>without registry cache&lt;/strong>:
&lt;img src="https://gardener.cloud/__resources/shoot-cluster-without-registry-cache_a0770d.png" alt="shoot-cluster-without-registry-cache">&lt;/p>
&lt;h3 id="solution">Solution&lt;/h3>
&lt;p>The registry-cache extension deploys and manages a registry in the Shoot cluster that runs as pull-through cache. The used registry implementation is &lt;a href="https://github.com/distribution/distribution">distribution/distribution&lt;/a>.&lt;/p>
&lt;h3 id="how-does-it-work">How does it work?&lt;/h3>
&lt;p>When the extension is enabled, a registry cache for each configured upstream is deployed to the Shoot cluster. Along with this, the containerd daemon on the Shoot cluster Nodes gets configured to use as a mirror the Service IP address of the deployed registry cache. For example, if a registry cache for upstream &lt;code>docker.io&lt;/code> is requested via the Shoot spec, then containerd gets configured to first pull the image from the deployed cache in the Shoot cluster. If this image pull operation fails, containerd falls back to the upstream itself (&lt;code>docker.io&lt;/code> in that case).&lt;/p>
&lt;p>The first time an image is requested from the pull-through cache, it pulls the image from the configured upstream registry and stores it locally before handing it back to the client. On subsequent requests, the pull-through cache is able to serve the image from its own storage.&lt;/p>
&lt;blockquote>
&lt;p>Note: The used registry implementation (&lt;a href="https://github.com/distribution/distribution">distribution/distribution&lt;/a>) supports mirroring of only one upstream registry.&lt;/p>
&lt;/blockquote>
&lt;p>The following diagram shows a rough outline of how image pull looks like for a Shoot cluster &lt;strong>with registry cache&lt;/strong>:
&lt;img src="https://gardener.cloud/__resources/shoot-cluster-with-registry-cache_9bbc9e.png" alt="shoot-cluster-with-registry-cache">&lt;/p>
&lt;h2 id="shoot-configuration">Shoot Configuration&lt;/h2>
&lt;p>The extension is not globally enabled and must be configured per Shoot cluster. The Shoot specification has to be adapted to include the &lt;code>registry-cache&lt;/code> extension configuration.&lt;/p>
&lt;p>Below is an example of &lt;code>registry-cache&lt;/code> extension configuration as part of the Shoot spec:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>metadata:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: crazy-botany
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespace: garden-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: registry-cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: registry.extensions.gardener.cloud/v1alpha2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: RegistryConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> caches:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: 100Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> storageClassName: premium
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: ghcr.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: quay.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> garbageCollection:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enabled: &lt;span style="color:#00f">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretReferenceName: quay-credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: quay-credentials
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: quay-credentials-v1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>providerConfig&lt;/code> field is required.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches&lt;/code> field contains information about the registry caches to deploy. It is a required field. At least one cache has to be specified.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].upstream&lt;/code> field is the remote registry host (and optionally port) to cache. It is a required field.
The desired format is &lt;code>host[:port]&lt;/code>. The value must not include a scheme. The configured upstream registry must be accessible by &lt;code>https&lt;/code> (&lt;code>https://&lt;/code> is the assumed scheme).&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].volume&lt;/code> field contains settings for the registry cache volume.
The registry-cache extension deploys a StatefulSet with a volume claim template. A PersistentVolumeClaim is created with the configured size and StorageClass name.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].volume.size&lt;/code> field is the size of the registry cache. Defaults to &lt;code>10Gi&lt;/code>. The size must be a positive quantity (greater than 0).
This field is immutable. See &lt;a href="#increase-the-cache-disk-size">Increase the cache disk size&lt;/a> on how to resize the disk.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].volume.storageClassName&lt;/code> field is the name of the StorageClass used by the registry cache volume.
This field is immutable. If the field is not specified, then the &lt;a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#default-storageclass">default StorageClass&lt;/a> will be used.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].garbageCollection.enabled&lt;/code> field enables/disables the cache&amp;rsquo;s garbage collection. Defaults to &lt;code>true&lt;/code>. The time to live (ttl) for an image is &lt;code>7d&lt;/code>. See the &lt;a href="#garbage-collection">garbage collection section&lt;/a> for more details.&lt;/p>
&lt;p>The &lt;code>providerConfig.caches[].secretReferenceName&lt;/code> is the name of the reference for the Secret containing the upstream registry credentials. To cache images from a private registry, credentials to the upstream registry should be supplied. For details see &lt;a href="https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/upstream-credentials/#how-to-provide-credentials-for-upstream-registry">How to provide credentials for upstream registry&lt;/a>.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: It&amp;rsquo;s only possible to provide one set of credentials for one private upstream registry.&lt;/p>
&lt;/blockquote>
&lt;h2 id="garbage-collection">Garbage Collection&lt;/h2>
&lt;p>When the registry cache receives a request for an image that is not present in its local store, it fetches the image from the upstream, returns it to the client and stores the image in the local store. The registry cache runs a scheduler that deletes images when their time to live (ttl) expires. When adding an image to the local store, the registry cache also adds a time to live for the image. The ttl value is &lt;code>7d&lt;/code>. Requesting an image from the registry cache does not extend the time to live of the image. Hence, an image is always garbage collected from the registry cache store after &lt;code>7d&lt;/code>.
At the time of writing this document, there is no functionality for garbage collection based on disk size - e.g. garbage collecting images when a certain disk usage threshold is passed.&lt;/p>
&lt;h2 id="increase-the-cache-disk-size">Increase the cache disk size&lt;/h2>
&lt;p>When there is no available disk space, the registry cache continues to respond to requests. However, it cannot store the remotely fetched images locally because it has no free disk space. In such case, it is simply acting as a proxy without being able to cache the images in its local store. The disk has to be resized to ensure that the registry cache continues to cache images.&lt;/p>
&lt;p>There are two alternatives to enlarge the cache&amp;rsquo;s disk size.&lt;/p>
&lt;h4 id="alternative-1-resize-the-pvc">[Alternative 1] Resize the PVC&lt;/h4>
&lt;p>To enlarge the PVC&amp;rsquo;s size follow the following steps:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Make sure that the &lt;code>KUBECONFIG&lt;/code> environment variable is targeting the correct Shoot cluster.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Find the PVC name to resize for the desired upstream. The below example fetches the PVC for the &lt;code>docker.io&lt;/code> upstream:&lt;/p>
&lt;pre tabindex="0">&lt;code>% kubectl -n kube-system get pvc -l upstream-host=docker.io
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>Patch the PVC&amp;rsquo;s size to the desired size. The below example patches the size of a PVC to &lt;code>10Gi&lt;/code>:&lt;/p>
&lt;pre tabindex="0">&lt;code>% kubectl -n kube-system patch pvc $PVC_NAME --type merge -p &amp;#39;{&amp;#34;spec&amp;#34;:{&amp;#34;resources&amp;#34;:{&amp;#34;requests&amp;#34;: {&amp;#34;storage&amp;#34;: &amp;#34;10Gi&amp;#34;}}}}&amp;#39;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>Make sure that the PVC gets resized. Describe the PVC to check the resize operation result:&lt;/p>
&lt;pre tabindex="0">&lt;code>% kubectl -n kube-system describe pvc -l upstream-host=docker.io
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Drawback of this approach: The cache&amp;rsquo;s size in the Shoot spec (&lt;code>providerConfig.caches[].size&lt;/code>) diverges from the PVC&amp;rsquo;s size.&lt;/p>
&lt;/blockquote>
&lt;h4 id="alternative-2-remove-and-re-add-the-cache">[Alternative 2] Remove and re-add the cache&lt;/h4>
&lt;p>There is always the option to remove the cache from the Shoot spec and to re-add it again with the updated size.&lt;/p>
&lt;blockquote>
&lt;p>Drawback of this approach: The already cached images get lost and the cache starts with an empty disk.&lt;/p>
&lt;/blockquote>
&lt;h2 id="high-availability">High-availability&lt;/h2>
&lt;p>The registry cache runs with a single replica. This fact may lead to concerns for the high-availability such as &amp;ldquo;What happens when the registry cache is down? Does containerd fail to pull the image?&amp;rdquo;. As outlined in the &lt;a href="#how-does-it-work">How does it work? section&lt;/a>, containerd is configured to fall back to the upstream registry if it fails to pull the image from the registry cache. Hence, when the registry cache is unavailable, the containerd&amp;rsquo;s image pull operations are not affected because containerd falls back to image pull from the upstream registry.&lt;/p>
&lt;h2 id="gotchas">Gotchas&lt;/h2>
&lt;ul>
&lt;li>The used registry implementation (&lt;a href="https://github.com/distribution/distribution">distribution/distribution&lt;/a>) supports mirroring of only one upstream registry. The extension deploys a pull-through cache for each configured upstream.&lt;/li>
&lt;li>&lt;code>gcr.io&lt;/code>, &lt;code>us.gcr.io&lt;/code>, &lt;code>eu.gcr.io&lt;/code>, and &lt;code>asia.gcr.io&lt;/code> are different upstreams. Hence, configuring &lt;code>gcr.io&lt;/code> as upstream won&amp;rsquo;t cache images from &lt;code>us.gcr.io&lt;/code>, &lt;code>eu.gcr.io&lt;/code>, or &lt;code>asia.gcr.io&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="limitations">Limitations&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Images that are pulled before a registry cache Pod is running or before a registry cache Service is reachable from the corresponding Node won&amp;rsquo;t be cached - containerd will pull these images directly from the upstream.&lt;/p>
&lt;p>The reasoning behind this limitation is that a registry cache Pod is running in the Shoot cluster. To have a registry cache&amp;rsquo;s Service cluster IP reachable from containerd running on the Node, the registry cache Pod has to be running and kube-proxy has to configure iptables/IPVS rules for the registry cache Service. If kube-proxy hasn&amp;rsquo;t configured iptables/IPVS rules for the registry cache Service, then the image pull times (and new Node bootstrap times) will be increased significantly. For more detailed explanations, see point 2. and &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/pull/68">https://github.com/gardener/gardener-extension-registry-cache/pull/68&lt;/a>.&lt;/p>
&lt;p>That&amp;rsquo;s why the registry configuration on a Node is applied only after the registry cache Service is reachable from the Node. The &lt;code>configure-containerd-registries.service&lt;/code> systemd unit sends requests to the registry cache&amp;rsquo;s Service. Once the registry cache responds with &lt;code>HTTP 200&lt;/code>, the unit creates the needed registry configuration file (&lt;code>hosts.toml&lt;/code>).&lt;/p>
&lt;p>As a result, for images from Shoot system components:&lt;/p>
&lt;ul>
&lt;li>On Shoot creation with the registry cache extension enabled a registry cache is unable to cache all of the images from the Shoot system components. Usually, until the registry cache Pod is running containerd pulls from upstream the images from Shoot system components (before the registry configuration gets applied).&lt;/li>
&lt;li>On new Node creation for existing Shoot with the registry cache extension enabled, a registry cache is unable to cache most of the images from Shoot system components. The reachability of the registry cache Service requires the Service network to be set up, i.e. the kube-proxy for that new Node to be running and to have set up iptables/IPVS configuration for the registry cache Service.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>containerd requests will time out in 30s in case kube-proxy hasn&amp;rsquo;t configured iptables/IPVS rules for the registry cache Service - the image pull times will increase significantly.&lt;/p>
&lt;p>containerd is configured to fall back to the upstream itself if a request against the cache fails. However, if the cluster IP of the registry cache Service does not exist or if kube-proxy hasn&amp;rsquo;t configured iptables/IPVS rules for the registry cache Service, then containerd requests against the registry cache time out in 30 seconds. This increases significantly the image pull times because containerd does multiple requests as part of the image pull (HEAD request to resolve the manifest by tag, GET request for the manifest by SHA, GET requests for blobs)&lt;/p>
&lt;p>Example: If the Service of a registry cache is deleted, then a new Service will be created. containerd registry config will still contain the old Service&amp;rsquo;s cluster IP. containerd requests against the old Service&amp;rsquo;s cluster IP will time out and containerd will fall back to upstream.&lt;/p>
&lt;ul>
&lt;li>Image pull of &lt;code>docker.io/library/alpine:3.13.2&lt;/code> from the upstream takes ~2s while image pull of the same image with invalid registry cache cluster IP takes ~2m.2s.&lt;/li>
&lt;li>Image pull of &lt;code>eu.gcr.io/gardener-project/gardener/ops-toolbelt:0.18.0&lt;/code> from the upstream takes ~10s while image pull of the same image with invalid registry cache cluster IP takes ~3m.10s.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: Extension Registry Cache</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/extension-registry-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/extension-registry-cache/</guid><description>
&lt;h1 id="developer-docs-for-gardener-extension-registry-cache">Developer Docs for Gardener Extension Registry Cache&lt;/h1>
&lt;p>This document outlines how the Shoot reconciliation and deletion work for a Shoot with the registry-cache extension enabled.&lt;/p>
&lt;h2 id="shoot-reconciliation">Shoot reconciliation&lt;/h2>
&lt;p>This section outlines how the reconciliation works for a Shoot with the registry-cache extension enabled.&lt;/p>
&lt;h4 id="extension-enablementreconciliation">Extension enablement/reconciliation&lt;/h4>
&lt;p>This section outlines how the extension enablement/reconciliation works, e.g the extension has beeen added to the Shoot spec.&lt;/p>
&lt;ol>
&lt;li>As part of the Shoot reconciliation flow, gardenlet deploys the &lt;a href="https://github.com/gardener/gardener/blob/v1.82.0/docs/extensions/extension.md">Extension&lt;/a> resource.&lt;/li>
&lt;li>The registry-cache extension reconciles the Extension resource. &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/controller/extension/actuator.go">pkg/controller/extension/actuator.go&lt;/a> contains the implementation of the &lt;a href="https://github.com/gardener/gardener/blob/v1.82.0/extensions/pkg/controller/extension/actuator.go">extension.Actuator&lt;/a> interface. The reconciliation of an Extension of type &lt;code>registry-cache&lt;/code> consists of the following steps:
&lt;ol>
&lt;li>The extension checks if a registry has been removed (by comparing the status and the spec of the Extension). If an upstream is being removed, then it deploys the &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/component/registryconfigurationcleaner/registry_configuration_cleaner.go">&lt;code>registry-cleaner&lt;/code> DaemonSet&lt;/a> to the Shoot cluster to clean up the existing configuration for the upstream that has to be removed.&lt;/li>
&lt;li>The registry-cache extension deploys resources to the Shoot cluster via ManagedResource. For every configured upstream it creates a StatefulSet (with PVC), Service and other resources.&lt;/li>
&lt;li>It lists all Services from the &lt;code>kube-system&lt;/code> namespace having the &lt;code>upstream-host&lt;/code> label. It will return an error (and retry in exponential backoff) until the Services count matches the configured registries count.&lt;/li>
&lt;li>When there is a Service created for each configured upstream registry, the registry-cache extension populates the Extension resource status. In the Extension status, for each upstream, it maintains an endpoint (in format &lt;code>http://&amp;lt;cluster-ip&amp;gt;:5000&lt;/code>) which can be used to access the registry cache from within the Shoot cluster. &lt;code>&amp;lt;cluster-ip&amp;gt;&lt;/code> is the cluster IP of the registry cache Service. The cluster IP of a Service is assigned by the Kubernetes API server on Service creation.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>As part of the Shoot reconciliation flow, gardenlet deploys the &lt;a href="https://github.com/gardener/gardener/blob/v1.82.0/docs/extensions/operatingsystemconfig.md">OperatingSystemConfig&lt;/a> resource.&lt;/li>
&lt;li>The registry-cache extension serves a webhook that mutates the OperatingSystemConfig resource for Shoots having the registry-cache extension enabled (the corresponding namespace gets labeled by gardenlet with &lt;code>extensions.gardener.cloud/registry-cache=true&lt;/code>). &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/webhook/operatingsystemconfig/ensurer.go">pkg/webhook/operatingsystemconfig/ensurer.go&lt;/a> contains implementation of the &lt;a href="https://github.com/gardener/gardener/blob/v1.82.0/extensions/pkg/webhook/controlplane/genericmutator/mutator.go">genericmutator.Ensurer&lt;/a> interface.
&lt;ol>
&lt;li>The webhook appends the &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/webhook/operatingsystemconfig/scripts/configure-containerd-registries.sh">configure-containerd-registries.sh&lt;/a> script to the OperatingSystemConfig files. The script accepts registries in the format &lt;code>&amp;lt;upstream_host&amp;gt;,&amp;lt;registry_cache_endpoint&amp;gt;,&amp;lt;upstream_url&amp;gt;&lt;/code> separated by a space. For each given registry the script waits until the given registry is available (a request to the &lt;code>&amp;lt;registry_cache_endpoint&amp;gt;&lt;/code> succeeds). Then it creates a &lt;code>hosts.toml&lt;/code> file for the given &lt;code>&amp;lt;upstream_host&amp;gt;&lt;/code>. In short, the &lt;code>hosts.toml&lt;/code> file instructs containerd to first try to pull images for the given &lt;code>&amp;lt;upstream_host&amp;gt;&lt;/code> from the configured &lt;code>&amp;lt;registry_cache_endpoint&amp;gt;&lt;/code>. For more information about containerd registry configuration, see the &lt;a href="https://github.com/containerd/containerd/blob/main/docs/hosts.md">containerd documentation&lt;/a>. The motivation to introduce the &lt;code>configure-containerd-registries.sh&lt;/code> script is that we need to create the &lt;code>hosts.toml&lt;/code> file when the corresponding registry is available. For more details, see &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/pull/68">https://github.com/gardener/gardener-extension-registry-cache/pull/68&lt;/a>.&lt;/li>
&lt;li>The webhook appends the &lt;code>configure-containerd-registries.service&lt;/code> unit to the OperatingSystemConfig units. The webhook fetches the Extension resource and then it configures the unit to invoke the &lt;code>configure-containerd-registries.sh&lt;/code> script with the registries from the Extension status.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h4 id="extension-disablement">Extension disablement&lt;/h4>
&lt;p>This section outlines how the extension disablement works, i.e the extension has be removed from the Shoot spec.&lt;/p>
&lt;ol>
&lt;li>As part of the Shoot reconciliation flow, gardenlet destroys the &lt;a href="https://github.com/gardener/gardener/blob/v1.82.0/docs/extensions/extension.md">Extension&lt;/a> resource because it is no longer needed.
&lt;ol>
&lt;li>If the Extension resource contains registries in its status, the registry-cache extension deploys the &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/component/registryconfigurationcleaner/registry_configuration_cleaner.go">&lt;code>registry-cleaner&lt;/code> DaemonSet&lt;/a> to the Shoot cluster to clean up the existing registry configuration.&lt;/li>
&lt;li>The extension deletes the ManagedResource containing the registry cache resources.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="shoot-deletion">Shoot deletion&lt;/h2>
&lt;p>This section outlines how the deletion works for a Shoot with the registry-cache extension enabled.&lt;/p>
&lt;ol>
&lt;li>As part of the Shoot deletion flow, gardenlet destroys the &lt;a href="https://github.com/gardener/gardener/blob/v1.82.0/docs/extensions/extension.md">Extension&lt;/a> resource.
&lt;ol>
&lt;li>In the Shoot deletion flow the Extension resource is deleted after the Worker resource. Hence, there is no need to deploy the &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/pkg/component/registryconfigurationcleaner/registry_configuration_cleaner.go">&lt;code>registry-cleaner&lt;/code> DaemonSet&lt;/a> to the Shoot cluster to clean up the existing registry configuration.&lt;/li>
&lt;li>The extension deletes the ManagedResource containing the registry cache resources.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol></description></item><item><title>Docs: Getting Started Locally</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/getting-started-locally/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/getting-started-locally/</guid><description>
&lt;h1 id="deploying-registry-cache-extension-locally">Deploying Registry Cache Extension Locally&lt;/h1>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;ul>
&lt;li>Make sure that you have a running local Gardener setup. The steps to complete this can be found in the &lt;a href="https://gardener.cloud/docs/gardener/deployment/getting_started_locally/">Deploying Gardener Locally guide&lt;/a>.&lt;/li>
&lt;/ul>
&lt;h2 id="setting-up-the-registry-cache-extension">Setting up the Registry Cache Extension&lt;/h2>
&lt;p>Make sure that your &lt;code>KUBECONFIG&lt;/code> environment variable is targeting the local Gardener cluster. When this is ensured, run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make extension-up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The corresponding make target will build the extension image, load it into the kind cluster Nodes, and deploy the registry-cache ControllerDeployment and ControllerRegistration resources. The container image in the ControllerDeployment will be the image that was build and loaded into the kind cluster Nodes.&lt;/p>
&lt;p>The make target will then deploy then registry-cache admission component. It will build the admission image, load it into the kind cluster Nodes, and finally install the admission component charts to the kind cluster.&lt;/p>
&lt;h2 id="creating-a-shoot-cluster">Creating a &lt;code>Shoot&lt;/code> Cluster&lt;/h2>
&lt;p>Once the above step is completed you can create a Shoot cluster. Review the Shoot specification in &lt;a href="https://github.com/gardener/gardener-extension-registry-cache/blob/main/example/shoot.yaml">&lt;code>example/shoot.yaml&lt;/code>&lt;/a>. Create the Shoot:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kubectl create -f example/shoot.yaml
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="tearing-down-the-dev-environment">Tearing Down the Dev Environment&lt;/h2>
&lt;p>To tear down the development environment delete the Shoot cluster or disable the &lt;code>registry-cache&lt;/code> extension in the Shoot&amp;rsquo;s specification. When the extension is not used by the Shoot anymore, you can run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make extension-down
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The make target will delete the ControllerDeployment and ControllerRegistration of the extension, and the registry-cache admission helm deployment.&lt;/p></description></item><item><title>Docs: Migration From V1alpha1 To V1alpha2</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/migration-from-v1alpha1-to-v1alpha2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/migration-from-v1alpha1-to-v1alpha2/</guid><description>
&lt;h1 id="migration-from-v1alpha1-to-v1alpha2">Migration from &lt;code>v1alpha1&lt;/code> to &lt;code>v1alpha2&lt;/code>&lt;/h1>
&lt;p>This document descibres how to migrate from API version &lt;code>registry.extensions.gardener.cloud/v1alpha1&lt;/code> of the &lt;code>RegistryConfig&lt;/code> to &lt;code>registry.extensions.gardener.cloud/v1alpha2&lt;/code>.&lt;/p>
&lt;p>The &lt;code>registry.extensions.gardener.cloud/v1alpha1&lt;/code> is deprecated and will be removed in a future version. Use &lt;code>registry.extensions.gardener.cloud/v1alpha2&lt;/code> instead.&lt;/p>
&lt;p>Let&amp;rsquo;s first inspect how the &lt;code>RegistryConfig&lt;/code> looks like in API version &lt;code>registry.extensions.gardener.cloud/v1alpha1&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: registry.extensions.gardener.cloud/v1alpha1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: RegistryConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>caches:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: 10Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> garbageCollection:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enabled: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretReferenceName: docker-credentials
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The translation of the above &lt;code>RegistryConfig&lt;/code> in API version &lt;code>registry.extensions.gardener.cloud/v1alpha2&lt;/code> is:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: registry.extensions.gardener.cloud/v1alpha2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: RegistryConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>caches:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: 10Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> storageClassName: default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> garbageCollection:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enabled: &lt;span style="color:#00f">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretReferenceName: docker-credentials
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can notice, there is one breaking change in API version &lt;code>registry.extensions.gardener.cloud/v1alpha2&lt;/code> - the &lt;code>caches[].size&lt;/code> field is moved to &lt;code>caches[].volume.size&lt;/code>.&lt;/p>
&lt;p>&lt;code>registry.extensions.gardener.cloud/v1alpha2&lt;/code> also adds a new field &lt;code>caches[].volume.storageClassName&lt;/code>. In &lt;code>v1alpha1&lt;/code> the StorageClass name was not configurable and the registry-cache extension assumed the StorageClass name to be &lt;code>default&lt;/code>. When migrating from &lt;code>v1alpha1&lt;/code> to &lt;code>v1alpha2&lt;/code>, the &lt;code>caches[].volume.storageClassName&lt;/code> field has to be set to &lt;code>default&lt;/code>. This is required due to backwards-compatibility reasons for registry caches created according to the &lt;code>v1alpha1&lt;/code> API version.&lt;/p></description></item><item><title>Docs: Upstream Credentials</title><link>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/upstream-credentials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/extensions/others/gardener-extension-registry-cache/upstream-credentials/</guid><description>
&lt;h1 id="how-to-provide-credentials-for-upstream-registry">How to provide credentials for upstream registry?&lt;/h1>
&lt;p>In order to pull private images through registry cache, it is required to supply credentials for the private upstream registry.&lt;/p>
&lt;h2 id="how-to-configure-the-registry-cache-to-use-upstream-registry-credentials">How to configure the registry cache to use upstream registry credentials?&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Create an immutable Secret with the upstream registry credentials&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>% kubectl create -f - &lt;span style="color:#a31515">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">apiVersion: v1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">kind: Secret
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">metadata:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> name: ro-docker-secret-v1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> namespace: garden-dev
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">type: Opaque
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">immutable: true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">data:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> username: $(echo -n $USERNAME | base64 -w0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515"> password: $(echo -n $PASSWORD | base64 -w0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a31515">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For GCR, the username is &lt;code>_json_key&lt;/code> and the password is the service account key in JSON format. To base64 encode the service account key, copy it and run:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>% echo -n $SERVICE_ACCOUNT_KEY_JSON | base64 -w0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Add the newly created Secret as a reference to the Shoot spec, and then to the registry-cache extension configuration&lt;/p>
&lt;p>In the registry-cache configuration set the &lt;code>secretReferenceName&lt;/code> field. It should point to a resource reference under &lt;code>spec.resources&lt;/code>. The resource reference itself points to the Secret in project namespace.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>apiVersion: core.gardener.cloud/v1beta1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kind: Shoot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spec:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extensions:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - type: registry-cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> providerConfig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: registry.extensions.gardener.cloud/v1alpha2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: RegistryConfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> caches:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - upstream: docker.io
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> secretReferenceName: docker-secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - name: docker-secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceRef:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> apiVersion: v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kind: Secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: ro-docker-secret-v1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#008000"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="how-to-rotate-the-registry-credentials">How to rotate the registry credentials?&lt;/h2>
&lt;p>To rotate registry credentials perform the following steps:&lt;/p>
&lt;ol>
&lt;li>Generate new pair of credentials in the cloud provider account. Do not invalidate the old ones.&lt;/li>
&lt;li>Create a new Secret (e.g. &lt;code>ro-docker-secret-v2&lt;/code>) with the newly generated credentials as described step 1. in &lt;a href="#how-to-configure-the-registry-cache-to-use-upstream-registry-credentials">How to configure the registry cache to use upstream registry credentials?&lt;/a>.&lt;/li>
&lt;li>Update the Shoot spec with newly created Secret as described step 2. in &lt;a href="#how-to-configure-the-registry-cache-to-use-upstream-registry-credentials">How to configure the registry cache to use upstream registry credentials?&lt;/a>.
1 The above step will trigger a Shoot reconciliation. Wait for the Shoot reconciliation to complete.&lt;/li>
&lt;li>Make sure that the old Secret is no longer referenced by any Shoot cluster. Finally, delete the Secret containing the old credentials (e.g. &lt;code>ro-docker-secret-v1&lt;/code>).&lt;/li>
&lt;li>Delete the corresponding old credentials from the cloud provider account.&lt;/li>
&lt;/ol>
&lt;h2 id="gotchas">Gotchas&lt;/h2>
&lt;ul>
&lt;li>The registry cache provides the credentials for every request against the corresponding upstream. In some cases, misconfigured credentials can prevent the registry cache to pull even public images from the upstream (for example: invalid service account key for GCR). However, this behaviour is controlled by the server-side logic of the upstream registry.&lt;/li>
&lt;/ul></description></item></channel></rss>