<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener – Concepts</title><link>https://gardener.cloud/docs/dashboard/concepts/</link><description>Recent content in Concepts on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/dashboard/concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Webterminals</title><link>https://gardener.cloud/docs/dashboard/concepts/webterminals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/dashboard/concepts/webterminals/</guid><description>
&lt;h1 id="webterminals">Webterminals&lt;/h1>
&lt;img width="180" alt="gardener-terminal-ascii" src="https://user-images.githubusercontent.com/5526658/66032047-ecfacc80-e504-11e9-9864-57d4f0bbaf5d.png">
&lt;h2 id="architecture-overview">Architecture Overview&lt;/h2>
&lt;img src="https://gardener.cloud/__resources/webterminals-1_a34bff.png">
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>We want to give garden operators and &amp;ldquo;regular&amp;rdquo; users of the Gardener dashboard an easy way to have a preconfigured shell directly in the browser.&lt;/p>
&lt;p>This has several advantages:&lt;/p>
&lt;ul>
&lt;li>no need to set up any tools locally&lt;/li>
&lt;li>no need to download / store kubeconfigs locally&lt;/li>
&lt;li>Each terminal session will have its own &amp;ldquo;access&amp;rdquo; service account created. This makes it easier to see &amp;ldquo;who&amp;rdquo; did &amp;ldquo;what&amp;rdquo; when using the web terminals.&lt;/li>
&lt;li>The &amp;ldquo;access&amp;rdquo; service account is deleted when the terminal session expires&lt;/li>
&lt;li>Easy &amp;ldquo;privileged&amp;rdquo; access to a node (privileged container, hostPID, and hostNetwork enabled, mounted host root fs) in case of troubleshooting node. If allowed by PSP.&lt;/li>
&lt;/ul>
&lt;h2 id="how-its-done---tldr">How it&amp;rsquo;s done - TL;DR&lt;/h2>
&lt;p>On the host cluster, we schedule a pod to which the dashboard frontend client attaches to (similar to &lt;code>kubectl attach&lt;/code>). Usually the &lt;a href="https://github.com/gardener/ops-toolbelt/">&lt;code>ops-toolbelt&lt;/code>&lt;/a> image is used, containing all relevant tools like &lt;code>kubectl&lt;/code>. The Pod has a kubeconfig secret mounted with the necessary privileges for the target cluster - usually &lt;code>cluster-admin&lt;/code>.&lt;/p>
&lt;h2 id="target-types">Target types&lt;/h2>
&lt;p>There are currently three targets, where a user can open a terminal session to:&lt;/p>
&lt;ul>
&lt;li>The (virtual) garden cluster - Currently operator only&lt;/li>
&lt;li>The shoot cluster&lt;/li>
&lt;li>The control plane of the shoot cluster - operator only&lt;/li>
&lt;/ul>
&lt;h2 id="host">Host&lt;/h2>
&lt;p>There are different factors on where the host cluster (and namespace) is chosen by the dashboard:&lt;/p>
&lt;ul>
&lt;li>Depending on, the selected target and the role of the user (operator or &amp;ldquo;regular&amp;rdquo; user) the host is chosen.&lt;/li>
&lt;li>For performance / low latency reasons, we want to place the &amp;ldquo;terminal&amp;rdquo; pods as near as possible to the target kube-apiserver.&lt;/li>
&lt;/ul>
&lt;p>For example, the user wants to have a terminal for a shoot cluster. The kube-apiserver of the shoot is running in the seed-shoot-ns on the seed.&lt;/p>
&lt;ul>
&lt;li>If the user is an operator, we place the &amp;ldquo;terminal&amp;rdquo; pod directly in the seed-shoot-ns on the seed.&lt;/li>
&lt;li>However, if the user is a &amp;ldquo;regular&amp;rdquo; user, we don’t want to have &amp;ldquo;untrusted&amp;rdquo; workload scheduled on the seeds, that&amp;rsquo;s why the &amp;ldquo;terminal&amp;rdquo; pod is scheduled on the shoot itself, in a temporary namespace that is deleted afterwards.&lt;/li>
&lt;/ul>
&lt;h2 id="lifecycle-of-a-web-terminal-session">Lifecycle of a Web Terminal Session&lt;/h2>
&lt;h3 id="1-browser--dashboard-frontend---open-terminal">1. Browser / Dashboard Frontend - Open Terminal&lt;/h3>
&lt;p>User chooses the target and clicks in the browser on &lt;code>Open terminal&lt;/code> button. A POST request is made to the dashboard backend to request a new terminal session.&lt;/p>
&lt;h3 id="2-dashboard-backend---create-terminal-resource">2. Dashboard Backend - Create Terminal Resource&lt;/h3>
&lt;p>According to the privileges of the user (operator / enduser) and the selected target, the dashboard backend creates a &lt;code>terminal&lt;/code> resource &lt;strong>on behalf of the user&lt;/strong> in the (virtual) garden and responds with a handle to the terminal session.&lt;/p>
&lt;h3 id="3-browser--dashboard-frontend">3. Browser / Dashboard Frontend&lt;/h3>
&lt;p>The frontend makes another POST request to the dashboard backend to fetch the terminal session. The Backend waits until the &lt;code>terminal&lt;/code> resource is in a &amp;ldquo;ready&amp;rdquo; state (timeout 10s) before sending a response to the frontend. More to that later.&lt;/p>
&lt;h3 id="4-terminal-resource">4. Terminal Resource&lt;/h3>
&lt;p>The &lt;code>terminal&lt;/code> resource, among other things, holds the information of the desired host and target cluster. The credentials to these clusters are declared as references (secretRef / serviceAccountRef). The &lt;code>terminal&lt;/code> resource itself doesn’t contain sensitive information.&lt;/p>
&lt;h3 id="5-admission">5. Admission&lt;/h3>
&lt;p>A validating webhook is in place to ensure that the user, that created the &lt;code>terminal&lt;/code> resource, has the &lt;strong>permission to read the referenced credentials&lt;/strong>. There is also a mutating webhook in place. Both admission configurations have &lt;strong>&lt;code>failurePolicy: Fail&lt;/code>&lt;/strong>.&lt;/p>
&lt;h3 id="6-terminal-controller-manager---apply-resources-on-host--target-cluster">6. Terminal-Controller-Manager - Apply Resources on Host &amp;amp; Target Cluster&lt;/h3>
&lt;p>&lt;em>Sidenote: The terminal-controller-manager has no knowledge about the gardener, its shoots, and seeds. In that sense it can be considered as independent from the gardener.&lt;/em>&lt;/p>
&lt;p>The &lt;a href="https://github.com/gardener/terminal-controller-manager">terminal-controller-manager&lt;/a> watches &lt;code>terminal&lt;/code> resources and ensures the desired state on the host and target cluster. The terminal-controller-manager needs the permission to read all secrets / service accounts in the virtual garden.
As additional safety net, the &lt;strong>terminal-controller-manager&lt;/strong> ensures that the &lt;code>terminal&lt;/code> resource was not created before the admission configurations were created.&lt;/p>
&lt;p>The terminal-controller-manager then creates the necessary resources in the host and target cluster.&lt;/p>
&lt;ul>
&lt;li>Target Cluster:
&lt;ul>
&lt;li>&amp;ldquo;Access&amp;rdquo; service account + (cluster)rolebinding usually to &lt;code>cluster-admin&lt;/code> cluster role
&lt;ul>
&lt;li>used from within the &amp;ldquo;terminal&amp;rdquo; pod&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Host Cluster:
&lt;ul>
&lt;li>&amp;ldquo;Attach&amp;rdquo; service Account + rolebinding to &amp;ldquo;attach&amp;rdquo; cluster role (privilege to attach and get pod)
&lt;ul>
&lt;li>will be used by the browser to attach to the pod&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Kubeconfig secret, containing the &amp;ldquo;access&amp;rdquo; token from the target cluster&lt;/li>
&lt;li>The &amp;ldquo;terminal&amp;rdquo; pod itself, having the kubeconfig secret mounted&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="7-dashboard-backend---responds-to-frontend">7. Dashboard Backend - Responds to Frontend&lt;/h3>
&lt;p>As mentioned in step 3, the dashboard backend waits until the &lt;code>terminal&lt;/code> resource is &amp;ldquo;ready&amp;rdquo;. It then reads the &amp;ldquo;attach&amp;rdquo; token from the host cluster &lt;strong>on behalf of the user&lt;/strong>.
It responds with:&lt;/p>
&lt;ul>
&lt;li>attach token&lt;/li>
&lt;li>hostname of the host cluster&amp;rsquo;s api server&lt;/li>
&lt;li>name of the pod and namespace&lt;/li>
&lt;/ul>
&lt;h3 id="8-browser--dashboard-frontend---attach-to-pod">8. Browser / Dashboard Frontend - Attach to Pod&lt;/h3>
&lt;p>Dashboard frontend attaches to the pod located on the host cluster by opening a WebSocket connection using the provided parameter and credentials.
As long as the terminal window is open, the dashboard regularly annotates the &lt;code>terminal&lt;/code> resource (heartbeat) to keep it alive.&lt;/p>
&lt;h3 id="9-terminal-controller-manager---cleanup">9. Terminal-Controller-Manager - Cleanup&lt;/h3>
&lt;p>When there is no heartbeat on the &lt;code>terminal&lt;/code> resource for a certain amount of time (default is &lt;code>5m&lt;/code>) the created resources in the host and target cluster are cleaned up again and the &lt;code>terminal&lt;/code> resource will be deleted.&lt;/p>
&lt;h2 id="browser-trusted-certificates-for-kube-apiservers">Browser Trusted Certificates for Kube-Apiservers&lt;/h2>
&lt;h3 id="motivation-1">Motivation&lt;/h3>
&lt;p>The dashboard frontend opens up a secure WebSocket connection to the kube-apiserver. The certificate presented by the kube-apiserver must be browser trusted, otherwise the connection can&amp;rsquo;t be established (rejected by browser policy).
Most kube-apiservers have self-signed certificates from a custom Root CA.&lt;/p>
&lt;h3 id="bootstrapping">Bootstrapping&lt;/h3>
&lt;h4 id="preferred-solution">Preferred Solution&lt;/h4>
&lt;p>There is an &lt;a href="https://github.com/gardener/gardener/issues/1413">issue&lt;/a> on the gardener component, to have browser trusted certificates for shoot kube-apiservers using SNI and certmanager.
However, this would solve the issue for shoots and shooted-seeds, but not for soil and plant kube-apiservers and potentially others.&lt;/p>
&lt;h4 id="current-solution">Current Solution&lt;/h4>
&lt;p>We had to &amp;ldquo;workaround&amp;rdquo; it by creating ingress resources for the kube-apiservers and letting the certmanager (or the new &lt;a href="https://github.com/gardener/gardener-extension-shoot-cert-service">shoot cert service&lt;/a>) request browser trusted certificates.&lt;/p></description></item></channel></rss>