<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=canonical type=text/html href=https://gardener.cloud/docs/gardener/concepts/><link rel=alternate type=application/rss+xml href=https://gardener.cloud/docs/gardener/concepts/index.xml><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=icon type=image/x-icon href=https://gardener.cloud/images/favicon.ico><link rel=icon type=image/png href=https://gardener.cloud/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://gardener.cloud/images/favicon-16x16.png sizes=16x16><title>Concepts | Gardener</title><meta name=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:title" content="Concepts"><meta property="og:description" content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:type" content="website"><meta property="og:url" content="https://gardener.cloud/docs/gardener/concepts/"><meta itemprop=name content="Concepts"><meta itemprop=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta name=twitter:card content="summary"><meta name=twitter:title content="Concepts"><meta name=twitter:description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><link rel=preload href=/scss/main.min.ca2e9ddee7809848b536632b41e4e4df665800778ffe11b75edde5bdd6c78963.css as=style><link href=/scss/main.min.ca2e9ddee7809848b536632b41e4e4df665800778ffe11b75edde5bdd6c78963.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://unpkg.com/lunr@2.3.8/lunr.min.js integrity=sha384-vRQ9bDyE0Wnu+lMfm57BlYLO0/XauFuKpVsZPs7KEDwYKktWi5+Kz3MP8++DFlRY crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg width="90" height="90" viewBox="0 0 90 90" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>logo</title><desc>Created with Sketch.</desc><defs><path d="M41.8864954.994901575c.996545099999999-.479910833 2.6164002-.477918931 3.6088091.0L76.8159138 16.0781121C77.8124589 16.5580229 78.8208647 17.8257185 79.0659694 18.8995926l7.7355517 33.8916663C87.0476474 53.8696088 86.6852538 55.4484075 85.9984855 56.3095876L64.3239514 83.4885938C63.6343208 84.3533632 62.1740175 85.0543973 61.0725268 85.0543973H26.3092731c-1.1060816.0-2.5646564-.704623400000003-3.2514246-1.5658035L1.38331434 56.3095876C.693683723 55.4448182.335174016 53.865133.580278769 52.7912589L8.31583044 18.8995926C8.56195675 17.8212428 9.57347722 16.556031 10.5658861 16.0781121L41.8864954.994901575z" id="path-1"/><linearGradient x1="12.7542673%" y1="-18.6617048%" x2="88.2666158%" y2="84.6075483%" id="linearGradient-3"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="50%" y1="4.93673768%" x2="148.756007%" y2="175.514523%" id="linearGradient-4"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="19.1574381%" y1="-9.04800713%" x2="82.2203149%" y2="77.9084293%" id="linearGradient-5"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="57.4403751%" y1="26.3148481%" x2="137.966711%" y2="158.080556%" id="linearGradient-6"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><g id="Rectangle-2" transform="translate(1.000000, 0.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Mask" fill="#009f76" xlink:href="#path-1"/><polygon fill="#000" opacity=".289628623" mask="url(#mask-2)" points="-17.6484375 54.5224609 30.8242188 25.0791016 63.4726562 58.5 24.7324219 92.6689453"/></g><path d="M56.8508631 39.260019C56.4193519 40.443987 55.6088085 41.581593 54.6736295 42.1938694l-8.0738997 5.2861089c-1.3854671.907087099999998-3.6247515.9116711-5.0172201.0L33.50861 42.1938694C32.123143 41.2867823 31 39.206345 31 37.545932V26.4150304c0-.725313.2131118-1.5301454.569268099999999-2.2825772L56.8508631 39.260019z" id="Combined-Shape" fill="url(#linearGradient-3)" transform="translate(43.925432, 36.147233) scale(-1, 1) translate(-43.925432, -36.147233)"/><path d="M56.0774672 25.1412464C56.4306829 25.8903325 56.6425556 26.6907345 56.6425556 27.4119019V38.5428034c0 1.6598979-1.1161415 3.73626640000001-2.50861 4.6479374l-8.0738997 5.286109c-1.3854671.907087000000004-3.6247516.911671000000005-5.0172201.0L32.9689261 43.1907408C32.2918101 42.7474223 31.6773514 42.0238435 31.2260376 41.206007L56.0774672 25.1412464z" id="Combined-Shape" fill="url(#linearGradient-4)" transform="translate(43.821278, 37.246598) scale(-1, 1) translate(-43.821278, -37.246598)"/><path d="M65.0702134 57.1846889C64.5985426 58.2007851 63.8367404 59.1236871 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.1597438 58.7930183 24 56.7816693 24 55.1323495V37.1145303C24 36.3487436 24.249712 35.5060005 24.6599102 34.7400631L65.0702134 57.1846889z" id="Combined-Shape" fill="url(#linearGradient-5)"/><path d="M65.0189476 34.954538C65.3636909 35.6617313 65.5692194 36.42021 65.5692194 37.1145303V55.1323495C65.5692194 56.7842831 64.4072119 58.7943252 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.9237304 59.2341061 25.3159155 58.5918431 24.8568495 57.8487596L65.0189476 34.954538z" id="Combined-Shape" fill="url(#linearGradient-6)"/></g></g></svg></span><span class=text-capitalize>Gardener</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/adopter><span>Adopters</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/blog><span>Blogs</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community><span>Community</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/docs><span>Documentation</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002; Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.2035d9813dafac83fe2a48b18d50f237.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/gardener/concepts/>Return to the regular view of this page</a>.</p></div><h1 class=title>Concepts</h1><div class=content></div></div><div class=td-content><h1 id=pg-ccbcc1039e04b807c6daf64b9352f3d3>1 - Admission Controller</h1><h1 id=gardener-admission-controller>Gardener Admission Controller</h1><p>While the Gardener API server works with <a href=/docs/gardener/concepts/apiserver_admission_plugins/>admission plugins</a> to validate and mutate resources belonging to Gardener related API groups, e.g. <code>core.gardener.cloud</code>, the same is needed for resources belonging to non-Gardener API groups as well, e.g. <code>Secret</code>s in the <code>core</code> API group.
Therefore, the Gardener Admission Controller runs a http(s) server with the following handlers which serve as validating/mutating endpoints for <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>admission webhooks</a>.
It is also used to serve http(s) handlers for authorization webhooks.</p><h2 id=admission-webhook-handlers>Admission Webhook Handlers</h2><p>This section describes the admission webhook handlers that are currently served.</p><h3 id=kubeconfig-secret-validator>Kubeconfig Secret Validator</h3><p><a href=https://github.com/kubernetes/kubectl/issues/697>Malicious Kubeconfigs</a> applied by end users may cause a leakage of sensitive data.
This handler checks if the incoming request contains a Kubernetes secret with a <code>.data.kubeconfig</code> field and denies the request if the Kubeconfig structure violates Gardener&rsquo;s security standards.</p><h3 id=namespace-validator>Namespace Validator</h3><p>Namespaces are the backing entities of Gardener projects in which shoot clusters objects reside.
This validation handler protects active namespaces against premature deletion requests.
Therefore, it denies deletion requests if a namespace still contains shoot clusters or if it belongs to a non-deleting Gardener project (w/o <code>.metadata.deletionTimestamp</code>).</p><h3 id=resource-size-validator>Resource Size Validator</h3><p>Since users directly apply Kubernetes native objects to the Garden cluster, it also involves the risk of being vulnerable to DoS attacks because these resources are read continuously watched and read by controllers.
One example is the creation of <code>Shoot</code> resources with large annotation values (up to 256 kB per value) which can cause severe out-of-memory issues for the Gardenlet component.
<a href=https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler>Vertical autoscaling</a> can help to mitigate such situations, but we cannot expect to scale infinitely, and thus need means to block the attack itself.</p><p>The Resource Size Validator checks arbitrary incoming admission requests against a configured maximum size for the resource&rsquo;s group-version-kind combination and denies the request if the contained object exceeds the quota.</p><p>Example for Gardener Admission Controller configuration:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>server:
  resourceAdmissionConfiguration:
    limits:
    - apiGroups: [<span style=color:#a31515>&#34;core.gardener.cloud&#34;</span>]
      apiVersions: [<span style=color:#a31515>&#34;*&#34;</span>]
      resources: [<span style=color:#a31515>&#34;shoots&#34;</span>, <span style=color:#a31515>&#34;plants&#34;</span>]
      size: 100k
    - apiGroups: [<span style=color:#a31515>&#34;&#34;</span>]
      apiVersions: [<span style=color:#a31515>&#34;v1&#34;</span>]
      resources: [<span style=color:#a31515>&#34;secrets&#34;</span>]
      size: 100k
    unrestrictedSubjects:
    - kind: Group
      name: gardener.cloud:system:seeds
      apiGroup: rbac.authorization.k8s.io
 <span style=color:green>#  - kind: User</span>
 <span style=color:green>#    name: admin</span>
 <span style=color:green>#    apiGroup: rbac.authorization.k8s.io</span>
 <span style=color:green>#  - kind: ServiceAccount</span>
 <span style=color:green>#    name: &#34;*&#34;</span>
 <span style=color:green>#    namespace: garden</span>
 <span style=color:green>#    apiGroup: &#34;&#34;</span>
    operationMode: block <span style=color:green>#log</span>
</code></pre></div><p>With the configuration above, the Resource Size Validator denies requests for shoots and plants with Gardener&rsquo;s core API group which exceed a size of 100 kB. The same is done for Kubernetes secrets.</p><p>As this feature is meant to protect the system from malicious requests sent by users, it is recommended to exclude trusted groups, users or service accounts from the size restriction via <code>resourceAdmissionConfiguration.unrestrictedSubjects</code>.
For example, the backing user for the Gardenlet should always be capable of changing the shoot resource instead of being blocked due to size restrictions.
This is because the Gardenlet itself occasionally changes the shoot specification, labels or annotations, and might violate the quota if the existing resource is already close to the quota boundary.
Also, operators are supposed to be trusted users and subjecting them to a size limitation can inhibit important operational tasks.
Wildcard ("*") in subject <code>name</code> is supported.</p><p>Size limitations depend on the individual Gardener setup and choosing the wrong values can affect the availability of your Gardener service.
<code>resourceAdmissionConfiguration.operationMode</code> allows to control if a violating request is actually denied (default) or only logged.
It&rsquo;s recommended to start with <code>log</code>, check the logs for exceeding requests, adjust the limits if necessary and finally switch to <code>block</code>.</p><h3 id=seedrestriction>SeedRestriction</h3><p>Please refer to <a href=/docs/gardener/deployment/gardenlet_api_access/>this document</a> for more information.</p><h2 id=authorization-webhook-handlers>Authorization Webhook Handlers</h2><p>This section describes the authorization webhook handlers that are currently served.</p><h3 id=seedauthorization>SeedAuthorization</h3><p>Please refer to <a href=/docs/gardener/deployment/gardenlet_api_access/>this document</a> for more information.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-467f70291b55149caa507ac09cae563f>2 - Apiserver</h1><h1 id=gardener-api-server>Gardener API server</h1><p>The Gardener API server is a Kubernetes-native extension based on its <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>aggregation layer</a>.
It is registered via an <code>APIService</code> object and designed to run inside a Kubernetes cluster whose API it wants to extend.</p><p>After registration, it exposes the following resources:</p><h2 id=cloudprofiles><code>CloudProfile</code>s</h2><p><code>CloudProfile</code>s are resources that describe a specific environment of an underlying infrastructure provider, e.g. AWS, Azure, etc.
Each shoot has to reference a <code>CloudProfile</code> to declare the environment it should be created in.
In a <code>CloudProfile</code> the gardener operator specifies certain constraints like available machine types, regions, which Kubernetes versions they want to offer, etc.
End-users can read <code>CloudProfile</code>s to see these values, but only operators can change the content or create/delete them.
When a shoot is created or updated then an admission plugin checks that only values are used that are allowed via the referenced <code>CloudProfile</code>.</p><p>Additionally, a <code>CloudProfile</code> may contain a <code>providerConfig</code> which is a special configuration dedicated for the infrastructure provider.
Gardener does not evaluate or understand this config, but extension controllers might need for declaration of provider-specific constraints, or global settings.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/30-cloudprofile.yaml>this</a> example manifest and consult the documentation of your provider extension controller to get information about its <code>providerConfig</code>.</p><h2 id=seeds><code>Seed</code>s</h2><p><code>Seed</code>s are resources that represent seed clusters.
Gardener does not care about how a seed cluster got created - the only requirement is that it is of at least Kubernetes v1.17 and passes the Kubernetes conformance tests.
The Gardener operator has to either deploy the Gardenlet into the cluster they want to use as seed (recommended, then the Gardenlet will create the <code>Seed</code> object itself after bootstrapping), or they provide the kubeconfig to the cluster inside a secret (that is referenced by the <code>Seed</code> resource) and create the <code>Seed</code> resource themselves.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/45-secret-seed-backup.yaml>this</a>, <a href=https://github.com/gardener/gardener/blob/master/example/50-seed.yaml>this</a>(, and optionally <a href=https://github.com/gardener/gardener/blob/master/example/40-secret-seed.yaml>this</a>) example manifests.</p><h2 id=shootquotas>Shoot<code>Quota</code>s</h2><p>In order to allow end-users not having their own dedicated infrastructure account to try out Gardener the operator can register an account owned by them that they allow to be used for trial clusters.
Trial clusters can be put under quota such that they don&rsquo;t consume too many resources (resulting in costs), and so that one user cannot consume all resources on their own.
These clusters are automatically terminated after a specified time, but end-users may extend the lifetime manually if needed.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/60-quota.yaml>this</a> example manifest.</p><h2 id=projects><code>Project</code>s</h2><p>The first thing before creating a shoot cluster is to create a <code>Project</code>.
A project is used to group multiple shoot clusters together.
End-users can invite colleagues to the project to enable collaboration, and they can either make them <code>admin</code> or <code>viewer</code>.
After an end-user has created a project they will get a dedicated namespace in the garden cluster for all their shoots.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/05-project-dev.yaml>this</a> example manifest.</p><h2 id=secretbindings><code>SecretBinding</code>s</h2><p>Now that the end-user has a namespace the next step is registering their infrastructure provider account.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/70-secret-provider.yaml>this</a> example manifest and consult the documentation of the extension controller for the respective infrastructure provider to get information about which keys are required in this secret.</p><p>After the secret has been created the end-user has to create a special <code>SecretBinding</code> resource that binds this secret.
Later when creating shoot clusters they will reference such a binding.</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/80-secretbinding.yaml>this</a> example manifest.</p><h2 id=shoots><code>Shoot</code>s</h2><p>Shoot cluster contain various settings that influence how end-user Kubernetes clusters will look like in the end.
As Gardener heavily relies on extension controllers for operating system configuration, networking, and infrastructure specifics, the end-user has the possibility (and responsibility) to provide these provider-specific configurations as well.
Such configurations are not evaluated by Gardener (because it doesn&rsquo;t know/understand them), but they are only transported to the respective extension controller.</p><p>⚠️ This means that any configuration issues/mistake on the end-user side that relates to a provider-specific flag or setting cannot be caught during the update request itself but only later during the reconciliation (unless a validator webhook has been registered in the garden cluster by an operator).</p><p>Please see <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml>this</a> example manifest and consult the documentation of the provider extension controller to get information about its <code>spec.provider.controlPlaneConfig</code>, <code>.spec.provider.infrastructureConfig</code>, and <code>.spec.provider.workers[].providerConfig</code>.</p><h2 id=clusteropenidconnectpresets><code>(Cluster)OpenIDConnectPreset</code>s</h2><p>Please see <a href=/docs/gardener/usage/openidconnect-presets/>this</a> separate documentation file.</p><h2 id=overview-data-model>Overview Data Model</h2><p><img src=/__resources/gardener-data-model-overview_c5b559.png alt="Gardener Overview Data Model"></p></div><div class=td-content style=page-break-before:always><h1 id=pg-330a9a0a66325841218788d3193e6fdf>3 - Apiserver Admission Plugins</h1><h1 id=admission-plugins>Admission Plugins</h1><p>Similar to the kube-apiserver, the gardener-apiserver comes with a few in-tree managed admission plugins.
If you want to get an overview of the what and why of admission plugins then <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/>this document</a> might be a good start.</p><p>This document lists all existing admission plugins with a short explanation of what it is responsible for.</p><h2 id=clusteropenidconnectpreset-openidconnectpreset><code>ClusterOpenIDConnectPreset</code>, <code>OpenIDConnectPreset</code></h2><p><em>(both enabled by default)</em></p><p>These admission controllers react on <code>CREATE</code> operations for <code>Shoot</code>s.
If the <code>Shoot</code> does not specify any OIDC configuration (<code>.spec.kubernetes.kubeAPIServer.oidcConfig=nil</code>) then it tries to find a matching <code>ClusterOpenIDConnectPreset</code> or <code>OpenIDConnectPreset</code>, respectively.
If there are multiples that match then the one with the highest weight &ldquo;wins&rdquo;.
In this case, the admission controller will default the OIDC configuration in the <code>Shoot</code>.</p><h2 id=controllerregistrationresources><code>ControllerRegistrationResources</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>ControllerRegistration</code>s.
It validates that there exists only one <code>ControllerRegistration</code> in the system that is primarily responsible for a given kind/type resource combination.
This prevents misconfiguration by the Gardener administrator/operator.</p><h2 id=customverbauthorizer><code>CustomVerbAuthorizer</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Project</code>s.
It validates whether the user is bound to a RBAC role with the <code>modify-spec-tolerations-whitelist</code> verb in case the user tries to change the <code>.spec.tolerations.whitelist</code> field of the respective <code>Project</code> resource.
Usually, regular project members are not bound to this custom verb, allowing the Gardener administrator to manage certain toleration whitelists on <code>Project</code> basis.</p><h2 id=deletionconfirmation><code>DeletionConfirmation</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>Project</code>s and <code>Shoot</code>s and <code>ShootState</code>s.
It validates that the respective resource is annotated with a deletion confirmation annotation, namely <code>confirmation.gardener.cloud/deletion=true</code>.
Only if this annotation is present it allows the <code>DELETE</code> operation to pass.
This prevents users from accidental/undesired deletions.</p><h2 id=exposureclass><code>ExposureClass</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>Create</code> operations for <code>Shoots</code>s.
It mutates <code>Shoot</code> resources which has an <code>ExposureClass</code> referenced by merging their both <code>shootSelectors</code> and/or <code>tolerations</code> into the <code>Shoot</code> resource.</p><h2 id=extensionvalidator><code>ExtensionValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>BackupEntry</code>s, <code>BackupBucket</code>s, <code>Seed</code>s, and <code>Shoot</code>s.
For all the various extension types in the specifications of these objects, it validates whether there exists a <code>ControllerRegistration</code> in the system that is primarily responsible for the stated extension type(s).
This prevents misconfigurations that would otherwise allow users to create such resources with extension types that don&rsquo;t exist in the cluster, effectively leading to failing reconciliation loops.</p><h2 id=extensionlabels><code>ExtensionLabels</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>BackupBucket</code>s, <code>BackupEntry</code>s, <code>CloudProfile</code>s, <code>Seed</code>s and <code>Shoot</code>s. For all the various extension types in the specifications of these objects, it adds a corresponding label in the resource. This would allow extension admission webhooks to filter out the resources they are responsible for and ignore all others. This label is of the form <code>&lt;extension-type>.extensions.gardener.cloud/&lt;extension-name> : "true"</code>. For example, an extension label for provider extension type <code>aws</code>, looks like <code>provider.extensions.gardener.cloud/aws : "true"</code>.</p><h2 id=plantvalidator><code>PlantValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Plant</code>s.
It sets the <code>gardener.cloud/created-by</code> annotation for newly created <code>Plant</code> resources.
Also, it prevents creating new <code>Plant</code> resources in <code>Project</code>s that are already have a deletion timestamp.</p><h2 id=projectvalidator><code>ProjectValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> operations for <code>Project</code>s.
It prevents creating <code>Project</code>s with a non-empty <code>.spec.namespace</code> if the value in <code>.spec.namespace</code> does not start with <code>garden-</code>.</p><p>⚠️ This admission plugin will be removed in a future release and its business logic will be incorporated into the static validation of the <code>gardener-apiserver</code>.</p><h2 id=resourcequota><code>ResourceQuota</code></h2><p><em>(enabled by default)</em></p><p>This admission controller enables <a href=https://kubernetes.io/docs/concepts/policy/resource-quotas/#object-count-quota>object count ResourceQuotas</a> for Gardener resources, e.g. <code>Shoots</code>, <code>SecretBindings</code>, <code>Projects</code>, etc..</p><blockquote><p>⚠️ In addition to this admission plugin, the <a href=https://github.com/kubernetes/kubernetes/blob/release-1.2/docs/design/admission_control_resource_quota.md#resource-quota-controller>ResourceQuota controller</a> must be enabled for the Kube-Controller-Manager of your Garden cluster.</p></blockquote><h2 id=resourcereferencemanager><code>ResourceReferenceManager</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>CloudProfile</code>s, <code>Project</code>s, <code>SecretBinding</code>s, <code>Seed</code>s, and <code>Shoot</code>s.
Generally, it checks whether referred resources stated in the specifications of these objects exist in the system (e.g., if a referenced <code>Secret</code> exists).
However, it also has some special behaviours for certain resources:</p><ul><li><code>CloudProfile</code>s: It rejects removing Kubernetes or machine image versions if there is at least one <code>Shoot</code> that refers to them.</li><li><code>Project</code>s: It sets the <code>.spec.createdBy</code> field for newly created <code>Project</code> resources, and defaults the <code>.spec.owner</code> field in case it is empty (to the same value of <code>.spec.createdBy</code>).</li><li><code>Seed</code>s: It rejects changing the <code>.spec.settings.shootDNS.enabled</code> value if there is at least one <code>Shoot</code> that refers to this seed.</li><li><code>Shoot</code>s: It sets the <code>gardener.cloud/created-by=&lt;username></code> annotation for newly created <code>Shoot</code> resources.</li></ul><h2 id=seedvalidator><code>SeedValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>Seed</code>s.
Rejects the deletion if <code>Shoot</code>(s) reference the seed cluster.</p><h2 id=shootdns><code>ShootDNS</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It tries to assign a default domain to the <code>Shoot</code> if it gets scheduled to a seed that enables DNS for shoots (<code>.spec.settings.shootDNS.enabled=true</code>).
It also validates that the DNS configuration (<code>.spec.dns</code>) is not set if the seed disables DNS for shoots.</p><h2 id=shootquotavalidator><code>ShootQuotaValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It validates the resource consumption declared in the specification against applicable <code>Quota</code> resources.
Only if the applicable <code>Quota</code> resources admit the configured resources in the <code>Shoot</code> then it allows the request.
Applicable <code>Quota</code>s are referred in the <code>SecretBinding</code> that is used by the <code>Shoot</code>.</p><h2 id=shootvpaenabledbydefault><code>ShootVPAEnabledByDefault</code></h2><p><em>(disabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> operations for <code>Shoot</code>s.
If enabled, it will enable the managed <code>VerticalPodAutoscaler</code> components (see <a href=/docs/gardener/usage/shoot_autoscaling/#vertical-pod-auto-scaling>this doc</a>)
by setting <code>spec.kubernetes.verticalPodAutoscaler.enabled=true</code> for newly created Shoots.
Already existing Shoots and new Shoots that explicitly disable VPA (<code>spec.kubernetes.verticalPodAutoscaler.enabled=false</code>)
will not be affected by this admission plugin.</p><h2 id=shoottolerationrestriction><code>ShootTolerationRestriction</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It validates the <code>.spec.tolerations</code> used in <code>Shoot</code>s against the whitelist of its <code>Project</code>, or against the whitelist configured in the admission controller&rsquo;s configuration, respectively.
Additionally, it defaults the <code>.spec.tolerations</code> in <code>Shoot</code>s with those configured in its <code>Project</code>, and those configured in the admission controller&rsquo;s configuration, respectively.</p><h2 id=shootvalidator><code>ShootValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>Shoot</code>s.
It validates certain configurations in the specification against the referred <code>CloudProfile</code> (e.g., machine images, machine types, used Kubernetes version, &mldr;).
Generally, it performs validations that cannot be handled by the static API validation due to their dynamic nature (e.g., when something needs to be checked against referred resources).
Additionally, it takes over certain defaulting tasks (e.g., default machine image for worker pools).</p><h2 id=shootmanagedseed><code>ShootManagedSeed</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>Shoot</code>s.
It rejects the deletion if the <code>Shoot</code> is referred to by a <code>ManagedSeed</code>.</p><h2 id=managedseedvalidator><code>ManagedSeedValidator</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>CREATE</code> and <code>UPDATE</code> operations for <code>ManagedSeeds</code>s.
It validates certain configuration values in the specification against the referred <code>Shoot</code>, for example Seed provider, network ranges, DNS domain, etc.
Similarly to <code>ShootValidator</code>, it performs validations that cannot be handled by the static API validation due to their dynamic nature.
Additionally, it performs certain defaulting tasks, making sure that configuration values that are not specified are defaulted to the values of the referred <code>Shoot</code>, for example Seed provider, network ranges, DNS domain, etc.</p><h2 id=managedseedshoot><code>ManagedSeedShoot</code></h2><p><em>(enabled by default)</em></p><p>This admission controller reacts on <code>DELETE</code> operations for <code>ManagedSeed</code>s.
It rejects the deletion if there are <code>Shoot</code>s that are scheduled onto the <code>Seed</code> that is registered by the <code>ManagedSeed</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c898670f6aa58e28fb8510640734a620>4 - Architecture</h1><h4 id=official-definition---what-is-kubernetes>Official Definition - What is Kubernetes?</h4><blockquote><p>&ldquo;Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications.&rdquo;</p></blockquote><h4 id=introduction---basic-principle>Introduction - Basic Principle</h4><p>The foundation of the Gardener (providing <em><strong>Kubernetes Clusters as a Service</strong></em>) is Kubernetes itself, because Kubernetes is the go-to solution to manage software in the Cloud, even when it&rsquo;s Kubernetes itself (see also OpenStack which is provisioned more and more on top of Kubernetes as well).</p><p>While self-hosting, meaning to run Kubernetes components inside Kubernetes, is a popular topic in the community, we apply a special pattern catering to the needs of our cloud platform to provision hundreds or even thousands of clusters. We take a so-called &ldquo;seed&rdquo; cluster and seed the control plane (such as the API server, scheduler, controllers, etcd persistence and others) of an end-user cluster, which we call &ldquo;shoot&rdquo; cluster, as pods into the &ldquo;seed&rdquo; cluster. That means one &ldquo;seed&rdquo; cluster, of which we will have one per IaaS and region, hosts the control planes of multiple &ldquo;shoot&rdquo; clusters. That allows us to avoid dedicated hardware/virtual machines for the &ldquo;shoot&rdquo; cluster control planes. We simply put the control plane into pods/containers and since the &ldquo;seed&rdquo; cluster watches them, they can be deployed with a replica count of 1 and only need to be scaled out when the control plane gets under pressure, but no longer for HA reasons. At the same time, the deployments get simpler (standard Kubernetes deployment) and easier to update (standard Kubernetes rolling update). The actual &ldquo;shoot&rdquo; cluster consists only out of the worker nodes (no control plane) and therefore the users may get full administrative access to their clusters.</p><h4 id=setting-the-scene---components-and-procedure>Setting The Scene - Components and Procedure</h4><p>We provide a central operator UI, which we call the &ldquo;Gardener Dashboard&rdquo;. It talks to a dedicated cluster, which we call the &ldquo;Garden&rdquo; cluster and uses custom resources managed by an <a href=https://kubernetes.io/docs/concepts/api-extension/custom-resources/#api-server-aggregation>aggregated API server</a>, one of the general extension concepts of Kubernetes) to represent &ldquo;shoot&rdquo; clusters. In this &ldquo;Garden&rdquo; cluster runs the &ldquo;Gardener&rdquo;, which is basically a Kubernetes controller that watches the custom resources and acts upon them, i.e. creates, updates/modifies, or deletes &ldquo;shoot&rdquo; clusters. The creation follows basically these steps:</p><ul><li>Create a namespace in the &ldquo;seed&rdquo; cluster for the &ldquo;shoot&rdquo; cluster which will host the &ldquo;shoot&rdquo; cluster control plane</li><li>Generate secrets and credentials which the worker nodes will need to talk to the control plane</li><li>Create the infrastructure (using <a href=https://www.terraform.io/>Terraform</a>), which basically consists out of the network setup)</li><li>Deploy the &ldquo;shoot&rdquo; cluster control plane into the &ldquo;shoot&rdquo; namespace in the &ldquo;seed&rdquo; cluster, containing the &ldquo;machine-controller-manager&rdquo; pod</li><li>Create machine CRDs in the &ldquo;seed&rdquo; cluster, describing the configuration and the number of worker machines for the &ldquo;shoot&rdquo; (the machine-controller-manager watches the CRDs and creates virtual machines out of it)</li><li>Wait for the &ldquo;shoot&rdquo; cluster API server to become responsive (pods will be scheduled, persistent volumes and load balancers are created by Kubernetes via the respective cloud provider)</li><li>Finally we deploy <code>kube-system</code> daemons like <code>kube-proxy</code> and further add-ons like the <code>dashboard</code> into the &ldquo;shoot&rdquo; cluster and the cluster becomes active</li></ul><h4 id=overview-architecture-diagram>Overview Architecture Diagram</h4><p><img src=/__resources/gardener-architecture-overview_2bd462.png alt="Gardener Overview Architecture Diagram"></p><h4 id=detailed-architecture-diagram>Detailed Architecture Diagram</h4><p><img src=/__resources/gardener-architecture-detailed_945c90.png alt="Gardener Detailed Architecture Diagram"></p><p>Note: The <code>kubelet</code> as well as the pods inside the &ldquo;shoot&rdquo; cluster talk through the front-door (load balancer IP; public Internet) to its &ldquo;shoot&rdquo; cluster API server running in the &ldquo;seed&rdquo; cluster. The reverse communication from the API server to the pod, service, and node networks happens through a VPN connection that we deploy into &ldquo;seed&rdquo; and &ldquo;shoot&rdquo; clusters.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-350220592a34dc9c03bc21617e258ada>5 - Backup Restore</h1><h1 id=backup-and-restore>Backup and restore</h1><p>Kubernetes uses Etcd as the key-value store for its resource definitions. Gardener supports the backup and restore of etcd. It is the responsibility of the shoot owners to backup the workload data.</p><p>Gardener uses <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a> component to backup the etcd backing the Shoot cluster regularly and restore in case of disaster. It is deployed as sidecar via <a href=https://github.com/gardener/etcd-druid>etcd-druid</a>. This doc mainly focuses on the backup and restore configuration used by Gardener when deploying these components. For more details on the design and internal implementation details, please refer <a href=/docs/gardener/proposals/06-etcd-druid/>GEP-06</a> and documentation on individual repository.</p><h2 id=bucket-provisioning>Bucket provisioning</h2><p>Refer the <a href=/docs/gardener/extensions/backupbucket/>backup bucket extension document</a> to know details about configuring backup bucket.</p><h2 id=backup-policy>Backup Policy</h2><p>etcd-backup-restore supports full snapshot and delta snapshots over full snapshot. In Gardener, this configuration is currently hard-coded to following parameters:</p><ul><li>Full Snapshot Schedule:<ul><li>Daily, <code>24hr</code> interval.</li><li>For each Shoot, the schedule time in a day is randomized based on the configured Shoot maintenance window.</li></ul></li><li>Delta Snapshot schedule:<ul><li>At <code>5min</code> interval.</li><li>If aggregated events size since last snapshot goes beyond <code>100Mib</code>.</li></ul></li><li>Backup History / Garbage backup deletion policy:<ul><li>Gardener configure backup restore to have <code>Exponential</code> garbage collection policy.</li><li>As per policy, following backups are retained.</li><li>All full backups and delta backups for the previous hour.</li><li>Latest full snapshot of each previous hour for the day.</li><li>Latest full snapshot of each previous day for 7 days.</li><li>Latest full snapshot of the previous 4 weeks.</li><li>Garbage Collection is configured at <code>12hr</code> interval.</li></ul></li><li>Listing:<ul><li>Gardener don&rsquo;t have any API to list out the backups.</li><li>To find the backup list, admin can checkout the <code>BackupEntry</code> resource associated with Shoot which holds the bucket and prefix details on object store.</li></ul></li></ul><h2 id=restoration>Restoration</h2><p>Restoration process of etcd is automated through the etcd-backup-restore component from latest snapshot. Gardener dosen&rsquo;t support Point-In-Time-Recovery (PITR) of etcd. In case of etcd disaster, the etcd is recovered from latest backup automatically. For further details, please refer the <a href=https://github.com/gardener/etcd-backup-restore/blob/master/doc/proposals/restoration.md>doc</a>. Post restoration of etcd, the Shoot reconciliation loop brings back the cluster to same state.</p><p>Again, Shoot owner is responsible for maintaining the backup/restore of his workload. Gardener does only take care of the cluster&rsquo;s etcd.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-deb4b0a712a04f62d9a5892607237729>6 - Cluster Api</h1><h1 id=relation-between-gardener-api-and-cluster-api-sig-cluster-lifecycle>Relation between Gardener API and Cluster API (SIG Cluster Lifecycle)</h1><p>In essence, the Cluster API harmonizes how to get to clusters, while Gardener goes one step further and also harmonizes the clusters themselves. The Cluster API delegates the specifics to so-called providers for infrastructures or control planes via specific CR(D)s while Gardener only has one cluster CR(D). Different Cluster API providers, e.g. for AWS, Azure, GCP, etc. give you vastly different Kubernetes clusters. In contrast, Gardener gives you the exact same clusters with the exact same K8s version, operating system, control plane configuration like for API server or kubelet, add-ons like overlay network, HPA/VPA, DNS and certificate controllers, ingress and network policy controllers, control plane monitoring and logging stacks, down to the behavior of update procedures, auto-scaling, self-healing, etc. on all supported infrastructures. These homogeneous clusters are an essential goal for Gardener as its main purpose is to simplify operations for teams that need to develop and ship software on Kubernetes clusters on a plethora of infrastructures (a.k.a. multi-cloud).</p><p>Incidentally, Gardener influenced the Machine API in the Cluster API with its <a href=https://github.com/gardener/machine-controller-manager>Machine Controller Manager</a> and was the <a href=https://github.com/kubernetes-sigs/cluster-api/commit/00b1ead264aea6f88585559056c180771cce3815>first to adopt it</a>, see also <a href="https://www.youtube.com/watch?v=Mtg8jygK3Hs">joint SIG Cluster Lifecycle KubeCon talk</a> where @hardikdr from our Gardener team in India spoke.</p><p>That means, we follow the <a href=https://github.com/kubernetes-sigs/cluster-api#cluster-api>Cluster API</a> with great interest and are active members. It was completely overhauled from <code>v1alpha1</code> to <code>v1alpha2</code>. But because <code>v1alpha2</code> made too many assumptions about the bring-up of masters and was enforcing master machine operations (see <a href=https://cluster-api.sigs.k8s.io/user/concepts.html#control-plane>here</a>: “As of <code>v1alpha2</code>, Machine-Based is the only control plane type that Cluster API supports”), services that managed their control planes differently like GKE or Gardener couldn&rsquo;t adopt it (e.g. <a href=https://cloud.google.com/anthos/gke/docs/on-prem/concepts/cluster-api>Google only supports <code>v1alpha1</code></a>). In 2020 <a href=https://kubernetes.io/blog/2020/04/21/cluster-api-v1alpha3-delivers-new-features-and-an-improved-user-experience/><code>v1alpha3</code></a> was introduced and made it possible (again) to integrate managed services like GKE or Gardener. The mapping from the Gardener API to the Cluster API is mostly syntactic.</p><p>To wrap it up, while the Cluster API knows about clusters, it doesn&rsquo;t know about their make-up. With Gardener, we wanted to go beyond that and harmonize the make-up of the clusters themselves and make them homogeneous across all supported infrastructures. Gardener can therefore deliver homogeneous clusters with exactly the same configuration and behavior on all infrastructures (see also <a href=https://k8s-testgrid.appspot.com/conformance-all>Gardener&rsquo;s coverage in the official conformance test grid</a>).</p><p>With <a href=https://kubernetes.io/blog/2020/04/21/cluster-api-v1alpha3-delivers-new-features-and-an-improved-user-experience>Cluster API <code>v1alpha3</code></a> and the support for declarative control plane management, it became now possible (again) to enable Kubernetes managed services like GKE or Gardener. We would be more than happy, if the community would be interested, to contribute a Gardener control plane provider.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-38b8e4d34b02317602d0c383c3c76cac>7 - Controller Manager</h1><h1 id=gardener-controller-manager>Gardener Controller Manager</h1><p>The Gardener Controller Manager (often refered to as &ldquo;GCM&rdquo;) is a component that runs next to the Gardener API server, similar to the Kubernetes Controller Manager.
It runs several control loops that do not require talking to any seed or shoot cluster.
Also, as of today it exposes a HTTPS server that is serving several endpoints for webhooks for certain resources.</p><p>This document explains the various functionalities of the Gardener Controller Manager and their purpose.</p><h2 id=control-loops>Control Loops</h2><h3 id=project-controller><code>Project</code> Controller</h3><p>This controller consists out of three reconciliation loops:
The main loop is reconciling <code>Project</code> resources while the second loop is controlling the necessary actions for stale projects.</p><h4 id=main-reconciler>&ldquo;Main&rdquo; Reconciler</h4><p>This reconciler will create a dedicated <code>Namespace</code> prefixed with <code>garden-</code> for each <code>Project</code> resource.
The name of the namespace can either be stated in the <code>.spec.namespace</code>, or it will be auto-generated by the reconciler.
If <code>.spec.namespace</code> is set then it creates it if it does not exist yet.
Otherwise, it tries to adopt it.
This will only succeed if the <code>Namespace</code> was previously labeled with <code>gardener.cloud/role=project</code> and <code>project.gardener.cloud/name=&lt;project-name></code>.
This is to prevent that end-users can adopt arbitrary namespaces and escalate their privileges, e.g. the <code>kube-system</code> namespace.</p><p>After the namespace was created/adopted the reconciler creates several <code>ClusterRole</code>s and <code>ClusterRoleBinding</code>s that allow the project members to access related resources based on their roles.
These RBAC resources are prefixed with <code>gardener.cloud:system:project{-member,-viewer}:&lt;project-name></code>.
Gardener administrators and extension developers can define their own roles, see <a href=/docs/gardener/extensions/project-roles/>this document</a> for more information.</p><p>In addition, operators can configure the Project controller to maintain a default <a href=https://kubernetes.io/docs/concepts/policy/resource-quotas/>ResourceQuota</a> for project namespaces.
Quotas can especially limit the creation of user facing resources, e.g. <code>Shoots</code>, <code>SecretBindings</code>, <code>Secrets</code> and thus protect the Garden cluster from massive resource exhaustion but also enable operators to align quotas with respective enterprise policies.</p><blockquote><p>⚠️ <strong>Gardener itself is not exempted from configured quotas</strong>. For example, Gardener creates <code>Secrets</code> for every shoot cluster in the project namespace and at the same time increases the available quota count. Please mind this additional resource consumption.</p></blockquote><p>The GCM configuration provides a template section <code>controllers.project.quotas</code> where such a ResourceQuota (see example below) can be deposited.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>controllers:
  project:
    quotas:
    - config:
        apiVersion: v1
        kind: ResourceQuota
        spec:
          hard:
            count/shoots.core.gardener.cloud: <span style=color:#a31515>&#34;100&#34;</span>
            count/secretbindings.core.gardener.cloud: <span style=color:#a31515>&#34;10&#34;</span>
            count/secrets: <span style=color:#a31515>&#34;800&#34;</span>
      projectSelector: {}
</code></pre></div><p>The Project controller takes the shown <code>config</code> and creates a <code>ResourceQuota</code> with the name <code>gardener</code> in the project namespace.
If a <code>ResourceQuota</code> resource with the name <code>gardener</code> already exists, the controller will only update fields in <code>spec.hard</code> which are <strong>unavailable</strong> at that time.
Labels and annotations on the <code>ResourceQuota</code> <code>config</code> get merged with the respective fields on existing <code>ResourceQuota</code>s.
An optional <code>projectSelector</code> narrows down the amount of projects that are equipped with the given <code>config</code>.
If multiple configs match for a project, then only the first match in the list is applied to the project namespace.</p><p>The <code>.status.phase</code> of the <code>Project</code> resources will be set to <code>Ready</code> or <code>Failed</code> by the reconciler to indicate whether the reconciliation loop was performed successfully.
Also, it will generate <code>Event</code>s to provide further information about its operations.</p><h4 id=stale-projects-reconciler>&ldquo;Stale Projects&rdquo; Reconciler</h4><p>As Gardener is a large-scale Kubernetes as a Service it is designed for being used by a large amount of end-users.
Over time, it is likely to happen that some of the hundreds or thousands of <code>Project</code> resources are no longer actively used.</p><p>Gardener offers the &ldquo;stale projects&rdquo; reconciler which will take care of identifying such stale projects, marking them with a &ldquo;warning&rdquo;, and eventually deleting them after a certain time period.
This reconciler is enabled by default and works as following:</p><ol><li>Projects are considered as &ldquo;stale&rdquo;/not actively used when all of the following conditions apply: The namespace associated with the <code>Project</code> does not have any&mldr;<ol><li><code>Shoot</code> resources.</li><li><code>Plant</code> resources.</li><li><code>BackupEntry</code> resources.</li><li><code>Secret</code> resources that are referenced by a <code>SecretBinding</code> that is in use by a <code>Shoot</code> (not necessarily in the same namespace).</li><li><code>Quota</code> resources that are referenced by a <code>SecretBinding</code> that is in use by a <code>Shoot</code> (not necessarily in the same namespace).</li><li>The time period when the projet was used for the last time (<code>status.lastActivityTimestamp</code>) is longer than the configured <code>minimumLifetimeDays</code></li></ol></li></ol><p>If a project is considered &ldquo;stale&rdquo; then its <code>.status.staleSinceTimestamp</code> will be set to the time when it was first detected to be stale.
If it gets actively used again this timestamp will be removed.
After some time the <code>.status.staleAutoDeleteTimestamp</code> will be set to a timestamp after which Gardener will auto-delete the <code>Project</code> resource if it still is not actively used.</p><p>The component configuration of the Gardener Controller Manager offers to configure the following options:</p><ul><li><code>minimumLifetimeDays</code>: Don&rsquo;t consider newly created <code>Project</code>s as &ldquo;stale&rdquo; too early to give people/end-users some time to onboard and get familiar with the system. The &ldquo;stale project&rdquo; reconciler won&rsquo;t set any timestamp for <code>Project</code>s younger than <code>minimumLifetimeDays</code>. When you change this value then projects marked as &ldquo;stale&rdquo; may be no longer marked as &ldquo;stale&rdquo; in case they are young enough, or vice versa.</li><li><code>staleGracePeriodDays</code>: Don&rsquo;t compute auto-delete timestamps for stale <code>Project</code>s that are unused for only less than <code>staleGracePeriodDays</code>. This is to not unnecessarily make people/end-users nervous &ldquo;just because&rdquo; they haven&rsquo;t actively used their <code>Project</code> for a given amount of time. When you change this value then already assigned auto-delete timestamps may be removed again if the new grace period is not yet exceeded.</li><li><code>staleExpirationTimeDays</code>: Expiration time after which stale <code>Project</code>s are finally auto-deleted (after <code>.status.staleSinceTimestamp</code>). If this value is changed and an auto-delete timestamp got already assigned to the projects then the new value will only take effect if it&rsquo;s increased. Hence, decreasing the <code>staleExpirationTimeDays</code> will not decrease already assigned auto-delete timestamps.</li></ul><blockquote><p>Gardener administrators/operators can exclude specific <code>Project</code>s from the stale check by annotating the related <code>Namespace</code> resource with <code>project.gardener.cloud/skip-stale-check=true</code>.</p></blockquote><h4 id=activity-reconciler>&ldquo;Activity&rdquo; Reconciler</h4><p>Since the other two reconcilers are unable to actively monitor the relevant objects that are used in a <code>Project</code> (<code>Shoot</code>, <code>Plant</code>, etc.), there could be a situation where the user creates and deletes objects in a short period of time. In that case the <code>Stale Project Reconciler</code> could not see that there was any activity on that project and it will still mark it as a <code>Stale</code>, even though it is actively used.</p><p>The <code>Project Activity Reconciler</code> is implemented to take care of such cases. An event handler will notify the reconciler for any acitivity (Currently only for <code>Shoots</code>) and then it will update the <code>status.lastActivityTimestamp</code>. This update will also trigger the <code>Stale Project Reconciler</code>.</p><h3 id=event-controller>Event Controller</h3><p>With the Gardener Event Controller you can prolong the lifespan of events related to Shoot clusters.
This is an optional controller which will become active once you provide the below mentioned configuration.</p><p>All events in K8s are deleted after a configurable time-to-live (controlled via a <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver argument</a> called <code>--event-ttl</code> (defaulting to 1 hour)).
The need to prolong the time-to-live for Shoot cluster events frequently arises when debugging customer issues on live systems.
This controller leaves events involving Shoots untouched while deleting all other events after a configured time.
In order to activate it, provide the following configuration:</p><ul><li><code>concurrentSyncs</code>: The amount of goroutines scheduled for reconciling events.</li><li><code>ttlNonShootEvents</code>: When an event reaches this time-to-live it gets deleted unless it is a Shoot-related event (defaults to <code>1h</code>, equivalent to the <code>event-ttl</code> default).</li></ul><blockquote><p>⚠️ In addition, you should also configure the <code>--event-ttl</code> for the kube-apiserver to define an upper-limit of how long Shoot-related events should be stored.
The <code>--event-ttl</code> should be larger than the <code>ttlNonShootEvents</code> or this controller will have no effect.</p></blockquote><h3 id=shoot-reference-controller>Shoot Reference Controller</h3><p>Shoot objects may specify references to further objects in the Garden cluster which are required for certain features.
For example, users can configure various DNS providers via <code>.spec.dns.providers</code> and usually need to refer to a corresponding <code>secret</code> with valid DNS provider credentials inside.
Such objects need a special protection against deletion requests as long as they are still being referenced by one or multiple shoots.</p><p>Therefore, the Shoot Reference Controller scans shoot clusters for referenced objects and adds the finalizer <code>gardener.cloud/reference-protection</code> to their <code>.metadata.finalizers</code> list.
The scanned shoot also gets this finalizer to enable a proper garbage collection in case the Gardener-Controller-Manager is offline at the moment of an incoming deletion request.
When an object is not actively referenced anymore because the shoot specification has changed or all related shoots were deleted (are in deletion), the controller will remove the added finalizer again, so that the object can safely be deleted or garbage collected.</p><p>The Shoot Reference Controller inspects the following references:</p><ul><li>DNS provider secrets (<code>.spec.dns.provider</code>)</li><li>Audit policy configmaps (<code>.spec.kubernetes.kubeAPIServer.auditConfig.auditPolicy.configMapRef</code>)</li></ul><p>Further checks might be added in the future.</p><h3 id=shoot-retry-controller>Shoot Retry Controller</h3><p>The Shoot Retry Controller is responsible for retrying certain failed Shoots. Currently the controller retries only failed Shoots with error code <code>ERR_INFRA_RATE_LIMITS_EXCEEDED</code>.</p><h3 id=seed-controller>Seed Controller</h3><p>The Seed controller in the Gardener Controller Manager reconciles <code>Seed</code> objects with the help of the following reconcilers.</p><h4 id=main-reconciler-1>&ldquo;Main&rdquo; Reconciler</h4><p>This reconciliation loop takes care about seed related operations in the Garden cluster. When a new <code>Seed</code> object is created
the reconciler creates a new <code>Namespace</code> in the garden cluster <code>seed-&lt;seed-name></code>. <code>Namespaces</code> dedicated to single
seed clusters allow us to segregate access permissions i.e., a Gardenlet must not have permissions to access objects in
all <code>Namespaces</code> in the Garden cluster.
There are objects in a Garden environment which are created once by the operator e.g., default domain secret,
alerting credentials, and required for operations happening in the Gardenlet. Therefore, we not only need a seed specific
<code>Namespace</code> but also a copy of these &ldquo;shared&rdquo; objects.</p><p>The &ldquo;main&rdquo; reconciler takes care about this replication:</p><table><thead><tr><th style=text-align:center>Kind</th><th style=text-align:center>Namespace</th><th style=text-align:center>Label Selector</th></tr></thead><tbody><tr><td style=text-align:center>Secret</td><td style=text-align:center>garden</td><td style=text-align:center>gardener.cloud/role</td></tr></tbody></table><h4 id=backup-bucket-reconciler>&ldquo;Backup Bucket&rdquo; Reconciler</h4><p>Every time a <code>BackupBucket</code> object is created or updated, the referenced <code>Seed</code> object is enqueued for reconciliation.
It&rsquo;s the reconciler&rsquo;s task to check the <code>status</code> subresource of all existing <code>BackupBuckets</code> that belong to this seed.
If at least one <code>BackupBucket</code> has <code>.status.lastError</code>, the seed condition <code>BackupBucketsReady</code> will turn <code>false</code> and
consequently the seed is considered as <code>NotReady</code>. Once the <code>BackupBucket</code> is healthy again, the seed will be re-queued
and the condition will turn <code>true</code>.</p><h4 id=lifecycle-reconciler>&ldquo;Lifecycle&rdquo; Reconciler</h4><p>The &ldquo;Lifecycle&rdquo; reconciler processes <code>Seed</code> objects which are enqueued every 10 seconds in order to check if the responsible
Gardenlet is still responding and operable. Therefore, it checks renewals via <code>Lease</code> objects of the seed in the garden cluster
which are renewed regularly by the Gardenlet.</p><p>In case a <code>Lease</code> is not renewed for the configured amount in <code>config.controllers.seed.monitorPeriod.duration</code>:</p><ol><li>The reconciler assumes that the Gardenlet stopped operating and updates the <code>GardenletReady</code> condition to <code>Unknown</code>.</li><li>Additionally, conditions and constraints of all <code>Shoot</code> resources scheduled on the affected seed are set to <code>Unknown</code> as well
because a striking Gardenlet won&rsquo;t be able to maintain these conditions any more.</li><li>If the gardenlet&rsquo;s client certificate has expired (identified based on the <code>.status.clientCertificateExpirationTimestamp</code> field in the <code>Seed</code> resource) and if it is managed by a <code>ManagedSeed</code> then this will be triggered for a reconciliation. This will trigger the bootstrapping process again and allows gardenlets to obtain a fresh client certificate.</li></ol><h3 id=controllerregistration-controller>ControllerRegistration Controller</h3><p>The <code>ControllerRegistration</code> controller makes sure that the required <a href=https://github.com/gardener/gardener/blob/master/docs/README.md#extensions>Gardener extensions</a> specified by the <a href=/docs/gardener/extensions/controllerregistration/><code>ControllerRegistration</code></a> resources are present in the seed clusters. It also takes care of the creation and deletion of <code>ControllerInstallation</code> objects for a given seed cluster.
The controller has three reconciliation loops.</p><h4 id=main-reconciler-2>&ldquo;Main&rdquo; Reconciler</h4><p>This reconciliation loop watches the <code>Seed</code> objects and determines which <code>ControllerRegistrations</code> are required for them and creates/deletes the corresponding extension controller to reach the determined state. To begin with, it computes the kind/type combinations of extensions required for the seed. For this, the controller examines a live list of <code>ControllerRegistration</code>s, <code>ControllerInstallation</code>s, <code>BackupBucket</code>s, <code>BackupEntry</code>s, <code>Shoot</code>s, and <code>Secret</code>s from the garden cluster. For example, it examines the shoots running on the seed and deducts kind/type like <code>Infrastructure/gcp</code>. It also decides whether they should always be deployed based on the <code>.spec.deployment.policy</code>.
For the configuration options, please see this <a href=/docs/gardener/extensions/controllerregistration/#deployment-configuration-options>section</a>.</p><p>Based on these required combinations, each of them are mapped to <code>ControllerRegistration</code> objects and then to their corresponding <code>ControllerInstallation</code> objects (if existing). The controller then creates or updates the required <code>ControllerInstallation</code> objects for the given seed. It also deletes every existing <code>ControllerInstallation</code> whose referenced <code>ControllerRegistration</code> is not part of the required list. For example, if the shoots in the seed are no longer using the DNS provider <code>aws-route53</code>, then the controller proceeds to delete the respective <code>ControllerInstallation</code> object.</p><h4 id=controllerregistration-reconciler>&ldquo;ControllerRegistration&rdquo; Reconciler</h4><p>This reconciliation loop watches the <code>ControllerRegistration</code> resource and adds finalizers to it when they are created. In case a deletion request comes in for the resource, i.e., if a <code>.metadata.deletionTimestamp</code> is set, it actively scans for a <code>ControllerInstallation</code> resource using this <code>ControllerRegistration</code>, and decides whether the deletion can be allowed. In case no related <code>ControllerInstallation</code> is present, it removes the finalizer and marks it for deletion.</p><h4 id=seed-reconciler>&ldquo;Seed&rdquo; Reconciler</h4><p>This loop also watches the <code>Seed</code> object and adds finalizers to it at creation. If a <code>.metadata.deletionTimestamp</code> is set for the seed then the controller checks for existing <code>ControllerInstallation</code> objects which reference this seed. If no such objects exist then it removes the finalizer and allows the deletion.</p><h3 id=certificatesigningrequest-controller>&ldquo;CertificateSigningRequest&rdquo; controller</h3><p>After the <a href=/docs/gardener/concepts/gardenlet/>gardenlet</a> gets deployed on the Seed cluster it needs to establish itself as a trusted party to communicate with the Gardener API server. It runs through a bootstrap flow similar to the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet bootstrap</a> process.</p><p>On startup the gardenlet uses a <code>kubeconfig</code> with a <a href=https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/>bootstrap token</a> which authenticates it as being part of the <code>system:bootstrappers</code> group. This kubeconfig is used to create a <a href=https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/><code>CertificateSigningRequest</code></a> (CSR) against the Gardener API server.</p><p>The controller in <code>gardener-controller-manager</code> checks whether the <code>CertificateSigningRequest</code> has the expected organisation, common name and usages which the gardenlet would request.</p><p>It only auto-approves the CSR if the client making the request is allowed to &ldquo;create&rdquo; the
<code>certificatesigningrequests/seedclient</code> subresource. Clients with the <code>system:bootstrappers</code> group are bound to the <code>gardener.cloud:system:seed-bootstrapper</code> <code>ClusterRole</code>, hence, they have such privileges. As the bootstrap kubeconfig for the gardenlet contains a bootstrap token which is authenticated as being part of the <a href=https://github.com/gardener/gardener/blob/master/charts/gardener/controlplane/charts/application/templates/clusterrolebinding-seed-bootstrapper.yaml><code>systems:bootstrappers</code> group</a>, its created CSR gets auto-approved.</p><h3 id=bastion-controller>&ldquo;Bastion&rdquo; Controller</h3><p><code>Bastion</code> resources have a limited lifetime, which can be extended up to a certain amount by performing a heartbeat on
them. The <code>Bastion</code> controller is responsible for deleting expired or rotten <code>Bastion</code>s.</p><ul><li>&ldquo;expired&rdquo; means a <code>Bastion</code> has exceeded its <code>status.ExpirationTimestamp</code>.</li><li>&ldquo;rotten&rdquo; means a <code>Bastion</code> is older than the configured <code>maxLifetime</code>.</li></ul><p>The <code>maxLifetime</code> is an option on the <code>Bastion</code> controller and defaults to 24 hours.</p><p>The deletion triggers the gardenlet to perform the necessary cleanups in the Seed cluster, so some time can pass between
deletion and the <code>Bastion</code> actually disappearing. Clients like <code>gardenctl</code> are advised to not re-use <code>Bastion</code>s whose
deletion timestamp has been set already.</p><p>Refer to <a href=/docs/gardener/proposals/15-manage-bastions-and-ssh-key-pair-rotation/>GEP-15</a> for more information on the lifecycle of
<code>Bastion</code> resources.</p><h3 id=plant-controller>&ldquo;Plant&rdquo; Controller</h3><p>Using the <code>Plant</code> resource, an external Kubernetes cluster (not managed by Gardener) can be registered to Gardener. Gardener Controller Manager is the component that is responsible for the <code>Plant</code> resource reconciliation. As part of the reconciliation loop, the Gardener Controller Manager performs health checks on the external Kubernetes cluster and gathers more information about it - all of this information serves for monitoring purposes of the external Kubernetes cluster.</p><p>The component configuration of the Gardener Controller Manager offers to configure the following options for the plant controller:</p><ul><li><code>syncPeriod</code>: The duration of how often the Plant resource is reconciled, i.e., how often health checks are performed. The default value is <code>30s</code>.</li><li><code>concurrentSyncs</code>: The number of goroutines scheduled for reconciling events, i.e., the number of possible parallel reconciliations. The default value is <code>5</code>.</li></ul><p>The <code>Plant</code> resource reports the following information for the external Kubernetes cluster:</p><ul><li>Cluster information<ul><li>Cloud provider information - the cloud provider type and region are maintained in the <code>Plant</code> status (<code>.status.clusterInfo.cloud</code>).</li><li>Kubernetes version - the Kubernetes version is maintained in the <code>Plant</code> status (<code>.status.clusterInfo.kubernetes.version</code>).</li></ul></li><li>Cluster status<ul><li>API Server availability - maintained as condition with type <code>APIServerAvailable</code>.</li><li>Cluster <code>Node</code>s healthiness - maintained as condition with type <code>EveryNodeReady</code>.</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a7a632a48267b040a5183cbf28440ddf>8 - Etc</h1><h1 id=etcd---key-value-store-for-kubernetes>etcd - Key-Value Store for Kubernetes</h1><p><a href=https://etcd.io/>etcd</a> is a strongly consistent key-value store and the most prevalent choice for the Kubernetes
persistence layer. All API cluster objects like <code>Pod</code>s, <code>Deployment</code>s, <code>Secret</code>s, etc. are stored in <code>etcd</code> which
makes it an essential part of a <a href=https://kubernetes.io/docs/concepts/overview/components/#control-plane-components>Kubernetes control plane</a>.</p><h2 id=shoot-cluster-persistence>Shoot cluster persistence</h2><p>Each shoot cluster gets its very own persistence for the control plane. It runs in the shoot namespace on the respective
seed cluster. Concretely, there are two etcd instances per shoot cluster which the <code>Kube-Apiserver</code> is configured
to use in the following way:</p><ul><li>etcd-main</li></ul><p>A store that contains all &ldquo;cluster critical&rdquo; or &ldquo;long-term&rdquo; objects. These object kinds are typically considered
for a backup to prevent any data loss.</p><ul><li>etcd-events</li></ul><p>A store that contains all <code>Event</code> objects (<code>events.k8s.io</code>) of a cluster. <code>Events</code> have usually a short retention
period, occur frequently but are not essential for a disaster recovery.</p><p>The setup above prevents both, the critical <code>etcd-main</code> is not flooded by Kubernetes <code>Events</code> as well as backup space is
not occupied by non-critical data. This segmentation saves time and resources.</p><h2 id=etcd-operator>etcd Operator</h2><p>Configuring, maintaining and health-checking <code>etcd</code> is outsourced to a dedicated operator called <a href=https://github.com/gardener/etcd-druid/>ETCD Druid</a>.
When <a href=/docs/gardener/concepts/gardenlet/>Gardenlet</a> reconciles a <code>Shoot</code> resource, it creates or updates an <a href=https://github.com/gardener/etcd-druid/blob/1d427e9167adac1476d1847c0e265c2c09d6bc62/config/samples/druid_v1alpha1_etcd.yaml>Etcd</a>
resources in the seed cluster, containing necessary information (backup information, defragmentation schedule, resources, etc.) <code>etcd-druid</code>
needs to manage the lifecycle of the desired etcd instance (today <code>main</code> or <code>events</code>). Likewise, when the shoot is deleted,
Gardenlet deletes the <code>Etcd</code> resource and <a href=https://github.com/gardener/etcd-druid/>ETCD Druid</a> takes care about cleaning up
all related objects, e.g. the backing <code>StatefulSet</code>.</p><h2 id=autoscaling>Autoscaling</h2><p>Gardenlet maintains <a href=https://github.com/gardener/hvpa-controller/blob/master/config/samples/autoscaling_v1alpha1_hvpa.yaml>HVPA</a>
objects for etcd <code>StatefulSet</code>s if the corresponding <a href=/docs/gardener/deployment/feature_gates/>feature gate</a> is enabled. This enables
a vertical scaling for <code>etcd</code>. Downscaling is handled more pessimistic to prevent many subsequent <code>etcd</code> restarts. Thus,
for <code>production</code> clusters downscaling is deactivated and for all other clusters lower advertised requests/limits are only
applied during a shoot&rsquo;s maintenance time window.</p><h2 id=backup>Backup</h2><p>If <code>Seed</code>s specify backups for etcd (<a href=https://github.com/gardener/gardener/blob/e9bf88a7a091a8cf8c495bef298bdada17a03c7f/example/50-seed.yaml#L19>example</a>),
then Gardener and the respective <a href=/docs/gardener/extensions/overview/>provider extensions</a> are responsible for creating a bucket
on the cloud provider&rsquo;s side (modelled through <a href=/docs/gardener/extensions/backupbucket/>BackupBucket resource</a>). The bucket stores
backups of shoots scheduled on that seed. Furthermore, Gardener creates a <a href=/docs/gardener/extensions/backupentry/>BackupEntry</a>
which subdivides the bucket and thus makes it possible to store backups of multiple shoot clusters.</p><p>The <code>etcd-main</code> instance itself is configured to run with a special backup-restore <em>sidecar</em>. It takes care about regularly
backing up etcd data and restoring it in case of data loss. More information can be found on the component&rsquo;s GitHub
page <a href=https://github.com/gardener/etcd-backup-restore>https://github.com/gardener/etcd-backup-restore</a>.</p><p>How long backups are stored in the bucket after a shoot has been deleted, depends on the configured <em>retention period</em> in the
<code>Seed</code> resource. Please see this <a href=https://github.com/gardener/gardener/blob/849cd857d0d20e5dde26b9740ca2814603a56dfd/example/20-componentconfig-gardenlet.yaml#L20>example configuration</a> for more information.</p><h2 id=housekeeping>Housekeeping</h2><p><a href=https://etcd.io/docs/v3.3/op-guide/maintenance/>etcd maintenance tasks</a> must be performed from time to time in order
to re-gain database storage and to ensure the system&rsquo;s reliability. The <a href=https://github.com/gardener/etcd-backup-restore>backup-restore</a>
<em>sidecar</em> takes care about this job as well. Gardener chooses a random time <strong>within the shoot&rsquo;s maintenance time</strong> to
schedule these tasks.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-899a4a43944208c044aaee6e6023bbba>9 - Gardenlet</h1><h1 id=gardenlet>Gardenlet</h1><p>Gardener is implemented using the <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/operator/>operator pattern</a>:
It uses custom controllers that act on our own custom resources,
and apply Kubernetes principles to manage clusters instead of containers.
Following this analogy, you can recognize components of the Gardener architecture
as well-known Kubernetes components, for example, shoot clusters can be compared with pods,
and seed clusters can be seen as worker nodes.</p><p>The following Gardener components play a similar role as the corresponding components
in the Kubernetes architecture:</p><table><thead><tr><th style=text-align:left>Gardener Component</th><th style=text-align:left>Kubernetes Component</th></tr></thead><tbody><tr><td style=text-align:left><code>gardener-apiserver</code></td><td style=text-align:left><code>kube-apiserver</code></td></tr><tr><td style=text-align:left><code>gardener-controller-manager</code></td><td style=text-align:left><code>kube-controller-manager</code></td></tr><tr><td style=text-align:left><code>gardener-scheduler</code></td><td style=text-align:left><code>kube-scheduler</code></td></tr><tr><td style=text-align:left><code>gardenlet</code></td><td style=text-align:left><code>kubelet</code></td></tr></tbody></table><p>Similar to how the <code>kube-scheduler</code> of Kubernetes finds an appropriate node
for newly created pods, the <code>gardener-scheduler</code> of Gardener finds an appropriate seed cluster
to host the control plane for newly ordered clusters.
By providing multiple seed clusters for a region or provider, and distributing the workload,
Gardener also reduces the blast radius of potential issues.</p><p>Kubernetes runs a primary &ldquo;agent&rdquo; on every node, the kubelet,
which is responsible for managing pods and containers on its particular node.
Decentralizing the responsibility to the kubelet has the advantage that the overall system
is scalable. Gardener achieves the same for cluster management by using a <strong>gardenlet</strong>
as primary &ldquo;agent&rdquo; on every seed cluster, and is only responsible for shoot clusters
located in its particular seed cluster:</p><p><img src=/__resources/gardenlet-architecture-similarities_ba8a1c.png alt="Counterparts in the Gardener Architecture and the Kubernetes Architecture"></p><p>The <code>gardener-controller-manager</code> has control loops to manage resources of the Gardener API. However, instead of letting the <code>gardener-controller-manager</code> talk directly to seed clusters or shoot clusters, the responsibility isn’t only delegated to the gardenlet, but also managed using a reversed control flow: It&rsquo;s up to the gardenlet to contact the Gardener API server, for example, to share a status for its managed seed clusters.</p><p>Reversing the control flow allows placing seed clusters or shoot clusters behind firewalls without the necessity of direct access via VPN tunnels anymore.</p><p><img src=/__resources/gardenlet-architecture-detailed_6f3172.png alt="Reversed Control Flow Using a Gardenlet"></p><h2 id=tls-bootstrapping>TLS Bootstrapping</h2><p>Kubernetes doesn’t manage worker nodes itself, and it’s also not
responsible for the lifecycle of the kubelet running on the workers.
Similarly, Gardener doesn’t manage seed clusters itself,
so Gardener is also not responsible for the lifecycle of the gardenlet running on the seeds.
As a consequence, both the gardenlet and the kubelet need to prepare
a trusted connection to the Gardener API server
and the Kubernetes API server correspondingly.</p><p>To prepare a trusted connection between the gardenlet
and the Gardener API server, the gardenlet initializes
a bootstrapping process after you deployed it into your seed clusters:</p><ol><li><p>The gardenlet starts up with a bootstrap <code>kubeconfig</code>
having a bootstrap token that allows to create <code>CertificateSigningRequest</code> (CSR) resources.</p></li><li><p>After the CSR is signed, the gardenlet downloads
the created client certificate, creates a new <code>kubeconfig</code> with it,
and stores it inside a <code>Secret</code> in the seed cluster.</p></li><li><p>The gardenlet deletes the bootstrap <code>kubeconfig</code> secret,
and starts up with its new <code>kubeconfig</code>.</p></li><li><p>The gardenlet starts normal operation.</p></li></ol><p>The <code>gardener-controller-manager</code> runs a control loop
that automatically signs CSRs created by gardenlets.</p><blockquote><p>The gardenlet bootstrapping process is based on the
kubelet bootstrapping process. More information:
<a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Kubelet&rsquo;s TLS bootstrapping</a>.</p></blockquote><p>If you don&rsquo;t want to run this bootstrap process you can create
a <code>kubeconfig</code> pointing to the garden cluster for the gardenlet yourself,
and use field <code>gardenClientConnection.kubeconfig</code> in the
gardenlet configuration to share it with the gardenlet.</p><h2 id=gardenlet-certificate-rotation>Gardenlet Certificate Rotation</h2><p>The certificate used to authenticate the gardenlet against the API server
has a certain validity based on the configuration of the garden cluster
(<code>--cluster-signing-duration</code> flag of the <code>kube-controller-manager</code> (default <code>1y</code>)).
After about 80% of the validity expired, the gardenlet tries to automatically replace
the current certificate with a new one (certificate rotation).</p><p>To use certificate rotation, you need to specify the secret to store
the <code>kubeconfig</code> with the rotated certificate in field
<code>.gardenClientConnection.kubeconfigSecret</code> of the
gardenlet <a href=#component-configuration>component configuration</a>.</p><h3 id=rotate-certificates-using-bootstrap-kubeconfig>Rotate certificates using bootstrap <code>kubeconfig</code></h3><p>If the gardenlet created the certificate during the initial TLS Bootstrapping
using the Bootstrap <code>kubeconfig</code>, certificates can be rotated automatically.
The same control loop in the <code>gardener-controller-manager</code> that signs
the CSRs during the initial TLS Bootstrapping also automatically signs
the CSR during a certificate rotation.</p><p>ℹ️ You can trigger an immediate renewal by annotating the <code>Secret</code> in the seed
cluster stated in the <code>.gardenClientConnection.kubeconfigSecret</code> field with
<code>gardener.cloud/operation=renew</code> and restarting the gardenlet. After it booted
up again, gardenlet will issue a new certificate independent of the remaining
validity of the existing one.</p><h3 id=rotate-certificate-using-custom-kubeconfig>Rotate Certificate Using Custom <code>kubeconfig</code></h3><p>When trying to rotate a custom certificate that wasn’t created by gardenlet
as part of the TLS Bootstrap, the x509 certificate&rsquo;s <code>Subject</code> field
needs to conform to the following:</p><ul><li>the Common Name (CN) is prefixed with <code>gardener.cloud:system:seed:</code></li><li>the Organization (O) equals <code>gardener.cloud:system:seeds</code></li></ul><p>Otherwise, the <code>gardener-controller-manager</code> doesn’t automatically
sign the CSR.
In this case, an external component or user needs to approve the CSR manually,
for example, using command <code>kubectl certificate approve seed-csr-&lt;...></code>).
If that doesn’t happen within 15 minutes,
the gardenlet repeats the process and creates another CSR.</p><h2 id=configuring-the-seed-to-work-with>Configuring the Seed to work with</h2><p>The Gardenlet works with a single seed, which must be configured in the
<code>GardenletConfiguration</code> under <code>.seedConfig</code>. This must be a copy of the
<code>Seed</code> resource, for example (see <code>example/20-componentconfig-gardenlet.yaml</code>
for a more complete example):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: gardenlet.config.gardener.cloud/v1alpha1
kind: GardenletConfiguration
seedConfig:
  metadata:
    name: my-seed
  spec:
    provider:
      type: aws
    <span style=color:green># ...</span>
    secretRef:
      name: my-seed-secret
      namespace: garden
</code></pre></div><p>When using <code>make start-gardenlet</code>, the corresponding script will automatically
fetch the seed cluster&rsquo;s <code>kubeconfig</code> based on the <code>seedConfig.spec.secretRef</code>
and set the environment accordingly.</p><p>On startup, gardenlet registers a <code>Seed</code> resource using the given template
in <code>seedConfig</code> if it&rsquo;s not present already.</p><h2 id=component-configuration>Component Configuration</h2><p>In the component configuration for the gardenlet, it’s possible to define:</p><ul><li>settings for the Kubernetes clients interacting with the various clusters</li><li>settings for the control loops inside the gardenlet</li><li>settings for leader election and log levels, feature gates, and seed selection or seed configuration.</li></ul><p>More information: <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>Example Gardenlet Component Configuration</a>.</p><h2 id=heartbeats>Heartbeats</h2><p>Similar to how Kubernetes uses <code>Lease</code> objects for node heart beats
(see <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/589-efficient-node-heartbeats/README.md>KEP</a>),
the gardenlet is using <code>Lease</code> objects for heart beats of the seed cluster.
Every two seconds, the gardenlet checks that the seed cluster&rsquo;s <code>/healthz</code>
endpoint returns HTTP status code 200.
If that is the case, the gardenlet renews the lease in the Garden cluster in the <code>gardener-system-seed-lease</code> namespace and updates
the <code>GardenletReady</code> condition in the <code>status.conditions</code> field of the <code>Seed</code> resource(s).</p><p>Similarly to the <code>node-lifecycle-controller</code> inside the <code>kube-controller-manager</code>,
the <code>gardener-controller-manager</code> features a <code>seed-lifecycle-controller</code> that sets
the <code>GardenletReady</code> condition to <code>Unknown</code> in case the gardenlet fails to renew the lease.
As a consequence, the <code>gardener-scheduler</code> doesn’t consider this seed cluster for newly created shoot clusters anymore.</p><h3 id=healthz-endpoint><code>/healthz</code> Endpoint</h3><p>The gardenlet includes an HTTPS server that serves a <code>/healthz</code> endpoint.
It’s used as a liveness probe in the <code>Deployment</code> of the gardenlet.
If the gardenlet fails to renew its lease
then the endpoint returns <code>500 Internal Server Error</code>, otherwise it returns <code>200 OK</code>.</p><p>Please note that the <code>/healthz</code> only indicates whether the gardenlet
could successfully probe the Seed&rsquo;s API server and renew the lease with
the Garden cluster.
It does <em>not</em> show that the Gardener extension API server (with the Gardener resource groups)
is available.
However, the Gardenlet is designed to withstand such connection outages and
retries until the connection is reestablished.</p><h2 id=control-loops>Control Loops</h2><p>The gardenlet consists out of several controllers which are now described in more detail.</p><p>⚠️ This section is not necessarily complete and might be under construction.</p><h3 id=backupentry-controller><code>BackupEntry</code> Controller</h3><p>The <code>BackupEntry</code> controller reconciles those <code>core.gardener.cloud/v1beta1.BackupEntry</code> resources whose <code>.spec.seedName</code> value is equal to the name of a <code>Seed</code> the respective gardenlet is responsible for.
Those resources are created by the <code>Shoot</code> controller (only if backup is enabled for the respective <code>Seed</code>) and there is exactly one <code>BackupEntry</code> per <code>Shoot</code>.</p><p>The controller creates an <code>extensions.gardener.cloud/v1alpha1.BackupEntry</code> resource (non-namespaced) in the seed cluster and waits until the responsible extension controller reconciled it (see <a href=/docs/gardener/extensions/backupentry/>this</a> for more details).
The status is populated in the <code>.status.lastOperation</code> field.</p><p>The <code>core.gardener.cloud/v1beta1.BackupEntry</code> resource has an owner reference pointing to the corresponding <code>Shoot</code>.
Hence, if the <code>Shoot</code> is deleted, also the <code>BackupEntry</code> resource gets deleted.
In this case, the controller deletes the <code>extensions.gardener.cloud/v1alpha1.BackupEntry</code> resource in the seed cluster and waits until the responsible extension controller has deleted it.
Afterwards, the finalizer of the <code>core.gardener.cloud/v1beta1.BackupEntry</code> resource is released so that it finally disappears from the system.</p><h4 id=keep-backup-for-deleted-shoots>Keep Backup for Deleted Shoots</h4><p>In some scenarios it might be beneficial to not immediately delete the <code>BackupEntry</code>s (and with them, the etcd backup) for deleted <code>Shoot</code>s.</p><p>In this case you can configure the <code>.controllers.backupEntry.deletionGracePeriodHours</code> field in the component configuration of the gardenlet.
For example, if you set it to <code>48</code>, then the <code>BackupEntry</code>s for deleted <code>Shoot</code>s will only be deleted <code>48</code> hours after the <code>Shoot</code> was deleted.</p><p>Additionally, you can limit the <a href=/docs/gardener/usage/shoot_purposes/>shoot purposes</a> for which this applies by setting <code>.controllers.backupEntry.deletionGracePeriodShootPurposes[]</code>.
For example, if you set it to <code>[production]</code> then only the <code>BackupEntry</code>s for <code>Shoot</code>s with <code>.spec.purpose=production</code> will be deleted after the configured grace period. All others will be deleted immediately after the <code>Shoot</code> deletion.</p><h2 id=managed-seeds>Managed Seeds</h2><p>Gardener users can use shoot clusters as seed clusters, so-called &ldquo;managed seeds&rdquo; (aka &ldquo;shooted seeds&rdquo;),
by creating <code>ManagedSeed</code> resources.
By default, the gardenlet that manages this shoot cluster then automatically
creates a clone of itself with the same version and the same configuration
that it currently has.
Then it deploys the gardenlet clone into the managed seed cluster.</p><p>If you want to prevent the automatic gardenlet deployment,
specify the <code>seedTemplate</code> section in the <code>ManagedSeed</code> resource, and don&rsquo;t specify
the <code>gardenlet</code> section.
In this case, you have to deploy the gardenlet on your own into the seed cluster.</p><p>More information: <a href=/docs/gardener/usage/managed_seed/>Register Shoot as Seed</a></p><h2 id=migrating-from-previous-gardener-versions>Migrating from Previous Gardener Versions</h2><p>If your Gardener version doesn’t support gardenlets yet,
no special migration is required, but the following prerequisites must be met:</p><ul><li>Your Gardener version is at least 0.31 before upgrading to v1.</li><li>You have to make sure that your garden cluster is exposed in a way
that it’s reachable from all your seed clusters.</li></ul><p>With previous Gardener versions, you had deployed the Gardener Helm chart
(incorporating the API server, <code>controller-manager</code>, and scheduler).
With v1, this stays the same, but you now have to deploy the gardenlet Helm chart as well
into all of your seeds (if they aren’t managed, as mentioned earlier).</p><p>More information: <a href=/docs/gardener/deployment/deploy_gardenlet/>Deploy a Gardenlet</a> for all instructions.</p><h2 id=related-links>Related Links</h2><p><a href=https://github.com/gardener/documentation/wiki/Architecture>Gardener Architecture</a></p><p><a href=https://github.com/gardener/gardener/issues/356>Issue #356: Implement Gardener Scheduler</a></p><p><a href=https://github.com/gardener/gardener/pull/2309>PR #2309: Add /healthz endpoint for Gardenlet</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-cb07d159d53f4035bc26172627a54c7b>10 - Network Policies</h1><h1 id=network-policies-in-gardener>Network Policies in Gardener</h1><p>As <code>Seed</code> clusters can host the <a href=https://kubernetes.io/docs/concepts/#kubernetes-control-plane>Kubernetes control planes</a> of many <code>Shoot</code> clusters, it is necessary to isolate the control planes from each other for security reasons.
Besides deploying each control plane in its own namespace, Gardener creates <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>network policies</a> to also isolate the networks.
Essentially, network policies make sure that pods can only talk to other pods over the network they are supposed to.
As such, network policies are an important part of Gardener&rsquo;s tenant isolation.</p><p>Gardener deploys network policies into</p><ul><li>each namespace hosting the Kubernetes control plane of the Shoot cluster.</li><li>the namespace dedicated to Gardener seed-wide global controllers. This namespace is often called <code>garden</code> and contains e.g. the <a href=https://github.com/gardener/gardener/blob/15cae57db802cbe460ff4cb3f80c26b2fc15e26f/docs/concepts/gardenlet.md>Gardenlet</a>.</li><li>the <code>kube-system</code> namespace in the Shoot.</li></ul><p>The aforementioned namespaces in the Seed contain a <code>deny-all</code> network policy that <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic>denies all ingress and egress traffic</a>.
This <a href=https://en.wikipedia.org/wiki/Secure_by_default>secure by default</a> setting requires pods to allow network traffic.
This is done by pods having <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource>labels matching to the selectors of the network policies</a> deployed by Gardener.</p><p>More details on the deployed network policies can be found in the <a href=https://github.com/gardener/gardener/tree/master/docs/development/seed_network_policies.md>development</a> and <a href=https://github.com/gardener/gardener/tree/master/docs/usage/shoot_network_policies.md>usage</a> sections.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-41370c41a8d3d04ad03bad8e1b4c465e>11 - Resource Manager</h1><h1 id=gardener-resource-manager>Gardener Resource Manager</h1><p>Initially, the gardener-resource-manager was a project similar to the <a href=https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/addon-manager>kube-addon-manager</a>.
It manages Kubernetes resources in a target cluster which means that it creates, updates, and deletes them.
Also, it makes sure that manual modifications to these resources are reconciled back to the desired state.</p><p>In the Gardener project we were using the kube-addon-manager since more than two years.
While we have progressed with our <a href=/docs/gardener/proposals/01-extensibility/>extensibility story</a> (moving cloud providers out-of-tree) we had decided that the kube-addon-manager is no longer suitable for this use-case.
The problem with it is that it needs to have its managed resources on its file system.
This requires storing the resources in <code>ConfigMap</code>s or <code>Secret</code>s and mounting them to the kube-addon-manager pod during deployment time.
The gardener-resource-manager uses <code>CustomResourceDefinition</code>s which allows to dynamically add, change, and remove resources with immediate action and without the need to reconfigure the volume mounts/restarting the pod.</p><p>Meanwhile, the <code>gardener-resource-manager</code> has evolved to a more generic component comprising several controllers and webhook handlers.
It is deployed by gardenlet once per seed (in the <code>garden</code> namespace) and once per shoot (in the respective shoot namespaces in the seed).</p><h2 id=controllers>Controllers</h2><h3 id=managedresource-controller><code>ManagedResource</code> controller</h3><p>This controller watches custom objects called <code>ManagedResource</code>s in the <code>resources.gardener.cloud/v1alpha1</code> API group.
These objects contain references to secrets which itself contain the resources to be managed.
The reason why a <code>Secret</code> is used to store the resources is that they could contain confidential information like credentials.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: Secret
metadata:
  name: managedresource-example1
  namespace: default
type: Opaque
data:
  objects.yaml: YXBpVmVyc2lvbjogdjEKa2luZDogQ29uZmlnTWFwCm1ldGFkYXRhOgogIG5hbWU6IHRlc3QtMTIzNAogIG5hbWVzcGFjZTogZGVmYXVsdAotLS0KYXBpVmVyc2lvbjogdjEKa2luZDogQ29uZmlnTWFwCm1ldGFkYXRhOgogIG5hbWU6IHRlc3QtNTY3OAogIG5hbWVzcGFjZTogZGVmYXVsdAo=
    <span style=color:green># apiVersion: v1</span>
    <span style=color:green># kind: ConfigMap</span>
    <span style=color:green># metadata:</span>
    <span style=color:green>#   name: test-1234</span>
    <span style=color:green>#   namespace: default</span>
    <span style=color:green># ---</span>
    <span style=color:green># apiVersion: v1</span>
    <span style=color:green># kind: ConfigMap</span>
    <span style=color:green># metadata:</span>
    <span style=color:green>#   name: test-5678</span>
    <span style=color:green>#   namespace: default</span>
---
apiVersion: resources.gardener.cloud/v1alpha1
kind: ManagedResource
metadata:
  name: example
  namespace: default
spec:
  secretRefs:
  - name: managedresource-example1
</code></pre></div><p>In the above example, the controller creates two <code>ConfigMap</code>s in the <code>default</code> namespace.
When a user is manually modifying them they will be reconciled back to the desired state stored in the <code>managedresource-example</code> secret.</p><p>It is also possible to inject labels into all the resources:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: Secret
metadata:
  name: managedresource-example2
  namespace: default
type: Opaque
data:
  other-objects.yaml: YXBpVmVyc2lvbjogYXBwcy92MSAjIGZvciB2ZXJzaW9ucyBiZWZvcmUgMS45LjAgdXNlIGFwcHMvdjFiZXRhMgpraW5kOiBEZXBsb3ltZW50Cm1ldGFkYXRhOgogIG5hbWU6IG5naW54LWRlcGxveW1lbnQKc3BlYzoKICBzZWxlY3RvcjoKICAgIG1hdGNoTGFiZWxzOgogICAgICBhcHA6IG5naW54CiAgcmVwbGljYXM6IDIgIyB0ZWxscyBkZXBsb3ltZW50IHRvIHJ1biAyIHBvZHMgbWF0Y2hpbmcgdGhlIHRlbXBsYXRlCiAgdGVtcGxhdGU6CiAgICBtZXRhZGF0YToKICAgICAgbGFiZWxzOgogICAgICAgIGFwcDogbmdpbngKICAgIHNwZWM6CiAgICAgIGNvbnRhaW5lcnM6CiAgICAgIC0gbmFtZTogbmdpbngKICAgICAgICBpbWFnZTogbmdpbng6MS43LjkKICAgICAgICBwb3J0czoKICAgICAgICAtIGNvbnRhaW5lclBvcnQ6IDgwCg==
    <span style=color:green># apiVersion: apps/v1</span>
    <span style=color:green># kind: Deployment</span>
    <span style=color:green># metadata:</span>
    <span style=color:green>#   name: nginx-deployment</span>
    <span style=color:green># spec:</span>
    <span style=color:green>#   selector:</span>
    <span style=color:green>#     matchLabels:</span>
    <span style=color:green>#       app: nginx</span>
    <span style=color:green>#   replicas: 2 # tells deployment to run 2 pods matching the template</span>
    <span style=color:green>#   template:</span>
    <span style=color:green>#     metadata:</span>
    <span style=color:green>#       labels:</span>
    <span style=color:green>#         app: nginx</span>
    <span style=color:green>#     spec:</span>
    <span style=color:green>#       containers:</span>
    <span style=color:green>#       - name: nginx</span>
    <span style=color:green>#         image: nginx:1.7.9</span>
    <span style=color:green>#         ports:</span>
    <span style=color:green>#         - containerPort: 80</span>

---
apiVersion: resources.gardener.cloud/v1alpha1
kind: ManagedResource
metadata:
  name: example
  namespace: default
spec:
  secretRefs:
  - name: managedresource-example2
  injectLabels:
    foo: bar
</code></pre></div><p>In this example the label <code>foo=bar</code> will be injected into the <code>Deployment</code> as well as into all created <code>ReplicaSet</code>s and <code>Pod</code>s.</p><h4 id=preventing-reconciliations>Preventing Reconciliations</h4><p>If a ManagedResource is annotated with <code>resources.gardener.cloud/ignore=true</code> then it will be skipped entirely by the controller (no reconciliations or deletions of managed resources at all).
However, when the ManagedResource itself is deleted (for example when a shoot is deleted) then the annotation is not respected and all resources will be deleted as usual.
This feature can be helpful to temporarily patch/change resources managed as part of such ManagedResource.</p><h4 id=modes>Modes</h4><p>The gardener-resource-manager can manage a resource in different modes. The supported modes are:</p><ul><li><code>Ignore</code><ul><li>The corresponding resource is removed from the ManagedResource status (<code>.status.resources</code>). No action is performed on the cluster - the resource is no longer &ldquo;managed&rdquo; (updated or deleted).</li><li>The primary use case is a migration of a resource from one ManagedResource to another one.</li></ul></li></ul><p>The mode for a resource can be specified with the <code>resources.gardener.cloud/mode</code> annotation. The annotation should be specified in the encoded resource manifest in the Secret that is referenced by the ManagedResource.</p><h4 id=resource-class>Resource Class</h4><p>By default, gardener-resource-manager controller watches for ManagedResources in all namespaces. <code>--namespace</code> flag can be specified to gardener-resource-manager binary to restrict the watch to ManagedResources in a single namespace.
A ManagedResource has an optional <code>.spec.class</code> field that allows to indicate that it belongs to given class of resources. <code>--resource-class</code> flag can be specified to gardener-resource-manager binary to restrict the watch to ManagedResources with the given <code>.spec.class</code>. A default class is assumed if no class is specified.</p><h4 id=conditions>Conditions</h4><p>A ManagedResource has a ManagedResourceStatus, which has an array of Conditions. Conditions currently include:</p><table><thead><tr><th>Condition</th><th>Description</th></tr></thead><tbody><tr><td><code>ResourcesApplied</code></td><td><code>True</code> if all resources are applied to the target cluster</td></tr><tr><td><code>ResourcesHealthy</code></td><td><code>True</code> if all resources are present and healthy</td></tr></tbody></table><p><code>ResourcesApplied</code> may be <code>False</code> when:</p><ul><li>the resource <code>apiVersion</code> is not known to the target cluster</li><li>the resource spec is invalid (for example the label value does not match the required regex for it)</li><li>&mldr;</li></ul><p><code>ResourcesHealthy</code> may be <code>False</code> when:</p><ul><li>the resource is not found</li><li>the resource is a Deployment and the Deployment does not have the minimum availability.</li><li>&mldr;</li></ul><p>Each Kubernetes resources has different notion for being healthy. For example, a Deployment is considered healthy if the controller observed its current revision and if the number of updated replicas is equal to the number of replicas.</p><p>The following section describes a healthy ManagedResource:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#a31515>&#34;conditions&#34;</span><span>:</span> [
  {
    &#34;type&#34;: <span style=color:#a31515>&#34;ResourcesApplied&#34;</span>,
    &#34;status&#34;: <span style=color:#a31515>&#34;True&#34;</span>,
    &#34;reason&#34;: <span style=color:#a31515>&#34;ApplySucceeded&#34;</span>,
    &#34;message&#34;: <span style=color:#a31515>&#34;All resources are applied.&#34;</span>,
    &#34;lastUpdateTime&#34;: <span style=color:#a31515>&#34;2019-09-09T11:31:21Z&#34;</span>,
    &#34;lastTransitionTime&#34;: <span style=color:#a31515>&#34;2019-09-08T19:53:23Z&#34;</span>
  },
  {
    &#34;type&#34;: <span style=color:#a31515>&#34;ResourcesHealthy&#34;</span>,
    &#34;status&#34;: <span style=color:#a31515>&#34;True&#34;</span>,
    &#34;reason&#34;: <span style=color:#a31515>&#34;ResourcesHealthy&#34;</span>,
    &#34;message&#34;: <span style=color:#a31515>&#34;All resources are healthy.&#34;</span>,
    &#34;lastUpdateTime&#34;: <span style=color:#a31515>&#34;2019-09-09T11:31:21Z&#34;</span>,
    &#34;lastTransitionTime&#34;: <span style=color:#a31515>&#34;2019-09-09T11:31:21Z&#34;</span>
  }
]  
</code></pre></div><h4 id=ignoring-updates>Ignoring Updates</h4><p>In some cases it is not desirable to update or re-apply some of the cluster components (for example, if customization is required or needs to be applied by the end-user).
For these resources, the annotation &ldquo;resources.gardener.cloud/ignore&rdquo; needs to be set to &ldquo;true&rdquo; or a truthy value (Truthy values are &ldquo;1&rdquo;, &ldquo;t&rdquo;, &ldquo;T&rdquo;, &ldquo;true&rdquo;, &ldquo;TRUE&rdquo;, &ldquo;True&rdquo;) in the corresponding managed resource secrets,
this can be done from the components that create the managed resource secrets, for example Gardener extensions or Gardener. Once this is done, the resource will be initially created and later ignored during reconciliation.</p><h4 id=preserving-replicas-or-resources-in-workload-resources>Preserving <code>replicas</code> or <code>resources</code> in Workload Resources</h4><p>The objects which are part of the <code>ManagedResource</code> can be annotated with</p><ul><li><code>resources.gardener.cloud/preserve-replicas=true</code> in case the <code>.spec.replicas</code> field of workload resources like <code>Deployment</code>s, <code>StatefulSet</code>s, etc. shall be preserved during updates.</li><li><code>resources.gardener.cloud/preserve-resources=true</code> in case the <code>.spec.containers[*].resources</code> fields of all containers of workload resources like <code>Deployment</code>s, <code>StatefulSet</code>s, etc. shall be preserved during updates.</li></ul><blockquote><p>This can be useful if there are non-standard horizontal/vertical auto-scaling mechanisms in place.
Standard mechanisms like <code>HorizontalPodAutoscaler</code> or <code>VerticalPodAutoscaler</code> will be auto-recognized by <code>gardener-resource-manager</code>, i.e., in such cases the annotations are not needed.</p></blockquote><h4 id=origin>Origin</h4><p>All the objects managed by the resource manager get a dedicated annotation
<code>resources.gardener.cloud/origin</code> describing the <code>ManagedResource</code> object that describes
this object.</p><p>By default this is in this format &lt;namespace>/&lt;objectname>.
In multi-cluster scenarios (the <code>ManagedResource</code> objects are maintained in a
cluster different from the one the described objects are managed), it might
be useful to include the cluster identity, as well.</p><p>This can be enforced by setting the <code>--cluster-id</code> option. Here, several
possibilities are supported:</p><ul><li>given a direct value: use this as id for the source cluster</li><li><code>&lt;cluster></code>: read the cluster identity from a <code>cluster-identity</code> config map
in the <code>kube-system</code> namespace (attribute <code>cluster-identity</code>). This is
automatically maintained in all clusters managed or involved in a gardener landscape.</li><li><code>&lt;default></code>: try to read the cluster identity from the config map. If not found,
no identity is used</li><li>empty string: no cluster identity is used (completely cluster local scenarios)</li></ul><p>The format of the origin annotation with a cluster id is &lt;cluster id>:&lt;namespace>/&lt;objectname>.</p><p>The default for the cluster id is the empty value (do not use cluster id).</p><h3 id=garbage-collector-for-immutable-configmapssecrets>Garbage Collector For Immutable <code>ConfigMap</code>s/<code>Secret</code>s</h3><p>In Kubernetes, workload resources (e.g., <code>Pod</code>s) can mount <code>ConfigMap</code>s or <code>Secret</code>s or reference them via environment variables in containers.
Typically, when the content of such <code>ConfigMap</code>/<code>Secret</code> gets changed then the respective workload is usually not dynamically reloading the configuration, i.e., a restart is required.
The most commonly used approach is probably having so-called <a href=https://helm.sh/docs/howto/charts_tips_and_tricks/#automatically-roll-deployments>checksum annotations in the pod template</a> which makes Kubernetes to recreate the pod if the checksum changes.
However, it has the downside that old, still running versions of the workload might not be able to properly work with the already updated content in the <code>ConfigMap</code>/<code>Secret</code>, potentially causing application outages.</p><p>In order to protect users from such outages (and to also improve the performance of the cluster), the Kubernetes community provides the <a href=https://kubernetes.io/docs/concepts/configuration/configmap/#configmap-immutable>&ldquo;immutable <code>ConfigMap</code>s/<code>Secret</code>s feature&rdquo;</a>.
Enabling immutability requires <code>ConfigMap</code>s/<code>Secret</code>s to have unique names.
Having unique names requires the client to delete <code>ConfigMap</code>s<code>/</code>Secret`s no longer in use.</p><p>In order to provide a similarly lightweight experience for clients (compared to the well-established checksum annotation approach), the Gardener Resource Manager features an optional garbage collector controller (disabled by default).
The purpose of this controller is cleaning up such immutable <code>ConfigMap</code>s/<code>Secret</code>s if they are no longer in use.</p><h4 id=how-does-the-garbage-collector-work>How does the garbage collector work?</h4><p>The following algorithm is implemented in the GC controller:</p><ol><li>List all <code>ConfigMap</code>s and <code>Secret</code>s labeled with <code>resources.gardener.cloud/garbage-collectable-reference=true</code>.</li><li>List all <code>Deployment</code>s, <code>StatefulSet</code>s, <code>DaemonSet</code>s, <code>Job</code>s, <code>CronJob</code>s, <code>Pod</code>s and for each of them<ol><li>iterate over the <code>.metadata.annotations</code> and for each of them<ol><li>If the annotation key follows the <code>reference.resources.gardener.cloud/{configmap,secret}-&lt;hash></code> scheme and the value equals <code>&lt;name></code> then consider it as &ldquo;in-use&rdquo;.</li></ol></li></ol></li><li>Delete all <code>ConfigMap</code>s and <code>Secret</code>s not considered as &ldquo;in-use&rdquo;.</li></ol><p>Consequently, clients need to</p><ol><li><p>Create immutable <code>ConfigMap</code>s/<code>Secret</code>s with unique names (e.g., a checksum suffix based on the <code>.data</code>).</p></li><li><p>Label such <code>ConfigMap</code>s/<code>Secret</code>s with <code>resources.gardener.cloud/garbage-collectable-reference=true</code>.</p></li><li><p>Annotate their workload resources with <code>reference.resources.gardener.cloud/{configmap,secret}-&lt;hash>=&lt;name></code> for all <code>ConfigMap</code>s/<code>Secret</code>s used by the containers of the respective <code>Pod</code>s.</p><p>⚠️ Add such annotations to <code>.metadata.annotations</code> as well as to all templates of other resources (e.g., <code>.spec.template.metadata.annotations</code> in <code>Deployment</code>s or <code>.spec.jobTemplate.metadata.annotations</code> and <code>.spec.jobTemplate.spec.template.metadata.annotations</code> for <code>CronJob</code>s.
This ensures that the GC controller does not unintentionally consider <code>ConfigMap</code>s/<code>Secret</code>s as &ldquo;not in use&rdquo; just because there isn&rsquo;t a <code>Pod</code> referencing them anymore (e.g., they could still be used by a <code>Deployment</code> scaled down to <code>0</code>).</p></li></ol><p>ℹ️ For the last step, there is a helper function <code>InjectAnnotations</code> in the <code>pkg/controller/garbagecollector/references</code> which you can use for your convenience.</p><p><strong>Example:</strong></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-1234
  namespace: default
  labels:
    resources.gardener.cloud/garbage-collectable-reference: <span style=color:#a31515>&#34;true&#34;</span>
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-5678
  namespace: default
  labels:
    resources.gardener.cloud/garbage-collectable-reference: <span style=color:#a31515>&#34;true&#34;</span>
---
apiVersion: v1
kind: Pod
metadata:
  name: example
  namespace: default
  annotations:
    reference.resources.gardener.cloud/configmap-82a3537f: test-5678
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    terminationGracePeriodSeconds: 2
</code></pre></div><p>The GC controller would delete the <code>ConfigMap/test-1234</code> because it is considered as not &ldquo;in-use&rdquo;.</p><p>ℹ️ If the GC controller is activated then the <code>ManagedResource</code> controller will no longer delete <code>ConfigMap</code>s/<code>Secret</code>s having the above label.</p><h4 id=how-to-activate-the-garbage-collector>How to activate the garbage collector?</h4><p>The GC controller can be activated by providing the <code>--garbage-collector-sync-period</code> flag with a value larger than <code>0</code> (e.g., <code>1h</code>) to the Gardener Resource Manager.</p><h3 id=tokeninvalidator>TokenInvalidator</h3><p>The Kubernetes community is slowly transitioning from static <code>ServiceAccount</code> token <code>Secret</code>s to <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection><code>ServiceAccount</code> Token Volume Projection</a>.
Typically, when you create a <code>ServiceAccount</code></p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ServiceAccount
metadata:
  name: default
</code></pre></div><p>then the <a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/serviceaccount/tokens_controller.go><code>serviceaccount-token</code></a> controller (part of <code>kube-controller-manager</code>) auto-generates a <code>Secret</code> with a static token:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
   annotations:
      kubernetes.io/service-account.name: default
      kubernetes.io/service-account.uid: 86e98645-2e05-11e9-863a-b2d4d086dd5a)
   name: default-token-ntxs9
type: kubernetes.io/service-account-token
data:
   ca.crt: base64(cluster-ca-cert)
   namespace: base64(namespace)
   token: base64(static-jwt-token)
</code></pre></div><p>Unfortunately, when using <code>ServiceAccount</code> Token Volume Projection in a <code>Pod</code>, this static token is actually not used at all:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  serviceAccountName: default
  containers:
  - image: nginx
    name: nginx
    volumeMounts:
    - mountPath: /var/run/secrets/tokens
      name: token
  volumes:
  - name: token
    projected:
      sources:
      - serviceAccountToken:
          path: token
          expirationSeconds: 7200
</code></pre></div><p>While the <code>Pod</code> is now using an expiring and auto-rotated token, the static token is still generated and valid.</p><p>As of Kubernetes v1.22, there is neither a way of preventing <code>kube-controller-manager</code> to generate such static tokens, nor a way to proactively remove or invalidate them:</p><ul><li><a href=https://github.com/kubernetes/kubernetes/issues/77599>https://github.com/kubernetes/kubernetes/issues/77599</a></li><li><a href=https://github.com/kubernetes/kubernetes/issues/77600>https://github.com/kubernetes/kubernetes/issues/77600</a></li></ul><p>Disabling the <code>serviceaccount-token</code> controller is an option, however, especially in the Gardener context it may either break end-users or it may not even be possible to control such settings.
Also, even if a future Kubernetes version supports native configuration of above behaviour, Gardener still supports older versions which won&rsquo;t get such features but need a solution as well.</p><p>This is where the <em>TokenInvalidator</em> comes into play:
Since it is not possible to prevent <code>kube-controller-manager</code> from generating static <code>ServiceAccount</code> <code>Secret</code>s, the <em>TokenInvalidator</em> is - as its name suggests - just invalidating these tokens.
It considers all such <code>Secret</code>s belonging to <code>ServiceAccount</code>s with <code>.automountServiceAccountToken=false</code>.
By default, all namespaces in the target cluster are watched, however, this can be configured by specifying the <code>--target-namespace</code> flag.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-serviceaccount
automountServiceAccountToken: <span style=color:#00f>false</span>
</code></pre></div><p>This will result in a static <code>ServiceAccount</code> token secret whose <code>token</code> value is invalid:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
kind: Secret
metadata:
  annotations:
    kubernetes.io/service-account.name: my-serviceaccount
    kubernetes.io/service-account.uid: 86e98645-2e05-11e9-863a-b2d4d086dd5a
  name: my-serviceaccount-token-ntxs9
type: kubernetes.io/service-account-token
data:
  ca.crt: base64(cluster-ca-cert)
  namespace: base64(namespace)
  token: AAAA
</code></pre></div><p>Any attempt to regenerate the token or creating a new such secret will again make the component invalidating it.</p><blockquote><p>You can opt-out of this behaviour for <code>ServiceAccount</code>s setting <code>.automountServiceAccountToken=false</code> by labeling them with <code>token-invalidator.resources.gardener.cloud/skip=true</code>.</p></blockquote><p>In order to enable the <em>TokenInvalidator</em> you have to set <code>--token-invalidator-max-concurrent-workers</code> to a value larger than <code>0</code>.</p><p>Below graphic shows an overview of the Token Invalidator for Service account secrets in the Shoot cluster.
<img src=/__resources/resource-manager-token-invalidator_b43fa2.jpg alt=image></p><h3 id=tokenrequestor>TokenRequestor</h3><p>This controller provides the service to create and auto-renew tokens via the <a href=https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/><code>TokenRequest</code> API</a>.</p><p>It provides a functionality similar to the kubelet&rsquo;s <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection>Service Account Token Volume Projection</a>.
It was created to handle the special case of issuing tokens to pods that run in a different cluster than the API server they communicate with (hence, using the native token volume projection feature is not possible).</p><p>The controller differentiates between <code>source cluster</code> and <code>target cluster</code>.
The <code>source cluster</code> hosts the gardener-resource-manager pod. Secrets in this cluster are watched and modified by the controller.
The <code>target cluster</code> <em>can</em> be configured to point to another cluster. The existence of ServiceAccounts are ensured and token requests are issued against the target.
When the gardener-resource-manager is deployed next to the Shoot&rsquo;s controlplane in the Seed the <code>source cluster</code> is the Seed while the <code>target cluster</code> points to the Shoot.</p><h4 id=reconciliation-loop>Reconciliation Loop</h4><p>This controller reconciles secrets in all namespaces in the source cluster with the label: <code>resources.gardener.cloud/purpose: token-requestor</code>.
See <a href=https://github.com/gardener/gardener/blob/master/example/resource-manager/30-secret-tokenrequestor.yaml>here</a> for an example of the secret.</p><p>The controller ensures a <code>ServiceAccount</code> exists in the target cluster as specified in the annotations of the <code>Secret</code> in the source cluster:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>serviceaccount.resources.gardener.cloud/name: &lt;sa-name&gt;
serviceaccount.resources.gardener.cloud/namespace: &lt;sa-namespace&gt;
</code></pre></div><p>The requested tokens will act with the privileges which are assigned to this <code>ServiceAccount</code>.</p><p>The controller will then request a token via the <a href=https://kubernetes.io/docs/reference/kubernetes-api/authentication-resources/token-request-v1/><code>TokenRequest</code> API</a> and populate it into the <code>.data.token</code> field to the <code>Secret</code> in the source cluster.</p><p>Alternatively, the client can provide a raw kubeconfig (in YAML or JSON format) via the <code>Secret</code>&rsquo;s <code>.data.kubeconfig</code> field.
The controller will then populate the requested token in the kubeconfig for the user used in the <code>.current-context</code>.
For example, if <code>.data.kubeconfig</code> is</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: AAAA
    server: some-server-url
  name: shoot--foo--bar
contexts:
- context:
    cluster: shoot--foo--bar
    user: shoot--foo--bar-token
  name: shoot--foo--bar
current-context: shoot--foo--bar
kind: Config
preferences: {}
users:
- name: shoot--foo--bar-token
  user:
    token: <span style=color:#a31515>&#34;&#34;</span>
</code></pre></div><p>then the <code>.users[0].user.token</code> field of the kubeconfig will be updated accordingly.</p><p>The controller also adds an annotation to the <code>Secret</code> to keep track when to renew the token before it expires.
By default, the tokens are issued to expire after 12 hours. The expiration time can be set with the following annotation:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>serviceaccount.resources.gardener.cloud/token-expiration-duration: 6h
</code></pre></div><p>It automatically renews once 80% of the lifetime is reached or after <code>24h</code>.</p><p>Optionally, the controller can also populate the token into a <code>Secret</code> in the target cluster. This can be requested by annotating the <code>Secret</code> in the source cluster with</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>token-requestor.resources.gardener.cloud/target-secret-name: <span style=color:#a31515>&#34;foo&#34;</span>
token-requestor.resources.gardener.cloud/target-secret-namespace: <span style=color:#a31515>&#34;bar&#34;</span>
</code></pre></div><p>Overall, the TokenRequestor controller provides credentials with limited lifetime (JWT tokens) used by Shoot control plane components running in the Seed
to talk to the Shoot API Server.
Please see the graphic below:</p><p><img src=/__resources/resource-manager-projected-token-controlplane-to-shoot-apiserver_da4cda.jpg alt=image></p><h2 id=webhooks>Webhooks</h2><h3 id=auto-mounting-projected-serviceaccount-tokens>Auto-Mounting Projected <code>ServiceAccount</code> Tokens</h3><p>When this webhook is activated then it automatically injects projected <code>ServiceAccount</code> token volumes into <code>Pod</code>s and all its containers if all of the following preconditions are fulfilled:</p><ol><li>The <code>Pod</code> is NOT labeled with <code>projected-token-mount.resources.gardener.cloud/skip=true</code>.</li><li>The <code>Pod</code>&rsquo;s <code>.spec.serviceAccountName</code> field is NOT empty and NOT set to <code>default</code>.</li><li>The <code>ServiceAccount</code> specified in the <code>Pod</code>&rsquo;s <code>.spec.serviceAccountName</code> sets <code>.automountServiceAccountToken=false</code>.</li><li>The <code>Pod</code>&rsquo;s <code>.spec.volumes[]</code> DO NOT already contain a volume with a name prefixed with <code>kube-api-access-</code>.</li></ol><p>The projected volume will look as follows:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>spec:
  volumes:
  - name: kube-api-access-gardener
    projected:
      defaultMode: 420
      sources:
      - serviceAccountToken:
          expirationSeconds: 43200
          path: token
      - configMap:
          items:
          - key: ca.crt
            path: ca.crt
          name: kube-root-ca.crt
      - downwardAPI:
          items:
          - fieldRef:
              apiVersion: v1
              fieldPath: metadata.namespace
            path: namespace
</code></pre></div><blockquote><p>The <code>expirationSeconds</code> are defaulted to <code>12h</code> and can be overwritten with the <code>--projected-token-mount-expiration-seconds</code> flag, or with the <code>projected-token-mount.resources.gardener.cloud/expiration-seconds</code> annotation on a <code>Pod</code> resource.</p></blockquote><p>The volume will be mounted into all containers specified in the <code>Pod</code> to the path <code>/var/run/secrets/kubernetes.io/serviceaccount</code>.
This is the default location where client libraries expect to find the tokens and mimics the <a href=https://github.com/kubernetes/kubernetes/tree/v1.22.2/plugin/pkg/admission/serviceaccount>upstream <code>ServiceAccount</code> admission plugin</a>, see <a href=https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#serviceaccount-admission-controller>this document</a> for more information.</p><p>Overall, this webhook is used to inject projected service account tokens into pods running in the Shoot and the Seed cluster.
Hence, it is served from the Seed GRM and each Shoot GRM.
Please find an overview below for pods deployed in the Shoot cluster:</p><p><img src=/__resources/resource-manager-projected-token-shoot-to-shoot-apiserver_4fdaf3.jpg alt=image></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d13c2ec04fc608d6d65a3a24ab54fbf9>12 - Scheduler</h1><h1 id=gardener-scheduler>Gardener Scheduler</h1><p>The Gardener Scheduler is in essence a controller that watches newly created shoots and assigns a seed cluster to them.
Conceptually, the task of the Gardener Scheduler is very similar to the task of the Kubernetes Scheduler: finding a seed for a shoot instead of a node for a pod.</p><p>Either the scheduling strategy or the shoot cluster purpose hereby determines how the scheduler is operating.
The following sections explain the configuration and flow in greater detail.</p><h2 id=why-is-the-gardener-scheduler-needed>Why is the Gardener Scheduler needed?</h2><h3 id=1-decoupling>1. Decoupling</h3><p>Previously, an admission plugin in the Gardener API server conducted the scheduling decisions.
This implies changes to the API server whenever adjustments of the scheduling are needed.
Decoupling the API server and the scheduler comes with greater flexibility to develop these components independently from each other.</p><h3 id=2-extensibility>2. Extensibility</h3><p>It should be possible to easily extend and tweak the scheduler in the future.
Possibly, similar to the Kubernetes scheduler, hooks could be provided which influence the scheduling decisions.
It should be also possible to completely replace the standard Gardener Scheduler with a custom implementation.</p><h2 id=algorithm-overview>Algorithm overview</h2><p>The following <strong>sequence</strong> describes the steps involved to determine a seed candidate:</p><ol><li>Determine usable seeds with &ldquo;usable&rdquo; defined as follows:<ul><li>no <code>.metadata.deletionTimestamp</code></li><li><code>.spec.settings.scheduling.visible</code> is <code>true</code></li><li>conditions <code>Bootstrapped</code>, <code>GardenletReady</code>, <code>BackupBucketsReady</code> (if available) are <code>true</code></li></ul></li><li>Filter seeds:<ul><li>matching <code>.spec.seedSelector</code> in <code>CloudProfile</code> used by the <code>Shoot</code></li><li>matching <code>.spec.seedSelector</code> in <code>Shoot</code></li><li>having no network intersection with the <code>Shoot</code>&rsquo;s networks (due to the VPN connectivity between seeds and shoots their networks must be disjoint)</li><li>having <code>.spec.settings.shootDNS.enabled=false</code> (only if the shoot specifies a DNS domain or does not use the <code>unmanaged</code> DNS provider)</li><li>whose taints (<code>.spec.taints</code>) are tolerated by the <code>Shoot</code> (<code>.spec.tolerations</code>)</li><li>whose capacity for shoots would not be exceeded if the shoot is scheduled onto the seed, see <a href=#ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring seeds capacity for shoots is not exceeded</a></li></ul></li><li>Apply active <a href=#strategies>strategy</a> e.g., <em>Minimal Distance strategy</em></li><li>Choose least utilized seed, i.e., the one with the least number of shoot control planes, will be the winner and written to the <code>.spec.seedName</code> field of the <code>Shoot</code>.</li></ol><h2 id=configuration>Configuration</h2><p>The Gardener Scheduler configuration has to be supplied on startup. It is a mandatory and also the only available flag.
<a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardener-scheduler.yaml>Here</a> is an example scheduler configuration.</p><p>Most of the configuration options are the same as in the Gardener Controller Manager (leader election, client connection, &mldr;).
However, the Gardener Scheduler on the other hand does not need a TLS configuration, because there are currently no webhooks configurable.</p><h2 id=strategies>Strategies</h2><p>The scheduling strategy is defined in the <em><strong>candidateDeterminationStrategy</strong></em> of the scheduler&rsquo;s configuration and can have the possible values <code>SameRegion</code> and <code>MinimalDistance</code>.
The <code>SameRegion</code> strategy is the default strategy.</p><ol><li><p><em>Same Region strategy</em></p><p>The Gardener Scheduler reads the <code>spec.provider.type</code> and <code>.spec.region</code> fields from the <code>Shoot</code> resource.
It tries to find a seed that has the identical <code>.spec.provider.type</code> and <code>.spec.provider.region</code> fields set.
If it cannot find a suitable seed, it adds an event to the shoot stating, that it is unschedulable.</p></li><li><p><em>Minimal Distance strategy</em></p><p>The Gardener Scheduler tries to find a valid seed with minimal distance to the shoot&rsquo;s intended region.
The distance is calculated based on the Levenshtein distance of the region. Therefore the region name
is split into a base name and an orientation. Possible orientations are <code>north</code>, <code>south</code>, <code>east</code>, <code>west</code> and <code>central</code>.
The distance then is twice the Levenshtein distance of the region&rsquo;s base name plus a correction value based on the
orientation and the provider.</p><p>If the orientations of shoot and seed candidate match, the correction value is 0, if they differ it is 2 and if
either the seed&rsquo;s or the shoot&rsquo;s region does not have an orientation it is 1.
If the provider differs the correction value is additionally incremented by 2.</p><p>Because of this a matching region with a matching provider is always prefered.</p></li></ol><p>In order to put the scheduling decision into effect, the scheduler sends an update request for the <code>Shoot</code> resource to
the API server. After validation, the Gardener Aggregated API server updates the shoot to have the <code>spec.seedName</code> field set.
Subsequently, the Gardenlet picks up and starts to create the cluster on the specified seed.</p><ol start=3><li><em>Special handling based on shoot cluster purpose</em></li></ol><p>Every shoot cluster can have a purpose that describes what the cluster is used for, and also influences how the cluster is setup (see <a href=/docs/gardener/usage/shoot_purposes/>this document</a> for more information).</p><p>In case the shoot has the <code>testing</code> purpose then the scheduler only reads the <code>.spec.provider.type</code> from the <code>Shoot</code> resource and tries to find a <code>Seed</code> that has the identical <code>.spec.provider.type</code>.
The region does not matter, i.e., <code>testing</code> shoots may also be scheduled on a seed in a complete different region if it is better for balancing the whole Gardener system.</p><h2 id=seedselector-field-in-the-shoot-specification><code>seedSelector</code> field in the <code>Shoot</code> specification</h2><p>Similar to the <code>.spec.nodeSelector</code> field in <code>Pod</code>s, the <code>Shoot</code> specification has an optional <code>.spec.seedSelector</code> field.
It allows the user to provide a label selector that must match the labels of <code>Seed</code>s in order to be scheduled to one of them.
The labels on <code>Seed</code>s are usually controlled by Gardener administrators/operators - end users cannot add arbitrary labels themselves.
If provided, the Gardener Scheduler will only consider those seeds as &ldquo;suitable&rdquo; whose labels match those provided in the <code>.spec.seedSelector</code> of the <code>Shoot</code>.</p><p>By default only seeds with the same provider than the shoot are selected. By adding a <code>providerTypes</code> field to the <code>seedSelector</code>
a dedicated set of possible providers (<code>*</code> means all provider types) can be selected.</p><h2 id=ensuring-seeds-capacity-for-shoots-is-not-exceeded>Ensuring seeds capacity for shoots is not exceeded</h2><p>Seeds have a practical limit of how many shoots they can accommodate. Exceeding this limit is undesirable as the system performance will be noticeably impacted. Therefore, the scheduler ensures that a seed&rsquo;s capacity for shoots is not exceeded by taking into account a maximum number of shoots that can be scheduled onto a seed.</p><p>This mechanism works as follows:</p><ul><li>The <code>gardenlet</code> is configured with certain <em>resources</em> and their total <em>capacity</em> (and, for certain resources, the amount <em>reserved</em> for Gardener), see <a href=https://github.com/gardener/gardener/blob/master/example/20-componentconfig-gardenlet.yaml>/example/20-componentconfig-gardenlet.yaml</a>. Currently, the only such resource is the maximum number of shoots that can be scheduled onto a seed.</li><li>The <code>gardenlet</code> seed controller updates the <code>capacity</code> and <code>allocatable</code> fields in Seed status with the capacity of each resource and how much of it is actually available to be consumed by shoots. The <code>allocatable</code> value of a resource is equal to <code>capacity</code> minus <code>reserved</code>.</li><li>When scheduling shoots, the scheduler filters out all candidate seeds whose allocatable capacity for shoots would be exceeded if the shoot is scheduled onto the seed.</li></ul><h2 id=failure-to-determine-a-suitable-seed>Failure to determine a suitable seed</h2><p>In case the scheduler fails to find a suitable seed, the operation is being retried with exponential backoff.</p><h2 id=current-limitation--future-plans>Current Limitation / Future Plans</h2><ul><li>Azure has unfortunately a geographically non-hierarchical naming pattern and does not start with the continent. This is the reason why we will exchange the implementation of the <code>MinimalDistance</code> strategy with a more suitable one in the future.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-948cfa9fe34970ab31d7b3bb36556f67>13 - Seed Admission Controller</h1><h1 id=gardener-seed-admission-controller>Gardener Seed Admission Controller</h1><p>The Gardener Seed admission controller is deployed by the Gardenlet as part of its seed bootstrapping phase and, consequently, running in every seed cluster.
It&rsquo;s main purpose is to serve webhooks (validating or mutating) in order to admit or deny certain requests to the seed&rsquo;s API server.</p><h2 id=what-is-it-doing-concretely>What is it doing concretely?</h2><h3 id=validating-webhooks>Validating Webhooks</h3><h4 id=unconfirmed-deletion-prevention>Unconfirmed Deletion Prevention</h4><p>As part of Gardener&rsquo;s <a href=/docs/gardener/extensions/overview/>extensibility concepts</a> a lot of <code>CustomResourceDefinition</code>s are deployed to the seed clusters that serve as extension points for provider-specific controllers.
For example, the <a href=/docs/gardener/extensions/infrastructure/><code>Infrastructure</code> CRD</a> triggers the provider extension to prepare the IaaS infrastructure of the underlying cloud provider for a to-be-created shoot cluster.
Consequently, these extension CRDs have a lot of power and control large portions of the end-user&rsquo;s shoot cluster.
Accidental or undesired deletions of those resource can cause tremendous and hard-to-recover-from outages and should be prevented.</p><p>Together with the deployment of the Gardener seed admission controller a <code>ValidatingWebhookConfiguration</code> for <code>CustomResourceDefinitions</code> and most (custom) resources in the <code>extensions.gardener.cloud/v1alpha1</code> API group is registered.
It prevents <code>DELETE</code> requests for those <code>CustomResourceDefinitions</code> labeled with <code>gardener.cloud/deletion-protected=true</code>, and for all mentioned custom resources if they were not previously annotated with the <code>confirmation.gardener.cloud/deletion=true</code>.
This prevents that undesired <code>kubectl delete &lt;...></code> requests are accepted.</p><h3 id=mutating-webhooks>Mutating Webhooks</h3><p>The admission controller endpoint <code>/webhooks/default-pod-scheduler-name/gardener-kube-scheduler</code> mutates <code>pods</code> and adds <code>gardener-kube-scheduler</code> to <code>.spec.scheduleName</code>.</p><p>When <code>SeedKubeScheduler</code> feature gate is enabled, all control plane components are mutated. The scheduler scores <code>Nodes</code> with most resource usage higher than the rest, resulting in greater resource utilization.</p></div></main></div></div><footer class="footer row d-print-none"><div class="container-fluid footer-wrapper"><ul class=nav><li><a href=https://gardener.cloud/blog/>Blogs</a></li><li><a href=https://gardener.cloud/community/>Community</a></li><li><a href=https://gardener.cloud/adopter/>Adopters</a></li><li><a href=/docs/>Documentation</a></li></ul><img src=/images/lp/gardener-logo.svg alt="Logo Gardener" class=logo><ul class=media-wr><li><a target=_blank href=https://kubernetes.slack.com/archives/CB57N0BFG><img src=/images/branding/slack-logo-white.svg class=media-icon><div class=media-text>Slack</div></a></li><li><a target=_blank href=https://github.com/gardener><img src=/images/branding/github-mark-logo.png class=media-icon><div class=media-text>GitHub</div></a></li><li><a target=_blank href=https://www.youtube.com/channel/UCwUhwKFREV8Su0gwAJQX7tw><img src=/images/branding/youtube-logo-dark.svg class=media-icon><div class=media-text>YouTube</div></a></li><li><a target=_blank href=https://twitter.com/GardenerProject><img src=/images/branding/twitter-logo-white.svg class=media-icon><div class=media-text>Twitter</div></a></li></ul><span class=copyright>Copyright 2019-2022 Gardener project authors. <a href=https://www.sap.com/corporate/en/legal/privacy.html>Privacy policy
<i class="fa fa-external-link" aria-hidden=true></i></a></span></div></footer></div><script src=https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js integrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js integrity=sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity=sha384-uQikAXnCAqsMb3ygtdqBYvcwvHUkzGIpjdGyy9owhURXHUxLC5LgTcSxJQH/RzjK crossorigin=anonymous></script><script src=/js/main.min.ef8e0714aff556fd5a9768ed6ecabd2964dd962cd9f89762a373947bb53bc742.js integrity="sha256-744HFK/1Vv1al2jtbsq9KWTdlizZ+Jdio3OUe7U7x0I=" crossorigin=anonymous></script></body></html>