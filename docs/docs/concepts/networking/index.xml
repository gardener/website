<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gardener – Networking</title><link>https://gardener.cloud/docs/concepts/networking/</link><description>Recent content in Networking on Gardener</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://gardener.cloud/docs/concepts/networking/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: DNS Management</title><link>https://gardener.cloud/docs/concepts/networking/dns-managment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/concepts/networking/dns-managment/</guid><description>
&lt;h1 id="external-dns-management">External DNS Management&lt;/h1>
&lt;p>The main artefact of this project is the &lt;b>DNS controller manager&lt;/b> for managing DNS records, also
nicknamed as the Gardener &amp;ldquo;DNS Controller&amp;rdquo;.&lt;/p>
&lt;p>It contains provisioning controllers for creating DNS records in one of the DNS cloud services&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/docs/aws-route53/README.md">&lt;em>Amazon Route53&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/docs/google-cloud-dns/README.md">&lt;em>Google CloudDNS&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/docs/alicloud-dns/README.md">&lt;em>AliCloud DNS&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/docs/azure-dns/README.md">&lt;em>Azure DNS&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/docs/openstack-designate/README.md">&lt;em>OpenStack Designate&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/docs/cloudflare/README.md">&lt;em>Cloudflare DNS&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/docs/infoblox/README.md">&lt;em>Infoblox&lt;/em>&lt;/a>,&lt;/li>
&lt;li>&lt;a href="https://github.com/gardener/external-dns-management/blob/master/docs/netlify/README.md">&lt;em>Netlify DNS&lt;/em>&lt;/a>,&lt;/li>
&lt;/ul>
&lt;p>and source controllers for services and ingresses to create DNS entries by annotations.&lt;/p>
&lt;p>The configuration for the external DNS service is specified in a custom resource &lt;code>DNSProvider&lt;/code>.
Multiple &lt;code>DNSProvider&lt;/code> can be used simultaneously and changed without restarting the DNS controller.&lt;/p>
&lt;p>DNS records are either created directly for a corresponding custom resource &lt;code>DNSEntry&lt;/code> or by
annotating a service or ingress.&lt;/p>
&lt;p>For a detailed explanation of the model, see section &lt;a href="#the-model">The Model&lt;/a>.&lt;/p>
&lt;p>For extending or adapting this project with your own source or provisioning controllers, see section
&lt;a href="#extensions">Extensions&lt;/a>&lt;/p>
&lt;h2 id="quick-start">Quick start&lt;/h2>
&lt;p>To install the &lt;b>DNS controller manager&lt;/b> in your Kubernetes cluster, follow these steps.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Prerequisites&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Check out or download the project to get a copy of the Helm charts.
It is recommended to check out the tag of the
&lt;a href="https://github.com/gardener/external-dns-management/releases">last release&lt;/a>, so that Helm
values reference the newest released container image for the deployment.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Make sure, that you have installed Helm client (&lt;code>helm&lt;/code>) locally and Helm server (&lt;code>tiller&lt;/code>) on
the Kubernetes cluster. See e.g. &lt;a href="https://helm.sh/docs/install/">Helm installation&lt;/a> for more details.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Install the DNS controller manager&lt;/p>
&lt;p>As multiple Gardener DNS controllers can act on the same DNS Hosted Zone concurrently, each instance needs
an &lt;a href="#owner-identifiers">owner identifier&lt;/a>. Therefore choose an identifier sufficiently unique across these instances.&lt;/p>
&lt;p>Then install the DNS controller manager with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">helm install charts/external-dns-management --name dns-controller --namespace&lt;span class="o">=&lt;/span>&amp;lt;my-namespace&amp;gt; --set configuration.identifier&lt;span class="o">=&lt;/span>&amp;lt;my-identifier&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will use the default configuration with all source and provisioning controllers enabled.
The complete set of configuration variables can be found in &lt;code>charts/external-dns-management/values.yaml&lt;/code>.
Their meaning is explained by their corresponding command line options in section
&lt;a href="#using-the-dns-controller-manager">Using the DNS controller manager&lt;/a>&lt;/p>
&lt;p>By default, the DNS controller looks for custom resources in all namespaces. The choosen namespace is
only relevant for the deployment itself.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create a &lt;code>DNSProvider&lt;/code>&lt;/p>
&lt;p>To specify a DNS provider, you need to create a custom resource &lt;code>DNSProvider&lt;/code> and a secret containing the
credentials for your account at the provider. E.g. if you want to use AWS Route53, create a secret and
provider with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">cat &lt;span class="s">&amp;lt;&amp;lt; EOF | kubectl apply -f -
&lt;/span>&lt;span class="s">apiVersion: v1
&lt;/span>&lt;span class="s">kind: Secret
&lt;/span>&lt;span class="s">metadata:
&lt;/span>&lt;span class="s"> name: aws-credentials
&lt;/span>&lt;span class="s"> namespace: default
&lt;/span>&lt;span class="s">type: Opaque
&lt;/span>&lt;span class="s">data:
&lt;/span>&lt;span class="s"> # replace &amp;#39;...&amp;#39; with values encoded as base64
&lt;/span>&lt;span class="s"> # see https://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html
&lt;/span>&lt;span class="s"> AWS_ACCESS_KEY_ID: ...
&lt;/span>&lt;span class="s"> AWS_SECRET_ACCESS_KEY: ...
&lt;/span>&lt;span class="s"> # or if the chain of credential providers should be used:
&lt;/span>&lt;span class="s"> #AWS_USE_CREDENTIALS_CHAIN: dHJ1ZQ==
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>and&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">cat &lt;span class="s">&amp;lt;&amp;lt; EOF | kubectl apply -f -
&lt;/span>&lt;span class="s">apiVersion: dns.gardener.cloud/v1alpha1
&lt;/span>&lt;span class="s">kind: DNSProvider
&lt;/span>&lt;span class="s">metadata:
&lt;/span>&lt;span class="s"> name: aws
&lt;/span>&lt;span class="s"> namespace: default
&lt;/span>&lt;span class="s">spec:
&lt;/span>&lt;span class="s"> type: aws-route53
&lt;/span>&lt;span class="s"> secretRef:
&lt;/span>&lt;span class="s"> name: aws-credentials
&lt;/span>&lt;span class="s"> domains:
&lt;/span>&lt;span class="s"> include:
&lt;/span>&lt;span class="s"> # this must be replaced with a (sub)domain of the hosted zone
&lt;/span>&lt;span class="s"> - my.own.domain.com
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Check the successful creation with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl get dnspr
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You should see something like&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">NAME TYPE STATUS AGE
aws aws-route53 Ready 12s
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Create a &lt;code>DNSEntry&lt;/code>&lt;/p>
&lt;p>Create an DNS entry with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">cat &lt;span class="s">&amp;lt;&amp;lt; EOF | kubectl apply -f -
&lt;/span>&lt;span class="s">apiVersion: dns.gardener.cloud/v1alpha1
&lt;/span>&lt;span class="s">kind: DNSEntry
&lt;/span>&lt;span class="s">metadata:
&lt;/span>&lt;span class="s"> name: mydnsentry
&lt;/span>&lt;span class="s"> namespace: default
&lt;/span>&lt;span class="s">spec:
&lt;/span>&lt;span class="s"> dnsName: &amp;#34;myentry.my-own-domain.com&amp;#34;
&lt;/span>&lt;span class="s"> ttl: 600
&lt;/span>&lt;span class="s"> targets:
&lt;/span>&lt;span class="s"> - 1.2.3.4
&lt;/span>&lt;span class="s">EOF&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Check the status of the DNS entry with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl get dnsentry
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You should see something like&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-txt" data-lang="txt">NAME DNS TYPE PROVIDER STATUS AGE
mydnsentry myentry.my-own-domain.com aws-route53 default/aws Ready 24s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As soon as the status of the entry is &lt;code>Ready&lt;/code>, the provider has accepted the new DNS record.
Depending on the provider and your DNS settings and cache, it may take up to a few minutes before
the domain name can be resolved.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Wait for/check DNS record&lt;/p>
&lt;p>To check the DNS resolution, use &lt;code>nslookup&lt;/code> or &lt;code>dig&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">nslookup myentry.my-own-domain.com
&lt;/code>&lt;/pre>&lt;/div>&lt;p>or with dig&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># or with dig&lt;/span>
dig +short myentry.my-own-domain.com
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Depending on your network settings, you may get a successful response faster using a public DNS server
(e.g. 8.8.8.8, 8.8.4.4, or 1.1.1.1)&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">dig @8.8.8.8 +short myentry.my-own-domain.com
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>For more examples about the custom resources and the annotations for services and ingresses
see the &lt;code>examples&lt;/code> directory.&lt;/p>
&lt;h3 id="automatic-creation-of-dns-entries-for-services-and-ingresses">Automatic creation of DNS entries for services and ingresses&lt;/h3>
&lt;p>Using the source controllers, it is also possible to create DNS entries for services (of type &lt;code>LoadBalancer&lt;/code>)
and ingresses automatically. The resources only need to be annotated with some special values.
In this case ensure that the source controllers are enabled on startup of the DNS controller manager, i.e. the
value of the command line option &lt;code>--controllers&lt;/code> must contain &lt;code>dnscontrollers&lt;/code> or equal to &lt;code>all&lt;/code>.
The DNS source controllers watch resources on the default cluster and create DNS entries on
the target cluster. As there can be multiple controllers active on the same cluster, you may
need to set the correct &lt;code>DNSClass&lt;/code> both for the controller and for the source resource by
setting the annotation &lt;code>dns.gardener.cloud/class&lt;/code>. The default value for the &lt;code>DNSClass&lt;/code> is &lt;code>gardendns&lt;/code>.&lt;/p>
&lt;p>Note that if you delegate the DNS management for shoot resources to Gardener via the
&lt;a href="https://github.com/gardener/gardener-extension-shoot-dns-service">shoot-dns-service extension&lt;/a>,
the correct annotation is &lt;code>dns.gardener.cloud/class=garden&lt;/code>.&lt;/p>
&lt;p>Here is an example for annotating a service (same as &lt;code>examples/50-service-with-dns.yaml&lt;/code>)]:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns.gardener.cloud/dnsnames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echo.my-dns-domain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns.gardener.cloud/ttl&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># If you are delegating the DNS Management to Gardener, uncomment the following line (see https://gardener.cloud/documentation/guides/administer_shoots/dns_names/)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#`dns.gardener.cloud/class`: garden&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">sessionAffinity&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">None&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">LoadBalancer&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-model">The Model&lt;/h2>
&lt;p>This project provides a flexible model allowing to
add DNS source objects and DNS provisioning environments by adding
new independent controllers.&lt;/p>
&lt;p>There is no single DNS controller anymore. The decoupling between the
handling of DNS source objects, like ingresses or services, and the
provisioning of DNS entries in an external DNS provider like
&lt;em>Route53&lt;/em> or &lt;em>CloudDNS&lt;/em> is achieved by introducing a new custom resource
&lt;code>DNSEntry&lt;/code>.&lt;/p>
&lt;p>These objects can either be explicitly created to request dedicated DNS
entries, or they are managed based on other resources like ingresses or
services. For the latter dedicated &lt;em>DNS Source Controllers&lt;/em> are used.
There might be any number of such source controllers. They do not need to know
anything about the various DNS environments. Their task is to figure out which
DNS entries are required in their realm and manage appropriate &lt;code>DNSEntry&lt;/code>
objects. From these objects they can also read the provisioning status and
report it back to the original source.&lt;/p>
&lt;p>&lt;img src="https://github.com/gardener/external-dns-management/raw/master/docs/model.png" alt="Model Overview">&lt;/p>
&lt;p>Provisioning of DNS entries in external DNS providers is done by
&lt;em>DNS Provisioning Controllers&lt;/em>. They don&amp;rsquo;t need to know anything about the
various DNS source objects. They watch &lt;code>DNSEntry&lt;/code> objects and check whether
they are responsible for such an object. If a provisioning controller feels
responsible for an entry it manages the corresponding settings in the
external DNS environment and reports the provisioning status back to the
corresponding &lt;code>DNSEntry&lt;/code> object.&lt;/p>
&lt;p>To do this a provisioning controller is responsible for a dedicated
environment (for example Route53). For every such environment the controller
uses a dedicated &lt;em>type&lt;/em> key. This key is used to look for &lt;code>DNSProvider&lt;/code> objects.
There might be multiple such objects per environment, specifying the
credentials needed to access different external accounts. These accounts are then
scanned for DNS zones and domain names they support.
This information is then used to dynamically assign &lt;code>DNSEntry&lt;/code> objects to
dedicated &lt;code>DNSProvider&lt;/code> objects. If such an assignment can be done by
a provisioning controller then it is &lt;em>responsible&lt;/em> for this entry and manages
the corresponding entries in the external environment.
&lt;code>DNSProvider&lt;/code> objects can specify explicit inclusion and exclusion sets of domain names
and/or DNS zone identifiers to override the scanning results of the account.&lt;/p>
&lt;h3 id="owner-identifiers">Owner Identifiers&lt;/h3>
&lt;p>Every DNS Provisioning Controller is responsible for a set of &lt;em>Owner Identifiers&lt;/em>.
DNS records in an external DNS environment are attached to such an identifier.
This is used to identify the records in the DNS environment managed by a dedicated
controller (manager). Every controller manager hosting DNS Provisioning Controllers
offers an option to specify a default identifier. Additionally there might
be dedicated &lt;code>DNSOwner&lt;/code> objects that enable or disable additional owner ids.&lt;/p>
&lt;p>Every &lt;code>DNSEntry&lt;/code> object may specify a dedicated owner that is used to tag
the records in the DNS environment. A DNS provisioning controller only acts
of DNS entries it is responsible for. Other resources in the external DNS
environment are not touched at all.&lt;/p>
&lt;p>This way it is possbible to&lt;/p>
&lt;ul>
&lt;li>identify records in the external DNS management environment that are managed
by the actual controller instance&lt;/li>
&lt;li>distinguish different DNS source environments sharing the same hosted zones
in the external management environment&lt;/li>
&lt;li>cleanup unused entries, even if the whole resource set is already
gone&lt;/li>
&lt;li>move the responsibility for dedicated sets of DNS entries among different
kubernetes clusters or DNS source environments running different
DNS Provisioning Controller without loosing the entries during the
migration process.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>If multiple DNS controller instances have access to the same DNS zones, it is very important, that every instance uses a unique owner identifier! Otherwise the cleanup of stale DNS record will delete entries created by another instance if they use the same identifier.&lt;/strong>&lt;/p>
&lt;h3 id="dns-classes">DNS Classes&lt;/h3>
&lt;p>Multiple sets of controllers of the DNS ecosystem can run in parallel in
a kubernetes cluster working on different object set. They are separated by
using different &lt;em>DNS Classes&lt;/em>. Adding a DNS class annotation to an object of the
DNS ecosytems assigns this object to such a dedicated set of DNS controllers.
This way it is possible to maintain clearly separated set of DNS objects in a
single kubernetes cluster.&lt;/p>
&lt;h3 id="dnsannotation-objects">DNSAnnotation objects&lt;/h3>
&lt;p>DNS source controllers support the creation of DNS entries for potentiialy
any kind of resource originally not equipped to describe the generation of
DNS entries. This is done by additionally annotations. Nevertheless it
might be the case, that those objects are again the result of a generation
process, ether by predefined helm starts or by other higher level controllers.
It is not necessarily possible to influence those generation steps to
additionally generate the deired DNS annotations.&lt;/p>
&lt;p>The typical mechanis in Kubernetes to handle this is to provide mutating
webhooks that enrich the generated objects accordingly. But this mechanism
is basically not intended to support dedicated settings for dedicated instances.
At least it is very strenous to provide web hooks for every such usecase.&lt;/p>
&lt;p>Therefore the DNS ecosystem provided by this project supports an additional
extension mechanism to annotate any kind of object with additional annotations
by supported a dedicated resource, the &lt;code>DNSAnnotation&lt;/code>.&lt;/p>
&lt;p>The handling of this resource is done by a dedicated controller, the &lt;code>annotation&lt;/code>
controller. It caches the annotation settings declared by those objects and
makes them accessible for the DNS source controllers.&lt;/p>
&lt;p>The DNS source controller responsible for a dedicated kind of resource
(for example Service reads the object analyses the annotations and then decides
what to do with it. Most of the flow is handled by a central library, only
some dedicated resource dependent steps are implemented separately by a
dedicated source controller. The &lt;code>DNSAnnotation&lt;/code>resource slightly extends this
flow: After reading the object the library additionally checks for the existence
of a &lt;code>DNSAnnotation&lt;/code> setting for this object by querying the &lt;code>annotation&lt;/code>
controller&amp;rsquo;s cache. If found, it adds annotations declared there to the original
object prior to the next processing steps.
This way, for example whenver a &lt;code>Service&lt;/code> without
any DNS related annotation is handled by the controller and it finds a matching
&lt;code>DNSAnnotation&lt;/code> setting, the set of actual annotations is enriched accordingly
before the actual processing of the service object is done by the controller.&lt;/p>
&lt;p>This &lt;code>DNSAnnotation&lt;/code> object can be created before or even after the object to
be annotated and will implicity cause a reprocessing of the original object by
its DNS source controller.&lt;/p>
&lt;p>For example, the following object enforces a DNS related annotation for the
processing of the service object &lt;code>testapp/default&lt;/code> by the service DNS source
controller:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">dns.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">DNSAnnotation&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">testapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">resourceRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">testapp&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns.gardener.cloud/dnsnames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">testapp.dns.gardener.cloud&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns.gardener.cloud/ttl&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;500&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="using-the-dns-controller-manager">Using the DNS controller manager&lt;/h2>
&lt;p>The controllers to run can be selected with the &lt;code>--controllers&lt;/code> option.
Here the following controller groups can be used:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>dnssources&lt;/code>: all DNS Source Controllers. It includes the conrollers&lt;/p>
&lt;ul>
&lt;li>&lt;code>ingress-dns&lt;/code>: handle DNS annotations for the standard kubernetes ingress resource&lt;/li>
&lt;li>&lt;code>service-dns&lt;/code>: handle DNS annotations for the standard kubernetes service resource&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>dnscontrollers&lt;/code>: all DNS Provisioning Controllers. It includes the controllers&lt;/p>
&lt;ul>
&lt;li>&lt;code>compound&lt;/code>: common DNS provisioning controller&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>all&lt;/code>: (default) all controllers&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>It is also possible to list dedicated controllers by their name.&lt;/p>
&lt;p>To restrict the compound DNS provisioning controller to specific provider types,
use the &lt;code>--provider-types&lt;/code> option.&lt;/p>
&lt;p>The following provider types can be selected (comma separated):&lt;/p>
&lt;ul>
&lt;li>&lt;code>alicloud-dns&lt;/code>: Alicloud DNS provider&lt;/li>
&lt;li>&lt;code>aws-route53&lt;/code>: AWS Route 53 provider&lt;/li>
&lt;li>&lt;code>azure-dns&lt;/code>: Azure DNS provider&lt;/li>
&lt;li>&lt;code>google-clouddns&lt;/code>: Google CloudDNS provider&lt;/li>
&lt;li>&lt;code>openstack-designate&lt;/code>: Openstack Designate provider&lt;/li>
&lt;li>&lt;code>cloudflare-dns&lt;/code>: Cloudflare DNS provider&lt;/li>
&lt;li>&lt;code>infoblox-dns&lt;/code>: Infoblox DNS provider&lt;/li>
&lt;li>&lt;code>netlify-dns&lt;/code>: Netlify DNS provider&lt;/li>
&lt;/ul>
&lt;p>If the compound DNS Provisioning Controller is enabled it is important to specify a
unique controller identity using the &lt;code>--identifier&lt;/code> option.
This identifier is stored in the DNS system to identify the DNS entries
managed by a dedicated controller. There should never be two
DNS controllers with the same identifier running at the same time for the
same DNS domains/accounts.&lt;/p>
&lt;p>Here is the complete list of options provided:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-txt" data-lang="txt">Usage:
dns-controller-manager [flags]
Flags:
--accepted-maintainers string accepted maintainer key(s) for crds
--advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--alicloud-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--alicloud-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--alicloud-dns.ratelimiter.burst int number of burst requests for rate limiter
--alicloud-dns.ratelimiter.enabled enables rate limiter for DNS provider requests
--alicloud-dns.ratelimiter.qps int maximum requests/queries per second
--annotation.default.pool.size int Worker pool size for pool default of controller annotation
--annotation.pool.size int Worker pool size of controller annotation
--annotation.setup int number of processors for controller setup of controller annotation
--aws-route53.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--aws-route53.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--aws-route53.ratelimiter.burst int number of burst requests for rate limiter
--aws-route53.ratelimiter.enabled enables rate limiter for DNS provider requests
--aws-route53.ratelimiter.qps int maximum requests/queries per second
--azure-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--azure-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--azure-dns.ratelimiter.burst int number of burst requests for rate limiter
--azure-dns.ratelimiter.enabled enables rate limiter for DNS provider requests
--azure-dns.ratelimiter.qps int maximum requests/queries per second
--bind-address-http string HTTP server bind address
--cache-dir string Directory to store zone caches (for reload after restart)
--cache-ttl int Time-to-live for provider hosted zone cache
--cloudflare-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--cloudflare-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--cloudflare-dns.ratelimiter.burst int number of burst requests for rate limiter
--cloudflare-dns.ratelimiter.enabled enables rate limiter for DNS provider requests
--cloudflare-dns.ratelimiter.qps int maximum requests/queries per second
--compound.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.alicloud-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.alicloud-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.alicloud-dns.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.alicloud-dns.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.alicloud-dns.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.aws-route53.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.aws-route53.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.aws-route53.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.aws-route53.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.aws-route53.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.azure-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.azure-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.azure-dns.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.azure-dns.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.azure-dns.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.cache-dir string Directory to store zone caches (for reload after restart) of controller compound
--compound.cache-ttl int Time-to-live for provider hosted zone cache of controller compound
--compound.cloudflare-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.cloudflare-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.cloudflare-dns.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.cloudflare-dns.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.cloudflare-dns.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.default.pool.size int Worker pool size for pool default of controller compound
--compound.disable-zone-state-caching disable use of cached dns zone state on changes of controller compound
--compound.dns-class string Class identifier used to differentiate responsible controllers for entry resources of controller compound
--compound.dns-delay duration delay between two dns reconciliations of controller compound
--compound.dns.pool.resync-period duration Period for resynchronization for pool dns of controller compound
--compound.dns.pool.size int Worker pool size for pool dns of controller compound
--compound.dry-run just check, don&amp;#39;t modify of controller compound
--compound.google-clouddns.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.google-clouddns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.google-clouddns.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.google-clouddns.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.google-clouddns.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.identifier string Identifier used to mark DNS entries in DNS system of controller compound
--compound.infoblox-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.infoblox-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.infoblox-dns.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.infoblox-dns.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.infoblox-dns.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.netlify-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.netlify-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.netlify-dns.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.netlify-dns.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.netlify-dns.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.openstack-designate.advanced.batch-size int batch size for change requests (currently only used for aws-route53) of controller compound
--compound.openstack-designate.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53) of controller compound
--compound.openstack-designate.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.openstack-designate.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.openstack-designate.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.ownerids.pool.size int Worker pool size for pool ownerids of controller compound
--compound.pool.resync-period duration Period for resynchronization of controller compound
--compound.pool.size int Worker pool size of controller compound
--compound.provider-types string comma separated list of provider types to enable of controller compound
--compound.providers.pool.resync-period duration Period for resynchronization for pool providers of controller compound
--compound.providers.pool.size int Worker pool size for pool providers of controller compound
--compound.ratelimiter.burst int number of burst requests for rate limiter of controller compound
--compound.ratelimiter.enabled enables rate limiter for DNS provider requests of controller compound
--compound.ratelimiter.qps int maximum requests/queries per second of controller compound
--compound.reschedule-delay duration reschedule delay after losing provider of controller compound
--compound.secrets.pool.size int Worker pool size for pool secrets of controller compound
--compound.setup int number of processors for controller setup of controller compound
--compound.statistic.pool.size int Worker pool size for pool statistic of controller compound
--compound.ttl int Default time-to-live for DNS entries. Defines how long the record is kept in cache by DNS servers or resolvers. of controller compound
--compound.zonepolicies.pool.size int Worker pool size for pool zonepolicies of controller compound
--config string config file
-c, --controllers string comma separated list of controllers to start (&amp;lt;name&amp;gt;,&amp;lt;group&amp;gt;,all)
--cpuprofile string set file for cpu profiling
--default.pool.resync-period duration Period for resynchronization for pool default
--default.pool.size int Worker pool size for pool default
--disable-namespace-restriction disable access restriction for namespace local access only
--disable-zone-state-caching disable use of cached dns zone state on changes
--dns-class string identifier used to differentiate responsible controllers for entries, Class identifier used to differentiate responsible controllers for entry resources, identifier used to differentiate responsible controllers for providers
--dns-delay duration delay between two dns reconciliations
--dns-target-class string identifier used to differentiate responsible dns controllers for target entries, identifier used to differentiate responsible dns controllers for target providers
--dns.pool.resync-period duration Period for resynchronization for pool dns
--dns.pool.size int Worker pool size for pool dns
--dnsentry-source.default.pool.resync-period duration Period for resynchronization for pool default of controller dnsentry-source
--dnsentry-source.default.pool.size int Worker pool size for pool default of controller dnsentry-source
--dnsentry-source.dns-class string identifier used to differentiate responsible controllers for entries of controller dnsentry-source
--dnsentry-source.dns-target-class string identifier used to differentiate responsible dns controllers for target entries of controller dnsentry-source
--dnsentry-source.exclude-domains stringArray excluded domains of controller dnsentry-source
--dnsentry-source.key string selecting key for annotation of controller dnsentry-source
--dnsentry-source.pool.resync-period duration Period for resynchronization of controller dnsentry-source
--dnsentry-source.pool.size int Worker pool size of controller dnsentry-source
--dnsentry-source.target-creator-label-name string label name to store the creator for generated DNS entries of controller dnsentry-source
--dnsentry-source.target-creator-label-value string label value for creator label of controller dnsentry-source
--dnsentry-source.target-name-prefix string name prefix in target namespace for cross cluster generation of controller dnsentry-source
--dnsentry-source.target-namespace string target namespace for cross cluster generation of controller dnsentry-source
--dnsentry-source.target-owner-id string owner id to use for generated DNS entries of controller dnsentry-source
--dnsentry-source.target-realms string realm(s) to use for generated DNS entries of controller dnsentry-source
--dnsentry-source.target-set-ignore-owners mark generated DNS entries to omit owner based access control of controller dnsentry-source
--dnsentry-source.targets.pool.size int Worker pool size for pool targets of controller dnsentry-source
--dnsprovider-replication.default.pool.resync-period duration Period for resynchronization for pool default of controller dnsprovider-replication
--dnsprovider-replication.default.pool.size int Worker pool size for pool default of controller dnsprovider-replication
--dnsprovider-replication.dns-class string identifier used to differentiate responsible controllers for providers of controller dnsprovider-replication
--dnsprovider-replication.dns-target-class string identifier used to differentiate responsible dns controllers for target providers of controller dnsprovider-replication
--dnsprovider-replication.pool.resync-period duration Period for resynchronization of controller dnsprovider-replication
--dnsprovider-replication.pool.size int Worker pool size of controller dnsprovider-replication
--dnsprovider-replication.target-creator-label-name string label name to store the creator for replicated DNS providers of controller dnsprovider-replication
--dnsprovider-replication.target-creator-label-value string label value for creator label of controller dnsprovider-replication
--dnsprovider-replication.target-name-prefix string name prefix in target namespace for cross cluster replication of controller dnsprovider-replication
--dnsprovider-replication.target-namespace string target namespace for cross cluster generation of controller dnsprovider-replication
--dnsprovider-replication.target-realms string realm(s) to use for replicated DNS provider of controller dnsprovider-replication
--dnsprovider-replication.targets.pool.size int Worker pool size for pool targets of controller dnsprovider-replication
--dry-run just check, don&amp;#39;t modify
--exclude-domains stringArray excluded domains
--force-crd-update enforce update of crds even they are unmanaged
--google-clouddns.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--google-clouddns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--google-clouddns.ratelimiter.burst int number of burst requests for rate limiter
--google-clouddns.ratelimiter.enabled enables rate limiter for DNS provider requests
--google-clouddns.ratelimiter.qps int maximum requests/queries per second
--grace-period duration inactivity grace period for detecting end of cleanup for shutdown
-h, --help help for dns-controller-manager
--identifier string Identifier used to mark DNS entries in DNS system
--infoblox-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--infoblox-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--infoblox-dns.ratelimiter.burst int number of burst requests for rate limiter
--infoblox-dns.ratelimiter.enabled enables rate limiter for DNS provider requests
--infoblox-dns.ratelimiter.qps int maximum requests/queries per second
--ingress-dns.default.pool.resync-period duration Period for resynchronization for pool default of controller ingress-dns
--ingress-dns.default.pool.size int Worker pool size for pool default of controller ingress-dns
--ingress-dns.dns-class string identifier used to differentiate responsible controllers for entries of controller ingress-dns
--ingress-dns.dns-target-class string identifier used to differentiate responsible dns controllers for target entries of controller ingress-dns
--ingress-dns.exclude-domains stringArray excluded domains of controller ingress-dns
--ingress-dns.key string selecting key for annotation of controller ingress-dns
--ingress-dns.pool.resync-period duration Period for resynchronization of controller ingress-dns
--ingress-dns.pool.size int Worker pool size of controller ingress-dns
--ingress-dns.target-creator-label-name string label name to store the creator for generated DNS entries of controller ingress-dns
--ingress-dns.target-creator-label-value string label value for creator label of controller ingress-dns
--ingress-dns.target-name-prefix string name prefix in target namespace for cross cluster generation of controller ingress-dns
--ingress-dns.target-namespace string target namespace for cross cluster generation of controller ingress-dns
--ingress-dns.target-owner-id string owner id to use for generated DNS entries of controller ingress-dns
--ingress-dns.target-realms string realm(s) to use for generated DNS entries of controller ingress-dns
--ingress-dns.target-set-ignore-owners mark generated DNS entries to omit owner based access control of controller ingress-dns
--ingress-dns.targets.pool.size int Worker pool size for pool targets of controller ingress-dns
--key string selecting key for annotation
--kubeconfig string default cluster access
--kubeconfig.disable-deploy-crds disable deployment of required crds for cluster default
--kubeconfig.id string id for cluster default
--kubeconfig.migration-ids string migration id for cluster default
--lease-duration duration lease duration
--lease-name string name for lease object
--lease-renew-deadline duration lease renew deadline
--lease-resource-lock string determines which resource lock to use for leader election, defaults to &amp;#39;configmapsleases&amp;#39;
--lease-retry-period duration lease retry period
-D, --log-level string logrus log level
--maintainer string maintainer key for crds (default &amp;#34;dns-controller-manager&amp;#34;)
--name string name used for controller manager (default &amp;#34;dns-controller-manager&amp;#34;)
--namespace string namespace for lease (default &amp;#34;kube-system&amp;#34;)
-n, --namespace-local-access-only enable access restriction for namespace local access only (deprecated)
--netlify-dns.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--netlify-dns.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--netlify-dns.ratelimiter.burst int number of burst requests for rate limiter
--netlify-dns.ratelimiter.enabled enables rate limiter for DNS provider requests
--netlify-dns.ratelimiter.qps int maximum requests/queries per second
--omit-lease omit lease for development
--openstack-designate.advanced.batch-size int batch size for change requests (currently only used for aws-route53)
--openstack-designate.advanced.max-retries int maximum number of retries to avoid paging stops on throttling (currently only used for aws-route53)
--openstack-designate.ratelimiter.burst int number of burst requests for rate limiter
--openstack-designate.ratelimiter.enabled enables rate limiter for DNS provider requests
--openstack-designate.ratelimiter.qps int maximum requests/queries per second
--ownerids.pool.size int Worker pool size for pool ownerids
--plugin-file string directory containing go plugins
--pool.resync-period duration Period for resynchronization
--pool.size int Worker pool size
--provider-types string comma separated list of provider types to enable
--providers string cluster to look for provider objects
--providers.disable-deploy-crds disable deployment of required crds for cluster provider
--providers.id string id for cluster provider
--providers.migration-ids string migration id for cluster provider
--providers.pool.resync-period duration Period for resynchronization for pool providers
--providers.pool.size int Worker pool size for pool providers
--ratelimiter.burst int number of burst requests for rate limiter
--ratelimiter.enabled enables rate limiter for DNS provider requests
--ratelimiter.qps int maximum requests/queries per second
--reschedule-delay duration reschedule delay after losing provider
--secrets.pool.size int Worker pool size for pool secrets
--server-port-http int HTTP server port (serving /healthz, /metrics, ...)
--service-dns.default.pool.resync-period duration Period for resynchronization for pool default of controller service-dns
--service-dns.default.pool.size int Worker pool size for pool default of controller service-dns
--service-dns.dns-class string identifier used to differentiate responsible controllers for entries of controller service-dns
--service-dns.dns-target-class string identifier used to differentiate responsible dns controllers for target entries of controller service-dns
--service-dns.exclude-domains stringArray excluded domains of controller service-dns
--service-dns.key string selecting key for annotation of controller service-dns
--service-dns.pool.resync-period duration Period for resynchronization of controller service-dns
--service-dns.pool.size int Worker pool size of controller service-dns
--service-dns.target-creator-label-name string label name to store the creator for generated DNS entries of controller service-dns
--service-dns.target-creator-label-value string label value for creator label of controller service-dns
--service-dns.target-name-prefix string name prefix in target namespace for cross cluster generation of controller service-dns
--service-dns.target-namespace string target namespace for cross cluster generation of controller service-dns
--service-dns.target-owner-id string owner id to use for generated DNS entries of controller service-dns
--service-dns.target-realms string realm(s) to use for generated DNS entries of controller service-dns
--service-dns.target-set-ignore-owners mark generated DNS entries to omit owner based access control of controller service-dns
--service-dns.targets.pool.size int Worker pool size for pool targets of controller service-dns
--setup int number of processors for controller setup
--statistic.pool.size int Worker pool size for pool statistic
--target string target cluster for dns requests
--target-creator-label-name string label name to store the creator for generated DNS entries, label name to store the creator for replicated DNS providers
--target-creator-label-value string label value for creator label
--target-name-prefix string name prefix in target namespace for cross cluster generation, name prefix in target namespace for cross cluster replication
--target-namespace string target namespace for cross cluster generation
--target-owner-id string owner id to use for generated DNS entries
--target-realms string realm(s) to use for generated DNS entries, realm(s) to use for replicated DNS provider
--target-set-ignore-owners mark generated DNS entries to omit owner based access control
--target.disable-deploy-crds disable deployment of required crds for cluster target
--target.id string id for cluster target
--target.migration-ids string migration id for cluster target
--targets.pool.size int Worker pool size for pool targets
--ttl int Default time-to-live for DNS entries. Defines how long the record is kept in cache by DNS servers or resolvers.
-v, --version version for dns-controller-manager
--zonepolicies.pool.size int Worker pool size for pool zonepolicies
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="extensions">Extensions&lt;/h2>
&lt;p>This project can also be used as library to implement own source and provisioning controllers.&lt;/p>
&lt;h3 id="how-to-implement-source-controllers">How to implement Source Controllers&lt;/h3>
&lt;p>Based on the provided source controller library a source controller must
implement the &lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/dns/source/interface.go">&lt;code>source.DNSSource&lt;/code> interface&lt;/a> and
provide an appropriate creator function.&lt;/p>
&lt;p>A source controller can be implemented following this example:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">service&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/resources&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/dns/source&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">_MAIN_RESOURCE&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">resources&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewGroupKind&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;core&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Service&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">DNSSourceController&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewDNSSouceTypeForExtractor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;service-dns&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_MAIN_RESOURCE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">GetTargets&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="kc">nil&lt;/span>&lt;span class="p">).&lt;/span>
&lt;span class="nf">FinalizerDomain&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;dns.gardener.cloud&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>
&lt;span class="nf">MustRegister&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">source&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CONTROLLER_GROUP_DNS_SOURCES&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Complete examples can be found in the sub packages of &lt;code>pkg/controller/source&lt;/code>.&lt;/p>
&lt;h3 id="how-to-implement-provisioning-controllers">How to implement Provisioning Controllers&lt;/h3>
&lt;p>Provisioning controllers can be implemented based on the provisioning controller library
in this repository and must implement the
&lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/dns/provider/interface.go">&lt;code>provider.DNSHandlerFactory&lt;/code> interface&lt;/a>.
This factory returns implementations of the &lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/dns/provider/interface.go">&lt;code>provider.DNSHandler&lt;/code> interface&lt;/a>
that does the effective work for a dedicated set of hosted zones.&lt;/p>
&lt;p>These factories can be embedded into a final controller manager (the runnable
instance) in several ways:&lt;/p>
&lt;ul>
&lt;li>The factory can be used to create a dedicated controller.
This controller can then be embedded into a controller manager, either in
its own controller manger or together with other controllers.&lt;/li>
&lt;li>The factory can be added to a compound factory, able to handle multiple
infrastructures. This one can then be used to create a dedicated controller,
again.&lt;/li>
&lt;/ul>
&lt;h4 id="embedding-a-factory-into-a-controller">Embedding a Factory into a Controller&lt;/h4>
&lt;p>A provisioning controller can be implemented following this
&lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/controller/provider/aws/controller/controller.go">example&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">controller&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/dns/provider&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">const&lt;/span> &lt;span class="nx">CONTROLLER_NAME&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;route53-dns-controller&amp;#34;&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">provider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">DNSController&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">CONTROLLER_NAME&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">Factory&lt;/span>&lt;span class="p">{}).&lt;/span>
&lt;span class="nf">FinalizerDomain&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;dns.gardener.cloud&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>
&lt;span class="nf">MustRegister&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">provider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CONTROLLER_GROUP_DNS_CONTROLLERS&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This controller can be embedded into a controller manager just by using
an &lt;a href="https://github.com/gardener/external-dns-management/blob/master/cmd/dns/main.go">anonymous import&lt;/a> of the controller package in the main package
of a dedicated controller manager.&lt;/p>
&lt;p>Complete examples are available in the sub packages of &lt;code>pkg/controller/provider&lt;/code>.
They also show a typical set of implementation structures that help
to structure the implementation of such controllers.&lt;/p>
&lt;p>The provider implemented in this project always follow the same structure:&lt;/p>
&lt;ul>
&lt;li>the provider package contains the provider code&lt;/li>
&lt;li>the factory source file registers the factory at a default compound factory&lt;/li>
&lt;li>it contains a sub package &lt;code>controller&lt;/code>, which contains the embedding of
the factory into a dedicated controller&lt;/li>
&lt;/ul>
&lt;h4 id="embedding-a-factory-into-a-compound-factory">Embedding a Factory into a Compound Factory&lt;/h4>
&lt;p>A provisioning controller based on a &lt;em>Compound Factory&lt;/em> can be extended by
a new provider factory by registering this factory at the compound factory.
This could be done, for example, by using the default compound factory provided
in package &lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/controller/provider/compound/factory.go">&lt;code>pkg/controller/provider/compound&lt;/code>&lt;/a> as shown
&lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/controller/provider/aws/factory.go">here&lt;/a>, where &lt;code>NewHandler&lt;/code> is a function creating
a dedicated handler for a dedicated provider type:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">
&lt;span class="kn">package&lt;/span> &lt;span class="nx">aws&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/compound&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/dns/provider&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">const&lt;/span> &lt;span class="nx">TYPE_CODE&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;aws-route53&amp;#34;&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">Factory&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">provider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewDNSHandlerFactory&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">TYPE_CODE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">NewHandler&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">compound&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MustRegister&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">Factory&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The compound factory is then again embedded into a provisioning controller as shown
in the previous section (see the &lt;a href="https://github.com/gardener/external-dns-management/blob/master/pkg/controller/provider/compound/controller/controller.go">&lt;code>controller&lt;/code>sub package&lt;/a>).&lt;/p>
&lt;h3 id="setting-up-a-controller-manager">Setting Up a Controller Manager&lt;/h3>
&lt;p>One or multiple controller packages can be bundled into a controller manager,
by implementing a main package like &lt;a href="https://github.com/gardener/external-dns-management/blob/master/cmd/dns/main.go">this&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/controllermanager&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/&amp;lt;your controller package&amp;gt;&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">controllermanager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;my-dns-controller-manager&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;dns controller manager&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;some description&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="using-the-standard-compound-provisioning-controller">Using the standard Compound Provisioning Controller&lt;/h3>
&lt;p>If the standard &lt;em>Compound Provisioning Controller&lt;/em> should be used it is required
to additionally add the anonymous imports for the providers intended to be
embedded into the compound factory like &lt;a href="https://github.com/gardener/external-dns-management/blob/master/cmd/compound/main.go">this&lt;/a>:&lt;/p>
&lt;details>
&lt;summary>&lt;b>Example Coding&lt;/b>&lt;/summary>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;os&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/controllermanager&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/compound/controller&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/&amp;lt;your provider&amp;gt;&amp;#34;&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">controllermanager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;dns-controller-manager&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;dns controller manager&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;nothing&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/details>
&lt;h3 id="multiple-cluster-support">Multiple Cluster Support&lt;/h3>
&lt;p>The controller implementations provided in this project are prepared to work
with multiple clusters by using the features of the used controller manager
library.&lt;/p>
&lt;p>The &lt;em>DNS Source Controllers&lt;/em> support two clusters:&lt;/p>
&lt;ul>
&lt;li>the default cluster is used to scan for source objects&lt;/li>
&lt;li>the logical cluster &lt;code>target&lt;/code> is used to maintain the &lt;code>DNSEnry&lt;/code> objects.&lt;/li>
&lt;/ul>
&lt;p>The &lt;em>DNS Provisioning Controllers&lt;/em> also support two clusters:&lt;/p>
&lt;ul>
&lt;li>the default cluster is used to scan for &lt;code>DNSEntry&lt;/code> objects. It is mapped
to the logical cluster &lt;code>target&lt;/code>&lt;/li>
&lt;li>the logical cluster &lt;code>provider&lt;/code> is used to look to the &lt;code>DNSProvider&lt;/code> objects
and their related secrets.&lt;/li>
&lt;/ul>
&lt;p>If those controller types should be combined in a single controller manager,
it can be configured to support three potential clusters with the
source objects, the one for the entry objects and the one with provider
objects using cluster mappings.&lt;/p>
&lt;p>This is shown in a complete &lt;a href="https://github.com/gardener/external-dns-management/blob/master/cmd/compound/main.go">example&lt;/a> using the dns
source controllers, the compound provisioning controller configured to
support all the included DNS provider type factories:&lt;/p>
&lt;details>
&lt;summary>&lt;b>Example Coding&lt;/b>&lt;/summary>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;os&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/controllermanager&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/controllermanager/cluster&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/controllermanager/controller&amp;#34;&lt;/span>
&lt;span class="s">&amp;#34;github.com/gardener/controller-manager-library/pkg/controllermanager/controller/mappings&amp;#34;&lt;/span>
&lt;span class="nx">dnsprovider&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/dns/provider&amp;#34;&lt;/span>
&lt;span class="nx">dnssource&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/dns/source&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/compound/controller&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/alicloud&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/aws&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/azure&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/google&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/openstack&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/cloudflare&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/provider/netlify&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/source/ingress&amp;#34;&lt;/span>
&lt;span class="nx">_&lt;/span> &lt;span class="s">&amp;#34;github.com/gardener/external-dns-management/pkg/controller/source/service&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// target cluster already defined in dns source controller package
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">cluster&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Configure&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="nx">dnsprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PROVIDER_CLUSTER&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;providers&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s">&amp;#34;cluster to look for provider objects&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">).&lt;/span>&lt;span class="nf">Fallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dnssource&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TARGET_CLUSTER&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="nx">mappings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ForControllerGroup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">dnsprovider&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CONTROLLER_GROUP_DNS_CONTROLLERS&lt;/span>&lt;span class="p">).&lt;/span>
&lt;span class="nf">Map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">controller&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CLUSTER_MAIN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">dnssource&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">TARGET_CLUSTER&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">MustRegister&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">controllermanager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Start&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;dns-controller-manager&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;dns controller manager&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;nothing&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/details>
&lt;p>Those clusters can the be separated by registering their names together with
command line option names. These can be used to specify different kubeconfig
files for those clusters.&lt;/p>
&lt;p>By default all logical clusters are mapped to the default physical cluster
specified via &lt;code>--kubeconfig&lt;/code> or default cluster access.&lt;/p>
&lt;p>If multiple physical clusters are defined they can be specified by a
corresponding cluster option defining the kubeconfig file used to access
this cluster. If no such option is specified the default is used.&lt;/p>
&lt;p>Therefore, even if the configuration is prepared for multiple clusters,
such a controller manager can easily work on a single cluster if no special
options are given on the command line.&lt;/p>
&lt;h2 id="why-not-using-the-community-external-dns-solution">Why not using the community external-dns solution?&lt;/h2>
&lt;p>Some of the reasons are context-specific, i.e. relate to Gardener&amp;rsquo;s highly dynamic requirements.&lt;/p>
&lt;ol>
&lt;li>Custom resource for DNS entries&lt;/li>
&lt;/ol>
&lt;p>DNS entries are explicitly specified as custom resources. As an important side effect, each DNS entry provides an own status. Simply by querying the Kubernetes API, a client can check if a requested DNS entry has been successfully added to the DNS backend, or if an update has already been deployed, or if not to reason about the cause. It also opens for easy extensibility, as DNS entries can be created directly via the Kubernetes API. And it simplifies Day 2 operations, e.g. automatic cleanup of unused entries if a DNS provider is deleted.&lt;/p>
&lt;ol start="2">
&lt;li>Management of multiple DNS providers&lt;/li>
&lt;/ol>
&lt;p>The Gardener DNS controller uses a custom resource DNSProvider to dynamically manage the backend DNS services. While with external-dns you have to specify the single provider during startup, in the Gardener DNS controller you can add/update/delete providers during runtime with different credentials and/or backends. This is important for a multi-tenant environment as in Gardener, where users can bring their own accounts.&lt;/p>
&lt;p>A DNS provider can also restrict its actions on subset of the DNS domains (includes and excludes) for which the credentials are capable to edit.&lt;/p>
&lt;p>Each provider can define a separate “owner” identifier, to differentiate DNS entries in the same DNS zone from different providers.&lt;/p>
&lt;ol start="3">
&lt;li>Multi cluster support&lt;/li>
&lt;/ol>
&lt;p>The Gardener DNS controller distinguish three different logical Kubernetes clusters: Source cluster, target cluster and runtime cluster. The source cluster is monitored by the DNS source controllers for annotations on ingress and service resources. These controllers then create DNS entries in the target cluster. DNS entries in the target cluster are then reconciliated/synchronized with the corresponding DNS backend service by the provider controller. The runtime cluster is the cluster the DNS controller runs on. For example, this enables needed flexibility in the Gardener deployment. The DNS controller runs on the seed cluster. This is also the target cluster. DNS providers and entries resources are created in the corresponding namespace of the shoot control plane, while the source cluster is the shoot cluster itself.&lt;/p>
&lt;ol start="4">
&lt;li>Optimizations for handling hundreds of DNS entries&lt;/li>
&lt;/ol>
&lt;p>Some DNS backend services are restricted on the API calls per second (e.g. the AWS Route 53 API). To manage hundreds of DNS entries it is important to minimize the number of API calls. The Gardener DNS controller heavily makes usage of caches and batch processing for this reason.&lt;/p></description></item><item><title>Docs: Certificates Management</title><link>https://gardener.cloud/docs/concepts/networking/cert-managment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/concepts/networking/cert-managment/</guid><description>
&lt;h1 id="cert-management">cert-management&lt;/h1>
&lt;p>&lt;a href="https://reuse.software/">&lt;img src="https://reuse.software/badge/reuse-compliant.svg" alt="reuse compliant">&lt;/a>&lt;/p>
&lt;p>Manages TLS certificates in Kubernetes clusters using custom resources.&lt;/p>
&lt;p>In a multi-cluster environment like Gardener, using existing open source projects
for certificate management like &lt;a href="https://github.com/jetstack/cert-manager">cert-manager&lt;/a> becomes cumbersome.
With this project the separation of concerns between multiple clusters is realized more easily.
The cert-controller-manager runs in a &lt;strong>secured cluster&lt;/strong> where the issuer secrets are stored.
At the same time it watches an untrusted &lt;strong>source cluster&lt;/strong> and can provide certificates for it.
The cert-controller-manager relies on DNS challenges (ACME only) for validating the domain names of the certificates.
For this purpose it creates DNSEntry custom resources (in a possible separate &lt;strong>dns cluster&lt;/strong>) to be
handled by the compagnion dns-controller-manager from &lt;a href="https://github.com/gardener/external-dns-management">external-dns-management&lt;/a>.&lt;/p>
&lt;p>Currently, the &lt;code>cert-controller-manager&lt;/code> supports certificate authorities via:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment">Automatic Certificate Management Environment (ACME)&lt;/a> protocol like &lt;a href="https://letsencrypt.org/">Let&amp;rsquo;s Encrypt&lt;/a>.&lt;/li>
&lt;li>Certificate Authority (CA): an existing certificate and a private key provided as a TLS Secret.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Index&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="#quick-start-using-certificates-in-a-gardener-shoot-cluster">Quick start using certificates in a Gardener shoot cluster&lt;/a>&lt;/li>
&lt;li>&lt;a href="#setting-up-issuers">Setting up Issuers&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#automatic-certificate-management-environment-acme">Automatic Certificate Management Environment (ACME)&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#auto-registration">Auto registration&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-existing-account">Using existing account&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#certificate-authority-ca">Certificate Authority (CA)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#requesting-a-certificate">Requesting a Certificate&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#using-commonname-and-optional-dnsnames">Using &lt;code>commonName&lt;/code> and optional &lt;code>dnsNames&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-a-certificate-signing-request-csr">Using a certificate signing request (CSR)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#requesting-a-certificate-for-ingress">Requesting a Certificate for Ingress&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#process">Process&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#requesting-a-certificate-for-service">Requesting a Certificate for Service&lt;/a>&lt;/li>
&lt;li>&lt;a href="#demo-quick-start">Demo quick start&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-the-cert-controller-manager">Using the cert-controller-manager&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#usage">Usage&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#renewal-of-certificates">Renewal of Certificates&lt;/a>&lt;/li>
&lt;li>&lt;a href="#revoking-certificates">Revoking Certificates&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#revoking-certificates-with-renewal">Revoking certificates with renewal&lt;/a>&lt;/li>
&lt;li>&lt;a href="#checking-ocsp-revocation-using-openssl">Checking OCSP revocation using OpenSSL&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#metrics">Metrics&lt;/a>&lt;/li>
&lt;li>&lt;a href="#development">Development&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="quick-start-using-certificates-in-a-gardener-shoot-cluster">Quick start using certificates in a Gardener shoot cluster&lt;/h2>
&lt;p>This component is typically deployed by the &lt;a href="https://gardener.cloud/docs/guides/install_gardener/setup">Gardener Extension for certificate services&lt;/a>
to simplify requesting certificates for Gardener shoot clusters.&lt;/p>
&lt;p>For a quick start please see &lt;a href="https://gardener.cloud/docs/guides/administer_shoots/request_cert/">Request X.509 Certificates&lt;/a>&lt;/p>
&lt;h2 id="setting-up-issuers">Setting up Issuers&lt;/h2>
&lt;p>Before you can obtain certificates from a certificate authority (CA), you need to set up an issuer.
The issuer is specified in the &lt;code>default&lt;/code> cluster, while the certificates are specified in the &lt;code>source&lt;/code> cluster.&lt;/p>
&lt;p>The issuer custom resource contains the configuration and registration data for your account at the CA.&lt;/p>
&lt;h3 id="automatic-certificate-management-environment-acme">Automatic Certificate Management Environment (ACME)&lt;/h3>
&lt;p>Two modes are supported:&lt;/p>
&lt;ul>
&lt;li>auto registration&lt;/li>
&lt;li>using an existing account&lt;/li>
&lt;/ul>
&lt;h4 id="auto-registration">Auto registration&lt;/h4>
&lt;p>Auto registration is mainly used for development and test environments. You only need to provide
the server URL and an email address. The registration process is done automatically for you
by creating a private key and performing the registration at the CA. Optionally you can provide
the target secret with the privateKeySecretRef section.&lt;/p>
&lt;p>For example see &lt;a href="https://github.com/gardener/cert-management/blob/master/examples/20-issuer-staging.yaml">examples/20-issuer-staging.yaml&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Issuer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-staging&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">acme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://acme-staging-v02.api.letsencrypt.org/directory&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">email&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">some.user@mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">autoRegistration&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># with &amp;#39;autoRegistration: true&amp;#39; a new account will be created if the secretRef is not existing&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">privateKeySecretRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-staging-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="using-existing-account">Using existing account&lt;/h4>
&lt;p>If you already have an existing account at the certificate authority, you need to
specify email address and reference the private key from a secret.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-issuer-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Opaque&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">privateKey&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">LS0tLS1...&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Issuer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-issuer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">acme&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">server&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://acme-v02.api.letsencrypt.org/directory&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">email&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my.account@mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">privateKeySecretRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">my-issuer-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In both cases, the state of an issuer resource can be checked on the &lt;code>default&lt;/code> cluster with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl get issuer
NAME SERVER EMAIL STATUS TYPE AGE
issuer-staging https://acme-staging-v02.api.letsencrypt.org/directory some.user@mydomain.com Ready acme 8s
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="certificate-authority-ca">Certificate Authority (CA)&lt;/h3>
&lt;p>This issuer is meant to be used where a central Certificate Authority
is already in place. The operator must request/provide by its own means a CA
or an intermediate CA. This is mainly used for &lt;strong>on-premises&lt;/strong> and
&lt;strong>airgapped&lt;/strong> environements.&lt;/p>
&lt;p>It can also be used for &lt;strong>developement&lt;/strong> or &lt;strong>testing&lt;/strong> purproses. In this case
a Self-signed Certificate Authority can be created by following the section below.&lt;/p>
&lt;p>&lt;em>Create a Self-signed Certificate Authority (optional)&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ openssl genrsa -out CA-key.pem &lt;span class="m">4096&lt;/span>
▶ &lt;span class="nb">export&lt;/span> &lt;span class="nv">CONFIG&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;
&lt;/span>&lt;span class="s2">[req]
&lt;/span>&lt;span class="s2">distinguished_name=dn
&lt;/span>&lt;span class="s2">[ dn ]
&lt;/span>&lt;span class="s2">[ ext ]
&lt;/span>&lt;span class="s2">basicConstraints=CA:TRUE,pathlen:0
&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
▶ openssl req &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -new -nodes -x509 -config &amp;lt;&lt;span class="o">(&lt;/span>&lt;span class="nb">echo&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="nv">$CONFIG&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> -key CA-key.pem &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> -subj &lt;span class="s2">&amp;#34;/CN=Hello&amp;#34;&lt;/span> -extensions ext -days &lt;span class="m">1000&lt;/span> -out CA-cert.pem
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Create a TLS secret from the certificate &lt;code>CA-cert.pem&lt;/code> and the private key &lt;code>CA-key.pem&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl -n default create secret tls issuer-ca-secret &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --cert&lt;span class="o">=&lt;/span>CA-cert.pem --key&lt;span class="o">=&lt;/span>CA-key.pem -oyaml &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span> --dry-run&lt;span class="o">=&lt;/span>client &amp;gt; secret.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The content of the &lt;code>secret.yaml&lt;/code> should look like the following, for a full example see &lt;a href="https://github.com/gardener/cert-management/blob/master/examples/20-issuer-ca.yaml">examples/20-issuer-ca.yaml&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">data&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls.crt&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{&lt;span class="l">base64 certificate}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls.key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>{&lt;span class="l">base64 private key}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-ca-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kubernetes.io/tls&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Apply the secrets in the cluster and create the issuer,
for example see &lt;a href="https://github.com/gardener/cert-management/blob/master/examples/20-issuer-ca.yaml">examples/20-issuer-ca.yaml&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nn">---&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Issuer&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-ca&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ca&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">privateKeySecretRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-ca-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The state of the issuer resource can be checked on the &lt;code>default&lt;/code> cluster with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl get issuer
NAME SERVER EMAIL STATUS TYPE AGE
issuer-ca Ready ca 6s
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Some details about the CA can be found in the status of the issuer.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl get issuer issuer-ca -ojsonpath&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;{.status}&amp;#39;&lt;/span> &lt;span class="p">|&lt;/span> jq &lt;span class="s1">&amp;#39;.&amp;#39;&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;ca&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;NotAfter&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;2023-05-31T14:55:55Z&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;NotBefore&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;2020-09-03T14:55:55Z&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;Subject&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;CommonName&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;my-domain.com&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;Country&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;DE&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
&lt;span class="s2">&amp;#34;Locality&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;Walldorf&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
&lt;span class="s2">&amp;#34;Organization&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;Gardener&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
&lt;span class="s2">&amp;#34;OrganizationalUnit&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;Gardener&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
&lt;span class="s2">&amp;#34;PostalCode&amp;#34;&lt;/span>: null,
&lt;span class="s2">&amp;#34;Province&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;BW&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
&lt;span class="s2">&amp;#34;SerialNumber&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;1E04A2C8F057AC890F45FEC5446AE4DDA73EA1D5&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;StreetAddress&amp;#34;&lt;/span>: null
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;observedGeneration&amp;#34;&lt;/span>: 1,
&lt;span class="s2">&amp;#34;requestsPerDayQuota&amp;#34;&lt;/span>: 10000,
&lt;span class="s2">&amp;#34;state&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;Ready&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;ca&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="requesting-a-certificate">Requesting a Certificate&lt;/h2>
&lt;p>To obtain a certificate for a domain, you specify a certificate custom resource on the &lt;code>source&lt;/code> cluster.
You can specify the issuer explicitly by reference. If there is no issuer reference, the default issuer is
used (provided as command line option). You must either specify the &lt;code>commonName&lt;/code> and further optional &lt;code>dnsNames&lt;/code> or
you can also start with a certificate signing request (CSR).&lt;/p>
&lt;p>For domain validation, the &lt;code>cert-controller-manager&lt;/code> only supports DNS challenges. For this purpose it relies
on the &lt;code>dns-controller-manager&lt;/code> from the &lt;a href="https://github.com/gardener/external-dns-management">external-dns-management&lt;/a>
project.
If any domain name (&lt;code>commonName&lt;/code> or any item from &lt;code>dnsNames&lt;/code>) needs to be validated, it creates a custom resource
&lt;code>DNSEntry&lt;/code> in the &lt;code>dns&lt;/code> cluster.
When the certificate authority sees the temporary DNS record, the certificate is stored in a secret finally.
The name of the secret can be specified explicitly with &lt;code>secretName&lt;/code> and will be stored in the same namespace as the
certificate on the &lt;code>source&lt;/code> cluster.&lt;/p>
&lt;p>The certificate is checked for renewal periodically. The renewal is performed automatically and the secret is updated.
Default values for periodical check is daily, the certificate is renewed if its validity expires within 60 days.&lt;/p>
&lt;h3 id="using-commonname-and-optional-dnsnames">Using &lt;code>commonName&lt;/code> and optional &lt;code>dnsNames&lt;/code>&lt;/h3>
&lt;p>For example see &lt;a href="https://github.com/gardener/cert-management/blob/master/examples/30-cert-simple.yaml">examples/30-cert-simple.yaml&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Certificate&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert-simple&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">commonName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert1.mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dnsNames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">cert1-foo.mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">cert1-bar.mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># if issuer is not specified, the default issuer is used&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">issuerRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-staging&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="using-a-certificate-signing-request-csr">Using a certificate signing request (CSR)&lt;/h3>
&lt;p>You can provide a complete CSR in PEM format (and encoded as Base64).&lt;/p>
&lt;p>For example see &lt;a href="https://github.com/gardener/cert-management/blob/master/examples/30-cert-csr.yaml">examples/30-cert-csr.yaml&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Certificate&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert-csr&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">csr&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">LS0tLS1CRUd...&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">issuerRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">issuer-staging&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>:warning: Using a CSR is only available for ACME Issuer&lt;/p>
&lt;h2 id="requesting-a-certificate-for-ingress">Requesting a Certificate for Ingress&lt;/h2>
&lt;p>Add the annotation &lt;code>cert.gardener.cloud/purpose: managed&lt;/code> to the Ingress resource.
The &lt;code>cert-controller-manager&lt;/code> will then automatically request a certificate for all domains given by the hosts in the
&lt;code>tls&lt;/code> section of the Ingress spec.&lt;/p>
&lt;p>For compatibility with the &lt;a href="https://github.com/gardener/cert-broker">Gardener Cert-Broker&lt;/a>, you can
alternatively use the deprecated label &lt;code>garden.sapcloud.io/purpose: managed-cert&lt;/code> for the same outcome.&lt;/p>
&lt;p>See also &lt;a href="https://github.com/gardener/cert-management/blob/master/examples/40-ingress-echoheaders.yaml">examples/40-ingress-echoheaders.yaml&lt;/a>:&lt;/p>
&lt;h3 id="process">Process&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>Create the Ingress Resource (optional)&lt;/p>
&lt;p>In order to request a certificate for a domain managed by &lt;code>cert-controller-manager&lt;/code> an Ingress is required.
In case you don’t already have one, take the following as an example:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">vuejs-ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Gardener managed default domain.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># The first host is used as common name and must not exceed 64 characters&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">hosts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">test.ingress.&amp;lt;GARDENER-CLUSTER&amp;gt;.&amp;lt;GARDENER-PROJECT&amp;gt;.shoot.example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Certificate and private key reside in this secret.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">testsecret-tls&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test.ingress.&amp;lt;GARDENER-CLUSTER&amp;gt;.&amp;lt;GARDENER-PROJECT&amp;gt;.shoot.example.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">vuejs-svc&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">servicePort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Annotate the Ingress Resource&lt;/p>
&lt;p>The annotation &lt;code>cert.gardener.cloud/purpose: managed&lt;/code> instructs &lt;code>cert-controller-manager&lt;/code> to handle certificate issuance for the domains found in labeled Ingress.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">networking.k8s.io/v1beta1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">tls-example-ingress&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Let Gardener manage certificates for this Ingress.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cert.gardener.cloud/purpose&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">managed&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#dns.gardener.cloud/class: garden # needed on Gardener shoot clusters for managed DNS record creation (if not covered by `*.ingress.&amp;lt;GARDENER-CLUSTER&amp;gt;.&amp;lt;GARDENER-PROJECT&amp;gt;.shoot.example.com)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#cert.gardener.cloud/commonname: &amp;#34;*.demo.mydomain.com&amp;#34; # optional, if not specified the first name from spec.tls[].hosts is used as common name&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#cert.gardener.cloud/dnsnames: &amp;#34;&amp;#34; # optional, if not specified the names from spec.tls[].hosts are used&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">tls&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">hosts&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">echoheaders.demo.mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secretName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert-echoheaders&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">host&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echoheaders.demo.mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">backend&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serviceName&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">echoheaders&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">servicePort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">path&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">/&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The annotation &lt;code>cert.gardener.cloud/commonname&lt;/code> can be set to explicitly specify the common name.
If no set, the first name of &lt;code>spec.tls.hosts&lt;/code> is used as common name.
The annotation &lt;code>cert.gardener.cloud/dnsnames&lt;/code> can be used to explicitly specify the alternative DNS names.
If no set, the names of &lt;code>spec.tls.hosts&lt;/code> are used.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Check status&lt;/p>
&lt;p>A &lt;code>certificate&lt;/code> custom resource is created in the same namespace of the &lt;code>source&lt;/code> cluster.
You can either check the status of this certificate resource with &lt;code>kubectl get cert&lt;/code> or you can check
the events for the ingress with &lt;code>kubectl get events&lt;/code>&lt;/p>
&lt;p>The certificate is stored in the secret as specified in the Ingress resource.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="requesting-a-certificate-for-service">Requesting a Certificate for Service&lt;/h2>
&lt;p>If you have a service of type &lt;code>LoadBalancer&lt;/code>, you can use the annotation &lt;code>cert.gardener.cloud/secretname&lt;/code> together
with the annotation &lt;code>dns.gardener.cloud/dnsnames&lt;/code> from the &lt;code>dns-controller-manager&lt;/code> to trigger automatic creation of
a certificate. If you wan to share a certificate between multiple services and ingresses, using the annotations
&lt;code>cert.gardener.cloud/commonname&lt;/code> and &lt;code>cert.gardener.cloud/dnsnames&lt;/code> may be helpful.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">annotations&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cert.gardener.cloud/secretname&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-service-secret&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns.gardener.cloud/dnsnames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-service.demo.mydomain.com&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#dns.gardener.cloud/class: garden # needed on Gardener shoot clusters for managed DNS record creation&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#cert.gardener.cloud/commonname: &amp;#34;*.demo.mydomain.com&amp;#34; # optional, if not specified the first name from dns.gardener.cloud/dnsnames is used as common name&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#cert.gardener.cloud/dnsnames: &amp;#34;&amp;#34; # optional, if specified overrides dns.gardener.cloud/dnsnames annotation for certificate names&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">dns.gardener.cloud/ttl&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;600&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">test-service&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">ports&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">http&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">port&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">80&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">protocol&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">TCP&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">targetPort&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">8080&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">type&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">LoadBalancer&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The annotation &lt;code>cert.gardener.cloud/commonname&lt;/code> is optional. If not specified, the first name of the annotation
&lt;code>dns.gardener.cloud/dnsnames&lt;/code> is used as common name. It is useful to specify it explicitly, if no &lt;code>DNSEntry&lt;/code>
should be created for the common name by the dns-controller-manager.
A typical use case is if the common name (limited to 64 characters) is set only to
deal with real domain names specified with &lt;code>dns.gardener.cloud/dnsnames&lt;/code> which are longer than 64 characters.
The annotation &lt;code>cert.gardener.cloud/dnsnames&lt;/code> can be used to explicitly specify the alternative DNS names.
If set, it overrides the values from the annotation &lt;code>dns.gardener.cloud/dnsnames&lt;/code> for the certificate (but not for
creating DNS records by the dns-controller-manager).&lt;/p>
&lt;p>If you want to share a certificate between multiple services and ingresses, using the annotations &lt;code>cert.gardener.cloud/commonname&lt;/code> and
&lt;code>cert.gardener.cloud/dnsnames&lt;/code> may be helpful. For example, to share a wildcard certificate, you should add these two annotations&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="w"> &lt;/span>&lt;span class="nt">cert.gardener.cloud/commonname&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;*.demo.mydomain.com&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cert.gardener.cloud/dnsnames&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will create or reuse a certificate for &lt;code>*.demo.mydomain.com&lt;/code>. An existing certificate is automatically reused,
if it has exactly the same common name and DNS names.&lt;/p>
&lt;h2 id="demo-quick-start">Demo quick start&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>Run dns-controller-manager with:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">./dns-controller-manager --controllers&lt;span class="o">=&lt;/span>azure-dns --identifier&lt;span class="o">=&lt;/span>myOwnerId --disable-namespace-restriction
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Ensure provider and its secret, e.g.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f azure-secret.yaml
kubectl apply -f azure-provider.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>check with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl get dnspr
NAME TYPE STATUS AGE
azure-playground azure-dns Ready 28m
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Create test namespace&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl create ns &lt;span class="nb">test&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Run cert-controller-manager&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">./cert-controller-manager
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>Register user &lt;code>some.user@mydomain.com&lt;/code> at let&amp;rsquo;s encrypt&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f examples/20-issuer-staging.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>check with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl get issuer
NAME SERVER EMAIL STATUS TYPE AGE
issuer-staging https://acme-staging-v02.api.letsencrypt.org/directory some.user@mydomain.com Ready acme 8s
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Request a certificate for &lt;code>cert1.martin.test6227.ml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">kubectl apply -f examples/30-cert-simple.yaml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If this certificate has been already registered for the same issuer before,
it will be returned immediately from the ACME server.
Otherwise a DNS challenge is started using a temporary DNSEntry to be set by &lt;code>dns-controller-manager&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>check with&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">▶ kubectl get cert -o wide
NAME COMMON NAME ISSUER STATUS EXPIRATION_DATE DNS_NAMES AGE
cert-simple cert1.mydomain.com issuer-staging Ready 2019-11-10T09:48:17Z &lt;span class="o">[&lt;/span>cert1.my-domain.com&lt;span class="o">]&lt;/span> 34s
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="using-the-cert-controller-manager">Using the cert-controller-manager&lt;/h2>
&lt;p>The cert-controller-manager communicated with up to four different clusters:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>default&lt;/strong>
used for managing issuers and lease management.
The path to the kubeconfig is specified with command line option &lt;code>--kubeconfig&lt;/code>.&lt;/li>
&lt;li>&lt;strong>source&lt;/strong>
used for watching resources ingresses, services and certificates
The path to the kubeconfig is specified with command line option &lt;code>--source&lt;/code>.
If option is omitted, the default cluster is used for source.&lt;/li>
&lt;li>&lt;strong>dns&lt;/strong>
used to write temporary DNSEntries for DNS challenges
The path to the kubeconfig is specified with command line option &lt;code>--dns&lt;/code>.
If option is omitted, the default cluster is used for dns.&lt;/li>
&lt;li>&lt;strong>target&lt;/strong>
used for storing generated certificates (and issuers if &lt;code>--allow-target-issuers&lt;/code>
option is set)
The path to the kubeconfig is specified with command line option &lt;code>--target&lt;/code>.
If option is omitted, the source cluster is also used for target.&lt;/li>
&lt;/ul>
&lt;h3 id="usage">Usage&lt;/h3>
&lt;p>The complete list of options is:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-text" data-lang="text">Usage:
cert-controller-manager [flags]
Flags:
--accepted-maintainers string accepted maintainer key(s) for crds
--allow-target-issuers If true, issuers are also watched on the target cluster
--bind-address-http string HTTP server bind address
--cascade-delete If true, certificate secrets are deleted if dependent resources (certificate, ingress) are deleted
--cert-class string Identifier used to differentiate responsible controllers for entries
--cert-target-class string Identifier used to differentiate responsible dns controllers for target entries
--config string config file
-c, --controllers string comma separated list of controllers to start (&amp;lt;name&amp;gt;,&amp;lt;group&amp;gt;,all)
--cpuprofile string set file for cpu profiling
--default-issuer string name of default issuer (from default cluster)
--default-issuer-domain-ranges string domain range restrictions when using default issuer separated by comma
--default-requests-per-day-quota int Default value for requestsPerDayQuota if not set explicitly in the issuer spec.
--default.pool.resync-period duration Period for resynchronization for pool default
--default.pool.size int Worker pool size for pool default
--disable-namespace-restriction disable access restriction for namespace local access only
--dns string cluster for writing challenge DNS entries
--dns-class string class for creating challenge DNSEntries (in DNS cluster)
--dns-namespace string namespace for creating challenge DNSEntries (in DNS cluster)
--dns-owner-id string ownerId for creating challenge DNSEntries
--dns.disable-deploy-crds disable deployment of required crds for cluster dns
--dns.id string id for cluster dns
--dns.migration-ids string migration id for cluster dns
--force-crd-update enforce update of crds even they are unmanaged
--grace-period duration inactivity grace period for detecting end of cleanup for shutdown
-h, --help help for cert-controller-manager
--ingress-cert.cert-class string Identifier used to differentiate responsible controllers for entries of controller ingress-cert
--ingress-cert.cert-target-class string Identifier used to differentiate responsible dns controllers for target entries of controller ingress-cert
--ingress-cert.default.pool.resync-period duration Period for resynchronization for pool default of controller ingress-cert
--ingress-cert.default.pool.size int Worker pool size for pool default of controller ingress-cert
--ingress-cert.pool.resync-period duration Period for resynchronization of controller ingress-cert
--ingress-cert.pool.size int Worker pool size of controller ingress-cert
--ingress-cert.target-name-prefix string name prefix in target namespace for cross cluster generation of controller ingress-cert
--ingress-cert.target-namespace string target namespace for cross cluster generation of controller ingress-cert
--ingress-cert.targets.pool.size int Worker pool size for pool targets of controller ingress-cert
--issuer-namespace string namespace to lookup issuers on default cluster
--issuer.allow-target-issuers If true, issuers are also watched on the target cluster of controller issuer
--issuer.cascade-delete If true, certificate secrets are deleted if dependent resources (certificate, ingress) are deleted of controller issuer
--issuer.cert-class string Identifier used to differentiate responsible controllers for entries of controller issuer
--issuer.default-issuer string name of default issuer (from default cluster) of controller issuer
--issuer.default-issuer-domain-ranges string domain range restrictions when using default issuer separated by comma of controller issuer
--issuer.default-requests-per-day-quota int Default value for requestsPerDayQuota if not set explicitly in the issuer spec. of controller issuer
--issuer.default.pool.resync-period duration Period for resynchronization for pool default of controller issuer
--issuer.default.pool.size int Worker pool size for pool default of controller issuer
--issuer.dns-class string class for creating challenge DNSEntries (in DNS cluster) of controller issuer
--issuer.dns-namespace string namespace for creating challenge DNSEntries (in DNS cluster) of controller issuer
--issuer.dns-owner-id string ownerId for creating challenge DNSEntries of controller issuer
--issuer.issuer-namespace string namespace to lookup issuers on default cluster of controller issuer
--issuer.issuers.pool.size int Worker pool size for pool issuers of controller issuer
--issuer.pool.resync-period duration Period for resynchronization of controller issuer
--issuer.pool.size int Worker pool size of controller issuer
--issuer.precheck-additional-wait duration additional wait time after DNS propagation check of controller issuer
--issuer.precheck-nameservers string DNS nameservers used for checking DNS propagation. If explicity set empty, it is tried to read them from /etc/resolv.conf of controller issuer
--issuer.propagation-timeout duration propagation timeout for DNS challenge of controller issuer
--issuer.renewal-overdue-window duration certificate is counted as &amp;#39;renewal overdue&amp;#39; if its validity period is shorter (metrics cert_management_overdue_renewal_certificates) of controller issuer
--issuer.renewal-window duration certificate is renewed if its validity period is shorter of controller issuer
--issuer.revocations.pool.size int Worker pool size for pool revocations of controller issuer
--issuer.secrets.pool.size int Worker pool size for pool secrets of controller issuer
--issuers.pool.size int Worker pool size for pool issuers
--kubeconfig string default cluster access
--kubeconfig.disable-deploy-crds disable deployment of required crds for cluster default
--kubeconfig.id string id for cluster default
--kubeconfig.migration-ids string migration id for cluster default
--lease-duration duration lease duration
--lease-name string name for lease object
--lease-renew-deadline duration lease renew deadline
--lease-resource-lock string determines which resource lock to use for leader election, defaults to &amp;#39;configmapsleases&amp;#39;
--lease-retry-period duration lease retry period
-D, --log-level string logrus log level
--maintainer string maintainer key for crds (default &amp;#34;cert-controller-manager&amp;#34;)
--name string name used for controller manager (default &amp;#34;cert-controller-manager&amp;#34;)
--namespace string namespace for lease (default &amp;#34;kube-system&amp;#34;)
-n, --namespace-local-access-only enable access restriction for namespace local access only (deprecated)
--omit-lease omit lease for development
--plugin-file string directory containing go plugins
--pool.resync-period duration Period for resynchronization
--pool.size int Worker pool size
--precheck-additional-wait duration additional wait time after DNS propagation check
--precheck-nameservers string DNS nameservers used for checking DNS propagation. If explicity set empty, it is tried to read them from /etc/resolv.conf
--propagation-timeout duration propagation timeout for DNS challenge
--renewal-overdue-window duration certificate is counted as &amp;#39;renewal overdue&amp;#39; if its validity period is shorter (metrics cert_management_overdue_renewal_certificates)
--renewal-window duration certificate is renewed if its validity period is shorter
--revocations.pool.size int Worker pool size for pool revocations
--secrets.pool.size int Worker pool size for pool secrets
--server-port-http int HTTP server port (serving /healthz, /metrics, ...)
--service-cert.cert-class string Identifier used to differentiate responsible controllers for entries of controller service-cert
--service-cert.cert-target-class string Identifier used to differentiate responsible dns controllers for target entries of controller service-cert
--service-cert.default.pool.resync-period duration Period for resynchronization for pool default of controller service-cert
--service-cert.default.pool.size int Worker pool size for pool default of controller service-cert
--service-cert.pool.resync-period duration Period for resynchronization of controller service-cert
--service-cert.pool.size int Worker pool size of controller service-cert
--service-cert.target-name-prefix string name prefix in target namespace for cross cluster generation of controller service-cert
--service-cert.target-namespace string target namespace for cross cluster generation of controller service-cert
--service-cert.targets.pool.size int Worker pool size for pool targets of controller service-cert
--source string source cluster to watch for ingresses and services
--source.disable-deploy-crds disable deployment of required crds for cluster source
--source.id string id for cluster source
--source.migration-ids string migration id for cluster source
--target string target cluster for certificates
--target-name-prefix string name prefix in target namespace for cross cluster generation
--target-namespace string target namespace for cross cluster generation
--target.disable-deploy-crds disable deployment of required crds for cluster target
--target.id string id for cluster target
--target.migration-ids string migration id for cluster target
--targets.pool.size int Worker pool size for pool targets
-v, --version version for cert-controller-manager
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="renewal-of-certificates">Renewal of Certificates&lt;/h2>
&lt;p>Certificates created with an &lt;code>ACME&lt;/code> issuer are automatically renewed. With the standard configuration,
the certificate is renewed 30 days before it validity expires.
For example, if &lt;a href="https://letsencrypt.org/">Let&amp;rsquo;s Encrypt&lt;/a> is used as certificate authority, a certificate
is always valid for 90 days and will be rolled 30 days before it expires by updating the referenced &lt;code>Secret&lt;/code>
in the &lt;code>Certificate&lt;/code> object.&lt;br>
The configuration can be changed with the command line parameter &lt;code>--issuer.renewal-window&lt;/code>.&lt;/p>
&lt;h2 id="revoking-certificates">Revoking Certificates&lt;/h2>
&lt;p>Certificates created with an &lt;code>ACME&lt;/code> issuer can also be revoked if private key of the certificate
is not longer safe. This page about &lt;a href="https://letsencrypt.org/docs/revoking/">Revoking certificates on Let&amp;rsquo;s Encrypt&lt;/a>
list various reasons:&lt;/p>
&lt;blockquote>
&lt;p>For instance, you might accidentally share the private key on a public website; hackers might copy the private key off
of your servers; or hackers might take temporary control over your servers or your DNS configuration, and use that to
validate and issue a certificate for which they hold the private key.&lt;/p>
&lt;/blockquote>
&lt;p>Revoking a certificate is quite simple. You create a &lt;code>CertificateRevocation&lt;/code> object on the source cluster with a reference
to the &lt;code>Certificate&lt;/code> object to be revoked.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CertificateRevocation&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">revoke-sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">certificateRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mycert&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Uncomment the following line if certificate should be renewed before revoking the old one(s)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#renew: true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Optionally specify a qualifying date. All certificates requested before this date will be revoked.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># If not specified, the current time is used by default.&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c">#qualifyingDate: &amp;#34;2020-12-22T17:00:35Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>cert-controller-manager&lt;/code> will then perform several steps.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Using the certificate secret it looks for other &lt;code>Certificate&lt;/code> objects using the same certificate. The &amp;ldquo;same&amp;rdquo;
certificate means same issuer, &lt;em>Common Name&lt;/em>, and &lt;em>DNS Names&lt;/em>. All found objects will be reconciled too.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>It will look for other valid certificate secrets older than the qualifying date. Concretely this will
deal with unused certificates, which are still valid. As a certificate is renewed 30 days before the end of validity,
the old certificate is still valid, but not used anymore.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>All found certificate secrets are revoked and marked with an annotation &lt;code>cert.gardener.cloud/revoked: &amp;quot;true&amp;quot;&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The state of all found &lt;code>Certificate&lt;/code> objects is set to &lt;code>Revoked&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The state of the &lt;code>CertificateRevocation&lt;/code> object is set to &lt;code>Applied&lt;/code>.
Additionally, the status of the &lt;code>CertificateRevocation&lt;/code> object contains more details about revoked
objects and secrets:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CertificateRevocation&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">revoke-sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">certificateRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mycert&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">qualifyingDate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2020-12-22T17:00:35Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">certificate(s) revoked&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">objects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">revoked&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mycert&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">revocationApplied&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2020-12-22T17:09:32Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secrets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">revoked&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert-backup-default-issuer-8a7e93f7-sks7p&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serialNumber&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fa:3f:9a:5e:ac:47:ee:d1:91:a6:31:a7:43:6f:8a:7e:93:f7&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">state&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Applied&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The secrets listed in the status are only the internal backups maintained by the &lt;code>cert-controller-manager&lt;/code>.
The actual secrets used by the &lt;code>Certificate&lt;/code> objects are not listed, but nonetheless marked as revoked.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="revoking-certificates-with-renewal">Revoking certificates with renewal&lt;/h3>
&lt;p>With this variant the certificate is renewed, before the old one(s) are revoked. This means the
certificate secrets of the &lt;code>Certificate&lt;/code> objects will contain newly requested certificates and
the old certificate(s) will be revoked afterwards.&lt;/p>
&lt;p>For this purpose, set &lt;code>renew: true&lt;/code> in the spec of the &lt;code>CertificateRevocation&lt;/code> object:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CertificateRevocation&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">revoke-sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">certificateRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mycert&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">renew&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this case, the status will list the &lt;strong>renewed&lt;/strong> &lt;code>Certificate&lt;/code> objects:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">apiVersion&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert.gardener.cloud/v1alpha1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">kind&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">CertificateRevocation&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">metadata&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">revoke-sample&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">spec&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">certificateRef&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mycert&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">renew&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">qualifyingDate&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2020-12-22T17:00:35Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">status&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">message&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">certificate renewed and old certificate(s) revoked&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">objects&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">renewed&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">mycert&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">default&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">revocationApplied&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;2020-12-22T17:09:32Z&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">secrets&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">revoked&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">cert-backup-default-issuer-8a7e93f7-sks7p&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">namespace&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">kube-system&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">serialNumber&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">fa:3f:9a:5e:ac:47:ee:d1:91:a6:31:a7:43:6f:8a:7e:93:f7&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">state&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Applied&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="checking-ocsp-revocation-using-openssl">Checking OCSP revocation using OpenSSL&lt;/h3>
&lt;p>To verify the OCSP revocation of the X509 certificate of a &lt;code>Certificate&lt;/code> object,
you can use the tool &lt;code>hack/check-cert-secret.sh&lt;/code> in this repository.&lt;/p>
&lt;p>Usage:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">hack/check-cert-secret.sh check-revoke mynamespace mycertname
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here &lt;em>mynamespace&lt;/em> and &lt;em>mycertname&lt;/em> are the namespace and the name of the certificate object.&lt;/p>
&lt;h2 id="metrics">Metrics&lt;/h2>
&lt;p>Metrics are exposed for Prometheus if the command line option &lt;code>--server-port-http &amp;lt;port&amp;gt;&lt;/code> is specified.
The endpoint URL is &lt;code>http://&amp;lt;pod-ip&amp;gt;:&amp;lt;port&amp;gt;/metrics&lt;/code>.
Besides the default Go metrics, the following cert-management specific metrics are provided:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Name&lt;/th>
&lt;th>Labels&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>cert_management_acme_account_registrations&lt;/td>
&lt;td>uri, email, issuer&lt;/td>
&lt;td>ACME account registrations&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cert_management_acme_orders&lt;/td>
&lt;td>issuer, success, dns_challenges, renew&lt;/td>
&lt;td>Number of ACME orders&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cert_management_cert_entries&lt;/td>
&lt;td>issuer, issuertype&lt;/td>
&lt;td>Total number of certificate objects per issuer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cert_management_acme_active_dns_challenges&lt;/td>
&lt;td>issuer&lt;/td>
&lt;td>Currently active number of ACME DNS challenges&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cert_management_overdue_renewal_certificates&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Number of certificate objects with certificate&amp;rsquo;s renewal overdue&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cert_management_revoked_certificates&lt;/td>
&lt;td>-&lt;/td>
&lt;td>Number of certificate objects with revoked certificate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>cert_management_secrets&lt;/td>
&lt;td>classification&lt;/td>
&lt;td>Number of certificate secrets per classification (only updated on startup and every 24h on GC of secrets). Currently there are three classifications: &lt;code>total&lt;/code> = total number of certificate secrets on the source cluster, &lt;code>revoked&lt;/code> = number of revoked certificate secrets, &lt;code>backup&lt;/code>= number of backups of certificate secrets (every certificate has a backup secret in the &lt;code>kube-system&lt;/code> namespace to allow revocation even if it is not used anymore)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="development">Development&lt;/h2>
&lt;p>For development it is recommended to use the issuer-staging&lt;/p></description></item><item><title>Docs: Network Policies</title><link>https://gardener.cloud/docs/concepts/networking/network_policies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gardener.cloud/docs/concepts/networking/network_policies/</guid><description>
&lt;h1 id="network-policies-in-gardener">Network Policies in Gardener&lt;/h1>
&lt;p>As &lt;code>Seed&lt;/code> clusters can host the &lt;a href="https://kubernetes.io/docs/concepts/#kubernetes-control-plane">Kubernetes control planes&lt;/a> of many &lt;code>Shoot&lt;/code> clusters, it is necessary to isolate the control planes from each other for security reasons.
Besides deploying each control plane in its own namespace, Gardener creates &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">network policies&lt;/a> to also isolate the networks.
Essentially, network policies make sure that pods can only talk to other pods over the network they are supposed to.
As such, network policies are an important part of Gardener&amp;rsquo;s tenant isolation.&lt;/p>
&lt;p>Gardener deploys network policies into&lt;/p>
&lt;ul>
&lt;li>each namespace hosting the Kubernetes control plane of the Shoot cluster.&lt;/li>
&lt;li>the namespace dedicated to Gardener seed-wide global controllers. This namespace is often called &lt;code>garden&lt;/code> and contains e.g. the &lt;a href="https://github.com/gardener/gardener/blob/15cae57db802cbe460ff4cb3f80c26b2fc15e26f/docs/concepts/gardenlet.md">Gardenlet&lt;/a>.&lt;/li>
&lt;li>the &lt;code>kube-system&lt;/code> namespace in the Shoot.&lt;/li>
&lt;/ul>
&lt;p>The aforementioned namespaces in the Seed contain a &lt;code>deny-all&lt;/code> network policy that &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic">denies all ingress and egress traffic&lt;/a>.
This &lt;a href="https://en.wikipedia.org/wiki/Secure_by_default">secure by default&lt;/a> setting requires pods to allow network traffic.
This is done by pods having &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource">labels matching to the selectors of the network policies&lt;/a> deployed by Gardener.&lt;/p>
&lt;p>More details on the deployed network policies can be found in the &lt;a href="https://github.com/gardener/gardener/tree/master/docs/development/seed_network_policies.md">development&lt;/a> and &lt;a href="https://github.com/gardener/gardener/tree/master/docs/usage/shoot_network_policies.md">usage&lt;/a> sections.&lt;/p></description></item></channel></rss>