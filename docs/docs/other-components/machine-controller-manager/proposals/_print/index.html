<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://gardener.cloud/docs/other-components/machine-controller-manager/proposals/><link rel=alternate type=application/rss+xml href=https://gardener.cloud/docs/other-components/machine-controller-manager/proposals/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Proposals | Gardener</title>
<meta name=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:url" content="https://gardener.cloud/docs/other-components/machine-controller-manager/proposals/"><meta property="og:site_name" content="Gardener"><meta property="og:title" content="Proposals"><meta property="og:description" content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta property="og:locale" content="en_US"><meta property="og:type" content="website"><meta property="og:image" content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta itemprop=name content="Proposals"><meta itemprop=description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><meta itemprop=image content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta name=twitter:title content="Proposals"><meta name=twitter:description content="Project Gardener Website - A Managed Kubernetes Service Done Right"><link rel=preload href=/scss/main.min.a0c8c4899ce282dcbb2306a0b99a4fae18db6c239ce7b3bc375f59e6ee82bdad.css as=style integrity="sha256-oMjEiZzigty7IwaguZpPrhjbbCOc57O8N19Z5u6Cva0=" crossorigin=anonymous><link href=/scss/main.min.a0c8c4899ce282dcbb2306a0b99a4fae18db6c239ce7b3bc375f59e6ee82bdad.css rel=stylesheet integrity="sha256-oMjEiZzigty7IwaguZpPrhjbbCOc57O8N19Z5u6Cva0=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="90" height="90" viewBox="0 0 90 90" xmlns:xlink="http://www.w3.org/1999/xlink"><title>logo</title><desc>Created with Sketch.</desc><defs><path d="M41.8864954.994901575c.996545099999999-.479910833 2.6164002-.477918931 3.6088091.0L76.8159138 16.0781121C77.8124589 16.5580229 78.8208647 17.8257185 79.0659694 18.8995926l7.7355517 33.8916663C87.0476474 53.8696088 86.6852538 55.4484075 85.9984855 56.3095876L64.3239514 83.4885938C63.6343208 84.3533632 62.1740175 85.0543973 61.0725268 85.0543973H26.3092731c-1.1060816.0-2.5646564-.704623400000003-3.2514246-1.5658035L1.38331434 56.3095876C.693683723 55.4448182.335174016 53.865133.580278769 52.7912589L8.31583044 18.8995926C8.56195675 17.8212428 9.57347722 16.556031 10.5658861 16.0781121L41.8864954.994901575z" id="path-1"/><linearGradient x1="12.7542673%" y1="-18.6617048%" x2="88.2666158%" y2="84.6075483%" id="linearGradient-3"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="50%" y1="4.93673768%" x2="148.756007%" y2="175.514523%" id="linearGradient-4"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="19.1574381%" y1="-9.04800713%" x2="82.2203149%" y2="77.9084293%" id="linearGradient-5"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="57.4403751%" y1="26.3148481%" x2="137.966711%" y2="158.080556%" id="linearGradient-6"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><g id="Rectangle-2" transform="translate(1.000000, 0.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Mask" fill="#009f76" xlink:href="#path-1"/><polygon fill="#000" opacity=".289628623" mask="url(#mask-2)" points="-17.6484375 54.5224609 30.8242188 25.0791016 63.4726562 58.5 24.7324219 92.6689453"/></g><path d="M56.8508631 39.260019C56.4193519 40.443987 55.6088085 41.581593 54.6736295 42.1938694l-8.0738997 5.2861089c-1.3854671.907087099999998-3.6247515.9116711-5.0172201.0L33.50861 42.1938694C32.123143 41.2867823 31 39.206345 31 37.545932V26.4150304c0-.725313.2131118-1.5301454.569268099999999-2.2825772L56.8508631 39.260019z" id="Combined-Shape" fill="url(#linearGradient-3)" transform="translate(43.925432, 36.147233) scale(-1, 1) translate(-43.925432, -36.147233)"/><path d="M56.0774672 25.1412464C56.4306829 25.8903325 56.6425556 26.6907345 56.6425556 27.4119019V38.5428034c0 1.6598979-1.1161415 3.73626640000001-2.50861 4.6479374l-8.0738997 5.286109c-1.3854671.907087000000004-3.6247516.911671000000005-5.0172201.0L32.9689261 43.1907408C32.2918101 42.7474223 31.6773514 42.0238435 31.2260376 41.206007L56.0774672 25.1412464z" id="Combined-Shape" fill="url(#linearGradient-4)" transform="translate(43.821278, 37.246598) scale(-1, 1) translate(-43.821278, -37.246598)"/><path d="M65.0702134 57.1846889C64.5985426 58.2007851 63.8367404 59.1236871 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.1597438 58.7930183 24 56.7816693 24 55.1323495V37.1145303C24 36.3487436 24.249712 35.5060005 24.6599102 34.7400631L65.0702134 57.1846889z" id="Combined-Shape" fill="url(#linearGradient-5)"/><path d="M65.0189476 34.954538C65.3636909 35.6617313 65.5692194 36.42021 65.5692194 37.1145303V55.1323495C65.5692194 56.7842831 64.4072119 58.7943252 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.9237304 59.2341061 25.3159155 58.5918431 24.8568495 57.8487596L65.0189476 34.954538z" id="Combined-Shape" fill="url(#linearGradient-6)"/></g></g></svg></span><span class=navbar-brand__name>Gardener</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://demo.gardener.cloud target=_blank rel=noopener><span>Demo</span></a></li><li class=nav-item><a class=nav-link href=/adopter><span>Adopters</span></a></li><li class=nav-item><a class=nav-link href=/docs><span>Documentation</span></a></li><li class=nav-item><a class=nav-link href=/blog><span>Blogs</span></a></li><li class=nav-item><a class=nav-link href=/community><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://join.slack.com/t/gardener-cloud/shared_invite/zt-33c9daems-3oOorhnqOSnldZPWqGmIBw target=_blank rel=noopener><span>Join us on</span></a></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.aa14855e051698d1fd61277f3db21e47.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/other-components/machine-controller-manager/proposals/>Return to the regular view of this page</a>.</p></div><h1 class=title>Proposals</h1><div class=content></div></div><div class=td-content><h1 id=pg-62e1d100b3bccabcb90bdb26a65462a9>1 - Excess Reserve Capacity</h1><h1 id=excess-reserve-capacity>Excess Reserve Capacity<a class=td-heading-self-link href=#excess-reserve-capacity aria-label="Heading self-link"></a></h1><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#excess-reserve-capacity>Excess Reserve Capacity</a><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#goal>Goal</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#note>Note</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#possible-approaches>Possible Approaches</a><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#approach-1-enhance-machine-controller-manager-to-also-entertain-the-excess-machines>Approach 1: Enhance Machine-controller-manager to also entertain the excess machines</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#approach-2-enhance-cluster-autoscaler-by-simulating-fake-pods-in-it>Approach 2: Enhance Cluster-autoscaler by simulating fake pods in it</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#approach-3-enhance-cluster-autoscaler-to-support-pluggable-scaling-events>Approach 3: Enhance cluster-autoscaler to support pluggable scaling-events</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/excess_reserve_capacity/#approach-4-make-intelligent-use-of-low-priority-pods>Approach 4: Make intelligent use of Low-priority pods</a></li></ul></li></ul></li></ul><h2 id=goal>Goal<a class=td-heading-self-link href=#goal aria-label="Heading self-link"></a></h2><p>Currently, autoscaler optimizes the number of machines for a given application-workload. Along with effective resource utilization, this feature brings concern where, many times, when new application instances are created - they don&rsquo;t find space in existing cluster. This leads the cluster-autoscaler to create new machines via MachineDeployment, which can take from 3-4 minutes to ~10 minutes, for the machine to really come-up and join the cluster. In turn, application-instances have to wait till new machines join the cluster.</p><p>One of the promising solutions to this issue is Excess Reserve Capacity. Idea is to keep a certain number of machines or percent of resources[cpu/memory] always available, so that new workload, in general, can be scheduled immediately unless huge spike in the workload. Also, the user should be given enough flexibility to choose how many resources or how many machines should be kept alive and non-utilized as this affects the Cost directly.</p><h2 id=note>Note<a class=td-heading-self-link href=#note aria-label="Heading self-link"></a></h2><ul><li>We decided to go with Approach-4 which is based on low priority pods. Please find more details here: <a href=https://github.com/gardener/gardener/issues/254>https://github.com/gardener/gardener/issues/254</a></li><li>Approach-3 looks more promising in long term, we may decide to adopt that in future based on developments/contributions in autoscaler-community.</li></ul><h2 id=possible-approaches>Possible Approaches<a class=td-heading-self-link href=#possible-approaches aria-label="Heading self-link"></a></h2><p>Following are the possible approaches, we could think of so far.</p><h3 id=approach-1-enhance-machine-controller-manager-to-also-entertain-the-excess-machines>Approach 1: Enhance Machine-controller-manager to also entertain the excess machines<a class=td-heading-self-link href=#approach-1-enhance-machine-controller-manager-to-also-entertain-the-excess-machines aria-label="Heading self-link"></a></h3><ul><li><p>Machine-controller-manager currently takes care of the machines in the shoot cluster starting from creation-deletion-health check to efficient rolling-update of the machines. From the architecture point of view, MachineSet makes sure that X number of machines are always <strong>running and healthy</strong>. MachineDeployment controller smartly uses this facility to perform rolling-updates.</p></li><li><p>We can expand the scope of MachineDeployment controller to maintain excess number of machines by introducing new parallel independent controller named <em>MachineTaint</em> controller. This will result in MCM to include Machine, MachineSet, MachineDeployment, MachineSafety, MachineTaint controllers. MachineTaint controller does not need to introduce any new CRD - analogy fits where taint-controller also resides into kube-controller-manager.</p></li><li><p>Only Job of MachineTaint controller will be:</p><ul><li>List all the Machines under each MachineDeployment.</li><li>Maintain taints of <a href=https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/><em>noSchedule</em> and <em>noExecute</em></a> on <code>X</code> latest MachineObjects.</li><li>There should be an event-based informer mechanism where MachineTaintController gets to know about any Update/Delete/Create event of MachineObjects - in turn, maintains the <em>noSchedule</em> and <em>noExecute</em> taints on all the <em>latest</em> machines.
- Why latest machines?
- Whenever autoscaler decides to add new machines - essentially ScaleUp event - taints from the older machines are removed and newer machines get the taints. This way X number of Machines immediately becomes free for new pods to be scheduled.
- While ScaleDown event, autoscaler specifically mentions which machines should be deleted, and that should not bring any concerns. Though we will have to put proper label/annotation defined by autoscaler on taintedMachines, so that autoscaler does not consider the taintedMachines for deletion while scale-down.
* Annotation on tainted node: <code>"cluster-autoscaler.kubernetes.io/scale-down-disabled": "true"</code></li></ul></li><li><p>Implementation Details:</p><ul><li>Expect new <strong>optional field</strong> <em>ExcessReplicas</em> in <code>MachineDeployment.Spec</code>. MachineDeployment controller now adds both <code>Spec.Replicas</code> and <code>Spec.ExcessReplicas</code>[if provided], and considers that as a standard desiredReplicas.
- Current working of MCM will not be affected if ExcessReplicas field is kept nil.</li><li>MachineController currently reads the <em>NodeObject</em> and sets the MachineConditions in MachineObject. Machine-controller will now also read the taints/labels from the MachineObject - and maintains it on the <em>NodeObject</em>.</li></ul></li><li><p>We expect cluster-autoscaler to intelligently make use of the provided feature from MCM.</p><ul><li>CA gets the input of <em>min:max:excess</em> from Gardener. CA continues to set the <code>MachineDeployment.Spec.Replicas</code> as usual based on the application-workload.</li><li>In addition, CA also sets the <code>MachieDeployment.Spec.ExcessReplicas</code> .</li><li>Corner-case:
* CA should decrement the excessReplicas field accordingly when <em>desiredReplicas+excessReplicas</em> on MachineDeployment goes beyond <em>max</em>.</li></ul></li></ul><h3 id=approach-2-enhance-cluster-autoscaler-by-simulating-fake-pods-in-it>Approach 2: Enhance Cluster-autoscaler by simulating fake pods in it<a class=td-heading-self-link href=#approach-2-enhance-cluster-autoscaler-by-simulating-fake-pods-in-it aria-label="Heading self-link"></a></h3><ul><li>There was already an attempt by community to support this feature.<ul><li>Refer for details to: <a href=https://github.com/kubernetes/autoscaler/pull/77/files>https://github.com/kubernetes/autoscaler/pull/77/files</a></li></ul></li></ul><h3 id=approach-3-enhance-cluster-autoscaler-to-support-pluggable-scaling-events>Approach 3: Enhance cluster-autoscaler to support pluggable scaling-events<a class=td-heading-self-link href=#approach-3-enhance-cluster-autoscaler-to-support-pluggable-scaling-events aria-label="Heading self-link"></a></h3><ul><li>Forked version of cluster-autoscaler could be improved to plug-in the algorithm for excess-reserve capacity.</li><li>Needs further discussion around upstream support.</li><li>Create golang channel to separate the algorithms to trigger scaling (hard-coded in cluster-autoscaler, currently) from the algorithms about how to to achieve the scaling (already pluggable in cluster-autoscaler). This kind of separation can help us introduce/plug-in new algorithms (such as based node resource utilisation) without affecting existing code-base too much while almost completely re-using the code-base for the actual scaling.</li><li>Also this approach is not specific to our fork of cluster-autoscaler. It can be made upstream eventually as well.</li></ul><h3 id=approach-4-make-intelligent-use-of-low-priority-pods>Approach 4: Make intelligent use of Low-priority pods<a class=td-heading-self-link href=#approach-4-make-intelligent-use-of-low-priority-pods aria-label="Heading self-link"></a></h3><ul><li>Refer to: <a href=https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/>pod-priority-preemption</a></li><li>TL; DR:<ul><li>High priority pods can preempt the low-priority pods which are already scheduled.</li><li>Pre-create bunch[equivivalent of X shoot-control-planes] of low-priority pods with priority of zero, then start creating the workload pods with better priority which will reschedule the low-priority pods or otherwise keep them in pending state if the limit for max-machines has reached.</li><li>This is still alpha feature.</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-099b6b715491def6df5afea44f6779f6>2 - GRPC Based Implementation of Cloud Providers</h1><h1 id=grpc-based-implementation-of-cloud-providers---wip>GRPC based implementation of Cloud Providers - WIP<a class=td-heading-self-link href=#grpc-based-implementation-of-cloud-providers---wip aria-label="Heading self-link"></a></h1><h2 id=goal>Goal:<a class=td-heading-self-link href=#goal aria-label="Heading self-link"></a></h2><p>Currently the Cloud Providers&rsquo; (CP) functionalities ( Create(), Delete(), List() ) are part of the Machine Controller Manager&rsquo;s (MCM)repository. Because of this, adding support for new CPs into MCM requires merging code into MCM which may not be required for core functionalities of MCM itself. Also, for various reasons it may not be feasible for all CPs to merge their code with MCM which is an Open Source project.</p><p>Because of these reasons, it was decided that the CP&rsquo;s code will be moved out in separate repositories so that they can be maintained separately by the respective teams. Idea is to make MCM act as a GRPC server, and CPs as GRPC clients. The CP can register themselves with the MCM using a GRPC service exposed by the MCM. Details of this approach is discussed below.</p><h2 id=how-it-works>How it works:<a class=td-heading-self-link href=#how-it-works aria-label="Heading self-link"></a></h2><p>MCM acts as GRPC server and listens on a pre-defined port 5000. It implements below GRPC services. Details of each of these services are mentioned in next section.</p><ul><li><code>Register()</code></li><li><code>GetMachineClass()</code></li><li><code>GetSecret()</code></li></ul><h2 id=grpc-services-exposed-by-mcm>GRPC services exposed by MCM:<a class=td-heading-self-link href=#grpc-services-exposed-by-mcm aria-label="Heading self-link"></a></h2><h3 id=register>Register()<a class=td-heading-self-link href=#register aria-label="Heading self-link"></a></h3><p><code>rpc Register(stream DriverSide) returns (stream MCMside) {}</code></p><p>The CP GRPC client calls this service to register itself with the MCM. The CP passes the <code>kind</code> and the <code>APIVersion</code> which it implements, and MCM maintains an internal map for all the registered clients. A GRPC stream is returned in response which is kept open througout the life of both the processes. MCM uses this stream to communicate with the client for machine operations: <code>Create()</code>, <code>Delete()</code> or <code>List()</code>.
The CP client is responsible for reading the incoming messages continuously, and based on the <code>operationType</code> parameter embedded in the message, it is supposed to take the required action. This part is already handled in the package <code>grpc/infraclient</code>.
To add a new CP client, import the package, and implement the <code>ExternalDriverProvider</code> interface:</p><pre tabindex=0><code>type ExternalDriverProvider interface {
	Create(machineclass *MachineClassMeta, credentials, machineID, machineName string) (string, string, error)
	Delete(machineclass *MachineClassMeta, credentials, machineID string) error
	List(machineclass *MachineClassMeta, credentials, machineID string) (map[string]string, error)
}
</code></pre><h3 id=getmachineclass>GetMachineClass()<a class=td-heading-self-link href=#getmachineclass aria-label="Heading self-link"></a></h3><p><code>rpc GetMachineClass(MachineClassMeta) returns (MachineClass) {}</code></p><p>As part of the message from MCM for various machine operations, the name of the machine class is sent instead of the full machine class spec. The CP client is expected to use this GRPC service to get the full spec of the machine class. This optionally enables the client to cache the machine class spec, and make the call only if the machine calass spec is not already cached.</p><h3 id=getsecret>GetSecret()<a class=td-heading-self-link href=#getsecret aria-label="Heading self-link"></a></h3><p><code>rpc GetSecret(SecretMeta) returns (Secret) {}</code></p><p>As part of the message from MCM for various machine operations, the Cloud Config (CC) and CP credentials are not sent. The CP client is expected to use this GRPC service to get the secret which has CC and CP&rsquo;s credentials from MCM. This enables the client to cache the CC and credentials, and to make the call only if the data is not already cached.</p><h2 id=how-to-add-a-new-cloud-providers-support>How to add a new Cloud Provider&rsquo;s support<a class=td-heading-self-link href=#how-to-add-a-new-cloud-providers-support aria-label="Heading self-link"></a></h2><p>Import the package <code>grpc/infraclient</code> and <code>grpc/infrapb</code> from MCM (currently in MCM&rsquo;s &ldquo;grpc-driver&rdquo; branch)</p><ul><li>Implement the interface <code>ExternalDriverProvider</code><ul><li><code>Create()</code>: Creates a new machine</li><li><code>Delete()</code>: Deletes a machine</li><li><code>List()</code>: Lists machines</li></ul></li><li>Use the interface <code>MachineClassDataProvider</code><ul><li><code>GetMachineClass()</code>: Makes the call to MCM to get machine class spec</li><li><code>GetSecret()</code>: Makes the call to MCM to get secret containing Cloud Config and CP&rsquo;s credentials</li></ul></li></ul><h3 id=example-implementation>Example implementation:<a class=td-heading-self-link href=#example-implementation aria-label="Heading self-link"></a></h3><p>Refer GRPC based implementation for AWS client:
<a href=https://github.com/ggaurav10/aws-driver-grpc>https://github.com/ggaurav10/aws-driver-grpc</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-9146991d7ac0a6e2b783c8a7932c0c52>3 - Hotupdate Instances</h1><h1 id=hot-update-virtualmachine-tags-without-triggering-a-rolling-update>Hot-Update VirtualMachine tags without triggering a rolling-update<a class=td-heading-self-link href=#hot-update-virtualmachine-tags-without-triggering-a-rolling-update aria-label="Heading self-link"></a></h1><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#hot-update-virtualmachine-tags-without-triggering-a-rolling-update>Hot-Update VirtualMachine tags without triggering a rolling-update</a><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#motivation>Motivation</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#boundary-condition>Boundary Condition</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#what-is-available-today>What is available today?</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#what-are-the-problems-with-the-current-approach>What are the problems with the current approach?</a><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#machineclass-update-and-its-impact>MachineClass Update and its impact</a></li></ul></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#proposal>Proposal</a><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#shoot-yaml-changes>Shoot YAML changes</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#provider-specific-workerconfig-api-changes>Provider specific WorkerConfig API changes</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#gardener-provider-extension-changes>Gardener provider extension changes</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#driver-interface-changes>Driver interface changes</a></li><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#machine-class-reconciliation>Machine Class reconciliation</a><ul><li><a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/#reconciliation-changes>Reconciliation Changes</a></li></ul></li></ul></li></ul></li></ul><h2 id=motivation>Motivation<a class=td-heading-self-link href=#motivation aria-label="Heading self-link"></a></h2><ul><li><p><a href=https://github.com/gardener/machine-controller-manager/issues/750>MCM Issue#750</a> There is a requirement to provide a way for consumers to add tags which can be hot-updated onto VMs. This requirement can be generalized to also offer a convenient way to specify tags which can be applied to VMs, NICs, Devices etc.</p></li><li><p><a href=https://github.com/gardener/machine-controller-manager/issues/635>MCM Issue#635</a> which in turn points to <a href=https://github.com/gardener/machine-controller-manager-provider-aws/issues/36#issuecomment-677530395>MCM-Provider-AWS Issue#36</a> - The issue hints at other fields like enable/disable <a href=https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html#EIP_Disable_SrcDestCheck>source/destination checks for NAT instances</a> which needs to be hot-updated on network interfaces.</p></li><li><p>In GCP provider - <code>instance.ServiceAccounts</code> can be updated without the need to roll-over the instance. <a href=https://cloud.google.com/compute/docs/access/service-accounts>See</a></p></li></ul><h2 id=boundary-condition>Boundary Condition<a class=td-heading-self-link href=#boundary-condition aria-label="Heading self-link"></a></h2><p>All tags that are added via means other than MachineClass.ProviderSpec should be preserved as-is. Only updates done to tags in <code>MachineClass.ProviderSpec</code> should be applied to the infra resources (VM/NIC/Disk).</p><h2 id=what-is-available-today>What is available today?<a class=td-heading-self-link href=#what-is-available-today aria-label="Heading self-link"></a></h2><p>WorkerPool configuration inside <a href=https://github.com/gardener/gardener/blob/fb29d38e6615ed17d409a8271a285254d9dd00ad/example/90-shoot.yaml#L61-L62>shootYaml</a> provides a way to set labels. As per the <a href=https://gardener.cloud/docs/gardener/api-reference/core/#core.gardener.cloud/v1beta1.Worker>definition</a> these labels will be applied on <code>Node</code> resources. Currently these labels are also passed to the VMs as tags. There is no distinction made between <code>Node</code> labels and <code>VM</code> tags.</p><p><code>MachineClass</code> has a field which holds <a href=https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/v1alpha1/machineclass_types.go#L54>provider specific configuration</a> and one such configuration is <code>tags</code>. Gardener provider extensions updates the tags in <code>MachineClass</code>.</p><ul><li>AWS provider extension directly passes the labels to the <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/0a740eeca301320275d77d1c48d3c32d4ebcd7dd/pkg/controller/worker/machines.go#L158-L164>tag section</a> of machineClass.</li><li>Azure provider extension <a href=https://github.com/gardener/gardener-extension-provider-azure/blob/b6424f0122e174863e783555aa0ad68700edd87b/pkg/controller/worker/machines.go#L371-L373>sanitizes</a> the woker pool labels and adds them as <a href=https://github.com/gardener/gardener-extension-provider-azure/blob/b6424f0122e174863e783555aa0ad68700edd87b/pkg/controller/worker/machines.go#L187>tags in MachineClass</a>.</li><li>GCP provider extension <a href=https://github.com/gardener/gardener-extension-provider-gcp/blob/eb851f716e45336b486f3aaf46268859de2adecb/pkg/controller/worker/machines.go#L312-L315>sanitizes</a> them, and then sets them as <a href=https://github.com/gardener/gardener-extension-provider-gcp/blob/eb851f716e45336b486f3aaf46268859de2adecb/pkg/controller/worker/machines.go#L169>labels in the MachineClass</a>. In GCP tags only have keys and are currently <a href=https://github.com/gardener/gardener-extension-provider-gcp/blob/eb851f716e45336b486f3aaf46268859de2adecb/pkg/controller/worker/machines.go#L204-L207>hard coded</a>.</li></ul><p>Let us look at an example of <code>MachineClass.ProviderSpec</code> in AWS:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>providerSpec:
</span></span><span style=display:flex><span>  ami: ami-02fe00c0afb75bbd3
</span></span><span style=display:flex><span>  tags:
</span></span><span style=display:flex><span>    <span style=color:green>#[section-1] pool lables added by gardener extension</span>
</span></span><span style=display:flex><span>    <span style=color:green>#########################################################</span>
</span></span><span style=display:flex><span>    kubernetes.io/arch: amd64
</span></span><span style=display:flex><span>    networking.gardener.cloud/node-local-dns-enabled: <span style=color:#a31515>&#34;true&#34;</span>
</span></span><span style=display:flex><span>    node.kubernetes.io/role: node
</span></span><span style=display:flex><span>    worker.garden.sapcloud.io/group: worker-ser234
</span></span><span style=display:flex><span>    worker.gardener.cloud/cri-name: containerd
</span></span><span style=display:flex><span>    worker.gardener.cloud/pool: worker-ser234
</span></span><span style=display:flex><span>    worker.gardener.cloud/system-components: <span style=color:#a31515>&#34;true&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>#[section-2] Tags defined in the gardener-extension-provider-aws</span>
</span></span><span style=display:flex><span>    <span style=color:green>###########################################################</span>
</span></span><span style=display:flex><span>    kubernetes.io/cluster/cluster-full-name: <span style=color:#a31515>&#34;1&#34;</span>
</span></span><span style=display:flex><span>    kubernetes.io/role/node: <span style=color:#a31515>&#34;1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>#[section-3]</span>
</span></span><span style=display:flex><span>    <span style=color:green>###########################################################</span>
</span></span><span style=display:flex><span>    user-defined-key1: user-defined-val1
</span></span><span style=display:flex><span>    user-defined-key2: user-defined-val2
</span></span></code></pre></div><blockquote><p>Refer <a href=https://github.com/gardener/gardener/blob/c11c86ae07d8ea784f5c41362cd41800f06bb3ed/pkg/operation/botanist/component/extensions/worker/worker.go#L171-L197>src</a> for tags defined in <code>section-1</code>.
Refer <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/0a740eeca301320275d77d1c48d3c32d4ebcd7dd/pkg/controller/worker/machines.go#L158-L164>src</a> for tags defined in <code>section-2</code>.
Tags in <code>section-3</code> are defined by the user.</p></blockquote><p>Out of the above three tag categories, MCM depends <code>section-2</code> tags (<code>mandatory-tags</code>) for its <code>orphan collection</code> and Driver&rsquo;s <code>DeleteMachine</code>and <code>GetMachineStatus</code> to work.</p><p><code>ProviderSpec.Tags</code> are transported to the provider specific resources as follows:</p><table><thead><tr><th>Provider</th><th>Resources Tags are set on</th><th>Code Reference</th><th>Comment</th></tr></thead><tbody><tr><td>AWS</td><td>Instance(VM), Volume, Network-Interface</td><td><a href=https://github.com/gardener/machine-controller-manager-provider-aws/blob/v0.17.0/pkg/aws/core.go#L116-L129>aws-VM-Vol-NIC</a></td><td>No distinction is made between tags set on VM, NIC or Volume</td></tr><tr><td>Azure</td><td>Instance(VM), Network-Interface</td><td><a href=https://github.com/gardener/machine-controller-manager-provider-azure/blob/v0.10.0/pkg/azure/utils.go#L234>azure-VM-parameters</a> & <a href=https://github.com/gardener/machine-controller-manager-provider-azure/blob/v0.10.0/pkg/azure/utils.go#L116>azureNIC-Parameters</a></td><td></td></tr><tr><td>GCP</td><td>Instance(VM), 1 tag: <code>name</code> (denoting the name of the worker) is added to Disk</td><td><a href=https://github.com/gardener/machine-controller-manager-provider-gcp/blob/v0.14.0/pkg/gcp/machine_controller_util.go#L78-L80>gcp-VM</a> & <a href=https://github.com/gardener/gardener-extension-provider-gcp/blob/v1.28.1/pkg/controller/worker/machines.go#L291-L293>gcp-Disk</a></td><td>In GCP key-value pairs are called <code>labels</code> while <code>network tags</code> have only keys</td></tr><tr><td>AliCloud</td><td>Instance(VM)</td><td><a href=https://github.com/gardener/machine-controller-manager-provider-alicloud/blob/master/pkg/spi/spi.go#L125-L129>aliCloud-VM</a></td><td></td></tr></tbody></table><h2 id=what-are-the-problems-with-the-current-approach>What are the problems with the current approach?<a class=td-heading-self-link href=#what-are-the-problems-with-the-current-approach aria-label="Heading self-link"></a></h2><p>There are a few shortcomings in the way tags/labels are handled:</p><ul><li>Tags can only be set at the time a machine is created.</li><li>There is no distinction made amongst tags/labels that are added to VM&rsquo;s, disks or network interfaces. As stated above for AWS same set of tags are added to all. There is a limit defined on the number of tags/labels that can be associated to the devices (disks, VMs, NICs etc). Example: In AWS a max of <a href=https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html>50 user created tags are allowed</a>. Similar restrictions are applied on different resources across providers. Therefore adding all tags to all devices even if the subset of tags are not meant for that resource exhausts the total allowed tags/labels for that resource.</li><li>The only placeholder in shoot yaml as mentioned above is meant to only hold labels that should be applied on primarily on the <a href=https://github.com/gardener/gardener/blob/v1.66.1/pkg/apis/core/v1beta1/types_shoot.go#L1315-L1317>Node</a> objects. So while you could use the node labels for <a href=https://github.com/gardener/machine-controller-manager/issues/727>extended resources</a>, using it also for tags is not clean.</li><li>There is no provision in the shoot YAML today to add tags only to a subset of resources.</li></ul><h3 id=machineclass-update-and-its-impact>MachineClass Update and its impact<a class=td-heading-self-link href=#machineclass-update-and-its-impact aria-label="Heading self-link"></a></h3><p>When <a href=https://github.com/gardener/gardener/blob/v1.66.1/pkg/apis/core/types_shoot.go#L1042-L1043>Worker.ProviderConfig</a> is changed then a <a href=https://github.com/gardener/gardener/blob/v1.66.1/extensions/pkg/controller/worker/machines.go#L146-L148>worker-hash</a> is computed which includes the raw <code>ProviderConfig</code>. This hash value is then used as a suffix when constructing the name for a <code>MachineClass</code>. See <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/pkg/controller/worker/machines.go#L190>aws-extension-provider</a> as an example. A change in the name of the <code>MachineClass</code> will then in-turn trigger a rolling update of machines. Since <code>tags</code> are provider specific and therefore will be part of <code>ProviderConfig</code>, any update to them will result in a rolling-update of machines.</p><h2 id=proposal>Proposal<a class=td-heading-self-link href=#proposal aria-label="Heading self-link"></a></h2><h3 id=shoot-yaml-changes>Shoot YAML changes<a class=td-heading-self-link href=#shoot-yaml-changes aria-label="Heading self-link"></a></h3><p>Provider specific configuration is set via <a href=https://github.com/gardener/gardener/blob/master/example/90-shoot.yaml#L57-L58>providerConfig</a> section for each worker pool.</p><p>Example worker provider config (current):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>providerConfig:
</span></span><span style=display:flex><span>   apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>   kind: WorkerConfig
</span></span><span style=display:flex><span>   volume:
</span></span><span style=display:flex><span>     iops: 10000
</span></span><span style=display:flex><span>   dataVolumes:
</span></span><span style=display:flex><span>   - name: kubelet-dir
</span></span><span style=display:flex><span>     snapshotID: snap-13234
</span></span><span style=display:flex><span>   iamInstanceProfile: <span style=color:green># (specify either ARN or name)</span>
</span></span><span style=display:flex><span>     name: my-profile
</span></span><span style=display:flex><span>     arn: my-instance-profile-arn
</span></span></code></pre></div><p>It is proposed that an additional field be added for <code>tags</code> under <code>providerConfig</code>. Proposed changed YAML:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>providerConfig:
</span></span><span style=display:flex><span>   apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>   kind: WorkerConfig
</span></span><span style=display:flex><span>   volume:
</span></span><span style=display:flex><span>     iops: 10000
</span></span><span style=display:flex><span>   dataVolumes:
</span></span><span style=display:flex><span>   - name: kubelet-dir
</span></span><span style=display:flex><span>     snapshotID: snap-13234
</span></span><span style=display:flex><span>   iamInstanceProfile: <span style=color:green># (specify either ARN or name)</span>
</span></span><span style=display:flex><span>     name: my-profile
</span></span><span style=display:flex><span>     arn: my-instance-profile-arn
</span></span><span style=display:flex><span>   tags:
</span></span><span style=display:flex><span>     vm:
</span></span><span style=display:flex><span>       key1: val1
</span></span><span style=display:flex><span>       key2: val2
</span></span><span style=display:flex><span>       ..
</span></span><span style=display:flex><span>     <span style=color:green># for GCP network tags are just keys (there is no value associated to them). </span>
</span></span><span style=display:flex><span>     <span style=color:green># What is shown below will work for AWS provider.</span>
</span></span><span style=display:flex><span>     network:
</span></span><span style=display:flex><span>       key3: val3
</span></span><span style=display:flex><span>       key4: val4
</span></span></code></pre></div><p>Under <code>tags</code> clear distinction is made between tags for VMs, Disks, network interface etc. Each provider has a different allowed-set of characters that it accepts as key names, has different limits on the tags that can be set on a resource (disk, NIC, VM etc.) and also has a different format (GCP network tags are only keys).</p><blockquote><p>TODO:</p><ul><li><p>Check if worker.labels are getting added as tags on infra resources. We should continue to support it and double check that these should only be added to VMs and not to other resources.</p></li><li><p>Should we support users adding VM tags as node labels?</p></li></ul></blockquote><h3 id=provider-specific-workerconfig-api-changes>Provider specific WorkerConfig API changes<a class=td-heading-self-link href=#provider-specific-workerconfig-api-changes aria-label="Heading self-link"></a></h3><blockquote><p>Taking <code>AWS</code> provider extension as an example to show the changes.</p></blockquote><p><a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/pkg/apis/aws/types_worker.go#L27-L38>WorkerConfig</a> will now have the following changes:</p><ol><li>A new field for tags will be introduced.</li><li>Additional metadata for struct fields will now be added via <code>struct tags</code>.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#00f>type</span> WorkerConfig <span style=color:#00f>struct</span> {
</span></span><span style=display:flex><span>    metav1.TypeMeta
</span></span><span style=display:flex><span>    Volume *Volume
</span></span><span style=display:flex><span>    <span style=color:green>// .. all fields are not mentioned here.
</span></span></span><span style=display:flex><span><span style=color:green></span>    <span style=color:green>// Tags are a collection of tags to be set on provider resources (e.g. VMs, Disks, Network Interfaces etc.)
</span></span></span><span style=display:flex><span><span style=color:green></span>    Tags *Tags <span style=color:#a31515>`hotupdatable:true`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// Tags is a placeholder for all tags that can be set/updated on VMs, Disks and Network Interfaces.
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>type</span> Tags <span style=color:#00f>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:green>// VM tags set on the VM instances.
</span></span></span><span style=display:flex><span><span style=color:green></span>    VM <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>]<span style=color:#2b91af>string</span>
</span></span><span style=display:flex><span>    <span style=color:green>// Network tags set on the network interfaces.
</span></span></span><span style=display:flex><span><span style=color:green></span>    Network <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>]<span style=color:#2b91af>string</span>
</span></span><span style=display:flex><span>    <span style=color:green>// Disk tags set on the volumes/disks.
</span></span></span><span style=display:flex><span><span style=color:green></span>    Disk <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>]<span style=color:#2b91af>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There is a need to distinguish fields within <code>ProviderSpec</code> (which is then mapped to the above <code>WorkerConfig</code>) which can be updated without the need to change the hash suffix for <code>MachineClass</code> and thus trigger a rolling update on machines.</p><p>To achieve that we propose to use <strong>struct tag</strong> <code>hotupdatable</code> whose value indicates if the field can be updated without the need to do a rolling update. To ensure backward compatibility, all fields which do not have this tag or have <code>hotupdatable</code> set to <code>false</code> will be considered as immutable and will require a rolling update to take affect.</p><h3 id=gardener-provider-extension-changes>Gardener provider extension changes<a class=td-heading-self-link href=#gardener-provider-extension-changes aria-label="Heading self-link"></a></h3><blockquote><p>Taking AWS provider extension as an example. Following changes should be made to all gardener provider extensions</p></blockquote><p>AWS Gardener Extension <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/v1.42.1/pkg/controller/worker/machines.go#L104-L107>generates machine config</a> using worker pool configuration. As part of that it also computes the <code>workerPoolHash</code> which is then used to create the <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/pkg/controller/worker/machines.go#L193>name of the MachineClass</a>.</p><p>Currently <code>WorkerPoolHash</code> function uses the <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/47d6bb34a538f3dfeedcf99361696de72d1eeae2/vendor/github.com/gardener/gardener/extensions/pkg/controller/worker/machines.go#L146-L148>entire providerConfig</a> to compute the hash. Proposal is to do the following:</p><ol><li>Remove the <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/47d6bb34a538f3dfeedcf99361696de72d1eeae2/vendor/github.com/gardener/gardener/extensions/pkg/controller/worker/machines.go#L146-L148>code</a> from function <code>WorkerPoolHash</code>.</li><li>Add another function to compute hash using all immutable fields in the provider config struct and then pass that to <code>worker.WorkerPoolHash</code> as <code>additionalData</code>.</li></ol><p>The above will ensure that tags and any other field in <code>WorkerConfig</code> which is marked with <code>updatable:true</code> is not considered for hash computation and will therefore not contribute to changing the name of <code>MachineClass</code> object thus preventing a rolling update.</p><p><code>WorkerConfig</code> and therefore the contained tags will be set as <a href=https://github.com/gardener/machine-controller-manager/blob/master/pkg/apis/machine/v1alpha1/machineclass_types.go#L54>ProviderSpec</a> in <code>MachineClass</code>.</p><p>If only fields which have <code>updatable:true</code> are changed then it should result in update/patch of <code>MachineClass</code> and not creation.</p><h3 id=driver-interface-changes>Driver interface changes<a class=td-heading-self-link href=#driver-interface-changes aria-label="Heading self-link"></a></h3><p><a href=https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/driver/driver.go#L28>Driver</a> interface which is a facade to provider specific API implementations will have one additional method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#00f>type</span> Driver <span style=color:#00f>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:green>// .. existing methods are not mentioned here for brevity.
</span></span></span><span style=display:flex><span><span style=color:green></span>    UpdateMachine(context.Context, *UpdateMachineRequest) <span style=color:#2b91af>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// UpdateMachineRequest is the request to update machine tags. 
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>type</span> UpdateMachineRequest <span style=color:#00f>struct</span> {
</span></span><span style=display:flex><span>    ProviderID <span style=color:#2b91af>string</span>
</span></span><span style=display:flex><span>    LastAppliedProviderSpec raw.Extension
</span></span><span style=display:flex><span>    MachineClass *v1alpha1.MachineClass
</span></span><span style=display:flex><span>    Secret *corev1.Secret
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>If any <code>machine-controller-manager-provider-&lt;providername></code> has not implemented <code>UpdateMachine</code> then updates of tags on Instances/NICs/Disks will not be done. An error message will be logged instead.</p></blockquote><blockquote></blockquote><h3 id=machine-class-reconciliation>Machine Class reconciliation<a class=td-heading-self-link href=#machine-class-reconciliation aria-label="Heading self-link"></a></h3><p>Current <a href=https://github.com/gardener/machine-controller-manager/blob/v0.48.1/pkg/util/provider/machinecontroller/machineclass.go#L140-L194>MachineClass reconciliation</a> does not reconcile <code>MachineClass</code> resource updates but it only enqueues associated machines. The reason is that it is assumed that anything that is changed in a MachineClass will result in a creation of a new MachineClass with a different name. This will result in a rolling update of all machines using the MachineClass as a template.</p><p>However, it is possible that there is data that all machines in a <code>MachineSet</code> share which do not require a rolling update (e.g. tags), therefore there is a need to reconcile the MachineClass as well.</p><h4 id=reconciliation-changes>Reconciliation Changes<a class=td-heading-self-link href=#reconciliation-changes aria-label="Heading self-link"></a></h4><p>In order to ensure that machines get updated eventually with changes to the <code>hot-updatable</code> fields defined in the <code>MachineClass.ProviderConfig</code> as <code>raw.Extension</code>.</p><p>We should only fix <a href=https://github.com/gardener/machine-controller-manager/issues/751>MCM Issue#751</a> in the MachineClass reconciliation and let it enqueue the machines as it does today. We additionally propose the following two things:</p><ol><li><p>Introduce a new annotation <code>last-applied-providerspec</code> on every machine resource. This will capture the last successfully applied <code>MachineClass.ProviderSpec</code> on this instance.</p></li><li><p>Enhance the machine reconciliation to include code to hot-update machine.</p></li></ol><p>In <a href=https://github.com/gardener/machine-controller-manager/blob/v0.48.1/pkg/util/provider/machinecontroller/machine.go#L114>machine-reconciliation</a> there are currently two flows <code>triggerDeletionFlow</code> and <code>triggerCreationFlow</code>. When a machine gets enqueued due to changes in MachineClass then in this method following changes needs to be introduced:</p><p>Check if the machine has <code>last-applied-providerspec</code> annotation.</p><p><em>Case 1.1</em></p><p>If the annotation is not present then there can be just 2 possibilities:</p><ul><li><p>It is a fresh/new machine and no backing resources (VM/NIC/Disk) exist yet. The current flow checks if the providerID is empty and <code>Status.CurrenStatus.Phase</code> is empty then it enters into the <code>triggerCreationFlow</code>.</p></li><li><p>It is an existing machine which does not yet have this annotation. In this case call <code>Driver.UpdateMachine</code>. If the driver returns no error then add <code>last-applied-providerspec</code> annotation with the value of <code>MachineClass.ProviderSpec</code> to this machine.</p></li></ul><p><em>Case 1.2</em></p><p>If the annotation is present then compare the last applied provider-spec with the current provider-spec. If there are changes (check their hash values) then call <code>Driver.UpdateMachine</code>. If the driver returns no error then add <code>last-applied-providerspec</code> annotation with the value of <code>MachineClass.ProviderSpec</code> to this machine.</p><blockquote><p>NOTE: It is assumed that if there are changes to the fields which are not marked as <code>hotupdatable</code> then it will result in the change of name for MachineClass resulting in a rolling update of machines. If the name has not changed + machine is enqueued + there is a change in machine-class then it will be change to a hotupdatable fields in the spec.</p></blockquote><p>Trigger update flow can be done after <code>reconcileMachineHealth</code> and <code>syncMachineNodeTemplates</code> in <a href=https://github.com/gardener/machine-controller-manager/blob/v0.48.1/pkg/util/provider/machinecontroller/machine.go#L164-L175>machine-reconciliation</a>.</p><p>There are 2 edge cases that needs attention and special handling:</p><blockquote><p>Premise: It is identified that there is an update done to one or more hotupdatable fields in the MachineClass.ProviderSpec.</p></blockquote><p><em>Edge-Case-1</em></p><p>In the machine reconciliation, an update-machine-flow is triggered which in-turn calls <code>Driver.UpdateMachine</code>. Consider the case where the hot update needs to be done to all VM, NIC and Disk resources. The driver returns an error which indicates a <code>partial-failure</code>. As we have mentioned above only when <code>Driver.UpdateMachine</code> returns no error will <code>last-applied-providerspec</code> be updated. In case of partial failure the annotation will not be updated. This event will be re-queued for a re-attempt. However consider a case where before the item is re-queued, another update is done to MachineClass reverting back the changes to the original spec.</p><table><thead><tr><th>At T1</th><th>At T2 (T2 > T1)</th><th>At T3 (T3> T2)</th></tr></thead><tbody><tr><td>last-applied-providerspec=S1<br>MachineClass.ProviderSpec = S1</td><td>last-applied-providerspec=S1<br>MachineClass.ProviderSpec = S2<br> Another update to MachineClass.ProviderConfig = S3 is enqueue (S3 == S1)</td><td>last-applied-providerspec=S1<br>Driver.UpdateMachine for S1-S2 update - returns partial failure<br>Machine-Key is requeued</td></tr></tbody></table><p>At T4 (T4> T3) when a machine is reconciled then it checks that <code>last-applied-providerspec</code> is S1 and current MachineClass.ProviderSpec = S3 and since S3 is same as S1, no update is done. At T2 Driver.UpdateMachine was called to update the machine with <code>S2</code> but it partially failed. So now you will have resources which are partially updated with S2 and no further updates will be attempted.</p><p><em>Edge-Case-2</em></p><p>The above situation can also happen when <code>Driver.UpdateMachine</code> is in the process of updating resources. It has hot-updated lets say 1 resource. But now MCM crashes. By the time it comes up another update to MachineClass.ProviderSpec is done essentially reverting back the previous change (same case as above). In this case reconciliation loop never got a chance to get any response from the driver.</p><p>To handle the above edge cases there are 2 options:</p><p><em>Option #1</em></p><p>Introduce a new annotation <code>inflight-providerspec-hash</code> . The value of this annotation will be the hash value of the <code>MachineClass.ProviderSpec</code> that is in the process of getting applied on this machine. The machine will be updated with this annotation just before calling <code>Driver.UpdateMachine</code> (in the trigger-update-machine-flow). If the driver returns no error then (in a single update):</p><ol><li><p><code>last-applied-providerspec</code> will be updated</p></li><li><p><code>inflight-providerspec-hash</code> annotation will be removed.</p></li></ol><p><em>Option #2</em> - Preferred</p><p>Leverage <code>Machine.Status.LastOperation</code> with <code>Type</code> set to <code>MachineOperationUpdate</code> and <code>State</code> set to <code>MachineStateProcessing</code> This status will be updated just before calling <code>Driver.UpdateMachine</code>.</p><p>Semantically <code>LastOperation</code> captures the details of the operation post-operation and not pre-operation. So this solution would be a divergence from the norm.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-52cc8311c573a80bf6dbfdc71d466074>4 - Initialize Machine</h1><h1 id=post-create-initialization-of-machine-instance>Post-Create Initialization of Machine Instance<a class=td-heading-self-link href=#post-create-initialization-of-machine-instance aria-label="Heading self-link"></a></h1><h2 id=background>Background<a class=td-heading-self-link href=#background aria-label="Heading self-link"></a></h2><p>Today the <a href=https://github.com/gardener/machine-controller-manager/blob/rel-v0.49/pkg/util/provider/driver/driver.go#L28>driver.Driver</a> facade represents the boundary between the the <code>machine-controller</code> and its various provider specific implementations.</p><p>We have abstract operations for creation/deletion and listing of machines (actually compute instances) but we do not correctly handle post-creation initialization logic. Nor do we provide an abstract operation to represent the hot update of an instance after creation.</p><p>We have found this to be necessary for several use cases. Today in the MCM AWS Provider, we already misuse <code>driver.GetMachineStatus</code> which is supposed to be a read-only operation obtaining the status of an instance.</p><ol><li><p>Each AWS EC2 instance performs source/destination checks by default.
For <a href=https://docs.aws.amazon.com/vpc/latest/userguide/VPC_NAT_Instance.html#EIP_Disable_SrcDestCheck>EC2 NAT</a> instances
these should be disabled. This is done by issuing
a <a href=https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>ModifyInstanceAttribute</a> request with the <code>SourceDestCheck</code> set to <code>false</code>. The MCM AWS Provider, decodes the <a href=https://github.com/gardener/machine-controller-manager-provider-aws/blob/39318bb2b5b4a573fdc77eaf400839d12c4abf59/pkg/aws/apis/aws_provider_spec.go#L63>AWSProviderSpec</a>, reads <code>providerSpec.SrcAndDstChecksEnabled</code> and correspondingly issues the call to modify the already launched instance. However, this should be done as an action after creating the instance and should not be part of the VM status retrieval.</p></li><li><p>Similarly, there is a <a href=https://github.com/gardener/machine-controller-manager-provider-aws/pull/128>pending PR</a> to add the <code>Ipv6AddessCount</code> and <code>Ipv6PrefixCount</code> to enable the assignment of an ipv6 address and an ipv6 prefix to instances. This requires constructing and issuing an <a href=https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_AssignIpv6Addresses.html>AssignIpv6Addresses</a> request after the EC2 instance is available.</p></li><li><p>We have other uses-cases such as <a href=https://github.com/gardener/machine-controller-manager/issues/750>MCM Issue#750</a> where there is a requirement to provide a way for consumers to add tags which can be hot-updated onto instances. This requirement can be generalized to also offer a convenient way to specify tags which can be applied to VMs, NICs, Devices etc.</p></li><li><p>We have a need for &ldquo;machine-instance-not-ready&rdquo; taint as described in <a href=https://github.com/gardener/machine-controller-manager/issues/740>MCM#740</a> which should only get removed once the post creation updates are finished.</p></li></ol><h2 id=objectives>Objectives<a class=td-heading-self-link href=#objectives aria-label="Heading self-link"></a></h2><p>We will split the fulfilment of this overall need into 2 stages of implementation.</p><ol><li><p><strong>Stage-A</strong>: Support post-VM creation initialization logic of the instance suing a proposed <code>Driver.InitializeMachine</code> by permitting provider implementors to add initialization logic after VM creation, return with special new error code <code>codes.Initialization</code> for initialization errors and correspondingly support a new machine operation stage <code>InstanceInitialization</code> which will be updated in the machine <code>LastOperation</code>. The <a href=https://github.com/gardener/machine-controller-manager/blob/rel-v0.50/pkg/util/provider/machinecontroller/machine.go#L310>triggerCreationFlow</a> - a reconciliation sub-flow of the MCM responsible for orchestrating instance creation and updating machine status will be changed to support this behaviour.</p></li><li><p><strong>Stage-B</strong>: Introduction of <code>Driver.UpdateMachine</code> and enhancing the MCM, MCM providers and gardener extension providers to support hot update of instances through <code>Driver.UpdateMachine</code>. The MCM <a href=https://github.com/gardener/machine-controller-manager/blob/v0.50.1/pkg/util/provider/machinecontroller/machine.go#L531>triggerUpdationFlow</a> - a reconciliation sub-flow of the MCM which is supposed to be responsible for orchestrating instance update - but currently not used, will be updated to invoke the provider <code>Driver.UpdateMachine</code> on hot-updates to to the <code>Machine</code> object</p></li></ol><h2 id=stage-a-proposal>Stage-A Proposal<a class=td-heading-self-link href=#stage-a-proposal aria-label="Heading self-link"></a></h2><h3 id=current-mcm-triggercreationflow>Current MCM triggerCreationFlow<a class=td-heading-self-link href=#current-mcm-triggercreationflow aria-label="Heading self-link"></a></h3><p>Today, <a href=https://github.com/gardener/machine-controller-manager/blob/v0.50.1/pkg/util/provider/machinecontroller/machine.go#L89>reconcileClusterMachine</a> which is the main routine for the <code>Machine</code> object reconciliation invokes <a href=https://github.com/gardener/machine-controller-manager/blob/rel-v0.50/pkg/util/provider/machinecontroller/machine.go#L310>triggerCreationFlow</a> at the end when the <code>machine.Spec.ProviderID</code> is empty or if the <code>machine.Status.CurrentStatus.Phase</code> is empty or in <code>CrashLoopBackOff</code></p><pre class=mermaid>%%{ init: {
    &#39;themeVariables&#39;:
        { &#39;fontSize&#39;: &#39;12px&#39;}
} }%%
flowchart LR

other[&#34;...&#34;]
--&gt;chk{&#34;machine ProviderID empty
OR
Phase empty or CrashLoopBackOff ?
&#34;}--yes--&gt;triggerCreationFlow
chk--noo--&gt;LongRetry[&#34;return machineutils.LongRetry&#34;]</pre><p>Today, the <code>triggerCreationFlow</code> is illustrated below with some minor details omitted/compressed for brevity</p><p><em>NOTES</em></p><ul><li>The <code>lastop</code> below is an abbreviation for <code>machine.Status.LastOperation</code>. This, along with the machine phase is generally updated on the <code>Machine</code> object just before returning from the method.</li><li>regarding <code>phase=CrashLoopBackOff|Failed</code>. the machine phase may either be <code>CrashLoopBackOff</code> or move to <code>Failed</code> if the difference between current time and the <code>machine.CreationTimestamp</code> has exceeded the configured <code>MachineCreationTimeout</code>.</li></ul><pre class=mermaid>%%{ init: {
    &#39;themeVariables&#39;:
        { &#39;fontSize&#39;: &#39;12px&#39;}
} }%%
flowchart TD


end1((&#34;end&#34;))
begin((&#34; &#34;))
medretry[&#34;return MediumRetry, err&#34;]
shortretry[&#34;return ShortRetry, err&#34;]
medretry--&gt;end1
shortretry--&gt;end1

begin--&gt;AddBootstrapTokenToUserData
--&gt;gms[&#34;statusResp,statusErr=driver.GetMachineStatus(...)&#34;]
--&gt;chkstatuserr{&#34;Check statusErr&#34;}
chkstatuserr--notFound--&gt;chknodelbl{&#34;Chk Node Label&#34;}
chkstatuserr--else--&gt;createFailed[&#34;lastop.Type=Create,lastop.state=Failed,phase=CrashLoopBackOff|Failed&#34;]--&gt;medretry
chkstatuserr--nil--&gt;initnodename[&#34;nodeName = statusResp.NodeName&#34;]--&gt;setnodename


chknodelbl--notset--&gt;createmachine[&#34;createResp, createErr=driver.CreateMachine(...)&#34;]--&gt;chkCreateErr{&#34;Check createErr&#34;}

chkCreateErr--notnil--&gt;createFailed

chkCreateErr--nil--&gt;getnodename[&#34;nodeName = createResp.NodeName&#34;]
--&gt;chkstalenode{&#34;nodeName != machine.Name\n//chk stale node&#34;}
chkstalenode--false--&gt;setnodename[&#34;if unset machine.Labels[&#39;node&#39;]= nodeName&#34;]
--&gt;machinepending[&#34;if empty/crashloopbackoff lastop.type=Create,lastop.State=Processing,phase=Pending&#34;]
--&gt;shortretry

chkstalenode--true--&gt;delmachine[&#34;driver.DeleteMachine(...)&#34;]
--&gt;permafail[&#34;lastop.type=Create,lastop.state=Failed,Phase=Failed&#34;]
--&gt;shortretry

subgraph noteA [&#34; &#34;]
    permafail -.- note1([&#34;VM was referring to stale node obj&#34;])
end
style noteA opacity:0


subgraph noteB [&#34; &#34;]
    setnodename-.- note2([&#34;Proposal: Introduce Driver.InitializeMachine after this&#34;])
end</pre><h3 id=enhancement-of-mcm-triggercreationflow>Enhancement of MCM triggerCreationFlow<a class=td-heading-self-link href=#enhancement-of-mcm-triggercreationflow aria-label="Heading self-link"></a></h3><h4 id=relevant-observations-on-current-flow>Relevant Observations on Current Flow<a class=td-heading-self-link href=#relevant-observations-on-current-flow aria-label="Heading self-link"></a></h4><ol><li>Observe that we always perform a call to <code>Driver.GetMachineStatus</code> and only then conditionally perform a call to <code>Driver.CreateMachine</code> if there was was no machine found.</li><li>Observe that after the call to a successful <code>Driver.CreateMachine</code>, the machine phase is set to <code>Pending</code>, the <code>LastOperation.Type</code> is currently set to <code>Create</code> and the <code>LastOperation.State</code> set to <code>Processing</code> before returning with a <code>ShortRetry</code>. The <code>LastOperation.Description</code> is (unfortunately) set to the fixed message: <code>Creating machine on cloud provider</code>.</li><li>Observe that after an erroneous call to <code>Driver.CreateMachine</code>, the machine phase is set to <code>CrashLoopBackOff</code> or <code>Failed</code> (in case of creation timeout).</li></ol><p>The following changes are proposed with a view towards minimal impact on current code and no introduction of a new Machine Phase.</p><h4 id=mcm-changes>MCM Changes<a class=td-heading-self-link href=#mcm-changes aria-label="Heading self-link"></a></h4><ol><li>We propose introducing a new machine operation <code>Driver.InitializeMachine</code> with the following signature<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#00f>type</span> Driver <span style=color:#00f>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:green>// .. existing methods are omitted for brevity.
</span></span></span><span style=display:flex><span><span style=color:green></span>
</span></span><span style=display:flex><span>    <span style=color:green>// InitializeMachine call is responsible for post-create initialization of the provider instance.
</span></span></span><span style=display:flex><span><span style=color:green></span>    InitializeMachine(context.Context, *InitializeMachineRequest) <span style=color:#2b91af>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green>// InitializeMachineRequest is the initialization request for machine instance initialization
</span></span></span><span style=display:flex><span><span style=color:green></span><span style=color:#00f>type</span> InitializeMachineRequest <span style=color:#00f>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:green>// Machine object whose VM instance should be initialized 
</span></span></span><span style=display:flex><span><span style=color:green></span>    Machine *v1alpha1.Machine
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// MachineClass backing the machine object
</span></span></span><span style=display:flex><span><span style=color:green></span>    MachineClass *v1alpha1.MachineClass
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// Secret backing the machineClass object
</span></span></span><span style=display:flex><span><span style=color:green></span>    Secret *corev1.Secret
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li>We propose introducing a new MC error code <code>codes.Initialization</code> indicating that the VM Instance was created but there was an error in initialization after VM creation. The implementor of <code>Driver.InitializeMachine</code> can return this error code, indicating that <code>InitializeMachine</code> needs to be called again. The Machine Controller will change the phase to <code>CrashLoopBackOff</code> as usual when encountering a <code>codes.Initialization</code> error.</li><li>We will introduce a new <em>machine operation</em> stage <code>InstanceInitialization</code>. In case of an <code>codes.Initialization</code> error<ol><li>the <code>machine.Status.LastOperation.Description</code> will be set to <code>InstanceInitialization</code>,</li><li><code>machine.Status.LastOperation.ErrorCode</code> will be set to <code>codes.Initialization</code></li><li>the <code>LastOperation.Type</code> will be set to <code>Create</code></li><li>the <code>LastOperation.State</code> set to <code>Failed</code> before returning with a <code>ShortRetry</code></li></ol></li><li>The semantics of <code>Driver.GetMachineStatus</code> will be changed. If the instance associated with machine exists, but the instance was not initialized as expected, the provider implementations of <code>GetMachineStatus</code> should return an error: <code>status.Error(codes.Initialization)</code>.</li><li>If <code>Driver.GetMachineStatus</code> returned an error encapsulating <code>codes.Initialization</code> then <code>Driver.InitializeMachine</code> will be invoked again in the <code>triggerCreationFlow</code>.</li><li>As according to the usual logic, the main machine controller reconciliation loop will now re-invoke the <code>triggerCreationFlow</code> again if the machine phase is <code>CrashLoopBackOff</code>.</li></ol><h4 id=illustration>Illustration<a class=td-heading-self-link href=#illustration aria-label="Heading self-link"></a></h4><p><img src=/docs/other-components/machine-controller-manager/proposals/initialize-machine-triggercreationflow.svg alt="Enhanced triggerCreationFlow"></p><h4 id=aws-provider-changes>AWS Provider Changes<a class=td-heading-self-link href=#aws-provider-changes aria-label="Heading self-link"></a></h4><h5 id=driverinitializemachine>Driver.InitializeMachine<a class=td-heading-self-link href=#driverinitializemachine aria-label="Heading self-link"></a></h5><p>The implementation for the AWS Provider will look something like:</p><ol><li>After the VM instance is available, check <code>providerSpec.SrcAndDstChecksEnabled</code>, construct <code>ModifyInstanceAttributeInput</code> and call <code>ModifyInstanceAttribute</code>. In case of an error return <code>codes.Initialization</code> instead of the current <code>codes.Internal</code></li><li>Check <code>providerSpec.NetworkInterfaces</code> and if <code>Ipv6PrefixCount</code> is not <code>nil</code>, then construct <code>AssignIpv6AddressesInput</code> and call <code>AssignIpv6Addresses</code>. In case of an error return <code>codes.Initialization</code>. Don&rsquo;t use the generic <code>codes.Internal</code></li></ol><p>The <a href=https://github.com/gardener/machine-controller-manager-provider-aws/pull/128>existing Ipv6 PR</a> will need modifications.</p><h5 id=drivergetmachinestatus>Driver.GetMachineStatus<a class=td-heading-self-link href=#drivergetmachinestatus aria-label="Heading self-link"></a></h5><ol><li>If <code>providerSpec.SrcAndDstChecksEnabled</code> is <code>false</code>, check <code>ec2.Instance.SourceDestCheck</code>. If it does not match then return <code>status.Error(codes.Initialization)</code></li><li>Check <code>providerSpec.NetworkInterfaces</code> and if <code>Ipv6PrefixCount</code> is not <code>nil</code>, check <code>ec2.Instance.NetworkInterfaces</code> and check if <code>InstanceNetworkInterface.Ipv6Addresses</code> has a non-nil slice. If this is not the case then return <code>status.Error(codes.Initialization)</code></li></ol><h3 id=instance-not-ready-taint>Instance Not Ready Taint<a class=td-heading-self-link href=#instance-not-ready-taint aria-label="Heading self-link"></a></h3><ul><li>Due to the fact that creation flow for machines will now be enhanced to correctly support post-creation startup logic, we should not scheduled workload until this startup logic is complete. Even without this feature we have a need for such a taint as described in <a href=https://github.com/gardener/machine-controller-manager/issues/740>MCM#740</a></li><li>We propose a new taint <code>node.machine.sapcloud.io/instance-not-ready</code> which will be added as a node startup taint in gardener core <a href=https://github.com/gardener/gardener/blob/v1.83.1/pkg/component/extensions/operatingsystemconfig/original/components/kubelet/config.go#L101>KubeletConfiguration.RegisterWithTaints</a></li><li>The will will then removed by MCM in health check reconciliation, once the machine becomes fully ready. (when moving to <code>Running</code> phase)</li><li>We will add this taint as part of <code>--ignore-taint</code> in CA</li><li>We will introduce a disclaimer / prerequisite in the MCM FAQ, to add this taint as part of kubelet config under <code>--register-with-taints</code>, otherwise workload could get scheduled , before machine beomes <code>Running</code></li></ul><h2 id=stage-b-proposal>Stage-B Proposal<a class=td-heading-self-link href=#stage-b-proposal aria-label="Heading self-link"></a></h2><h3 id=enhancement-of-driver-interface-for-hot-updation>Enhancement of Driver Interface for Hot Updation<a class=td-heading-self-link href=#enhancement-of-driver-interface-for-hot-updation aria-label="Heading self-link"></a></h3><p>Kindly refer to the <a href=/docs/other-components/machine-controller-manager/proposals/hotupdate-instances/>Hot-Update Instances</a> design which provides elaborate detail.</p></div></main></div></div><footer class="footer row d-print-none"><div class="container-fluid footer-wrapper"><ul class=nav><li><a href=https://demo.gardener.cloud>Demo</a></li><li><a href=https://gardener.cloud/adopter/>Adopters</a></li><li><a href=/docs/>Documentation</a></li><li><a href=https://gardener.cloud/blog/>Blogs</a></li><li><a href=https://gardener.cloud/community/>Community</a></li></ul><img src=/images/lp/gardener-logo.svg alt="Logo Gardener" class=logo><ul class=media-wr><li><a target=_blank href=https://gardener-cloud.slack.com/><img src=/images/branding/slack-logo-white.svg class=media-icon><div class=media-text>Slack</div></a></li><li><a target=_blank href=https://github.com/gardener><img src=/images/branding/github-mark-logo.png class=media-icon><div class=media-text>GitHub</div></a></li><li><a target=_blank href=https://www.youtube.com/channel/UCwUhwKFREV8Su0gwAJQX7tw><img src=/images/branding/youtube-logo-dark.svg class=media-icon><div class=media-text>YouTube</div></a></li><li><a target=_blank href=https://x.com/GardenerProject><img src=/images/branding/x-logo-white.svg class=media-icon><div class=media-text>X</div></a></li></ul><span class=copyright>Copyright 2019-2025 Gardener project authors.
<a href=https://www.sap.com/about/legal/terms-of-use.html>Terms of Use
<i class="fa fa-external-link" aria-hidden=true></i>
</a>|
<a href=https://www.sap.com/about/legal/terms-of-use.html>Privacy Statement
<i class="fa fa-external-link" aria-hidden=true></i>
</a>|
<a href=https://www.sap.com/about/legal/terms-of-use.html>Legal Disclosure
<i class="fa fa-external-link" aria-hidden=true></i></a></span></div></footer></div><script src=/js/main.min.69e2c1ae9320465ab10236d9ef752c6a4442c54b48b883b17c497b7c7d96a796.js integrity="sha256-aeLBrpMgRlqxAjbZ73UsakRCxUtIuIOxfEl7fH2Wp5Y=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script><script src=/js/navbar.js></script><script src=/js/filtering.js></script><script src=/js/page-content.js></script></body></html>