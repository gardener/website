<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://gardener.cloud/docs/gardener/extensions/><link rel=alternate type=application/rss+xml href=https://gardener.cloud/docs/gardener/extensions/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Extensions | Gardener</title>
<meta name=description content="Extensibility OverviewInitially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself. But as the project grew, it got more and more difficult to add new providers and maintain the existing code base. As a consequence and in order to become agile and flexible again, we proposed GEP-1 (Gardener Enhancement Proposal) and later gardener/gardener#9635 as an enhancement. The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with out-of-tree cloud providers or with CSI volume plugins)."><meta property="og:url" content="https://gardener.cloud/docs/gardener/extensions/"><meta property="og:site_name" content="Gardener"><meta property="og:title" content="Extensions"><meta property="og:description" content="Extensibility OverviewInitially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself. But as the project grew, it got more and more difficult to add new providers and maintain the existing code base. As a consequence and in order to become agile and flexible again, we proposed GEP-1 (Gardener Enhancement Proposal) and later gardener/gardener#9635 as an enhancement. The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with out-of-tree cloud providers or with CSI volume plugins)."><meta property="og:locale" content="en_US"><meta property="og:type" content="website"><meta property="og:image" content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta itemprop=name content="Extensions"><meta itemprop=description content="Extensibility OverviewInitially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself. But as the project grew, it got more and more difficult to add new providers and maintain the existing code base. As a consequence and in order to become agile and flexible again, we proposed GEP-1 (Gardener Enhancement Proposal) and later gardener/gardener#9635 as an enhancement. The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with out-of-tree cloud providers or with CSI volume plugins)."><meta itemprop=wordCount content="1094"><meta itemprop=image content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gardener.cloud/images/lp/gardener-logo.svg"><meta name=twitter:title content="Extensions"><meta name=twitter:description content="Extensibility OverviewInitially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself. But as the project grew, it got more and more difficult to add new providers and maintain the existing code base. As a consequence and in order to become agile and flexible again, we proposed GEP-1 (Gardener Enhancement Proposal) and later gardener/gardener#9635 as an enhancement. The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with out-of-tree cloud providers or with CSI volume plugins)."><link rel=preload href=/scss/main.min.26acfdfb147ebf2e823b350f7e183142a26f105f5e474d2e37605e9c55009e66.css as=style integrity="sha256-Jqz9+xR+vy6COzUPfhgxQqJvEF9eR00uN2BenFUAnmY=" crossorigin=anonymous><link href=/scss/main.min.26acfdfb147ebf2e823b350f7e183142a26f105f5e474d2e37605e9c55009e66.css rel=stylesheet integrity="sha256-Jqz9+xR+vy6COzUPfhgxQqJvEF9eR00uN2BenFUAnmY=" crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script></head><body class=td-section><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg width="90" height="90" viewBox="0 0 90 90" xmlns:xlink="http://www.w3.org/1999/xlink"><title>logo</title><desc>Created with Sketch.</desc><defs><path d="M41.8864954.994901575c.996545099999999-.479910833 2.6164002-.477918931 3.6088091.0L76.8159138 16.0781121C77.8124589 16.5580229 78.8208647 17.8257185 79.0659694 18.8995926l7.7355517 33.8916663C87.0476474 53.8696088 86.6852538 55.4484075 85.9984855 56.3095876L64.3239514 83.4885938C63.6343208 84.3533632 62.1740175 85.0543973 61.0725268 85.0543973H26.3092731c-1.1060816.0-2.5646564-.704623400000003-3.2514246-1.5658035L1.38331434 56.3095876C.693683723 55.4448182.335174016 53.865133.580278769 52.7912589L8.31583044 18.8995926C8.56195675 17.8212428 9.57347722 16.556031 10.5658861 16.0781121L41.8864954.994901575z" id="path-1"/><linearGradient x1="12.7542673%" y1="-18.6617048%" x2="88.2666158%" y2="84.6075483%" id="linearGradient-3"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="50%" y1="4.93673768%" x2="148.756007%" y2="175.514523%" id="linearGradient-4"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="19.1574381%" y1="-9.04800713%" x2="82.2203149%" y2="77.9084293%" id="linearGradient-5"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient><linearGradient x1="57.4403751%" y1="26.3148481%" x2="137.966711%" y2="158.080556%" id="linearGradient-6"><stop stop-color="#fff" offset="0"/><stop stop-color="#439246" offset="100%"/></linearGradient></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="logo"><g id="Rectangle-2" transform="translate(1.000000, 0.000000)"><mask id="mask-2" fill="#fff"><use xlink:href="#path-1"/></mask><use id="Mask" fill="#009f76" xlink:href="#path-1"/><polygon fill="#000" opacity=".289628623" mask="url(#mask-2)" points="-17.6484375 54.5224609 30.8242188 25.0791016 63.4726562 58.5 24.7324219 92.6689453"/></g><path d="M56.8508631 39.260019C56.4193519 40.443987 55.6088085 41.581593 54.6736295 42.1938694l-8.0738997 5.2861089c-1.3854671.907087099999998-3.6247515.9116711-5.0172201.0L33.50861 42.1938694C32.123143 41.2867823 31 39.206345 31 37.545932V26.4150304c0-.725313.2131118-1.5301454.569268099999999-2.2825772L56.8508631 39.260019z" id="Combined-Shape" fill="url(#linearGradient-3)" transform="translate(43.925432, 36.147233) scale(-1, 1) translate(-43.925432, -36.147233)"/><path d="M56.0774672 25.1412464C56.4306829 25.8903325 56.6425556 26.6907345 56.6425556 27.4119019V38.5428034c0 1.6598979-1.1161415 3.73626640000001-2.50861 4.6479374l-8.0738997 5.286109c-1.3854671.907087000000004-3.6247516.911671000000005-5.0172201.0L32.9689261 43.1907408C32.2918101 42.7474223 31.6773514 42.0238435 31.2260376 41.206007L56.0774672 25.1412464z" id="Combined-Shape" fill="url(#linearGradient-4)" transform="translate(43.821278, 37.246598) scale(-1, 1) translate(-43.821278, -37.246598)"/><path d="M65.0702134 57.1846889C64.5985426 58.2007851 63.8367404 59.1236871 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.1597438 58.7930183 24 56.7816693 24 55.1323495V37.1145303C24 36.3487436 24.249712 35.5060005 24.6599102 34.7400631L65.0702134 57.1846889z" id="Combined-Shape" fill="url(#linearGradient-5)"/><path d="M65.0189476 34.954538C65.3636909 35.6617313 65.5692194 36.42021 65.5692194 37.1145303V55.1323495C65.5692194 56.7842831 64.4072119 58.7943252 62.9788591 59.6189851L47.37497 68.6278947c-1.4306165.825966800000003-3.75236779999999.8246599-5.1807206.0L26.5903603 59.6189851C25.9237304 59.2341061 25.3159155 58.5918431 24.8568495 57.8487596L65.0189476 34.954538z" id="Combined-Shape" fill="url(#linearGradient-6)"/></g></g></svg></span><span class=navbar-brand__name>Gardener</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=https://demo.gardener.cloud target=_blank rel=noopener><span>Demo</span></a></li><li class=nav-item><a class=nav-link href=/adopter><span>Adopters</span></a></li><li class=nav-item><a class=nav-link href=/docs><span>Documentation</span></a></li><li class=nav-item><a class=nav-link href=/blog><span>Blogs</span></a></li><li class=nav-item><a class=nav-link href=/community><span>Community</span></a></li><li class=nav-item><a class=nav-link href=https://join.slack.com/t/gardener-cloud/shared_invite/zt-33c9daems-3oOorhnqOSnldZPWqGmIBw target=_blank rel=noopener><span>Join us on</span></a></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/offline-search-index.56d1071f195d039cc2bbc32c31641d91.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/gardener/extensions/>Return to the regular view of this page</a>.</p></div><h1 class=title>Extensions</h1><div class=content><h1 id=extensibility-overview>Extensibility Overview<a class=td-heading-self-link href=#extensibility-overview aria-label="Heading self-link"></a></h1><p>Initially, everything was developed in-tree in the Gardener project. All cloud providers and the configuration for all the supported operating systems were released together with the Gardener core itself.
But as the project grew, it got more and more difficult to add new providers and maintain the existing code base.
As a consequence and in order to become agile and flexible again, we proposed <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/01-extensibility.md>GEP-1</a> (Gardener Enhancement Proposal) and later <a href=https://github.com/gardener/gardener/issues/9635>gardener/gardener#9635</a> as an enhancement.
The document describes an out-of-tree extension architecture that keeps the Gardener core logic independent of provider-specific knowledge (similar to what Kubernetes has achieved with <a href=https://github.com/kubernetes/enhancements/issues/88>out-of-tree cloud providers</a> or with <a href=https://github.com/kubernetes/community/pull/1258>CSI volume plugins</a>).</p><h2 id=basic-concepts>Basic Concepts<a class=td-heading-self-link href=#basic-concepts aria-label="Heading self-link"></a></h2><p>Gardener components run in the garden and seed clusters, implementing the core logic for garden, seed, and shoot cluster reconciliation and deletion.
Extensions are Kubernetes controllers themselves (like Gardener) and run in the garden runtime and seed clusters.
As usual, we try to use Kubernetes wherever applicable.
We rely on Kubernetes extension concepts in order to enable extensibility for Gardener.</p><h3 id=building-blocks>Building Blocks<a class=td-heading-self-link href=#building-blocks aria-label="Heading self-link"></a></h3><p>Extensions consist of the following building blocks:</p><ol><li>A Helm chart as the vehicle to generally deploy extension controllers to a Kubernetes clusters</li><li>Extension controllers that reconcile objects of the API group <code>extensions.gardener.cloud</code>. These controllers take over outsourced tasks, like creating the shoot infrastructure or deploying components to the control-plane. Optionally, extensions can bring their own webhooks to mutate resources deployed by Gardener.</li><li>Optionally, a Helm chart with an admission component inside. The admission controller runs in the garden runtime cluster and validates extension specific settings of the <code>Shoot</code> (given in <code>providerConfig</code> fields). See <a href=/docs/gardener/extensions/admission/>admission</a> for more details.</li></ol><h3 id=registration>Registration<a class=td-heading-self-link href=#registration aria-label="Heading self-link"></a></h3><p>Before an extension can be used, it needs to be made known to the system. The <a href=https://github.com/gardener/gardener/blob/master/docs/concepts/gardener-operator.md>gardener-operator</a> automates much of the registration process, making <code>Extension</code> resources (group <code>operator.gardener.cloud</code>) the preferred method for registering extensions. For more information, see the <a href=/docs/gardener/extensions/registration/>Registration documentation</a>.
Practically, many extensions provide basic example manifests to start with the registration in their <code>example</code> directory (<a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/example>example1</a>, <a href=https://github.com/gardener/gardener-extension-shoot-cert-service/tree/master/example>example2</a>).</p><h3 id=kinds-and-types>Kinds and Types<a class=td-heading-self-link href=#kinds-and-types aria-label="Heading self-link"></a></h3><p>Extensions are defined by their Kinds (defined by Gardener - see <a href=https://github.com/gardener/gardener/blob/master/docs/resources%5D>resources</a>) and Types.</p><p>For example, the following is an extension resource of Kind <code>Infrastructure</code> and Type <code>local</code>, which means we need a Gardener extension <code>local</code> that reconciles <code>Infrastructure</code> resources.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Infrastructure
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: infrastructure
</span></span><span style=display:flex><span>  namespace: shoot--core--aws-01
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: local
</span></span></code></pre></div><h3 id=classes>Classes<a class=td-heading-self-link href=#classes aria-label="Heading self-link"></a></h3><p>A Gardener landscape consists of various cluster types which extension controllers may consider during reconciliation.
The <code>.spec.class</code> field identifies the different deployment cases.</p><h4 id=garden>Garden<a class=td-heading-self-link href=#garden aria-label="Heading self-link"></a></h4><p>Extension controllers serve the garden (run in garden runtime), e.g. installing certificates for API and ingress endpoints.
In the course of the <code>Garden</code> reconciliation, the <code>gardener-operator</code> creates <code>BackupBucket</code>, <code>DNSRecord</code> and <code>Extension</code> resources (group <code>extensions.gardener.cloud</code>) which triggers the responsible extension controllers to reconcile them.</p><h4 id=seed>Seed<a class=td-heading-self-link href=#seed aria-label="Heading self-link"></a></h4><p>Extension controllers serve the seed (run in seed), e.g. requesting a wildcard certificate for the seed&rsquo;s ingress domain.
In the course of the <code>Seed</code> reconciliation, the <code>gardenlet</code> creates <code>DNSRecord</code> and <code>Extension</code> resources (group <code>extensions.gardener.cloud</code>) which triggers the responsible extension controllers to reconcile them.</p><h4 id=shoot>Shoot<a class=td-heading-self-link href=#shoot aria-label="Heading self-link"></a></h4><p>Extension controllers serve the shoot (run in seed), e.g. deploying a certificate controller into the control-plane namespace.
In the course of the <code>Shoot</code> reconciliation, the <code>gardenlet</code> creates various extension resources (group <code>extensions.gardener.cloud</code>) which triggers the responsible extension controllers to reconcile them.</p><h3 id=gardenlet-reconciliation-walkthrough><code>gardenlet</code> Reconciliation Walkthrough<a class=td-heading-self-link href=#gardenlet-reconciliation-walkthrough aria-label="Heading self-link"></a></h3><p>Resources of group <code>extensions.gardener.cloud</code> are always created by Gardener itself, either in the garden runtime or in the seed cluster.
To get a better understanding of how the concept works, we will walk through the reconciliation process of a <code>Shoot</code> resource in the seed cluster.</p><ol><li><p>During the shoot reconciliation process, Gardener will write CRDs into the seed cluster that are watched and managed by the extension controllers. They will reconcile (based on the <code>.spec</code>) and report whether everything went well or errors occurred in the CRD&rsquo;s <code>.status</code> field.</p></li><li><p>Gardener keeps deploying the provider-independent control plane components (etcd, kube-apiserver, etc.). However, some of these components might still need little customization by providers, e.g., additional configuration, flags, etc. In this case, the extension controllers register webhooks in order to manipulate the manifests.</p></li></ol><p><strong>Example 1</strong>:</p><p>Gardener creates a new AWS shoot cluster and requires the preparation of infrastructure in order to proceed (networks, security groups, etc.).
It writes the following CRD into the seed cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Infrastructure
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: infrastructure
</span></span><span style=display:flex><span>  namespace: shoot--core--aws-01
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: aws
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureConfig
</span></span><span style=display:flex><span>    networks:
</span></span><span style=display:flex><span>      vpc:
</span></span><span style=display:flex><span>        cidr: 10.250.0.0/16
</span></span><span style=display:flex><span>      internal:
</span></span><span style=display:flex><span>      - 10.250.112.0/22
</span></span><span style=display:flex><span>      public:
</span></span><span style=display:flex><span>      - 10.250.96.0/22
</span></span><span style=display:flex><span>      workers:
</span></span><span style=display:flex><span>      - 10.250.0.0/19
</span></span><span style=display:flex><span>    zones:
</span></span><span style=display:flex><span>    - eu-west-1a
</span></span><span style=display:flex><span>  dns:
</span></span><span style=display:flex><span>    apiserver: api.aws-01.core.example.com
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: my-aws-credentials
</span></span><span style=display:flex><span>  sshPublicKey: |<span style=color:#a31515>
</span></span></span><span style=display:flex><span><span style=color:#a31515>    base64(key)</span>    
</span></span></code></pre></div><p>Please note that the <code>.spec.providerConfig</code> is a raw blob and not evaluated or known in any way by Gardener.
Instead, it was specified by the user (in the <code>Shoot</code> resource) and just &ldquo;forwarded&rdquo; to the extension controller.
Only the AWS controller understands this configuration and will now start provisioning/reconciling the infrastructure.
It reports in the <code>.status</code> field the result:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  observedGeneration: ...
</span></span><span style=display:flex><span>  state: ...
</span></span><span style=display:flex><span>  lastError: ..
</span></span><span style=display:flex><span>  lastOperation: ...
</span></span><span style=display:flex><span>  providerStatus:
</span></span><span style=display:flex><span>    apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureStatus
</span></span><span style=display:flex><span>    vpc:
</span></span><span style=display:flex><span>      id: vpc-1234
</span></span><span style=display:flex><span>      subnets:
</span></span><span style=display:flex><span>      - id: subnet-acbd1234
</span></span><span style=display:flex><span>        name: workers
</span></span><span style=display:flex><span>        zone: eu-west-1
</span></span><span style=display:flex><span>      securityGroups:
</span></span><span style=display:flex><span>      - id: sg-xyz12345
</span></span><span style=display:flex><span>        name: workers
</span></span><span style=display:flex><span>    iam:
</span></span><span style=display:flex><span>      nodesRoleARN: &lt;some-arn&gt;
</span></span><span style=display:flex><span>      instanceProfileName: foo
</span></span><span style=display:flex><span>    ec2:
</span></span><span style=display:flex><span>      keyName: bar
</span></span></code></pre></div><p>Gardener waits until the <code>.status.lastOperation</code> / <code>.status.lastError</code> indicates that the operation reached a final state and either continuous with the next step, or stops and reports the potential error.
The extension-specific output in <code>.status.providerStatus</code> is - similar to <code>.spec.providerConfig</code> - not evaluated, and simply forwarded to CRDs in subsequent steps.</p><p><strong>Example 2</strong>:</p><p>Gardener deploys the control plane components into the seed cluster, e.g. the <code>kube-controller-manager</code> deployment with the following flags:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: apps/v1
</span></span><span style=display:flex><span>kind: Deployment
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>      - command:
</span></span><span style=display:flex><span>        - /usr/local/bin/kube-controller-manager
</span></span><span style=display:flex><span>        - --allocate-node-cidrs=true
</span></span><span style=display:flex><span>        - --attach-detach-reconcile-sync-period=1m0s
</span></span><span style=display:flex><span>        - --controllers=*,bootstrapsigner,tokencleaner
</span></span><span style=display:flex><span>        - --cluster-cidr=100.96.0.0/11
</span></span><span style=display:flex><span>        - --cluster-name=shoot--core--aws-01
</span></span><span style=display:flex><span>        - --cluster-signing-cert-file=/srv/kubernetes/ca/ca.crt
</span></span><span style=display:flex><span>        - --cluster-signing-key-file=/srv/kubernetes/ca/ca.key
</span></span><span style=display:flex><span>        - --concurrent-deployment-syncs=10
</span></span><span style=display:flex><span>        - --concurrent-replicaset-syncs=10
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>The AWS controller requires some additional flags in order to make the cluster functional.
It needs to provide a Kubernetes cloud-config and also some cloud-specific flags.
Consequently, it registers a <code>MutatingWebhookConfiguration</code> on <code>Deployment</code>s and adds these flags to the container:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>        - --cloud-provider=external
</span></span><span style=display:flex><span>        - --external-cloud-volume-plugin=aws
</span></span><span style=display:flex><span>        - --cloud-config=/etc/kubernetes/cloudprovider/cloudprovider.conf
</span></span></code></pre></div><p>Of course, it would have needed to create a <code>ConfigMap</code> containing the cloud config and to add the proper <code>volume</code> and <code>volumeMounts</code> to the manifest as well.</p><p>(Please note for this special example: The Kubernetes community is also working on making the <code>kube-controller-manager</code> provider-independent.
However, there will most probably be still components other than the <code>kube-controller-manager</code> which need to be adapted by extensions.)</p><p>If you are interested in writing an extension, or generally in digging deeper to find out the nitty-gritty details of the extension concepts, please read <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/01-extensibility.md>GEP-1</a>.
We are truly looking forward to your feedback!</p><h2 id=known-extensions>Known Extensions<a class=td-heading-self-link href=#known-extensions aria-label="Heading self-link"></a></h2><p>We track all extensions of Gardener in the <a href=/docs/gardener/#known-extension-implementations>known Gardener Extensions List</a> repo.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-e9153baa28bd1b2484836c89d02e92c8>1 - Access to the Garden Cluster for Extensions</h1><h1 id=access-to-the-garden-cluster-for-extensions>Access to the Garden Cluster for Extensions<a class=td-heading-self-link href=#access-to-the-garden-cluster-for-extensions aria-label="Heading self-link"></a></h1><p>Gardener offers different means to provide or equip registered extensions with a kubeconfig which may be used to connect to the garden cluster.</p><h2 id=admission-controllers>Admission Controllers<a class=td-heading-self-link href=#admission-controllers aria-label="Heading self-link"></a></h2><p>For extensions with an admission controller deployment, <code>gardener-operator</code> injects a token-based kubeconfig as a volume and volume mount.
The token is valid for <code>12h</code>, automatically renewed, and associated with a dedicated <code>ServiceAccount</code> in the garden cluster.
The path to this kubeconfig is revealed under the <code>GARDEN_KUBECONFIG</code> environment variable, also added to the pod spec(s).</p><h2 id=extensions-on-seed-clusters>Extensions on <code>Seed</code> Clusters<a class=td-heading-self-link href=#extensions-on-seed-clusters aria-label="Heading self-link"></a></h2><p>Extensions that are installed on seed clusters via a <code>ControllerInstallation</code> can request <code>gardenlet</code> to inject a kubeconfig and a token for the garden cluster.</p><p>In order to do so, <code>injectGardenKubeconfig</code> must be set to <code>true</code> in the referenced <code>ControllerDeployment</code>.
If it should still be disabled for an individual workload resource (<code>Deployment</code>, <code>StatefulSet</code>, etc.), they must be labeled with <code>extensions.gardener.cloud/inject-garden-kubeconfig=false</code>.</p><p>When enabled, extensions can then simply read the kubeconfig file specified by the <code>GARDEN_KUBECONFIG</code> environment variable to create a garden cluster client.
With this, they use a short-lived token (valid for <code>12h</code>) associated with a dedicated <code>ServiceAccount</code> in the <code>seed-&lt;seed-name></code> namespace to securely access the garden cluster.
The used <code>ServiceAccounts</code> are granted permissions in the garden cluster similar to gardenlet clients.</p><h3 id=background>Background<a class=td-heading-self-link href=#background aria-label="Heading self-link"></a></h3><p>Historically, <code>gardenlet</code> has been the only component running in the seed cluster that has access to both the seed cluster and the garden cluster.
Accordingly, extensions running on the seed cluster didn&rsquo;t have access to the garden cluster.</p><p>Starting from Gardener <a href=https://github.com/gardener/gardener/releases/v1.74.0><code>v1.74.0</code></a>, there is a new mechanism for components running on seed clusters to get access to the garden cluster.
For this, <code>gardenlet</code> runs an instance of the <a href=/docs/gardener/concepts/gardenlet/#tokenrequestor-controller><code>TokenRequestor</code></a> for requesting tokens that can be used to communicate with the garden cluster.</p><h3 id=using-gardenlet-managed-garden-access>Using Gardenlet-Managed Garden Access<a class=td-heading-self-link href=#using-gardenlet-managed-garden-access aria-label="Heading self-link"></a></h3><p>By default, extensions are equipped with secure access to the garden cluster using a dedicated <code>ServiceAccount</code> without requiring any additional action.
They can simply read the file specified by the <code>GARDEN_KUBECONFIG</code> and construct a garden client with it.</p><p>When installing a <a href=/docs/gardener/extensions/registration/#deploying-extension-controllers><code>ControllerInstallation</code></a>, gardenlet creates two secrets in the installation&rsquo;s namespace: a generic garden kubeconfig (<code>generic-garden-kubeconfig-&lt;hash></code>) and a garden access secret (<code>garden-access-extension</code>).
Note that the <code>ServiceAccount</code> created based on this access secret will be created in the respective <code>seed-*</code> namespace in the garden cluster and labelled with <code>controllerregistration.core.gardener.cloud/name=&lt;name></code>.</p><p>Additionally, gardenlet injects <code>volume</code>, <code>volumeMounts</code>, and two environment variables into all (init) containers in all objects in the <code>apps</code> and <code>batch</code> API groups:</p><ul><li><code>GARDEN_KUBECONFIG</code>: points to the path where the generic garden kubeconfig is mounted.</li><li><code>SEED_NAME</code>: set to the name of the <code>Seed</code> where the extension is installed.
This is useful for restricting watches in the garden cluster to relevant objects.</li></ul><p>If an object already contains the <code>GARDEN_KUBECONFIG</code> environment variable, it is not overwritten and injection of <code>volume</code> and <code>volumeMounts</code> is skipped.</p><p>For example, a <code>Deployment</code> deployed via a <code>ControllerInstallation</code> will be mutated as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: apps/v1
</span></span><span style=display:flex><span>kind: Deployment
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: gardener-extension-provider-local
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    reference.resources.gardener.cloud/secret-795f7ca6: garden-access-extension
</span></span><span style=display:flex><span>    reference.resources.gardener.cloud/secret-d5f5a834: generic-garden-kubeconfig-81fb3a88
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      annotations:
</span></span><span style=display:flex><span>        reference.resources.gardener.cloud/secret-795f7ca6: garden-access-extension
</span></span><span style=display:flex><span>        reference.resources.gardener.cloud/secret-d5f5a834: generic-garden-kubeconfig-81fb3a88
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      containers:
</span></span><span style=display:flex><span>      - name: gardener-extension-provider-local
</span></span><span style=display:flex><span>        env:
</span></span><span style=display:flex><span>        - name: GARDEN_KUBECONFIG
</span></span><span style=display:flex><span>          value: /var/run/secrets/gardener.cloud/garden/generic-kubeconfig/kubeconfig
</span></span><span style=display:flex><span>        - name: SEED_NAME
</span></span><span style=display:flex><span>          value: local
</span></span><span style=display:flex><span>        volumeMounts:
</span></span><span style=display:flex><span>        - mountPath: /var/run/secrets/gardener.cloud/garden/generic-kubeconfig
</span></span><span style=display:flex><span>          name: garden-kubeconfig
</span></span><span style=display:flex><span>          readOnly: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>      volumes:
</span></span><span style=display:flex><span>      - name: garden-kubeconfig
</span></span><span style=display:flex><span>        projected:
</span></span><span style=display:flex><span>          defaultMode: 420
</span></span><span style=display:flex><span>          sources:
</span></span><span style=display:flex><span>          - secret:
</span></span><span style=display:flex><span>              items:
</span></span><span style=display:flex><span>              - key: kubeconfig
</span></span><span style=display:flex><span>                path: kubeconfig
</span></span><span style=display:flex><span>              name: generic-garden-kubeconfig-81fb3a88
</span></span><span style=display:flex><span>              optional: <span style=color:#00f>false</span>
</span></span><span style=display:flex><span>          - secret:
</span></span><span style=display:flex><span>              items:
</span></span><span style=display:flex><span>              - key: token
</span></span><span style=display:flex><span>                path: token
</span></span><span style=display:flex><span>              name: garden-access-extension
</span></span><span style=display:flex><span>              optional: <span style=color:#00f>false</span>
</span></span></code></pre></div><p>The generic garden kubeconfig will look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    certificate-authority-data: LS0t...
</span></span><span style=display:flex><span>    server: https://garden.local.gardener.cloud:6443
</span></span><span style=display:flex><span>  name: garden
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: garden
</span></span><span style=display:flex><span>    user: extension
</span></span><span style=display:flex><span>  name: garden
</span></span><span style=display:flex><span>current-context: garden
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: extension
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    tokenFile: /var/run/secrets/gardener.cloud/garden/generic-kubeconfig/token
</span></span></code></pre></div><h3 id=manually-requesting-a-token-for-the-garden-cluster>Manually Requesting a Token for the Garden Cluster<a class=td-heading-self-link href=#manually-requesting-a-token-for-the-garden-cluster aria-label="Heading self-link"></a></h3><p>Seed components that need to communicate with the garden cluster can request a token in the garden cluster by creating a garden access secret.
This secret has to be labelled with <code>resources.gardener.cloud/purpose=token-requestor</code> and <code>resources.gardener.cloud/class=garden</code>, e.g.:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: garden-access-example
</span></span><span style=display:flex><span>  namespace: example
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    resources.gardener.cloud/purpose: token-requestor
</span></span><span style=display:flex><span>    resources.gardener.cloud/class: garden
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    serviceaccount.resources.gardener.cloud/name: example
</span></span><span style=display:flex><span>type: Opaque
</span></span></code></pre></div><p>This will instruct gardenlet to create a new <code>ServiceAccount</code> named <code>example</code> in its own <code>seed-&lt;seed-name></code> namespace in the garden cluster, request a token for it, and populate the token in the secret&rsquo;s data under the <code>token</code> key.</p><h3 id=permissions-in-the-garden-cluster>Permissions in the Garden Cluster<a class=td-heading-self-link href=#permissions-in-the-garden-cluster aria-label="Heading self-link"></a></h3><p>Both the <a href=/docs/gardener/deployment/gardenlet_api_access/><code>SeedAuthorizer</code> and the <code>SeedRestriction</code> plugin</a> handle extensions clients and generally grant the same permissions in the garden cluster to them as to gardenlet clients.
With this, extensions are restricted to work with objects in the garden cluster that are related to seed they are running one just like gardenlet.
Note that if the plugins are not enabled, extension clients are only granted read access to global resources like <code>CloudProfiles</code> (this is granted to all authenticated users).
There are a few exceptions to the granted permissions as documented <a href=/docs/gardener/deployment/gardenlet_api_access/#rule-exceptions-for-extension-clients>here</a>.</p><h3 id=additional-permissions>Additional Permissions<a class=td-heading-self-link href=#additional-permissions aria-label="Heading self-link"></a></h3><p>If an extension needs access to additional resources in the garden cluster (e.g., extension-specific custom resources), permissions need to be granted via the usual RBAC means.
Let&rsquo;s consider the following example: An extension requires the privileges to create <a href=https://kubernetes.io/docs/reference/kubernetes-api/authorization-resources/subject-access-review-v1/><code>authorization.k8s.io/v1.SubjectAccessReview</code></a>s (which is not covered by the &ldquo;default&rdquo; permissions mentioned above).
This requires a human Gardener operator to create a <code>ClusterRole</code> in the garden cluster with the needed rules:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: rbac.authorization.k8s.io/v1
</span></span><span style=display:flex><span>kind: ClusterRole
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: extension-create-subjectaccessreviews
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    authorization.gardener.cloud/extensions-serviceaccount-selector: <span style=color:#a31515>&#39;{&#34;matchLabels&#34;:{&#34;controllerregistration.core.gardener.cloud/name&#34;:&#34;&lt;extension-name&gt;&#34;}}&#39;</span>
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    authorization.gardener.cloud/custom-extensions-permissions: <span style=color:#a31515>&#34;true&#34;</span>
</span></span><span style=display:flex><span>rules:
</span></span><span style=display:flex><span>- apiGroups:
</span></span><span style=display:flex><span>  - authorization.k8s.io
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>  - subjectaccessreviews
</span></span><span style=display:flex><span>  verbs:
</span></span><span style=display:flex><span>  - create
</span></span></code></pre></div><p>Note the label <code>authorization.gardener.cloud/extensions-serviceaccount-selector</code> which contains a label selector for <code>ServiceAccount</code>s.</p><p>There is a controller part of <code>gardener-controller-manager</code> which takes care of maintaining the respective <code>ClusterRoleBinding</code> resources.
It binds all <code>ServiceAccount</code>s in the seed namespaces in the garden cluster (i.e., all extension clients) whose labels match.
You can read more about this controller <a href=/docs/gardener/concepts/controller-manager/#-extension-clusterrole--reconciler>here</a>.</p><h4 id=custom-permissions>Custom Permissions<a class=td-heading-self-link href=#custom-permissions aria-label="Heading self-link"></a></h4><p>If an extension wants to create a dedicated <code>ServiceAccount</code> for accessing the garden cluster <strong>without</strong> automatically inheriting all permissions of the gardenlet, it first needs to create a garden access secret in its extension namespace in the seed cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: my-custom-component
</span></span><span style=display:flex><span>  namespace: &lt;extension-namespace&gt;
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    resources.gardener.cloud/purpose: token-requestor
</span></span><span style=display:flex><span>    resources.gardener.cloud/class: garden
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    serviceaccount.resources.gardener.cloud/name: my-custom-component-extension-foo
</span></span><span style=display:flex><span>    serviceaccount.resources.gardener.cloud/labels: <span style=color:#a31515>&#39;{&#34;foo&#34;:&#34;bar}&#39;</span>
</span></span><span style=display:flex><span>type: Opaque
</span></span></code></pre></div><p>❗️<strong>️Do not prefix the service account name with <code>extension-</code> to prevent inheriting the gardenlet permissions!</strong> It is still recommended to add the extension name (e.g., as a suffix) for easier identification where this <code>ServiceAccount</code> comes from.</p><p>Next, you can follow the same approach <a href=/docs/gardener/extensions/garden-api-access/#additional-permissions>described above</a>.
However, the <code>authorization.gardener.cloud/extensions-serviceaccount-selector</code> annotation should <strong>not</strong> contain <code>controllerregistration.core.gardener.cloud/name=&lt;extension-name></code> but rather custom labels, e.g. <code>foo=bar</code>.</p><p>This way, the created <code>ServiceAccount</code> will only get the permissions of <a href=/docs/gardener/extensions/garden-api-access/#additional-permissions>above <code>ClusterRole</code></a> and nothing else.</p><h3 id=renewing-all-garden-access-secrets>Renewing All Garden Access Secrets<a class=td-heading-self-link href=#renewing-all-garden-access-secrets aria-label="Heading self-link"></a></h3><p>Operators can trigger an automatic renewal of all garden access secrets in a given <code>Seed</code> and their requested <code>ServiceAccount</code> tokens, e.g., when rotating the garden cluster&rsquo;s <code>ServiceAccount</code> signing key.
For this, the <code>Seed</code> has to be annotated with <code>gardener.cloud/operation=renew-garden-access-secrets</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-dfa4a7f5eddd3e92a6a94007ba1f4648>2 - CA Rotation</h1><h1 id=ca-rotation-in-extensions>CA Rotation in Extensions<a class=td-heading-self-link href=#ca-rotation-in-extensions aria-label="Heading self-link"></a></h1><p><a href=https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md>GEP-18</a> proposes adding support for automated rotation of Shoot cluster certificate authorities (CAs).
This document outlines all the requirements that Gardener extensions need to fulfill in order to support the CA rotation feature.</p><h2 id=requirements-for-shoot-cluster-ca-rotation>Requirements for Shoot Cluster CA Rotation<a class=td-heading-self-link href=#requirements-for-shoot-cluster-ca-rotation aria-label="Heading self-link"></a></h2><ul><li>Extensions must not rely on static CA <code>Secret</code> names managed by the gardenlet, because their names are changing during CA rotation.</li><li>Extensions cannot issue or use client certificates for authenticating against shoot API servers. Instead, they should use short-lived auto-rotated <code>ServiceAccount</code> tokens via gardener-resource-manager&rsquo;s <code>TokenRequestor</code>. Also see <a href=/docs/gardener/extensions/conventions/>Conventions</a> and <a href=/docs/gardener/concepts/resource-manager/#tokenrequestor><code>TokenRequestor</code></a> documents.</li><li>Extensions need to generate dedicated CAs for signing server certificates (e.g. <code>cloud-controller-manager</code>). There should be one CA per controller and purpose in order to bind the lifecycle to the reconciliation cycle of the respective object for which it is created.</li><li>CAs managed by extensions should be rotated in lock-step with the shoot cluster CA.
When the user triggers a rotation, the gardenlet writes phase and initiation time to <code>Shoot.status.credentials.rotation.certificateAuthorities.{phase,lastInitiationTime}</code>. See <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md#rotation-sequence-for-cluster-and-client-ca>GEP-18</a> for a detailed description on what needs to happen in each phase.
Extensions can retrieve this information from <a href=/docs/gardener/extensions/cluster/><code>Cluster.shoot.status</code></a>.</li></ul><h2 id=utilities-for-secrets-management>Utilities for Secrets Management<a class=td-heading-self-link href=#utilities-for-secrets-management aria-label="Heading self-link"></a></h2><p>In order to fulfill the requirements listed above, extension controllers can reuse the <a href=/docs/gardener/secrets_management/><code>SecretsManager</code></a> that the gardenlet uses to manage all shoot cluster CAs, certificates, and other secrets as well.
It implements the core logic for managing secrets that need to be rotated, auto-renewed, etc.</p><p>Additionally, there are utilities for reusing <code>SecretsManager</code> in extension controllers.
They already implement the above requirements based on the <code>Cluster</code> resource and allow focusing on the extension controllers&rsquo; business logic.</p><p>For example, a simple <code>SecretsManager</code> usage in an extension controller could look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#00f>const</span> (
</span></span><span style=display:flex><span>  <span style=color:green>// identity for SecretsManager instance in ControlPlane controller
</span></span></span><span style=display:flex><span><span style=color:green></span>  identity = <span style=color:#a31515>&#34;provider-foo-controlplane&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:green>// secret config name of the dedicated CA
</span></span></span><span style=display:flex><span><span style=color:green></span>  caControlPlaneName = <span style=color:#a31515>&#34;ca-provider-foo-controlplane&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f>func</span> Reconcile() {
</span></span><span style=display:flex><span>  <span style=color:#00f>var</span> (
</span></span><span style=display:flex><span>    cluster *extensionscontroller.Cluster
</span></span><span style=display:flex><span>    client  client.Client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green>// define wanted secrets with options
</span></span></span><span style=display:flex><span><span style=color:green></span>    secretConfigs = []extensionssecretsmanager.SecretConfigWithOptions{
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:green>// dedicated CA for ControlPlane controller
</span></span></span><span style=display:flex><span><span style=color:green></span>        Config: &amp;secretutils.CertificateSecretConfig{
</span></span><span style=display:flex><span>          Name:       caControlPlaneName,
</span></span><span style=display:flex><span>          CommonName: <span style=color:#a31515>&#34;ca-provider-foo-controlplane&#34;</span>,
</span></span><span style=display:flex><span>          CertType:   secretutils.CACert,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:green>// persist CA so that it gets restored on control plane migration
</span></span></span><span style=display:flex><span><span style=color:green></span>        Options: []secretsmanager.GenerateOption{secretsmanager.Persist()},
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:green>// server cert for control plane component
</span></span></span><span style=display:flex><span><span style=color:green></span>        Config: &amp;secretutils.CertificateSecretConfig{
</span></span><span style=display:flex><span>          Name:       <span style=color:#a31515>&#34;cloud-controller-manager&#34;</span>,
</span></span><span style=display:flex><span>          CommonName: <span style=color:#a31515>&#34;cloud-controller-manager&#34;</span>,
</span></span><span style=display:flex><span>          DNSNames:   kutil.DNSNamesForService(<span style=color:#a31515>&#34;cloud-controller-manager&#34;</span>, namespace),
</span></span><span style=display:flex><span>          CertType:   secretutils.ServerCert,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:green>// sign with our dedicated CA
</span></span></span><span style=display:flex><span><span style=color:green></span>        Options: []secretsmanager.GenerateOption{secretsmanager.SignedByCA(caControlPlaneName)},
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green>// initialize SecretsManager based on Cluster object
</span></span></span><span style=display:flex><span><span style=color:green></span>  sm, err := extensionssecretsmanager.SecretsManagerForCluster(ctx, logger.WithName(<span style=color:#a31515>&#34;secretsmanager&#34;</span>), clock.RealClock{}, client, cluster, identity, secretConfigs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green>// generate all wanted secrets (first CAs, then the rest)
</span></span></span><span style=display:flex><span><span style=color:green></span>  secrets, err := extensionssecretsmanager.GenerateAllSecrets(ctx, sm, secretConfigs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green>// cleanup any secrets that are not needed any more (e.g. after rotation)
</span></span></span><span style=display:flex><span><span style=color:green></span>  err = sm.Cleanup(ctx)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Please pay attention to the following points:</p><ul><li>There should be one <code>SecretsManager</code> identity per controller (and purpose if applicable) in order to prevent conflicts between different instances.
E.g., there should be different identities for <code>Infrastructrue</code>, <code>Worker</code> controller, etc., and the <code>ControlPlane</code> controller should use dedicated <code>SecretsManager</code> identities per purpose (e.g. <code>provider-foo-controlplane</code> and <code>provider-foo-controlplane-exposure</code>).</li><li>All other points in <a href=/docs/gardener/secrets_management/#reusing-the-secretsmanager-in-other-components>Reusing the SecretsManager in Other Components</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1dcf839b2e87160673811784e7578d4a>3 - Cluster</h1><h1 id=cluster-resource><code>Cluster</code> Resource<a class=td-heading-self-link href=#cluster-resource aria-label="Heading self-link"></a></h1><p>As part of the extensibility epic, a lot of responsibility that was previously taken over by Gardener directly has now been shifted to extension controllers running in the seed clusters.
These extensions often serve a well-defined purpose (e.g., the management of <a href=/docs/gardener/extensions/resources/dnsrecord/>DNS records</a>, <a href=/docs/gardener/extensions/resources/infrastructure/>infrastructure</a>).
We have introduced a couple of extension CRDs in the seeds whose specification is written by Gardener, and which are acted up by the extensions.</p><p>However, the extensions sometimes require more information that is not directly part of the specification.
One example of that is the GCP infrastructure controller which needs to know the shoot&rsquo;s pod and service network.
Another example is the Azure infrastructure controller which requires some information out of the <code>CloudProfile</code> resource.
The problem is that Gardener does not know which extension requires which information so that it can write it into their specific CRDs.</p><p>In order to deal with this problem we have introduced the <code>Cluster</code> extension resource.
This CRD is written into the seeds, however, it does not contain a <code>status</code>, so it is not expected that something acts upon it.
Instead, you can treat it like a <code>ConfigMap</code> which contains data that might be interesting for you.
In the context of Gardener, seeds and shoots, and extensibility the <code>Cluster</code> resource contains the <code>CloudProfile</code>, <code>Seed</code>, and <code>Shoot</code> manifest.
Extension controllers can take whatever information they want out of it that might help completing their individual tasks.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Cluster
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  cloudProfile:
</span></span><span style=display:flex><span>    apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>    kind: CloudProfile
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  seed:
</span></span><span style=display:flex><span>    apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>    kind: Seed
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>  shoot:
</span></span><span style=display:flex><span>    apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>    kind: Shoot
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><p>The resource is written by Gardener before it starts the reconciliation flow of the shoot.</p><p>&#9888;&#xfe0f; All Gardener components use the <code>core.gardener.cloud/v1beta1</code> version, i.e., the <code>Cluster</code> resource will contain the objects in this version.</p><h2 id=important-information-that-should-be-taken-into-account>Important Information that Should Be Taken into Account<a class=td-heading-self-link href=#important-information-that-should-be-taken-into-account aria-label="Heading self-link"></a></h2><p>There are some fields in the <code>Shoot</code> specification that might be interesting to take into account.</p><ul><li><code>.spec.hibernation.enabled={true,false}</code>: Extension controllers might want to behave differently if the shoot is hibernated or not (probably they might want to scale down their control plane components, for example).</li><li><code>.status.lastOperation.state=Failed</code>: If Gardener sets the shoot&rsquo;s last operation state to <code>Failed</code>, it means that Gardener won&rsquo;t automatically retry to finish the reconciliation/deletion flow because an error occurred that could not be resolved within the last <code>24h</code> (default). In this case, end-users are expected to manually re-trigger the reconciliation flow in case they want Gardener to try again. Extension controllers are expected to follow the same principle. This means they have to read the shoot state out of the <code>Cluster</code> resource.</li></ul><h2 id=extension-resources-not-associated-with-a-shoot>Extension Resources Not Associated with a Shoot<a class=td-heading-self-link href=#extension-resources-not-associated-with-a-shoot aria-label="Heading self-link"></a></h2><p>In some cases, Gardener may create extension resources that are not associated with a shoot, but are needed to support some functionality internal to Gardener. Such resources will be created in the <code>garden</code> namespace of a seed cluster.</p><p>For example, if the <a href=/docs/gardener/deployment/deploy_gardenlet_manually/>managed ingress controller</a> is active on the seed, Gardener will create a <a href=/docs/gardener/extensions/resources/dnsrecord/>DNSRecord</a> resource(s) in the <code>garden</code> namespace of the seed cluster for the ingress DNS record.</p><p>Extension controllers that may be expected to reconcile extension resources in the <code>garden</code> namespace should make sure that they can tolerate the absence of a cluster resource. This means that they should not attempt to read the cluster resource in such cases, or if they do they should ignore the &ldquo;not found&rdquo; error.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_cluster.go><code>Cluster</code> API (Golang Specification)</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b8aa124fe8bedbc5e039bbe785060c38>4 - ControlPlane Webhooks</h1><h1 id=controlplane-customization-webhooks>ControlPlane Customization Webhooks<a class=td-heading-self-link href=#controlplane-customization-webhooks aria-label="Heading self-link"></a></h1><p>Gardener creates the Shoot controlplane in several steps of the Shoot flow. At different point of this flow, it:</p><ul><li>Deploys standard controlplane components such as kube-apiserver, kube-controller-manager, and kube-scheduler by creating the corresponding deployments, services, and other resources in the Shoot namespace.</li><li>Initiates the deployment of custom controlplane components by <a href=/docs/gardener/extensions/resources/controlplane/>ControlPlane controllers</a> by creating a <code>ControlPlane</code> resource in the Shoot namespace.</li></ul><p>In order to apply any provider-specific changes to the configuration provided by Gardener for the standard controlplane components, cloud extension providers can install mutating admission webhooks for the resources created by Gardener in the Shoot namespace.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-cloud-provider>What needs to be implemented to support a new cloud provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-cloud-provider aria-label="Heading self-link"></a></h2><p>In order to support a new cloud provider, you should install &ldquo;controlplane&rdquo; mutating webhooks for any of the following resources:</p><ul><li>Deployment with name <code>kube-apiserver</code>, <code>kube-controller-manager</code>, or <code>kube-scheduler</code></li><li>Service with name <code>kube-apiserver</code></li><li><code>OperatingSystemConfig</code> with any name, and purpose <code>reconcile</code></li></ul><p>See <a href=/docs/gardener/extensions/controlplane-webhooks/#contract-specification>Contract Specification</a> for more details on the contract that Gardener and webhooks should adhere to regarding the content of the above resources.</p><p>You can install 2 different kinds of controlplane webhooks:</p><ul><li><code>Shoot</code>, or <code>controlplane</code> webhooks apply changes needed by the Shoot cloud provider, for example the <code>--cloud-provider</code> command line flag of <code>kube-apiserver</code> and <code>kube-controller-manager</code>. Such webhooks should only operate on Shoot namespaces labeled with <code>shoot.gardener.cloud/provider=&lt;provider></code>.</li><li><code>Seed</code>, or <code>seedprovider</code> webhooks apply changes needed by the Seed cloud provider, for example adapting the storage class and capacity on <code>Etcd</code> objects. Such webhooks should only operate on Shoot namespaces labeled with <code>seed.gardener.cloud/provider=&lt;provider></code>.</li></ul><p>The labels <code>shoot.gardener.cloud/provider</code> and <code>seed.gardener.cloud/provider</code> are added by Gardener when it creates the Shoot namespace.</p><p>The resources mutated by the &ldquo;controlplane&rdquo; mutating webhooks are labeled with <code>provider.extensions.gardener.cloud/mutated-by-controlplane-webhook: true</code> by gardenlet. The provider extensions can add an object selector to their &ldquo;controlplane&rdquo; mutating webhooks to not intercept requests for unrelated objects.</p><h2 id=contract-specification>Contract Specification<a class=td-heading-self-link href=#contract-specification aria-label="Heading self-link"></a></h2><p>This section specifies the contract that Gardener and webhooks should adhere to in order to ensure smooth interoperability. Note that this contract can&rsquo;t be specified formally and is therefore easy to violate, especially by Gardener. The Gardener team will nevertheless do its best to adhere to this contract in the future and to ensure via additional measures (tests, validations) that it&rsquo;s not unintentionally broken. If it needs to be changed intentionally, this can only happen after proper communication has taken place to ensure that the affected provider webhooks could be adapted to work with the new version of the contract.</p><blockquote><p><strong>Note:</strong> The contract described below may not necessarily be what Gardener does currently (as of May 2019). Rather, it reflects the target state after changes for <a href=/docs/gardener/extensions/>Gardener extensibility</a> have been introduced.</p></blockquote><h3 id=kube-apiserver>kube-apiserver<a class=td-heading-self-link href=#kube-apiserver aria-label="Heading self-link"></a></h3><p>To deploy kube-apiserver, Gardener <strong>shall</strong> create a deployment and a service both named <code>kube-apiserver</code> in the Shoot namespace. They can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>The pod template of the <code>kube-apiserver</code> deployment <strong>shall</strong> contain a container named <code>kube-apiserver</code>.</p><p>The <code>command</code> field of the <code>kube-apiserver</code> container <strong>shall</strong> contain the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver command line</a>. It <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li>admission plugins (<code>--enable-admission-plugins</code>, <code>--disable-admission-plugins</code>)</li><li>secure communications (<code>--etcd-cafile</code>, <code>--etcd-certfile</code>, <code>--etcd-keyfile</code>, &mldr;)</li><li>audit log (<code>--audit-log-*</code>)</li><li>ports (<code>--secure-port</code>)</li></ul><p>The kube-apiserver command line <strong>shall not</strong> contain any provider-specific flags, such as:</p><ul><li><code>--cloud-provider</code></li><li><code>--cloud-config</code></li></ul><p>These flags can be added by webhooks if needed.</p><p>The <code>kube-apiserver</code> command line <strong>may</strong> contain a number of additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-apiserver behavior for the specific provider. Among the flags to be considered are:</p><ul><li><code>--endpoint-reconciler-type</code></li><li><code>--advertise-address</code></li><li><code>--feature-gates</code></li></ul><p>Gardener uses <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/08-shoot-apiserver-via-sni.md>SNI</a> to expose the apiserver. In this case, Gardener expects that the <code>--endpoint-reconciler-type</code> and <code>--advertise-address</code> flags of the <code>kube-apiserver</code>&rsquo;s <code>Deployment</code> are not modified.</p><p>The <code>--enable-admission-plugins</code> flag <strong>may</strong> contain admission plugins that are not compatible with CSI plugins such as <code>PersistentVolumeLabel</code>. Webhooks should therefore ensure that such admission plugins are either explicitly enabled (if CSI plugins are not used) or disabled (otherwise).</p><p>The <code>env</code> field of the <code>kube-apiserver</code> container <strong>shall not</strong> contain any provider-specific environment variables (so it will be empty). If any provider-specific environment variables are needed, they should be added by webhooks.</p><p>The <code>volumes</code> field of the pod template of the <code>kube-apiserver</code> deployment, and respectively the <code>volumeMounts</code> field of the <code>kube-apiserver</code> container <strong>shall not</strong> contain any provider-specific <code>Secret</code> or <code>ConfigMap</code> resources. If such resources should be mounted as volumes, this should be done by webhooks.</p><p>The <code>kube-apiserver</code> <code>Service</code> <strong>will</strong> be of type <code>ClusterIP</code>. In this case, Gardener expects that for this <code>Service</code> no mutations happen.</p><h3 id=kube-controller-manager>kube-controller-manager<a class=td-heading-self-link href=#kube-controller-manager aria-label="Heading self-link"></a></h3><p>To deploy kube-controller-manager, Gardener <strong>shall</strong> create a deployment named <code>kube-controller-manager</code> in the Shoot namespace. It can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>The pod template of the <code>kube-controller-manager</code> deployment <strong>shall</strong> contain a container named <code>kube-controller-manager</code>.</p><p>The <code>command</code> field of the <code>kube-controller-manager</code> container <strong>shall</strong> contain the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager command line</a>. It <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li><code>--kubeconfig</code>, <code>--authentication-kubeconfig</code>, <code>--authorization-kubeconfig</code></li><li><code>--leader-elect</code></li><li>secure communications (<code>--tls-cert-file</code>, <code>--tls-private-key-file</code>, &mldr;)</li><li>cluster CIDR and identity (<code>--cluster-cidr</code>, <code>--cluster-name</code>)</li><li>sync settings (<code>--concurrent-deployment-syncs</code>, <code>--concurrent-replicaset-syncs</code>)</li><li>horizontal pod autoscaler (<code>--horizontal-pod-autoscaler-*</code>)</li><li>ports (<code>--port</code>, <code>--secure-port</code>)</li></ul><p>The kube-controller-manager command line <strong>shall not</strong> contain any provider-specific flags, such as:</p><ul><li><code>--cloud-provider</code></li><li><code>--cloud-config</code></li><li><code>--configure-cloud-routes</code></li><li><code>--external-cloud-volume-plugin</code></li></ul><p>These flags can be added by webhooks if needed.</p><p>The kube-controller-manager command line <strong>may</strong> contain a number of additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-controller-manager behavior for the specific provider. Among the flags to be considered are:</p><ul><li><code>--feature-gates</code></li></ul><p>The <code>env</code> field of the <code>kube-controller-manager</code> container <strong>shall not</strong> contain any provider-specific environment variables (so it will be empty). If any provider-specific environment variables are needed, they should be added by webhooks.</p><p>The <code>volumes</code> field of the pod template of the <code>kube-controller-manager</code> deployment, and respectively the <code>volumeMounts</code> field of the <code>kube-controller-manager</code> container <strong>shall not</strong> contain any provider-specific <code>Secret</code> or <code>ConfigMap</code> resources. If such resources should be mounted as volumes, this should be done by webhooks.</p><h3 id=kube-scheduler>kube-scheduler<a class=td-heading-self-link href=#kube-scheduler aria-label="Heading self-link"></a></h3><p>To deploy kube-scheduler, Gardener <strong>shall</strong> create a deployment named <code>kube-scheduler</code> in the Shoot namespace. It can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>The pod template of the <code>kube-scheduler</code> deployment <strong>shall</strong> contain a container named <code>kube-scheduler</code>.</p><p>The <code>command</code> field of the <code>kube-scheduler</code> container <strong>shall</strong> contain the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler command line</a>. It <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li><code>--config</code></li><li><code>--authentication-kubeconfig</code>, <code>--authorization-kubeconfig</code></li><li>secure communications (<code>--tls-cert-file</code>, <code>--tls-private-key-file</code>, &mldr;)</li><li>ports (<code>--port</code>, <code>--secure-port</code>)</li></ul><p>The kube-scheduler command line <strong>may</strong> contain additional provider-independent flags. In general, webhooks should ignore these unless they are known to interfere with the desired kube-controller-manager behavior for the specific provider. Among the flags to be considered are:</p><ul><li><code>--feature-gates</code></li></ul><p>The kube-scheduler command line can&rsquo;t contain provider-specific flags, and it makes no sense to specify provider-specific environment variables or mount provider-specific <code>Secret</code> or <code>ConfigMap</code> resources as volumes.</p><h3 id=etcd-main-and-etcd-events>etcd-main and etcd-events<a class=td-heading-self-link href=#etcd-main-and-etcd-events aria-label="Heading self-link"></a></h3><p>To deploy etcd, Gardener <strong>shall</strong> create 2 <a href=https://github.com/gardener/etcd-druid/blob/1d427e9167adac1476d1847c0e265c2c09d6bc62/config/samples/druid_v1alpha1_etcd.yaml>Etcd</a> named <code>etcd-main</code> and <code>etcd-events</code> in the Shoot namespace. They can be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener.</p><p>Gardener <strong>shall</strong> configure the <code>Etcd</code> resource completely to set up an etcd cluster which uses the default storage class of the seed cluster.</p><h3 id=cloud-controller-manager>cloud-controller-manager<a class=td-heading-self-link href=#cloud-controller-manager aria-label="Heading self-link"></a></h3><p>Gardener <strong>shall not</strong> deploy a cloud-controller-manager. If it is needed, it should be added by a <a href=/docs/gardener/extensions/resources/controlplane/><code>ControlPlane</code> controller</a></p><h3 id=csi-controllers>CSI Controllers<a class=td-heading-self-link href=#csi-controllers aria-label="Heading self-link"></a></h3><p>Gardener <strong>shall not</strong> deploy a CSI controller. If it is needed, it should be added by a <a href=/docs/gardener/extensions/resources/controlplane/><code>ControlPlane</code> controller</a></p><h3 id=kubelet>kubelet<a class=td-heading-self-link href=#kubelet aria-label="Heading self-link"></a></h3><p>To specify the kubelet configuration, Gardener <strong>shall</strong> create a <a href=/docs/gardener/extensions/resources/operatingsystemconfig/><code>OperatingSystemConfig</code> resource</a> with any name and purpose <code>reconcile</code> in the Shoot namespace. It can therefore also be mutated by webhooks to apply any provider-specific changes to the standard configuration provided by Gardener. Gardener <strong>may</strong> write multiple such resources with different <code>type</code> to the same Shoot namespaces if multiple OSs are used.</p><p>The OSC resource <strong>shall</strong> contain a unit named <code>kubelet.service</code>, containing the corresponding systemd unit configuration file. The <code>[Service]</code> section of this file <strong>shall</strong> contain a single <code>ExecStart</code> option having the <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/>kubelet command line</a> as its value.</p><p>The OSC resource <strong>shall</strong> contain a file with path <code>/var/lib/kubelet/config/kubelet</code>, which contains a <code>KubeletConfiguration</code> resource in YAML format. Most of the flags that can be specified in the kubelet command line can alternatively be specified as options in this configuration as well.</p><p>The kubelet command line <strong>shall</strong> contain a number of provider-independent flags that should be ignored by webhooks, such as:</p><ul><li><code>--config</code></li><li><code>--bootstrap-kubeconfig</code>, <code>--kubeconfig</code></li><li><code>--network-plugin</code> (and, if it equals <code>cni</code>, also <code>--cni-bin-dir</code> and <code>--cni-conf-dir</code>)</li><li><code>--node-labels</code></li></ul><p>The kubelet command line <strong>shall not</strong> contain any provider-specific flags, such as:</p><ul><li><code>--cloud-provider</code></li><li><code>--cloud-config</code></li><li><code>--provider-id</code></li></ul><p>These flags can be added by webhooks if needed.</p><p>The kubelet command line / configuration <strong>may</strong> contain a number of additional provider-independent flags / options. In general, webhooks should ignore these unless they are known to interfere with the desired kubelet behavior for the specific provider. Among the flags / options to be considered are:</p><ul><li><code>--enable-controller-attach-detach</code> (<code>enableControllerAttachDetach</code>) - should be set to <code>true</code> if CSI plugins are used, but in general can also be ignored since its default value is also <code>true</code>, and this should work both with and without CSI plugins.</li><li><code>--feature-gates</code> (<code>featureGates</code>) - should contain a list of specific feature gates if CSI plugins are used. If CSI plugins are not used, the corresponding feature gates can be ignored since enabling them should not harm in any way.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-719af9bdc56f6cf5b7e123daddb6f6a4>5 - Conventions</h1><h1 id=general-conventions>General Conventions<a class=td-heading-self-link href=#general-conventions aria-label="Heading self-link"></a></h1><p>All the extensions that are registered to Gardener are deployed to the garden runtime and seed clusters on which they are required (also see <a href=/docs/gardener/extensions/registration/>extension registration documentation</a>).</p><p>Some of these extensions might need to create global resources in the seed (e.g., <code>ClusterRole</code>s), i.e., it&rsquo;s important to have a naming scheme to avoid conflicts as it cannot be checked or validated upfront that two extensions don&rsquo;t use the same names.</p><p>Consequently, this page should help answering some general questions that might come up when it comes to developing an extension.</p><h2 id=extension-classes>Extension Classes<a class=td-heading-self-link href=#extension-classes aria-label="Heading self-link"></a></h2><p>Each extension resource has a <code>.spec.class</code> field that is used to distinguish between different instances of the same extension type.
For extensions configured in <code>Shoot</code>s the class is named <code>shoot</code> (or unspecified for backwards compatibility), for <code>Seed</code>s the class is named <code>seed</code>.</p><p>Extension controllers ought to use the <code>class</code> field for event filtering (see <a href=https://github.com/gardener/gardener/blob/7361a19f4c3830a9f5134c073d3bfd72f4dcfa49/extensions/pkg/predicate/predicate.go#L60>HasClass Predicate</a>) and during reconciliation.</p><h2 id=priorityclasses><code>PriorityClass</code>es<a class=td-heading-self-link href=#priorityclasses aria-label="Heading self-link"></a></h2><p>Extensions are not supposed to create and use self-defined <code>PriorityClasses</code>.
Instead, they can and should rely on well-known <a href=/docs/gardener/priority-classes/><code>PriorityClasses</code></a> managed by gardenlet.</p><h2 id=high-availability-of-deployed-components>High Availability of Deployed Components<a class=td-heading-self-link href=#high-availability-of-deployed-components aria-label="Heading self-link"></a></h2><p>Extensions might deploy components via <code>Deployment</code>s, <code>StatefulSet</code>s, etc., as part of the shoot control plane, or the seed or shoot system components.
In case a seed or shoot cluster is highly available, there are various failure tolerance types. For more information, see <a href=/docs/gardener/high-availability/shoot_high_availability/>Highly Available Shoot Control Plane</a>.
Accordingly, the <code>replicas</code>, <code>topologySpreadConstraints</code> or <code>affinity</code> settings of the deployed components might need to be adapted.</p><p>Instead of doing this one-by-one for each and every component, extensions can rely on a mutating webhook provided by Gardener.
Please refer to <a href=/docs/gardener/high-availability-of-components/>High Availability of Deployed Components</a> for details.</p><p>To reduce costs and to improve the network traffic latency in multi-zone clusters, extensions can make a Service topology-aware.
Please refer to <a href=/docs/gardener/topology_aware_routing/>this document</a> for details.</p><h2 id=is-there-a-naming-scheme-for-global-resources>Is there a naming scheme for (global) resources?<a class=td-heading-self-link href=#is-there-a-naming-scheme-for-global-resources aria-label="Heading self-link"></a></h2><p>As there is no formal process to validate non-existence of conflicts between two extensions, please follow these naming schemes when creating resources (especially, when creating global resources, but it&rsquo;s in general a good idea for most created resources):</p><p><em>The resource name should be prefixed with <code>extensions.gardener.cloud:&lt;extension-type>-&lt;extension-name>:&lt;resource-name></code></em>, for example:</p><ul><li><code>extensions.gardener.cloud:provider-aws:some-controller-manager</code></li><li><code>extensions.gardener.cloud:extension-certificate-service:cert-broker</code></li></ul><h2 id=how-to-create-resources-in-the-shoot-cluster>How to create resources in the shoot cluster?<a class=td-heading-self-link href=#how-to-create-resources-in-the-shoot-cluster aria-label="Heading self-link"></a></h2><p>Some extensions might not only create resources in the seed cluster itself but also in the shoot cluster. Usually, every extension comes with a <code>ServiceAccount</code> and the required RBAC permissions when it gets installed to the seed.
However, there are no credentials for the shoot for every extension.</p><p>Extensions are supposed to use <a href=/docs/gardener/concepts/resource-manager/#ManagedResource-controller><code>ManagedResources</code></a> to manage resources in shoot clusters.
gardenlet deploys gardener-resource-manager instances into all shoot control planes, that will reconcile <code>ManagedResources</code> without a specified class (<code>spec.class=null</code>) in shoot clusters. Mind that Gardener acts on <code>ManagedResources</code> with the <code>origin=gardener</code> label. In order to prevent unwanted behavior, extensions should omit the <code>origin</code> label or provide their own unique value for it when creating such resources.</p><p>If you need to deploy a non-DaemonSet resource, Gardener automatically ensures that it only runs on nodes that are allowed to host system components and extensions. For more information, see <a href=/docs/gardener/concepts/resource-manager/#System-Components-Webhook>System Components Webhook</a>.</p><h2 id=how-to-create-kubeconfigs-for-the-shoot-cluster>How to create kubeconfigs for the shoot cluster?<a class=td-heading-self-link href=#how-to-create-kubeconfigs-for-the-shoot-cluster aria-label="Heading self-link"></a></h2><p>Historically, Gardener extensions used to generate kubeconfigs with client certificates for components they deploy into the shoot control plane.
For this, they reused the shoot cluster CA secret (<code>ca</code>) to issue new client certificates.
With <a href=https://github.com/gardener/gardener/issues/4661>gardener/gardener#4661</a> we moved away from using client certificates in favor of short-lived, auto-rotated <code>ServiceAccount</code> tokens. These tokens are managed by gardener-resource-manager&rsquo;s <a href=/docs/gardener/concepts/resource-manager/#tokenrequestor><code>TokenRequestor</code></a>.
Extensions are supposed to reuse this mechanism for requesting tokens and a <code>generic-token-kubeconfig</code> for authenticating against shoot clusters.</p><p>With <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md>GEP-18</a> (Shoot cluster CA rotation), a dedicated CA will be used for signing client certificates (<a href=https://github.com/gardener/gardener/pull/5779>gardener/gardener#5779</a>) which will be rotated when triggered by the shoot owner.
With this, extensions cannot reuse the <code>ca</code> secret anymore to issue client certificates.
Hence, extensions must switch to short-lived <code>ServiceAccount</code> tokens in order to support the CA rotation feature.</p><p>The <code>generic-token-kubeconfig</code> secret contains the CA bundle for establishing trust to shoot API servers. However, as the secret is immutable, its name changes with the rotation of the cluster CA.
Extensions need to look up the <code>generic-token-kubeconfig.secret.gardener.cloud/name</code> annotation on the respective <a href=/docs/gardener/extensions/cluster/><code>Cluster</code></a> object in order to determine which secret contains the current CA bundle.
The helper function <code>extensionscontroller.GenericTokenKubeconfigSecretNameFromCluster</code> can be used for this task.</p><p>You can take a look at <a href=/docs/gardener/extensions/ca-rotation/>CA Rotation in Extensions</a> for more details on the CA rotation feature in regard to extensions.</p><h2 id=how-to-create-certificates-for-the-shoot-cluster>How to create certificates for the shoot cluster?<a class=td-heading-self-link href=#how-to-create-certificates-for-the-shoot-cluster aria-label="Heading self-link"></a></h2><p>Gardener creates several certificate authorities (CA) that are used to create server certificates for various components.
For example, the shoot&rsquo;s etcd has its own CA, the kube-aggregator has its own CA as well, and both are different to the actual cluster&rsquo;s CA.</p><p>With <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/18-shoot-CA-rotation.md>GEP-18</a> (Shoot cluster CA rotation), extensions are required to do the same and generate dedicated CAs for their components (e.g. for signing a server certificate for cloud-controller-manager). They must not depend on the CA secrets managed by gardenlet.</p><p>Please see <a href=/docs/gardener/extensions/ca-rotation/>CA Rotation in Extensions</a> for the exact requirements that extensions need to fulfill in order to support the CA rotation feature.</p><h2 id=how-to-enforce-a-pod-security-standard-for-extension-namespaces>How to enforce a Pod Security Standard for extension namespaces?<a class=td-heading-self-link href=#how-to-enforce-a-pod-security-standard-for-extension-namespaces aria-label="Heading self-link"></a></h2><p>The <code>pod-security.kubernetes.io/enforce</code> namespace label enforces the <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Pod Security Standards</a>.</p><p>You can set the <code>pod-security.kubernetes.io/enforce</code> label for extension namespace by adding the <code>security.gardener.cloud/pod-security-enforce</code> annotation to your <code>ControllerRegistration</code>. The value of the annotation would be the value set for the <code>pod-security.kubernetes.io/enforce</code> label. It is advised to set the annotation with the most restrictive pod security standard that your extension pods comply with.</p><p>If you are using the <code>./hack/generate-controller-registration.sh</code> script to generate your <code>ControllerRegistration</code> you can use the -e, &ndash;pod-security-enforce option to set the <code>security.gardener.cloud/pod-security-enforce</code> annotation. If the option is not set, it defaults to <code>baseline</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cccbc07c41ead19afe0981cd7ae2e37f>6 - Force Deletion</h1><h1 id=force-deletion>Force Deletion<a class=td-heading-self-link href=#force-deletion aria-label="Heading self-link"></a></h1><p>From <code>v1.81</code>, Gardener supports <a href=/docs/gardener/shoot-operations/shoot_operations/#force-deletion>Shoot Force Deletion</a>. All extension controllers should also properly support it. This document outlines some important points that extension maintainers should keep in mind to support force deletion in their extensions.</p><h2 id=overall-principles>Overall Principles<a class=td-heading-self-link href=#overall-principles aria-label="Heading self-link"></a></h2><p>The following principles should always be upheld:</p><ul><li>All resources pertaining to the extension and managed by it should be appropriately handled and cleaned up by the extension when force deletion is initiated.</li></ul><h2 id=implementation-details>Implementation Details<a class=td-heading-self-link href=#implementation-details aria-label="Heading self-link"></a></h2><h3 id=forcedelete-actuator-methods>ForceDelete Actuator Methods<a class=td-heading-self-link href=#forcedelete-actuator-methods aria-label="Heading self-link"></a></h3><p>Most extension controller implementations follow a common pattern where a generic <code>Reconciler</code> implementation delegates to an <code>Actuator</code> interface that contains the methods <code>Reconcile</code>, <code>Delete</code>, <code>Migrate</code> and <code>Restore</code> provided by the extension. A new method, <code>ForceDelete</code> has been added to all such <code>Actuator</code> interfaces; see <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go>the infrastructure <code>Actuator</code> interface</a> as an example. The generic reconcilers call this method if the Shoot has annotation <code>confirmation.gardener.cloud/force-deletion=true</code>. Thus, it should be implemented by the extension controller to forcefully delete resources if not possible to delete them gracefully. If graceful deletion is possible, then in the <code>ForceDelete</code>, they can simply call the <code>Delete</code> method.</p><h3 id=extension-controllers-based-on-generic-actuators>Extension Controllers Based on Generic Actuators<a class=td-heading-self-link href=#extension-controllers-based-on-generic-actuators aria-label="Heading self-link"></a></h3><p>In practice, the implementation of many extension controllers (for example, the controlplane and worker controllers in most provider extensions) are based on a <em>generic <code>Actuator</code> implementation</em> that only delegates to extension methods for behavior that is truly provider-specific. In all such cases, the <code>ForceDelete</code> method has already been implemented with a method that should suit most of the extensions. If it doesn&rsquo;t suit your extension, then the <code>ForceDelete</code> method needs to be overridden; see the <a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/controlplane>Azure controlplane controller</a> as an example.</p><h3 id=extension-controllers-not-based-on-generic-actuators>Extension Controllers Not Based on Generic Actuators<a class=td-heading-self-link href=#extension-controllers-not-based-on-generic-actuators aria-label="Heading self-link"></a></h3><p>The implementation of some extension controllers (for example, the infrastructure controllers in all provider extensions) are not based on a generic <code>Actuator</code> implementation. Such extension controllers must always provide a proper implementation of the <code>ForceDelete</code> method according to the above guidelines; see the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure>AWS infrastructure controller</a> as an example. In practice, this might result in code duplication between the different extensions, since the <code>ForceDelete</code> code is usually not OS-specific.</p><h3 id=some-general-implementation-examples>Some General Implementation Examples<a class=td-heading-self-link href=#some-general-implementation-examples aria-label="Heading self-link"></a></h3><ul><li>If the extension deploys only resources in the shoot cluster not backed by infrastructure in third-party systems, then performing the regular deletion code (<code>actuator.Delete</code>) will suffice in the majority of cases. (e.g - <a href=https://github.com/gardener/gardener-extension-shoot-networking-filter/blob/1d95a483d803874e8aa3b1de89431e221a7d574e/pkg/controller/lifecycle/actuator.go#L175-L178>https://github.com/gardener/gardener-extension-shoot-networking-filter/blob/1d95a483d803874e8aa3b1de89431e221a7d574e/pkg/controller/lifecycle/actuator.go#L175-L178</a>)</li><li>If the extension deploys resources which are backed by infrastructure in third-party systems:<ul><li>If the resource is in the Seed cluster, the extension should remove the finalizers and delete the resource. This is needed especially if the resource is a custom resource since <code>gardenlet</code> will not be aware of this resource and cannot take action.</li><li>If the resource is in the Shoot and if it&rsquo;s deployed by a <code>ManagedResource</code>, then <code>gardenlet</code> will take care to forcefully delete it in a later step of force-deletion. If the resource is not deployed via a <code>ManagedResource</code>, then it wouldn&rsquo;t block the deletion flow anyway since it is in the Shoot cluster. In both cases, the extension controller can ignore the resource and return <code>nil</code>.</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-079331a6be1955be3c4c16acf0c583c1>7 - Healthcheck Library</h1><h1 id=health-check-library>Health Check Library<a class=td-heading-self-link href=#health-check-library aria-label="Heading self-link"></a></h1><h2 id=goal>Goal<a class=td-heading-self-link href=#goal aria-label="Heading self-link"></a></h2><p>Typically, an extension reconciles a specific resource (Custom Resource Definitions (CRDs)) and creates / modifies resources in the cluster (via helm, managed resources, kubectl, &mldr;).
We call these API Objects &lsquo;dependent objects&rsquo; - as they are bound to the lifecycle of the extension.</p><p>The goal of this library is to enable extensions to setup health checks for their &lsquo;dependent objects&rsquo; with minimal effort.</p><h2 id=usage>Usage<a class=td-heading-self-link href=#usage aria-label="Heading self-link"></a></h2><p>The library provides a generic controller with the ability to register any resource that satisfies the <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types.go>extension object interface</a>.
An example is <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_worker.go>the <code>Worker</code> CRD</a>.</p><p>Health check functions for commonly used dependent objects can be reused and registered with the controller, such as:</p><ul><li>Deployment</li><li>DaemonSet</li><li>StatefulSet</li><li>ManagedResource (Gardener specific)</li></ul><p>See the below example <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/pkg/controller/healthcheck/add.go>taken from the provider-aws</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>health.DefaultRegisterExtensionForHealthCheck(
</span></span><span style=display:flex><span>               aws.Type,
</span></span><span style=display:flex><span>               extensionsv1alpha1.SchemeGroupVersion.WithKind(extensionsv1alpha1.WorkerResource),
</span></span><span style=display:flex><span>               <span style=color:#00f>func</span>() runtime.Object { <span style=color:#00f>return</span> &amp;extensionsv1alpha1.Worker{} },
</span></span><span style=display:flex><span>               mgr, <span style=color:green>// controller runtime manager
</span></span></span><span style=display:flex><span><span style=color:green></span>               opts, <span style=color:green>// options for the health check controller
</span></span></span><span style=display:flex><span><span style=color:green></span>               <span style=color:#00f>nil</span>, <span style=color:green>// custom predicates
</span></span></span><span style=display:flex><span><span style=color:green></span>               <span style=color:#00f>map</span>[extensionshealthcheckcontroller.HealthCheck]<span style=color:#2b91af>string</span>{
</span></span><span style=display:flex><span>                       general.CheckManagedResource(genericactuator.McmShootResourceName): string(gardencorev1beta1.ShootSystemComponentsHealthy),
</span></span><span style=display:flex><span>                       general.CheckSeedDeployment(aws.MachineControllerManagerName):      string(gardencorev1beta1.ShootEveryNodeReady),
</span></span><span style=display:flex><span>                       worker.SufficientNodesAvailable():                                  string(gardencorev1beta1.ShootEveryNodeReady),
</span></span><span style=display:flex><span>               })
</span></span></code></pre></div><p>This creates a health check controller that reconciles the <code>extensions.gardener.cloud/v1alpha1.Worker</code> resource with the spec.type &lsquo;aws&rsquo;.
Three health check functions are registered that are executed during reconciliation.
Each health check is mapped to a single <code>HealthConditionType</code> that results in conditions with the same <code>condition.type</code> (see below).
To contribute to the Shoot&rsquo;s health, the following conditions can be used: <code>SystemComponentsHealthy</code>, <code>EveryNodeReady</code>, <code>ControlPlaneHealthy</code>, <code>ObservabilityComponentsHealthy</code>. In case of workerless <code>Shoot</code> the <code>EveryNodeReady</code> condition is not present, so it can&rsquo;t be used.</p><p>The Gardener/Gardenlet checks each extension for conditions matching these types.
However, extensions are free to choose any <code>HealthConditionType</code>.
For more information, see <a href=/docs/gardener/extensions/shoot-health-status-conditions/>Contributing to Shoot Health Status Conditions</a>.</p><p>A health check has to <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/healthcheck/actuator.go>satisfy the below interface</a>.
You can find implementation examples in the <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/healthcheck/general>healtcheck folder</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#00f>type</span> HealthCheck <span style=color:#00f>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:green>// Check is the function that executes the actual health check
</span></span></span><span style=display:flex><span><span style=color:green></span>    Check(context.Context, types.NamespacedName) (*SingleCheckResult, <span style=color:#2b91af>error</span>)
</span></span><span style=display:flex><span>    <span style=color:green>// InjectSeedClient injects the seed client
</span></span></span><span style=display:flex><span><span style=color:green></span>    InjectSeedClient(client.Client)
</span></span><span style=display:flex><span>    <span style=color:green>// InjectShootClient injects the shoot client
</span></span></span><span style=display:flex><span><span style=color:green></span>    InjectShootClient(client.Client)
</span></span><span style=display:flex><span>    <span style=color:green>// SetLoggerSuffix injects the logger
</span></span></span><span style=display:flex><span><span style=color:green></span>    SetLoggerSuffix(<span style=color:#2b91af>string</span>, <span style=color:#2b91af>string</span>)
</span></span><span style=display:flex><span>    <span style=color:green>// DeepCopy clones the healthCheck
</span></span></span><span style=display:flex><span><span style=color:green></span>    DeepCopy() HealthCheck
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The health check controller regularly (default: <code>30s</code>) reconciles the extension resource and executes the registered health checks for the dependent objects.
As a result, the controller writes condition(s) to the status of the extension containing the health check result.
In our example, two checks are mapped to <code>ShootEveryNodeReady</code> and one to <code>ShootSystemComponentsHealthy</code>, leading to conditions with two distinct <code>HealthConditionTypes</code> (condition.type):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  conditions:
</span></span><span style=display:flex><span>    - lastTransitionTime: <span style=color:#a31515>&#34;20XX-10-28T08:17:21Z&#34;</span>
</span></span><span style=display:flex><span>      lastUpdateTime: <span style=color:#a31515>&#34;20XX-11-28T08:17:21Z&#34;</span>
</span></span><span style=display:flex><span>      message: (1/1) Health checks successful
</span></span><span style=display:flex><span>      reason: HealthCheckSuccessful
</span></span><span style=display:flex><span>      status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>      type: SystemComponentsHealthy
</span></span><span style=display:flex><span>    - lastTransitionTime: <span style=color:#a31515>&#34;20XX-10-28T08:17:21Z&#34;</span>
</span></span><span style=display:flex><span>      lastUpdateTime: <span style=color:#a31515>&#34;20XX-11-28T08:17:21Z&#34;</span>
</span></span><span style=display:flex><span>      message: (2/2) Health checks successful
</span></span><span style=display:flex><span>      reason: HealthCheckSuccessful
</span></span><span style=display:flex><span>      status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>      type: EveryNodeReady
</span></span></code></pre></div><p>Please note that there are four statuses: <code>True</code>, <code>False</code>, <code>Unknown</code>, and <code>Progressing</code>.</p><ul><li><code>True</code> should be used for successful health checks.</li><li><code>False</code> should be used for unsuccessful/failing health checks.</li><li><code>Unknown</code> should be used when there was an error trying to determine the health status.</li><li><code>Progressing</code> should be used to indicate that the health status did not succeed but for expected reasons (e.g., a cluster scale up/down could make the standard health check fail because something is wrong with the <code>Machines</code>, however, it&rsquo;s actually an expected situation and known to be completed within a few minutes.)</li></ul><p>Health checks that report <code>Progressing</code> should also provide a timeout, after which this &ldquo;progressing situation&rdquo; is expected to be completed.
The health check library will automatically transition the status to <code>False</code> if the timeout was exceeded.</p><h2 id=additional-considerations>Additional Considerations<a class=td-heading-self-link href=#additional-considerations aria-label="Heading self-link"></a></h2><p>It is up to the extension to decide how to conduct health checks, though it is recommended to make use of the build-in health check functionality of <code>managedresources</code> for trivial checks.
By <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/worker/genericactuator/machine_controller_manager.go>deploying the depending resources via managed resources</a>, the <a href=https://github.com/gardener/gardener-resource-manager>gardener resource manager</a> conducts basic checks for different API objects out-of-the-box (e.g <code>Deployments</code>, <code>DaemonSets</code>, &mldr;) - and writes health conditions.</p><p>By default, Gardener performs health checks for all the <code>ManagedResource</code>s created in the shoot namespaces.
Their status will be aggregated to the <code>Shoot</code> conditions according to the following rules:</p><ul><li>Health checks of <code>ManagedResource</code> with <code>.spec.class=nil</code> are aggregated to the <code>SystemComponentsHealthy</code> condition</li><li>Health checks of <code>ManagedResource</code> with <code>.spec.class!=nil</code> are aggregated to the <code>ControlPlaneHealthy</code> condition unless the <code>ManagedResource</code> is labeled with <code>care.gardener.cloud/condition-type=&lt;other-condition-type></code>. In such case, it is aggregated to the <code>&lt;other-condition-type></code>.</li></ul><p>More sophisticated health checks should be implemented by the extension controller itself (implementing the <code>HealthCheck</code> interface).</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0e4beafbeaa3ceeadf6e6af4e27a26ae>8 - Heartbeat</h1><h1 id=heartbeat-controller>Heartbeat Controller<a class=td-heading-self-link href=#heartbeat-controller aria-label="Heading self-link"></a></h1><p>The heartbeat controller renews a dedicated <code>Lease</code> object named <code>gardener-extension-heartbeat</code> at regular 30 second intervals by default. This <code>Lease</code> is used for heartbeats similar to how <code>gardenlet</code> uses <code>Lease</code> objects for seed heartbeats (see <a href=/docs/gardener/concepts/gardenlet/#heartbeats>gardenlet heartbeats</a>).</p><p>The <code>gardener-extension-heartbeat</code> <code>Lease</code> can be checked by other controllers to verify that the corresponding extension controller is still running. Currently, <code>gardenlet</code> checks this <code>Lease</code> when performing shoot health checks and expects to find the <code>Lease</code> inside the namespace where the extension controller is deployed by the corresponding <code>ControllerInstallation</code>. For each extension resource deployed in the Shoot control plane, <code>gardenlet</code> finds the corresponding <code>gardener-extension-heartbeat</code> <code>Lease</code> resource and checks whether the <code>Lease</code>&rsquo;s <code>.spec.renewTime</code> is older than the allowed threshold for stale extension health checks - in this case, <code>gardenlet</code> considers the health check report for an extension resource as &ldquo;outdated&rdquo; and reflects this in the <code>Shoot</code> status.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-95017ccbee8525055e43da8a42034f57>9 - Logging And Monitoring</h1><h1 id=logging-and-monitoring-for-extensions>Logging and Monitoring for Extensions<a class=td-heading-self-link href=#logging-and-monitoring-for-extensions aria-label="Heading self-link"></a></h1><p>Gardener provides an integrated logging and monitoring stack for alerting, monitoring, and troubleshooting of its managed components by operators or end users. For further information how to make use of it in these roles, refer to the corresponding guides for <a href=https://github.com/gardener/logging/tree/master/docs/usage/README.md>exploring logs</a> and for <a href=https://github.com/credativ/plutono>monitoring with Plutono</a>.</p><p>The components that constitute the logging and monitoring stack are managed by Gardener. By default, it deploys <a href=https://prometheus.io/>Prometheus</a> and <a href=https://prometheus.io/docs/alerting/latest/alertmanager/>Alertmanager</a> (managed via <a href=https://github.com/prometheus-operator/prometheus-operator><code>prometheus-operator</code></a>, and <a href=https://github.com/credativ/plutono>Plutono</a> into the <code>garden</code> namespace of all seed clusters. If the logging is enabled in the <code>gardenlet</code> configuration (<code>logging.enabled</code>), it will deploy <a href=https://github.com/fluent/fluent-operator>fluent-operator</a> and <a href=https://github.com/credativ/plutono>Vali</a> in the <code>garden</code> namespace too.</p><p>Each shoot namespace hosts managed logging and monitoring components. As part of the shoot reconciliation flow, Gardener deploys a shoot-specific Prometheus, blackbox-exporter, Plutono, and, if configured, an Alertmanager into the shoot namespace, next to the other control plane components. If the logging is enabled in the <code>gardenlet</code> configuration (<code>logging.enabled</code>) and the <a href=/docs/gardener/shoot/shoot_purposes/#behavioral-differences>shoot purpose</a> is not <code>testing</code>, it deploys a shoot-specific Vali in the shoot namespace too.</p><p>The logging and monitoring stack is extensible by configuration. Gardener extensions can take advantage of that and contribute monitoring configurations encoded in <code>ConfigMap</code>s for their own, specific dashboards, alerts and other supported assets and integrate with it. As with other Gardener resources, they will be continuously reconciled. The extensions can also deploy directly fluent-operator custom resources which will be created in the seed cluster and plugged into the fluent-bit instance.</p><p>This guide is about the roles and extensibility options of the logging and monitoring stack components, and how to integrate extensions with:</p><ul><li><a href=/docs/gardener/extensions/logging-and-monitoring/#monitoring>Monitoring</a></li><li><a href=/docs/gardener/extensions/logging-and-monitoring/#logging>Logging</a></li></ul><h2 id=monitoring>Monitoring<a class=td-heading-self-link href=#monitoring aria-label="Heading self-link"></a></h2><h3 id=seed-cluster>Seed Cluster<a class=td-heading-self-link href=#seed-cluster aria-label="Heading self-link"></a></h3><h4 id=cache-prometheus>Cache Prometheus<a class=td-heading-self-link href=#cache-prometheus aria-label="Heading self-link"></a></h4><p>The central Prometheus instance in the <code>garden</code> namespace (called &ldquo;cache Prometheus&rdquo;) fetches metrics and data from all seed cluster nodes and all seed cluster pods.
It uses the <a href=https://prometheus.io/docs/prometheus/latest/federation/>federation</a> concept to allow the shoot-specific instances to scrape only the metrics for the pods of the control plane they are responsible for.
This mechanism allows to scrape the metrics for the nodes/pods once for the whole cluster, and to have them distributed afterwards.
For more details, continue reading <a href=/docs/gardener/monitoring/#prometheus>here</a>.</p><p>Typically, this is not necessary, but in case an extension wants to extend the configuration for this cache Prometheus, they can create the <a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions"><code>prometheus-operator</code>&rsquo;s custom resources</a> and label them with <code>prometheus=cache</code>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: monitoring.coreos.com/v1
</span></span><span style=display:flex><span>kind: ServiceMonitor
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    prometheus: cache
</span></span><span style=display:flex><span>  name: cache-my-component
</span></span><span style=display:flex><span>  namespace: garden
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      app: my-component
</span></span><span style=display:flex><span>  endpoints:
</span></span><span style=display:flex><span>  - metricRelabelings:
</span></span><span style=display:flex><span>    - action: keep
</span></span><span style=display:flex><span>      regex: ^(metric1|metric2|...)$
</span></span><span style=display:flex><span>      sourceLabels:
</span></span><span style=display:flex><span>      - __name__
</span></span><span style=display:flex><span>    port: metrics
</span></span></code></pre></div><h4 id=seed-prometheus>Seed Prometheus<a class=td-heading-self-link href=#seed-prometheus aria-label="Heading self-link"></a></h4><p>Another Prometheus instance in the <code>garden</code> namespace (called &ldquo;seed Prometheus&rdquo;) fetches metrics and data from seed system components, kubelets, cAdvisors, and extensions.
If you want your extension pods to be scraped then they must be annotated with <code>prometheus.io/scrape=true</code> and <code>prometheus.io/port=&lt;metrics-port></code>.
For more details, continue reading <a href=/docs/gardener/monitoring/#seed-prometheus>here</a>.</p><p>Typically, this is not necessary, but in case an extension wants to extend the configuration for this seed Prometheus, they can create the <a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions"><code>prometheus-operator</code>&rsquo;s custom resources</a> and label them with <code>prometheus=seed</code>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: monitoring.coreos.com/v1
</span></span><span style=display:flex><span>kind: ServiceMonitor
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    prometheus: seed
</span></span><span style=display:flex><span>  name: seed-my-component
</span></span><span style=display:flex><span>  namespace: garden
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      app: my-component
</span></span><span style=display:flex><span>  endpoints:
</span></span><span style=display:flex><span>  - metricRelabelings:
</span></span><span style=display:flex><span>    - action: keep
</span></span><span style=display:flex><span>      regex: ^(metric1|metric2|...)$
</span></span><span style=display:flex><span>      sourceLabels:
</span></span><span style=display:flex><span>      - __name__
</span></span><span style=display:flex><span>    port: metrics
</span></span></code></pre></div><h4 id=aggregate-prometheus>Aggregate Prometheus<a class=td-heading-self-link href=#aggregate-prometheus aria-label="Heading self-link"></a></h4><p>Another Prometheus instance in the <code>garden</code> namespace (called &ldquo;aggregate Prometheus&rdquo;) stores pre-aggregated data from the cache Prometheus and shoot Prometheus.
An ingress exposes this Prometheus instance allowing it to be scraped from another cluster.
For more details, continue reading <a href=/docs/gardener/monitoring/#aggregate-prometheus>here</a>.</p><p>Typically, this is not necessary, but in case an extension wants to extend the configuration for this aggregate Prometheus, they can create the <a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions"><code>prometheus-operator</code>&rsquo;s custom resources</a> and label them with <code>prometheus=aggregate</code>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: monitoring.coreos.com/v1
</span></span><span style=display:flex><span>kind: ServiceMonitor
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    prometheus: aggregate
</span></span><span style=display:flex><span>  name: aggregate-my-component
</span></span><span style=display:flex><span>  namespace: garden
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      app: my-component
</span></span><span style=display:flex><span>  endpoints:
</span></span><span style=display:flex><span>  - metricRelabelings:
</span></span><span style=display:flex><span>    - action: keep
</span></span><span style=display:flex><span>      regex: ^(metric1|metric2|...)$
</span></span><span style=display:flex><span>      sourceLabels:
</span></span><span style=display:flex><span>      - __name__
</span></span><span style=display:flex><span>    port: metrics
</span></span></code></pre></div><h4 id=plutono>Plutono<a class=td-heading-self-link href=#plutono aria-label="Heading self-link"></a></h4><p>A <a href=https://github.com/credativ/plutono>Plutono</a> instance is deployed by <code>gardenlet</code> into the seed cluster&rsquo;s <code>garden</code> namespace for visualizing monitoring metrics and logs via dashboards.
In order to provide custom dashboards, create a <code>ConfigMap</code> in the <code>garden</code> namespace labelled with <code>dashboard.monitoring.gardener.cloud/seed=true</code> that contains the respective JSON documents, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ConfigMap
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    dashboard.monitoring.gardener.cloud/seed: <span style=color:#a31515>&#34;true&#34;</span>
</span></span><span style=display:flex><span>  name: extension-foo-my-custom-dashboard
</span></span><span style=display:flex><span>  namespace: garden
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  my-custom-dashboard.json: &lt;dashboard-JSON-document&gt;
</span></span></code></pre></div><h3 id=shoot-cluster>Shoot Cluster<a class=td-heading-self-link href=#shoot-cluster aria-label="Heading self-link"></a></h3><h4 id=shoot-prometheus>Shoot Prometheus<a class=td-heading-self-link href=#shoot-prometheus aria-label="Heading self-link"></a></h4><p>The shoot-specific metrics are then made available to operators and users in the shoot Plutono, using the shoot Prometheus as data source.</p><p>Extension controllers might deploy components as part of their reconciliation next to the shoot&rsquo;s control plane.
Examples for this would be a cloud-controller-manager or CSI controller deployments. Extensions that want to have their managed control plane components integrated with monitoring can contribute their per-shoot configuration for scraping Prometheus metrics, Alertmanager alerts or Plutono dashboards.</p><h4 id=extensions-monitoring-integration>Extensions Monitoring Integration<a class=td-heading-self-link href=#extensions-monitoring-integration aria-label="Heading self-link"></a></h4><p>In case an extension wants to extend the configuration for the shoot Prometheus, they can create the <a href="https://github.com/prometheus-operator/prometheus-operator?tab=readme-ov-file#customresourcedefinitions"><code>prometheus-operator</code>&rsquo;s custom resources</a> and label them with <code>prometheus=shoot</code>.</p><h5 id=servicemonitor><code>ServiceMonitor</code><a class=td-heading-self-link href=#servicemonitor aria-label="Heading self-link"></a></h5><p>When the component runs in the seed cluster (e.g., as part of the shoot control plane), <code>ServiceMonitor</code> resources should be used:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: monitoring.coreos.com/v1
</span></span><span style=display:flex><span>kind: ServiceMonitor
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    prometheus: shoot
</span></span><span style=display:flex><span>  name: shoot-my-controlplane-component
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      app: my-component
</span></span><span style=display:flex><span>  endpoints:
</span></span><span style=display:flex><span>  - metricRelabelings:
</span></span><span style=display:flex><span>    - action: keep
</span></span><span style=display:flex><span>      regex: ^(metric1|metric2|...)$
</span></span><span style=display:flex><span>      sourceLabels:
</span></span><span style=display:flex><span>      - __name__
</span></span><span style=display:flex><span>    port: metrics
</span></span></code></pre></div><p>In case <code>HTTPS</code> scheme is used, the CA certificate should be provided like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  scheme: HTTPS
</span></span><span style=display:flex><span>  tlsConfig:
</span></span><span style=display:flex><span>    ca:
</span></span><span style=display:flex><span>      secret:
</span></span><span style=display:flex><span>        name: &lt;name-of-ca-bundle-secret&gt;
</span></span><span style=display:flex><span>        key: bundle.crt
</span></span></code></pre></div><p>In case the component requires credentials when contacting its metrics endpoint, provide them like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  authorization:
</span></span><span style=display:flex><span>    credentials:
</span></span><span style=display:flex><span>      name: &lt;name-of-secret-containing-credentials&gt;
</span></span><span style=display:flex><span>      key: &lt;data-keyin-secret&gt;
</span></span></code></pre></div><p>If the component delegates authorization to the <code>kube-apiserver</code> of the shoot cluster, you can use the <code>shoot-access-prometheus-shoot</code> secret:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  authorization:
</span></span><span style=display:flex><span>    credentials:
</span></span><span style=display:flex><span>      name: shoot-access-prometheus-shoot
</span></span><span style=display:flex><span>      key: token
</span></span><span style=display:flex><span>  <span style=color:green># in case the component&#39;s server certificate is signed by the cluster CA:</span>
</span></span><span style=display:flex><span>  scheme: HTTPS
</span></span><span style=display:flex><span>  tlsConfig:
</span></span><span style=display:flex><span>    ca:
</span></span><span style=display:flex><span>      secret:
</span></span><span style=display:flex><span>        name: &lt;name-of-ca-bundle-secret&gt;
</span></span><span style=display:flex><span>        key: bundle.crt
</span></span></code></pre></div><h5 id=scrapeconfigs><code>ScrapeConfig</code>s<a class=td-heading-self-link href=#scrapeconfigs aria-label="Heading self-link"></a></h5><p>If the component runs in the shoot cluster itself, metrics are scraped via the <code>kube-apiserver</code> proxy.
In this case, Prometheus needs to authenticate itself with the API server.
This can be done like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: monitoring.coreos.com/v1alpha1
</span></span><span style=display:flex><span>kind: ScrapeConfig
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    prometheus: shoot
</span></span><span style=display:flex><span>  name: shoot-my-cluster-component
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  authorization:
</span></span><span style=display:flex><span>    credentials:
</span></span><span style=display:flex><span>      name: shoot-access-prometheus-shoot
</span></span><span style=display:flex><span>      key: token
</span></span><span style=display:flex><span>  scheme: HTTPS
</span></span><span style=display:flex><span>  tlsConfig:
</span></span><span style=display:flex><span>    ca:
</span></span><span style=display:flex><span>      secret:
</span></span><span style=display:flex><span>        name: &lt;name-of-ca-bundle-secret&gt;
</span></span><span style=display:flex><span>        key: bundle.crt
</span></span><span style=display:flex><span>  kubernetesSDConfigs:
</span></span><span style=display:flex><span>  - apiServer: https://kube-apiserver
</span></span><span style=display:flex><span>    authorization:
</span></span><span style=display:flex><span>      credentials:
</span></span><span style=display:flex><span>        name: shoot-access-prometheus-shoot
</span></span><span style=display:flex><span>        key: token
</span></span><span style=display:flex><span>    followRedirects: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    namespaces:
</span></span><span style=display:flex><span>      names:
</span></span><span style=display:flex><span>      - kube-system
</span></span><span style=display:flex><span>    role: endpoints
</span></span><span style=display:flex><span>    tlsConfig:
</span></span><span style=display:flex><span>      ca:
</span></span><span style=display:flex><span>        secret:
</span></span><span style=display:flex><span>          name: &lt;name-of-ca-bundle-secret&gt;
</span></span><span style=display:flex><span>          key: bundle.crt
</span></span><span style=display:flex><span>      cert: {}
</span></span><span style=display:flex><span>  metricRelabelings:
</span></span><span style=display:flex><span>  - sourceLabels:
</span></span><span style=display:flex><span>    - __name__
</span></span><span style=display:flex><span>    action: keep
</span></span><span style=display:flex><span>    regex: ^(metric1|metric2)$
</span></span><span style=display:flex><span>  - sourceLabels:
</span></span><span style=display:flex><span>    - namespace
</span></span><span style=display:flex><span>    action: keep
</span></span><span style=display:flex><span>    regex: kube-system
</span></span><span style=display:flex><span>  relabelings:
</span></span><span style=display:flex><span>  - action: replace
</span></span><span style=display:flex><span>    replacement: my-cluster-component
</span></span><span style=display:flex><span>    targetLabel: job
</span></span><span style=display:flex><span>  - sourceLabels: [__meta_kubernetes_service_name, __meta_kubernetes_pod_container_port_name]
</span></span><span style=display:flex><span>    separator: ;
</span></span><span style=display:flex><span>    regex: my-component-service;metrics
</span></span><span style=display:flex><span>    replacement: $1
</span></span><span style=display:flex><span>    action: keep
</span></span><span style=display:flex><span>  - sourceLabels: [__meta_kubernetes_endpoint_node_name]
</span></span><span style=display:flex><span>    separator: ;
</span></span><span style=display:flex><span>    regex: (.*)
</span></span><span style=display:flex><span>    targetLabel: node
</span></span><span style=display:flex><span>    replacement: $1
</span></span><span style=display:flex><span>    action: replace
</span></span><span style=display:flex><span>  - sourceLabels: [__meta_kubernetes_pod_name]
</span></span><span style=display:flex><span>    separator: ;
</span></span><span style=display:flex><span>    regex: (.*)
</span></span><span style=display:flex><span>    targetLabel: pod
</span></span><span style=display:flex><span>    replacement: $1
</span></span><span style=display:flex><span>    action: replace
</span></span><span style=display:flex><span>  - targetLabel: __address__
</span></span><span style=display:flex><span>    replacement: kube-apiserver:443
</span></span><span style=display:flex><span>  - sourceLabels: [__meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number]
</span></span><span style=display:flex><span>    separator: ;
</span></span><span style=display:flex><span>    regex: (.+);(.+)
</span></span><span style=display:flex><span>    targetLabel: __metrics_path__
</span></span><span style=display:flex><span>    replacement: /api/v1/namespaces/kube-system/pods/${1}:${2}/proxy/metrics
</span></span><span style=display:flex><span>    action: replace
</span></span></code></pre></div><blockquote class="alert alert-tip"><div class=alert-title><svg viewBox="0 0 24 24" width="24" height="24"><title>lightbulb-on-outline</title><path d="M20 11h3v2H20V11M1 11H4v2H1V11M13 1V4H11V1h2M4.92 3.5 7.05 5.64 5.63 7.05 3.5 4.93 4.92 3.5M16.95 5.63 19.07 3.5 20.5 4.93 18.37 7.05 16.95 5.63M12 6a6 6 0 016 6c0 2.22-1.21 4.16-3 5.2V19a1 1 0 01-1 1H10A1 1 0 019 19V17.2C7.21 16.16 6 14.22 6 12a6 6 0 016-6m2 15v1a1 1 0 01-1 1H11a1 1 0 01-1-1V21h4m-3-3h2V15.87c1.73-.44 3-2.01 3-3.87A4 4 0 0012 8 4 4 0 008 12c0 1.86 1.27 3.43 3 3.87V18z"/></svg><p>Tip</p></div><p>Developers can make use of the <code>pkg/component/observability/monitoring/prometheus/shoot.ClusterComponentScrapeConfigSpec</code> function in order to generate a <code>ScrapeConfig</code> like above.</p></blockquote><h5 id=prometheusrule><code>PrometheusRule</code><a class=td-heading-self-link href=#prometheusrule aria-label="Heading self-link"></a></h5><p>Similar to <code>ServiceMonitor</code>s, <code>PrometheusRule</code>s can be created with the <code>prometheus=shoot</code> label:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: monitoring.coreos.com/v1
</span></span><span style=display:flex><span>kind: PrometheusRule
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    prometheus: shoot
</span></span><span style=display:flex><span>  name: shoot-my-component
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  groups:
</span></span><span style=display:flex><span>  - name: my.rules
</span></span><span style=display:flex><span>    rules:
</span></span><span style=display:flex><span>    <span style=color:green># ...</span>
</span></span></code></pre></div><h5 id=plutono-dashboards>Plutono Dashboards<a class=td-heading-self-link href=#plutono-dashboards aria-label="Heading self-link"></a></h5><p>A <a href=https://github.com/credativ/plutono>Plutono</a> instance is deployed by <code>gardenlet</code> into the shoot cluster&rsquo;s namespace for visualizing monitoring metrics and logs via dashboards.
In order to provide custom dashboards, create a <code>ConfigMap</code> in the shoot cluster&rsquo;s namespace labelled with <code>dashboard.monitoring.gardener.cloud/shoot=true</code> that contains the respective JSON documents, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ConfigMap
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    dashboard.monitoring.gardener.cloud/shoot: <span style=color:#a31515>&#34;true&#34;</span>
</span></span><span style=display:flex><span>  name: extension-foo-my-custom-dashboard
</span></span><span style=display:flex><span>  namespace: shoot--project--name
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  my-custom-dashboard.json: &lt;dashboard-JSON-document&gt;
</span></span></code></pre></div><h2 id=logging>Logging<a class=td-heading-self-link href=#logging aria-label="Heading self-link"></a></h2><p>In Kubernetes clusters, container logs are non-persistent and do not survive stopped and destroyed containers. Gardener addresses this problem for the components hosted in a seed cluster by introducing its own managed logging solution. It is integrated with the Gardener monitoring stack to have all troubleshooting context in one place.</p><p><img src=/__resources/logging-architecture_8711a9.png alt="&ldquo;Cluster Logging Topology&rdquo;" title="Cluster Logging Topology"></p><p>Gardener logging consists of components in three roles - log collectors and forwarders, log persistency and exploration/consumption interfaces. All of them live in the seed clusters in multiple instances:</p><ul><li>Logs are persisted by Vali instances deployed as StatefulSets - one per shoot namespace, if the logging is enabled in the <code>gardenlet</code> configuration (<code>logging.enabled</code>) and the <a href=/docs/gardener/shoot/shoot_purposes/#behavioral-differences>shoot purpose</a> is not <code>testing</code>, and one in the <code>garden</code> namespace. The shoot instances store logs from the control plane components hosted there. The <code>garden</code> Vali instance is responsible for logs from the rest of the seed namespaces - <code>kube-system</code>, <code>garden</code>, <code>extension-*</code>, and others.</li><li>Fluent-bit DaemonSets deployed by the fluent-operator on each seed node collect logs from it. A custom plugin takes care to distribute the collected log messages to the Vali instances that they are intended for. This allows to fetch the logs once for the whole cluster, and to distribute them afterwards.</li><li>Plutono is the UI component used to explore monitoring and log data together for easier troubleshooting and in context. Plutono instances are configured to use the corresponding Vali instances, sharing the same namespace as data providers. There is one Plutono Deployment in the <code>garden</code> namespace and one Deployment per shoot namespace (exposed to the end users and to the operators).</li></ul><p>Logs can be produced from various sources, such as containers or systemd, and in different formats. The fluent-bit design supports configurable <a href=https://docs.fluentbit.io/manual/concepts/data-pipeline>data pipeline</a> to address that problem. Gardener provides such <a href=https://github.com/gardener/gardener/blob/master/pkg/component/kubernetes/apiserver/logging.go>configuration</a> for logs produced by all its core managed components as <code>ClusterFilters</code> and <code>ClusterParsers</code> . Extensions can contribute their own, specific configurations as fluent-operator custom resources too. See for example the <a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/charts/gardener-extension-provider-aws/templates/clusterfilters-logging.yaml>logging configuration</a> for the Gardener AWS provider extension.</p><h3 id=fluent-bit-log-parsers-and-filters>Fluent-bit Log Parsers and Filters<a class=td-heading-self-link href=#fluent-bit-log-parsers-and-filters aria-label="Heading self-link"></a></h3><p>To integrate with Gardener logging, extensions can and <em>should</em> specify how fluent-bit will handle the logs produced by the managed components that they contribute to Gardener. Normally, that would require to configure a <em>parser</em> for the specific logging format, if none of the available is applicable, and a <em>filter</em> defining how to apply it. For a complete reference for the configuration options, refer to fluent-bit&rsquo;s <a href=https://docs.fluentbit.io/manual/>documentation</a>.</p><p>To contribute its own configuration to the fluent-bit agents data pipelines, an extension must deploy a <code>fluent-operator</code> custom resource labeled with <code>fluentbit.gardener/type: seed</code> in the seed cluster.</p><blockquote><p><strong>Note:</strong> Take care to provide the correct data pipeline elements in the corresponding fields and not to mix them.</p></blockquote><p><strong>Example:</strong> Logging configuration for provider-specific <code>cloud-controller-manager</code> deployed into shoot namespaces that reuses the <code>kube-apiserver-parser</code> defined in <a href=https://github.com/gardener/gardener/blob/master/pkg/component/kubernetes/apiserver/logging.go>logging.go</a> to parse the component logs:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: fluentbit.fluent.io/v1alpha2
</span></span><span style=display:flex><span>kind: ClusterFilter
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    fluentbit.gardener/type: <span style=color:#a31515>&#34;seed&#34;</span>
</span></span><span style=display:flex><span>  name: cloud-controller-manager-aws-cloud-controller-manager
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  filters:
</span></span><span style=display:flex><span>  - parser:
</span></span><span style=display:flex><span>      keyName: log
</span></span><span style=display:flex><span>      parser: kube-apiserver-parser
</span></span><span style=display:flex><span>      reserveData: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>  match: kubernetes.*cloud-controller-manager*aws-cloud-controller-manager*
</span></span></code></pre></div><p>Further details how to define parsers and use them with examples can be found in the following <a href=/docs/gardener/log_parsers/>guide</a>.</p><h3 id=plutono-1>Plutono<a class=td-heading-self-link href=#plutono-1 aria-label="Heading self-link"></a></h3><p>The two types of Plutono instances found in a seed cluster are configured to expose logs of different origin in their dashboards:</p><ul><li>Garden Plutono dashboards expose logs from non-shoot namespaces of the seed clusters<ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/seed/pod-logs.json>Pod Logs</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/seed/extensions-dashboard.json>Extensions</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/seed/systemd-logs.json>Systemd Logs</a></li></ul></li><li>Shoot Plutono dashboards expose logs from the shoot cluster namespace where they belong<ul><li>Kube Apiserver</li><li>Kube Controller Manager</li><li>Kube Scheduler</li><li>Cluster Autoscaler</li><li>VPA components</li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/component/observability/plutono/dashboards/shoot/owners/kubernetes-pods-dashboard.json>Kubernetes Pods</a></li></ul></li></ul><p>If the type of logs exposed in the Plutono instances needs to be changed, it is necessary to update the corresponding instance dashboard configurations.</p><h2 id=tips>Tips<a class=td-heading-self-link href=#tips aria-label="Heading self-link"></a></h2><ul><li>Be careful to create <code>ClusterFilters</code> and <code>ClusterParsers</code> with unique names because they are not namespaced. We use <code>pod_name</code> for filters with one container and <code>pod_name--container_name</code> for pods with multiple containers.</li><li>Be careful to match exactly the log names that you need for a particular parser in your filters configuration. The regular expression you will supply will match names in the form <code>kubernetes.pod_name.&lt;metadata>.container_name</code>. If there are extensions with the same container and pod names, they will all match the same parser in a filter. That may be a desired effect, if they all share the same log format. But it will be a problem if they don&rsquo;t. To solve it, either the pod or container names must be unique, and the regular expression in the filter has to match that unique pattern. A recommended approach is to prefix containers with the extension name and tune the regular expression to match it. For example, using <code>myextension-container</code> as container name and a regular expression <code>kubernetes.mypod.*myextension-container</code> will guarantee match of the right log name. Make sure that the regular expression does not match more than you expect. For example, <code>kubernetes.systemd.*systemd.*</code> will match both <code>systemd-service</code> and <code>systemd-monitor-service</code>. You will want to be as specific as possible.</li><li>It&rsquo;s a good idea to put the logging configuration into the Helm chart that also deploys the extension <em>controller</em>, while the monitoring configuration can be part of the Helm chart/deployment routine that deploys the <em>component</em> managed by the controller.</li><li>For monitoring to work in the Gardener context, scrape targets need to be labelled appropriately, see <a href=/docs/gardener/network_policies/><code>NetworkPolicy</code>s In Garden, Seed, Shoot Clusters</a> for details.</li></ul><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/issues/1351>GitHub Issue Describing the Concept</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-gcp/blob/master/charts/internal/seed-controlplane/charts/cloud-controller-manager/templates/configmap-observability.yaml>Exemplary Implementation (Monitoring) for the GCP Provider</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/blob/master/charts/gardener-extension-provider-aws/templates/clusterfilters-logging.yaml>Exemplary Implementation (ClusterFilter) for the AWS Provider</a></li><li><a href=https://github.com/gardener/gardener-extension-shoot-dns-service/blob/master/charts/gardener-extension-shoot-dns-service/templates/clusterparsers-logging.yaml>Exemplary Implementation (ClusterParser) for the Shoot DNS Service</a></li><li><a href=/docs/gardener/network_policies/#logging--monitoring>Network Policies for Logging & Monitoring in Garden Runtime Cluster</a></li><li><a href=/docs/gardener/network_policies/#logging--monitoring-1>Network Policies for Logging & Monitoring in Seed Cluster</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-107acf6f6b69c9ac1c403a4f60e455d7>10 - Managedresources</h1><h1 id=deploy-resources-to-the-shoot-cluster>Deploy Resources to the Shoot Cluster<a class=td-heading-self-link href=#deploy-resources-to-the-shoot-cluster aria-label="Heading self-link"></a></h1><p>We have introduced a component called <a href=/docs/gardener/concepts/resource-manager/><code>gardener-resource-manager</code></a> that is deployed as part of every shoot control plane in the seed.
One of its tasks is to manage CRDs, so called <code>ManagedResource</code>s.
Managed resources contain Kubernetes resources that shall be created, reconciled, updated, and deleted by the gardener-resource-manager.</p><p>Extension controllers may create these <code>ManagedResource</code>s in the shoot namespace if they need to create any resource in the shoot cluster itself, for example RBAC roles (or anything else).</p><h2 id=where-can-i-find-more-examples-and-more-information-how-to-use-managedresources>Where can I find more examples and more information how to use <code>ManagedResource</code>s?<a class=td-heading-self-link href=#where-can-i-find-more-examples-and-more-information-how-to-use-managedresources aria-label="Heading self-link"></a></h2><p>Please take a look at the <a href=/docs/gardener/concepts/resource-manager/>respective documentation</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fb6f6dc9c480f0bfbe05fce71647dcf7>11 - Migration</h1><h1 id=control-plane-migration>Control Plane Migration<a class=td-heading-self-link href=#control-plane-migration aria-label="Heading self-link"></a></h1><p><em>Control Plane Migration</em> is a new Gardener feature that has been recently implemented as proposed in <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/07-shoot-control-plane-migration.md>GEP-7 Shoot Control Plane Migration</a>. It should be properly supported by all extensions controllers. This document outlines some important points that extension maintainers should keep in mind to properly support migration in their extensions.</p><h2 id=overall-principles>Overall Principles<a class=td-heading-self-link href=#overall-principles aria-label="Heading self-link"></a></h2><p>The following principles should always be upheld:</p><ul><li>All states maintained by the extension that is external from the seed cluster, for example infrastructure resources in a cloud provider, DNS entries, etc., should be kept during the migration. No such state should be deleted and then recreated, as this might cause disruption in the availability of the shoot cluster.</li><li>All Kubernetes resources maintained by the extension in the shoot cluster itself should also be kept during the migration. No such resources should be deleted and then recreated.</li></ul><h2 id=migrate-and-restore-operations>Migrate and Restore Operations<a class=td-heading-self-link href=#migrate-and-restore-operations aria-label="Heading self-link"></a></h2><p>Two new operations have been introduced in Gardener. They can be specified as values of the <code>gardener.cloud/operation</code> annotation on an extension resource to indicate that an operation different from a normal <code>reconcile</code> should be performed by the corresponding extension controller:</p><ul><li>The <code>migrate</code> operation is used to ask the extension controller in the source seed to stop reconciling extension resources (in case they are requeued due to errors) and perform cleanup activities, if such are required. These cleanup activities might involve removing finalizers on resources in the shoot namespace that have been previously created by the extension controller and deleting them without actually deleting any resources external to the seed cluster. This is also the last opportunity for extensions to persist their state into the <code>.status.state</code> field of the reconciled extension resource before its restored in the new destination seed cluster.</li><li>The <code>restore</code> operation is used to ask the extension controller in the destination seed to restore any state saved in the extension resource <code>status</code>, before performing the actual reconciliation.</li></ul><p>Unlike the <a href=/docs/gardener/extensions/reconcile-trigger/>reconcile operation</a>, extension controllers must remove the <code>gardener.cloud/operation</code> annotation at the end of a successful reconciliation when the current operation is <code>migrate</code> or <code>restore</code>, not at the beginning of a reconciliation.</p><h2 id=cleaning-up-source-seed-resources>Cleaning-Up Source Seed Resources<a class=td-heading-self-link href=#cleaning-up-source-seed-resources aria-label="Heading self-link"></a></h2><p>All resources in the source seed that have been created by an extension controller, for example secrets, config maps, <a href=/docs/gardener/extensions/managedresources/>managed resources</a>, etc., should be properly cleaned up by the extension controller when the current operation is <code>migrate</code>. As mentioned above, such resources should be deleted without actually deleting any resources external to the seed cluster.</p><p>There is one exception to this: <code>Secret</code>s labeled with <code>persist=true</code> created via the <a href=/docs/gardener/secrets_management/>secrets manager</a>. They should be kept (i.e., the <code>Cleanup</code> function of secrets manager should not be called) and will be garbage collected automatically at the end of the <code>migrate</code> operation. This ensures that they can be properly persisted in the <code>ShootState</code> resource and get restored on the new destination seed cluster.</p><p>For many custom resources, for example MCM resources, the above requirement means in practice that any finalizers should be removed before deleting the resource, in addition to ensuring that the resource deletion is not reconciled by its respective controller if there is no finalizer. For managed resources, the above requirement means in practice that the <code>spec.keepObjects</code> field should be set to <code>true</code> before deleting the extension resource.</p><p>Here it is assumed that any resources that contain state needed by the extension controller can be safely deleted, since any such state has been saved as described in <a href=/docs/gardener/extensions/migration/#saving-and-restoring-extension-states>Saving and Restoring Extension States</a> at the end of the last successful reconciliation.</p><h2 id=saving-and-restoring-extension-states>Saving and Restoring Extension States<a class=td-heading-self-link href=#saving-and-restoring-extension-states aria-label="Heading self-link"></a></h2><p>Some extension controllers create and maintain their own state when reconciling extension resources. For example, most infrastructure controllers use Terraform and maintain the terraform state in a special config map in the shoot namespace. This state must be properly migrated to the new seed cluster during control plane migration, so that subsequent reconciliations in the new seed could find and use it appropriately.</p><p>All extension controllers that require such state migration must save their state in the <code>status.state</code> field of their extension resource at the end of a successful reconciliation. They must also restore their state from that same field upon reconciling an extension resource when the current operation is <code>restore</code>, as specified by the <code>gardener.cloud/operation</code> annotation, before performing the actual reconciliation.</p><p>As an example, an infrastructure controller that uses Terraform must save the terraform state in the <code>status.state</code> field of the <code>Infrastructure</code> resource. An <code>Infrastructure</code> resource with a properly saved state might look as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Infrastructure
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: infrastructure
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: azure
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: cloudprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureConfig
</span></span><span style=display:flex><span>    resourceGroup:
</span></span><span style=display:flex><span>      name: mygroup
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  state: |<span style=color:#a31515>
</span></span></span><span style=display:flex><span><span style=color:#a31515>    {
</span></span></span><span style=display:flex><span><span style=color:#a31515>      &#34;version&#34;: 3,
</span></span></span><span style=display:flex><span><span style=color:#a31515>      &#34;terraform_version&#34;: &#34;0.11.14&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a31515>      &#34;serial&#34;: 2,
</span></span></span><span style=display:flex><span><span style=color:#a31515>      &#34;lineage&#34;: &#34;3a1e2faa-e7b6-f5f0-5043-368dd8ea6c10&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a31515>      ...
</span></span></span><span style=display:flex><span><span style=color:#a31515>    }</span>    
</span></span></code></pre></div><p>Extension controllers that do not use a saved state and therefore do not require state migration could leave the <code>status.state</code> field as <code>nil</code> at the end of a successful reconciliation, and just perform a normal reconciliation when the current operation is <code>restore</code>.</p><p>In addition, extension controllers that use <a href=/docs/gardener/extensions/referenced-resources/>referenced resources</a> (usually secrets) must also make sure that these resources are added to the <code>status.resources</code> field of their extension resource at the end of a successful reconciliation, so they could be properly migrated by Gardener to the destination seed.</p><h2 id=implementation-details>Implementation Details<a class=td-heading-self-link href=#implementation-details aria-label="Heading self-link"></a></h2><h3 id=migrate-and-restore-actuator-methods>Migrate and Restore Actuator Methods<a class=td-heading-self-link href=#migrate-and-restore-actuator-methods aria-label="Heading self-link"></a></h3><p>Most extension controller implementations follow a common pattern where a generic <code>Reconciler</code> implementation delegates to an <code>Actuator</code> interface that contains the methods <code>Reconcile</code> and <code>Delete</code>, provided by the extension.
Two methods <code>Migrate</code> and <code>Restore</code> are available in all such <code>Actuator</code> interfaces, see <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go>the infrastructure <code>Actuator</code> interface</a> as an example.
These methods are called by the generic reconcilers for the <a href=/docs/gardener/extensions/migration/#migrate-and-restore-operations>migrate and restore operations</a> respectively, and should be implemented by the extension according to the above guidelines.</p><h3 id=extension-controllers-based-on-generic-actuators>Extension Controllers Based on Generic Actuators<a class=td-heading-self-link href=#extension-controllers-based-on-generic-actuators aria-label="Heading self-link"></a></h3><p>In practice, the implementation of many extension controllers (for example, the <code>ControlPlane</code> and <code>Worker</code> controllers in most provider extensions) are based on a <em>generic <code>Actuator</code> implementation</em> that only delegates to extension methods for behavior that is truly provider specific.
In all such cases, the <code>Migrate</code> and <code>Restore</code> methods have already been implemented properly in the generic actuators and there is nothing more to do in the extension itself.</p><p>In some rare cases, extension controllers based on a generic actuator might still introduce a custom <code>Actuator</code> implementation to override some of the generic actuator methods in order to enhance or change their behavior in a certain way.
In such cases, the <code>Migrate</code> and <code>Restore</code> methods might need to be overridden as well, see the <a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/controlplane>Azure controlplane controller</a> as an example.</p><h4 id=worker-state><code>Worker</code> State<a class=td-heading-self-link href=#worker-state aria-label="Heading self-link"></a></h4><p>Note that the machine state is handled specially by <code>gardenlet</code> (i.e., all relevant objects in the <code>machine.sapcloud.io/v1alpha1</code> API are directly persisted by <code>gardenlet</code> and <strong>NOT</strong> by the generic actuators).
In the past, they were persisted to the <code>Worker</code>&rsquo;s <code>.status.state</code> field by the so-called &ldquo;worker state reconciler&rdquo;, however, this reconciler was dropped and changed as part of <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/22-improved-usage-of-shootstate-api.md#eliminating-the-worker-state-reconciler>GEP-22</a>.
Nowadays, <code>gardenlet</code> directly writes the state to the <code>ShootState</code> resource during the <code>Migrate</code> phase of a <code>Shoot</code> (without the detour of the <code>Worker</code>&rsquo;s <code>.status.state</code> field).
On restoration, unlike for other extension kinds, <code>gardenlet</code> no longer populates the machine state into the <code>Worker</code>&rsquo;s <code>.status.state</code> field.
Instead, the extension controller should read the machine state directly from the <code>ShootState</code> in the garden cluster (see <a href=/docs/gardener/extensions/garden-api-access/>this document</a> for information how to access the garden cluster) and use it to subsequently restore the relevant <code>machine.sapcloud.io/v1alpha1</code> resources.
This flow is implemented in the <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/worker/genericactuator/actuator_restore.go>generic <code>Worker</code> actuator</a>.
As a result, Extension controllers using this generic actuator do not need to implement any custom logic.</p><h3 id=extension-controllers-not-based-on-generic-actuators>Extension Controllers Not Based on Generic Actuators<a class=td-heading-self-link href=#extension-controllers-not-based-on-generic-actuators aria-label="Heading self-link"></a></h3><p>The implementation of some extension controllers (for example, the infrastructure controllers in all provider extensions) are not based on a generic <code>Actuator</code> implementation.
Such extension controllers must always provide a proper implementation of the <code>Migrate</code> and <code>Restore</code> methods according to the above guidelines, see the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure>AWS infrastructure controller</a> as an example.
In practice, this might result in code duplication between the different extensions, since the <code>Migrate</code> and <code>Restore</code> code is usually not provider or OS-specific.</p><blockquote><p>If you do not use the generic <code>Worker</code> actuator, see <a href=/docs/gardener/extensions/migration/#worker-state>this section</a> for information how to handle the machine state related to the <code>Worker</code> resource.</p></blockquote></div><div class=td-content style=page-break-before:always><h1 id=pg-d20ec57f1c788e4c86ed68fe624544eb>12 - Project Roles</h1><h1 id=extending-project-roles>Extending Project Roles<a class=td-heading-self-link href=#extending-project-roles aria-label="Heading self-link"></a></h1><p>The <code>Project</code> resource allows to specify a list of roles for every member (<code>.spec.members[*].roles</code>).
There are a few standard roles defined by Gardener itself.
Please consult <a href=/docs/gardener/project/projects/>Projects</a> for further information.</p><p>However, extension controllers running in the garden cluster may also create <code>CustomResourceDefinition</code>s that project members might be able to CRUD.
For this purpose, Gardener also allows to specify extension roles.</p><p>An extension role is prefixed with <code>extension:</code>, e.g.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: Project
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: dev
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  members:
</span></span><span style=display:flex><span>  - apiGroup: rbac.authorization.k8s.io
</span></span><span style=display:flex><span>    kind: User
</span></span><span style=display:flex><span>    name: alice.doe@example.com
</span></span><span style=display:flex><span>    role: admin
</span></span><span style=display:flex><span>    roles:
</span></span><span style=display:flex><span>    - owner
</span></span><span style=display:flex><span>    - extension:foo
</span></span></code></pre></div><p>The project controller will, for every extension role, create a <code>ClusterRole</code> with name <code>gardener.cloud:extension:project:&lt;projectName>:&lt;roleName></code>, i.e., for the above example: <code>gardener.cloud:extension:project:dev:foo</code>.
This <code>ClusterRole</code> aggregates other <code>ClusterRole</code>s that are labeled with <code>rbac.gardener.cloud/aggregate-to-extension-role=foo</code> which might be created by extension controllers.</p><p>An extension that might want to contribute to the core <code>admin</code> or <code>viewer</code> roles can use the labels <code>rbac.gardener.cloud/aggregate-to-project-member=true</code> or <code>rbac.gardener.cloud/aggregate-to-project-viewer=true</code>, respectively.</p><p>Please note that the names of the extension roles are restricted to 20 characters!</p><p>Moreover, the project controller will also create a corresponding <code>RoleBinding</code> with the same name in the project namespace.
It will automatically assign all members that are assigned to this extension role.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-45f5e5c8792c123831d7123647c5db0c>13 - Provider Local</h1><h1 id=local-provider-extension>Local Provider Extension<a class=td-heading-self-link href=#local-provider-extension aria-label="Heading self-link"></a></h1><p>The &ldquo;local provider&rdquo; extension is used to allow the usage of seed and shoot clusters which run entirely locally without any real infrastructure or cloud provider involved.
It implements Gardener&rsquo;s extension contract (<a href=https://github.com/gardener/gardener/blob/master/docs/proposals/01-extensibility.md>GEP-1</a>) and thus comprises several controllers and webhooks acting on resources in seed and shoot clusters.</p><p>The code is maintained in <a href=https://github.com/gardener/gardener/tree/master/pkg/provider-local><code>pkg/provider-local</code></a>.</p><h2 id=motivation>Motivation<a class=td-heading-self-link href=#motivation aria-label="Heading self-link"></a></h2><p>The motivation for maintaining such extension is the following:</p><ul><li>🛡 Output Qualification: Run fast and cost-efficient end-to-end tests, locally and in CI systems (increased confidence ⛑ before merging pull requests)</li><li>⚙️ Development Experience: Develop Gardener entirely on a local machine without any external resources involved (improved costs 💰 and productivity 🚀)</li><li>🤝 Open Source: Quick and easy setup for a first evaluation of Gardener and a good basis for first contributions</li></ul><h2 id=current-limitations>Current Limitations<a class=td-heading-self-link href=#current-limitations aria-label="Heading self-link"></a></h2><p>The following enlists the current limitations of the implementation.
Please note that all of them are not technical limitations/blockers, but simply advanced scenarios that we haven&rsquo;t had invested yet into.</p><ol><li><p>No load balancers for Shoot clusters.</p><p><em>We have not yet developed a <code>cloud-controller-manager</code> which could reconcile load balancer <code>Service</code>s in the shoot cluster.</em></p></li><li><p>In case a seed cluster with multiple availability zones, i.e. multiple entries in <code>.spec.provider.zones</code>, is used in conjunction with a single-zone shoot control plane, i.e. a shoot cluster without <code>.spec.controlPlane.highAvailability</code> or with <code>.spec.controlPlane.highAvailability.failureTolerance.type</code> set to <code>node</code>, the local address of the API server endpoint needs to be determined manually or via the in-cluster <code>coredns</code>.</p><p><em>As the different istio ingress gateway loadbalancers have individual external IP addresses, single-zone shoot control planes can end up in a random availability zone. Having the local host use the <code>coredns</code> in the cluster as name resolver would form a name resolution cycle. The tests mitigate the issue by adapting the DNS configuration inside the affected test.</em></p></li></ol><h2 id=managedseeds><code>ManagedSeed</code>s<a class=td-heading-self-link href=#managedseeds aria-label="Heading self-link"></a></h2><p>It is possible to deploy <a href=/docs/gardener/managed_seed/><code>ManagedSeed</code>s</a> with <code>provider-local</code> by first creating a <a href=https://github.com/gardener/gardener/blob/master/example/provider-local/managedseeds/shoot-managedseed.yaml><code>Shoot</code> in the <code>garden</code> namespace</a> and then creating a referencing <a href=https://github.com/gardener/gardener/blob/master/example/provider-local/managedseeds/managedseed.yaml><code>ManagedSeed</code> object</a>.</p><blockquote><p>Please note that this is only supported by the <a href=/docs/gardener/deployment/getting_started_locally/><code>Skaffold</code>-based setup</a>.</p></blockquote><p>The corresponding e2e test can be run via:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./hack/test-e2e-local.sh --label-filter <span style=color:#a31515>&#34;ManagedSeed&#34;</span>
</span></span></code></pre></div><h3 id=implementation-details>Implementation Details<a class=td-heading-self-link href=#implementation-details aria-label="Heading self-link"></a></h3><p>The images locally built by <code>Skaffold</code> for the Gardener components which are deployed to this shoot cluster are managed by a container registry in the <code>registry</code> namespace in the kind cluster.
<code>provider-local</code> configures this registry as mirror for the shoot by mutating the <code>OperatingSystemConfig</code> and using the <a href=/docs/gardener/advanced/custom-containerd-config/>default contract for extending the <code>containerd</code> configuration</a>.</p><p>In order to bootstrap a seed cluster, the <code>gardenlet</code> deploys <code>PersistentVolumeClaim</code>s and <code>Service</code>s of type <code>LoadBalancer</code>.
While storage is supported in shoot clusters by using the <a href=https://github.com/rancher/local-path-provisioner><code>local-path-provisioner</code></a>, load balancers are not supported yet.
However, <code>provider-local</code> runs a <code>Service</code> controller which specifically reconciles the seed-related <code>Service</code>s of type <code>LoadBalancer</code>.
This way, they get an IP and <code>gardenlet</code> can finish its bootstrapping process.
Note that these IPs are not reachable, however for the sake of developing <code>ManagedSeed</code>s this is sufficient for now.</p><p>Also, please note that the <code>provider-local</code> extension only gets deployed because of the <code>Always</code> deployment policy in its corresponding <code>ControllerRegistration</code> and because the DNS provider type of the seed is set to <code>local</code>.</p><h2 id=implementation-details-1>Implementation Details<a class=td-heading-self-link href=#implementation-details-1 aria-label="Heading self-link"></a></h2><p>This section contains information about how the respective controllers and webhooks in <code>provider-local</code> are implemented and what their purpose is.</p><h3 id=bootstrapping>Bootstrapping<a class=td-heading-self-link href=#bootstrapping aria-label="Heading self-link"></a></h3><p>The Helm chart of the <code>provider-local</code> extension defined in its <a href=/docs/gardener/extensions/registration/><code>Extension</code></a> contains a special deployment for a <a href=https://coredns.io/>CoreDNS</a> instance in a <code>gardener-extension-provider-local-coredns</code> namespace in the seed cluster.</p><p>This CoreDNS instance is responsible for enabling the components running in the shoot clusters to be able to resolve the DNS names when they communicate with their <code>kube-apiserver</code>s.</p><p>It contains a static configuration to resolve the DNS names based on <code>local.gardener.cloud</code> to <code>istio-ingressgateway.istio-ingress.svc</code>.</p><h3 id=controllers>Controllers<a class=td-heading-self-link href=#controllers aria-label="Heading self-link"></a></h3><p>There are controllers for all resources in the <code>extensions.gardener.cloud/v1alpha1</code> API group except for <code>BackupBucket</code> and <code>BackupEntry</code>s.</p><h4 id=controlplane><code>ControlPlane</code><a class=td-heading-self-link href=#controlplane aria-label="Heading self-link"></a></h4><p>This controller is deploying the <a href=https://github.com/rancher/local-path-provisioner>local-path-provisioner</a> as well as a related <code>StorageClass</code> in order to support <code>PersistentVolumeClaim</code>s in the local shoot cluster.
Additionally, it creates a few (currently unused) dummy secrets (CA, server and client certificate, basic auth credentials) for the sake of testing the secrets manager integration in the extensions library.</p><h4 id=dnsrecord><code>DNSRecord</code><a class=td-heading-self-link href=#dnsrecord aria-label="Heading self-link"></a></h4><p>The controller adapts the cluster internal DNS configuration by extending the <code>coredns</code> configuration for every observed <code>DNSRecord</code>. It will add two corresponding entries in the custom DNS configuration per shoot cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  api.local.local.external.local.gardener.cloud.override: |
</span></span><span style=display:flex><span>    rewrite stop name regex api.local.local.external.local.gardener.cloud istio-ingressgateway.istio-ingress.svc.cluster.local answer auto
</span></span><span style=display:flex><span>  api.local.local.internal.local.gardener.cloud.override: |
</span></span><span style=display:flex><span>    rewrite stop name regex api.local.local.internal.local.gardener.cloud istio-ingressgateway.istio-ingress.svc.cluster.local answer auto
</span></span></code></pre></div><h4 id=infrastructure><code>Infrastructure</code><a class=td-heading-self-link href=#infrastructure aria-label="Heading self-link"></a></h4><p>This controller generates a <code>NetworkPolicy</code> which allows the control plane pods (like <code>kube-apiserver</code>) to communicate with the worker machine pods (see <a href=/docs/gardener/extensions/provider-local/#worker><code>Worker</code> section</a>).</p><h4 id=network><code>Network</code><a class=td-heading-self-link href=#network aria-label="Heading self-link"></a></h4><p>This controller is not implemented anymore. In the initial version of <code>provider-local</code>, there was a <code>Network</code> controller deploying <a href=https://github.com/kubernetes-sigs/kind/blob/main/images/kindnetd/README.md>kindnetd</a> (see <a href=https://github.com/gardener/gardener/tree/v1.44.1/pkg/provider-local/controller/network>release v1.44.1</a>).
However, we decided to drop it because this setup prevented us from using <code>NetworkPolicy</code>s (kindnetd does not ship a <code>NetworkPolicy</code> controller).
In addition, we had issues with shoot clusters having more than one node (hence, we couldn&rsquo;t support rolling updates, see <a href=https://github.com/gardener/gardener/pull/5666/commits/491b3cd16e40e5c20ef02367fda93a34ff9465eb>PR #5666</a>).</p><h4 id=operatingsystemconfig><code>OperatingSystemConfig</code><a class=td-heading-self-link href=#operatingsystemconfig aria-label="Heading self-link"></a></h4><p>This controller renders a simple cloud-init template which can later be executed by the shoot worker nodes.</p><p>The shoot worker nodes are <code>Pod</code>s with a container based on the <code>kindest/node</code> image. This is maintained in the <a href=https://github.com/gardener/machine-controller-manager-provider-local/tree/master/node>gardener/machine-controller-manager-provider-local repository</a> and has a special <code>run-userdata</code> systemd service which executes the cloud-init generated earlier by the <code>OperatingSystemConfig</code> controller.</p><h4 id=worker><code>Worker</code><a class=td-heading-self-link href=#worker aria-label="Heading self-link"></a></h4><p>This controller leverages the standard <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker/genericactuator>generic <code>Worker</code> actuator</a> in order to deploy the <a href=https://github.com/gardener/machine-controller-manager><code>machine-controller-manager</code></a> as well as the <a href=https://github.com/gardener/machine-controller-manager-provider-local><code>machine-controller-manager-provider-local</code></a>.</p><p>Additionally, it generates the <a href=https://github.com/gardener/machine-controller-manager-provider-local/blob/master/kubernetes/machine-class.yaml><code>MachineClass</code>es</a> and the <code>MachineDeployment</code>s based on the specification of the <code>Worker</code> resources.</p><h4 id=ingress><code>Ingress</code><a class=td-heading-self-link href=#ingress aria-label="Heading self-link"></a></h4><p>The gardenlet creates a wildcard DNS record for the Seed&rsquo;s ingress domain pointing to the <code>nginx-ingress-controller</code>&rsquo;s LoadBalancer.
This domain is commonly used by all <code>Ingress</code> objects created in the Seed for Seed and Shoot components.
As provider-local implements the <code>DNSRecord</code> extension API (see the <a href=/docs/gardener/extensions/provider-local/#dnsrecord><code>DNSRecord</code>section</a>), this controller reconciles all <code>Ingress</code>s and creates <code>DNSRecord</code>s of type <code>local</code> for each host included in <code>spec.rules</code>.
This only happens for shoot namespaces (<code>gardener.cloud/role=shoot</code> label) to make <code>Ingress</code> domains resolvable on the machine pods.</p><h4 id=service><code>Service</code><a class=td-heading-self-link href=#service aria-label="Heading self-link"></a></h4><p>This controller reconciles <code>Services</code> of type <code>LoadBalancer</code> in the local <code>Seed</code> cluster.
Since the local Kubernetes clusters used as Seed clusters typically don&rsquo;t support such services, this controller sets the <code>.status.ingress.loadBalancer.ip[0]</code> to the IP of the host.
It makes important LoadBalancer Services (e.g. <code>istio-ingress/istio-ingressgateway</code> and <code>garden/nginx-ingress-controller</code>) available to the host by setting <code>spec.ports[].nodePort</code> to well-known ports that are mapped to <code>hostPorts</code> in the kind cluster configuration.</p><p><code>istio-ingress/istio-ingressgateway</code> is set to be exposed on <code>nodePort</code> <code>30433</code> by this controller.</p><p>In case the seed has multiple availability zones (<code>.spec.provider.zones</code>) and it uses SNI, the different zone-specific <code>istio-ingressgateway</code> loadbalancers are exposed via different IP addresses. Per default, IP addresses <code>172.18.255.10</code>, <code>172.18.255.11</code>, and <code>172.18.255.12</code> are used for the zones <code>0</code>, <code>1</code>, and <code>2</code> respectively.</p><h4 id=etcd-backups>ETCD Backups<a class=td-heading-self-link href=#etcd-backups aria-label="Heading self-link"></a></h4><p>This controller reconciles the <code>BackupBucket</code> and <code>BackupEntry</code> of the shoot allowing the <code>etcd-backup-restore</code> to create and copy backups using the <code>local</code> provider functionality. The backups are stored on the host file system. This is achieved by mounting that directory to the <code>etcd-backup-restore</code> container.</p><h4 id=extension-seed>Extension Seed<a class=td-heading-self-link href=#extension-seed aria-label="Heading self-link"></a></h4><p>This controller reconciles <code>Extensions</code> of type <code>local-ext-seed</code>. It creates a single <code>serviceaccount</code> named <code>local-ext-seed</code> in the shoot&rsquo;s namespace in the seed. The extension is reconciled before the <code>kube-apiserver</code>. More on extension lifecycle strategies can be read in <a href=/docs/gardener/extensions/registration/#extension-lifecycle>Registering Extension Controllers</a>.</p><h4 id=extension-shoot>Extension Shoot<a class=td-heading-self-link href=#extension-shoot aria-label="Heading self-link"></a></h4><p>This controller reconciles <code>Extensions</code> of type <code>local-ext-shoot</code>. It creates a single <code>serviceaccount</code> named <code>local-ext-shoot</code> in the <code>kube-system</code> namespace of the shoot. The extension is reconciled after the <code>kube-apiserver</code>. More on extension lifecycle strategies can be read <a href=/docs/gardener/extensions/registration/#extension-lifecycle>Registering Extension Controllers</a>.</p><h4 id=extension-shoot-after-worker>Extension Shoot After Worker<a class=td-heading-self-link href=#extension-shoot-after-worker aria-label="Heading self-link"></a></h4><p>This controller reconciles <code>Extensions</code> of type <code>local-ext-shoot-after-worker</code>. It creates a <code>deployment</code> named <code>local-ext-shoot-after-worker</code> in the <code>kube-system</code> namespace of the shoot. The extension is reconciled after the workers and waits until the deployment is ready. More on extension lifecycle strategies can be read <a href=/docs/gardener/extensions/registration/#extension-lifecycle>Registering Extension Controllers</a>.</p><h4 id=health-checks>Health Checks<a class=td-heading-self-link href=#health-checks aria-label="Heading self-link"></a></h4><p>The health check controller leverages the <a href=/docs/gardener/extensions/healthcheck-library/>health check library</a> in order to:</p><ul><li>check the health of the <code>ManagedResource/extension-controlplane-shoot-webhooks</code> and populate the <code>SystemComponentsHealthy</code> condition in the <code>ControlPlane</code> resource.</li><li>check the health of the <code>ManagedResource/extension-networking-local</code> and populate the <code>SystemComponentsHealthy</code> condition in the <code>Network</code> resource.</li><li>check the health of the <code>ManagedResource/extension-worker-mcm-shoot</code> and populate the <code>SystemComponentsHealthy</code> condition in the <code>Worker</code> resource.</li><li>check the health of the <code>Deployment/machine-controller-manager</code> and populate the <code>ControlPlaneHealthy</code> condition in the <code>Worker</code> resource.</li><li>check the health of the <code>Node</code>s and populate the <code>EveryNodeReady</code> condition in the <code>Worker</code> resource.</li></ul><h3 id=webhooks>Webhooks<a class=td-heading-self-link href=#webhooks aria-label="Heading self-link"></a></h3><h4 id=control-plane>Control Plane<a class=td-heading-self-link href=#control-plane aria-label="Heading self-link"></a></h4><p>This webhook reacts on the <code>OperatingSystemConfig</code> containing the configuration of the kubelet and sets the <code>failSwapOn</code> to <code>false</code> (independent of what is configured in the <code>Shoot</code> spec) (<a href=https://github.com/kubernetes-sigs/kind/blob/b6bc112522651d98c81823df56b7afa511459a3b/site/content/docs/design/node-image.md#design>ref</a>).</p><h4 id=dns-config>DNS Config<a class=td-heading-self-link href=#dns-config aria-label="Heading self-link"></a></h4><p>This webhook reacts on events for the <code>dependency-watchdog-probe</code> <code>Deployment</code>, the <code>blackbox-exporter</code> <code>Deployment</code>, as well as on events for <code>Pod</code>s created when the <code>machine-controller-manager</code> reconciles <code>Machine</code>s.
All these pods need to be able to resolve the DNS names for shoot clusters.
It sets the <code>.spec.dnsPolicy=None</code> and <code>.spec.dnsConfig.nameServers</code> to the cluster IP of the <code>coredns</code> <code>Service</code> created in the <code>gardener-extension-provider-local-coredns</code> namespaces so that these pods can resolve the DNS records for shoot clusters (see the <a href=/docs/gardener/extensions/provider-local/#bootstrapping>Bootstrapping section</a> for more details).</p><h4 id=machine-controller-manager>Machine Controller Manager<a class=td-heading-self-link href=#machine-controller-manager aria-label="Heading self-link"></a></h4><p>This webhook mutates the global <code>ClusterRole</code> related to <code>machine-controller-manager</code> and injects permissions for <code>Service</code> resources.
The <code>machine-controller-manager-provider-local</code> deploys <code>Pod</code>s for each <code>Machine</code> (while real infrastructure provider obviously deploy VMs, so no Kubernetes resources directly).
It also deploys a <code>Service</code> for these machine pods, and in order to do so, the <code>ClusterRole</code> must allow the needed permissions for <code>Service</code> resources.</p><h4 id=node>Node<a class=td-heading-self-link href=#node aria-label="Heading self-link"></a></h4><p>This webhook reacts on updates to <code>nodes/status</code> in both seed and shoot clusters and sets the <code>.status.{allocatable,capacity}.cpu="100"</code> and <code>.status.{allocatable,capacity}.memory="100Gi"</code> fields.</p><p>Background: Typically, the <code>.status.{capacity,allocatable}</code> values are determined by the resources configured for the Docker daemon (see for example the <a href=https://docs.docker.com/desktop/mac/#resources>docker Quick Start Guide</a> for Mac).
Since many of the <code>Pod</code>s deployed by Gardener have quite high <code>.spec.resources.requests</code>, the <code>Node</code>s easily get filled up and only a few <code>Pod</code>s can be scheduled (even if they barely consume any of their reserved resources).
In order to improve the user experience, on startup/leader election the provider-local extension submits an empty patch which triggers the &ldquo;node webhook&rdquo; (see the below section) for the seed cluster.
The webhook will increase the capacity of the <code>Node</code>s to allow all <code>Pod</code>s to be scheduled.
For the shoot clusters, this empty patch trigger is not needed since the <code>MutatingWebhookConfiguration</code> is reconciled by the <code>ControlPlane</code> controller and exists before the <code>Node</code> object gets registered.</p><h4 id=shoot>Shoot<a class=td-heading-self-link href=#shoot aria-label="Heading self-link"></a></h4><p>This webhook reacts on the <code>ConfigMap</code> used by the <code>kube-proxy</code> and sets the <code>maxPerCore</code> field to <code>0</code> since other values don&rsquo;t work well in conjunction with the <code>kindest/node</code> image which is used as base for the shoot worker machine pods (<a href=https://github.com/kubernetes-sigs/kind/blob/fa7d86470f4c0e924fc4c2e767ec8491c45f4304/pkg/cluster/internal/kubeadm/config.go#L283-L285>ref</a>).</p><h3 id=dns-configuration-for-multi-zonal-seeds>DNS Configuration for Multi-Zonal Seeds<a class=td-heading-self-link href=#dns-configuration-for-multi-zonal-seeds aria-label="Heading self-link"></a></h3><p>In case a seed cluster has multiple availability zones as specified in <code>.spec.provider.zones</code>, multiple istio ingress gateways are deployed, one per availability zone in addition to the default deployment. The result is that single-zone shoot control planes, i.e. shoot clusters with <code>.spec.controlPlane.highAvailability</code> set or with <code>.spec.controlPlane.highAvailability.failureTolerance.type</code> set to <code>node</code>, may be exposed via any of the zone-specific istio ingress gateways. Previously, the endpoints were statically mapped via <code>/etc/hosts</code>. Unfortunately, this is no longer possible due to the aforementioned dynamic in the endpoint selection.</p><p>For multi-zonal seed clusters, there is an additional configuration following <code>coredns</code>&rsquo;s <a href=https://github.com/coredns/coredns/tree/master/plugin/view>view plugin</a> mapping the external IP addresses of the zone-specific loadbalancers to the corresponding internal istio ingress gateway domain names. This configuration is only in place for requests from outside of the seed cluster. Those requests are currently being identified by the protocol. UDP requests are interpreted as originating from within the seed cluster while TCP requests are assumed to come from outside the cluster via the docker hostport mapping.</p><p>The corresponding test sets the DNS configuration accordingly so that the name resolution during the test use <code>coredns</code> in the cluster.</p><h3 id=machine-controller-manager-provider-local>machine-controller-manager-provider-local<a class=td-heading-self-link href=#machine-controller-manager-provider-local aria-label="Heading self-link"></a></h3><p>Out of tree (controller-based) implementation for <code>local</code> as a new provider.
The local out-of-tree provider implements the interface defined at <a href=https://github.com/gardener/machine-controller-manager/blob/master/pkg/util/provider/driver/driver.go>MCM OOT driver</a>.</p><h4 id=fundamental-design-principles>Fundamental Design Principles<a class=td-heading-self-link href=#fundamental-design-principles aria-label="Heading self-link"></a></h4><p>Following are the basic principles kept in mind while developing the external plugin.</p><ul><li>Communication between this Machine Controller (MC) and Machine Controller Manager (MCM) is achieved using the Kubernetes native declarative approach.</li><li>Machine Controller (MC) behaves as the controller used to interact with the <code>local</code> provider and manage the VMs corresponding to the machine objects.</li><li>Machine Controller Manager (MCM) deals with higher level objects such as machine-set and machine-deployment objects.</li></ul><h2 id=future-work>Future Work<a class=td-heading-self-link href=#future-work aria-label="Heading self-link"></a></h2><p>Future work could mostly focus on resolving the above listed <a href=/docs/gardener/extensions/provider-local/#limitations>limitations</a>, i.e.:</p><ul><li>Implement a <code>cloud-controller-manager</code> and deploy it via the <a href=/docs/gardener/extensions/provider-local/#controlplane><code>ControlPlane</code> controller</a>.</li><li>Properly implement <code>.spec.machineTypes</code> in the <code>CloudProfile</code>s (i.e., configure <code>.spec.resources</code> properly for the created shoot worker machine pods).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-874f35cd0bbeb8acb3c1033b641e3d43>14 - Reconcile Trigger</h1><h1 id=reconcile-trigger>Reconcile Trigger<a class=td-heading-self-link href=#reconcile-trigger aria-label="Heading self-link"></a></h1><p>Gardener dictates the time of reconciliation for resources of the API group <code>extensions.gardener.cloud</code>.
It does that by annotating the respected resource with <code>gardener.cloud/operation=reconcile</code>.
Extension controllers shall react to this annotation and start reconciling the resource.
They have to remove this annotation as soon as they begin with their reconcile operation and maintain the <code>status</code> of the extension resource accordingly.</p><p>The reason for this behaviour is that it is possible to configure Gardener to reconcile only in the shoots&rsquo; maintenance time windows.
In order to avoid that, extension controllers reconcile outside of the shoot&rsquo;s maintenance time window we have introduced this contract.
This way extension controllers don&rsquo;t need to care about when the shoot maintenance time window happens.
Gardener keeps control and decides when the shoot shall be reconciled/updated.</p><p>Our <a href=https://github.com/gardener/gardener/tree/master/extensions>extension controller library</a> provides all the required utilities to conveniently implement this behaviour.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-df45cc83f21d97b2fdcceee7d9127056>15 - Referenced Resources</h1><h1 id=referenced-resources>Referenced Resources<a class=td-heading-self-link href=#referenced-resources aria-label="Heading self-link"></a></h1><p><code>Shoot</code>s and <code>Seed</code>s can include a list of resources (usually secrets) that can be referenced by name in the extension <code>providerConfig</code> and other Shoot sections, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kind: Shoot
</span></span><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: crazy-botany
</span></span><span style=display:flex><span>  namespace: garden-dev
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  extensions:
</span></span><span style=display:flex><span>  - type: foobar
</span></span><span style=display:flex><span>    providerConfig:
</span></span><span style=display:flex><span>      apiVersion: foobar.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>      kind: FooBarConfig
</span></span><span style=display:flex><span>      foo: bar
</span></span><span style=display:flex><span>      secretRef: foobar-secret
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>  - name: foobar-secret
</span></span><span style=display:flex><span>    resourceRef:
</span></span><span style=display:flex><span>      apiVersion: v1
</span></span><span style=display:flex><span>      kind: Secret
</span></span><span style=display:flex><span>      name: my-foobar-secret
</span></span></code></pre></div><p>Gardener expects these referenced resources to be located in the project namespace (e.g., <code>garden-dev</code>) for <code>Shoot</code>s and in the <code>garden</code> namespace for <code>Seed</code>s.
<code>Seed</code> resources are copied to the <code>garden</code> namespace in the seed cluster, while <code>Shoot</code> resources are copied to the control-plane namespace in the shoot cluster.
To avoid conflicts with other resources in the shoot, all resources in the seed are prefixed with a static value.</p><p>Extension controllers can resolve the references to these resources by accessing the Shoot via the <code>Cluster</code> resource. To properly read a referenced resources, extension controllers should use the utility function <code>GetObjectByReference</code> from the <code>extensions/pkg/controller</code> package, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    ref = &amp;autoscalingv1.CrossVersionObjectReference{
</span></span><span style=display:flex><span>        APIVersion: <span style=color:#a31515>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>        Kind:       <span style=color:#a31515>&#34;Secret&#34;</span>,
</span></span><span style=display:flex><span>        Name:       <span style=color:#a31515>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    secret := &amp;corev1.Secret{}
</span></span><span style=display:flex><span>    <span style=color:#00f>if</span> err := controller.GetObjectByReference(ctx, client, ref, <span style=color:#a31515>&#34;shoot--test--foo&#34;</span>, secret); err != <span style=color:#00f>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#00f>return</span> err
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:green>// Use secret
</span></span></span><span style=display:flex><span><span style=color:green></span>    ...
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b96820cc3e0edad09e2d87e52ac54e38>16 - Registering Extension Controllers</h1><h1 id=registering-extension-controllers>Registering Extension Controllers<a class=td-heading-self-link href=#registering-extension-controllers aria-label="Heading self-link"></a></h1><p>Before Gardener can manage shoot clusters, it needs to know which required and optional extensions are available in the landscape.
The following sections explain the general registration process for extensions.</p><h2 id=extensions><code>Extension</code>s<a class=td-heading-self-link href=#extensions aria-label="Heading self-link"></a></h2><p>The registration starts by creating <a href=https://github.com/gardener/gardener/blob/master/example/operator/15-extension.yaml><code>Extension</code></a> resources in the garden runtime cluster.
They represent the single source for all deployment aspects an extension may offer (garden, seed, shoot, admission).
The <code>gardener-operator</code> takes these resources to deploy the extension controllers to the garden runtime cluster, as well as creating corresponding <a href=https://github.com/gardener/gardener/blob/master/example/25-controllerregistration.yaml><code>ControllerRegistration</code></a> and <a href=https://github.com/gardener/gardener/blob/master/example/25-controllerdeployment.yaml><code>ControllerDeployment</code></a> resources in the virtual garden cluster.</p><p>Please see the following example of an <code>Extension</code> resource which mainly configures:</p><ul><li>The resource kinds and types the extension is responsible for</li><li>A Reference the OCI Helm chart(s) for the extension admission and optional values</li><li>A Reference the OCI Helm chart for the extension controller</li><li>Optional values for the extension in the garden runtime cluster</li><li>Optional values for the deployment in the seed clusters</li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: operator.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Extension
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: provider-local
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>  - kind: BackupBucket
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: BackupEntry
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: DNSRecord
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: Infrastructure
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: ControlPlane
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: Worker
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  deployment:
</span></span><span style=display:flex><span>    admission:
</span></span><span style=display:flex><span>      runtimeCluster:
</span></span><span style=display:flex><span>        helm:
</span></span><span style=display:flex><span>          ociRepository:
</span></span><span style=display:flex><span>            ref: registry.example.com/gardener/extensions/local/admission-runtime:v1.0.0
</span></span><span style=display:flex><span>      virtualCluster:
</span></span><span style=display:flex><span>        helm:
</span></span><span style=display:flex><span>          ociRepository:
</span></span><span style=display:flex><span>            ref: registry.example.com/gardener/extensions/local/adission-application:v1.0.0
</span></span><span style=display:flex><span>      values: {}
</span></span><span style=display:flex><span>    extension:
</span></span><span style=display:flex><span>      helm:
</span></span><span style=display:flex><span>          ociRepository:
</span></span><span style=display:flex><span>            ref: registry.example.com/gardener/extensions/local/extension:v1.0.0
</span></span><span style=display:flex><span>      values:
</span></span><span style=display:flex><span>         controllers:
</span></span><span style=display:flex><span>           dnsrecord:
</span></span><span style=display:flex><span>             concurrentSyncs: 20
</span></span><span style=display:flex><span>      runtimeClusterValues:
</span></span><span style=display:flex><span>        controllers:
</span></span><span style=display:flex><span>          dnsrecord:
</span></span><span style=display:flex><span>            concurrentSyncs: 1
</span></span></code></pre></div><p>Operators may use <code>Extension</code>s to observe their status conditions, regularly updated by <code>gardener-operator</code>.
They provide more information about whether an extension is currently in use and if their installation was successful.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  conditions:
</span></span><span style=display:flex><span>  - lastTransitionTime: <span style=color:#a31515>&#34;2025-03-12T13:46:51Z&#34;</span>
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2025-03-12T13:46:51Z&#34;</span>
</span></span><span style=display:flex><span>    message: Extension required for kinds [DNSRecord]
</span></span><span style=display:flex><span>    reason: ExtensionRequired
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>    type: RequiredRuntime
</span></span><span style=display:flex><span>  - lastTransitionTime: <span style=color:#a31515>&#34;2025-01-20T10:39:47Z&#34;</span>
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2025-01-20T10:39:47Z&#34;</span>
</span></span><span style=display:flex><span>    message: Extension has required ControllerInstallations for seed clusters
</span></span><span style=display:flex><span>    reason: RequiredControllerInstallation
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>    type: RequiredVirtual
</span></span><span style=display:flex><span>  - lastTransitionTime: <span style=color:#a31515>&#34;2025-04-03T06:42:37Z&#34;</span>
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2025-04-03T06:42:37Z&#34;</span>
</span></span><span style=display:flex><span>    message: Extension has been reconciled successfully
</span></span><span style=display:flex><span>    reason: ReconcileSuccessful
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>    type: Installed
</span></span></code></pre></div><h2 id=controllerregistrations><code>ControllerRegistration</code>s<a class=td-heading-self-link href=#controllerregistrations aria-label="Heading self-link"></a></h2><p>In the virtual garden cluster, the native extension registration resource kinds are <code>ControllerRegistration</code> and <code>ControllerDeployment</code>.
These resources are usually created by the <code>gardener-operator</code> based on <code>Extension</code>s in the runtime cluster.
They provide the <code>gardenlet</code>s in the seed clusters with information about which extensions are available and how to deploy them.</p><blockquote class="alert alert-note"><div class=alert-title><svg viewBox="0 0 24 24" width="24" height="24"><title>information-outline</title><path d="M11 9h2V7H11m1 13c-4.41.0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8M12 2A10 10 0 002 12 10 10 0 0012 22 10 10 0 0022 12 10 10 0 0012 2M11 17h2V11H11v6z"/></svg><p>Note</p></div><p>Before <a href=https://github.com/gardener/gardener/issues/9635>gardener/gardener#9635</a>, the only option to register extensions was via <code>ControllerRegistration</code>/<code>ControllerDeployment</code> resources.
In the meantime, they became an implementation detail of the extension registration and should be treated as a gardener internal object.
While it&rsquo;s still possible to create them manually (without <code>Extension</code>s), operators should only consider this option for advanced use cases.</p></blockquote><p>Once created, gardener evaluates the registrations and deployments and creates <a href=https://github.com/gardener/gardener/blob/master/example/25-controllerinstallation.yaml><code>ControllerInstallation</code></a> resources which describe the request &ldquo;please install this controller <code>X</code> to this seed <code>Y</code>&rdquo;.</p><p>The specification mainly describes which of Gardener&rsquo;s extension CRDs are managed, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: core.gardener.cloud/v1
</span></span><span style=display:flex><span>kind: ControllerDeployment
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: provider-local
</span></span><span style=display:flex><span>helm:
</span></span><span style=display:flex><span>  ociRepository:
</span></span><span style=display:flex><span>    ref: registry.example.com/gardener/extensions/local/extension:v1.0.0
</span></span><span style=display:flex><span>  values:
</span></span><span style=display:flex><span>    controllers:
</span></span><span style=display:flex><span>      dnsrecord:
</span></span><span style=display:flex><span>        concurrentSyncs: 20
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: ControllerRegistration
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: provider-local
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  deployment:
</span></span><span style=display:flex><span>    deploymentRefs:
</span></span><span style=display:flex><span>    - name: provider-local
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>  - kind: BackupBucket
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: BackupEntry
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: DNSRecord
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: Infrastructure
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: ControlPlane
</span></span><span style=display:flex><span>    type: local
</span></span><span style=display:flex><span>  - kind: Worker
</span></span><span style=display:flex><span>    type: local
</span></span></code></pre></div><p>This information tells Gardener that there is an extension controller that can handle <code>BackupBucket</code>, <code>BackupEntry</code>, <code>DNSRecord</code>, <code>Infrastructure</code>, <code>ControlPlane</code> and <code>Worker</code> resources of type <code>local</code>.
A reference to the shown <code>ControllerDeployment</code> specifies how the deployment of the extension controller is accomplished.</p><h2 id=deploying-extension-controllers>Deploying Extension Controllers<a class=td-heading-self-link href=#deploying-extension-controllers aria-label="Heading self-link"></a></h2><p>In the garden runtime cluster <code>gardener-operator</code> deploys the extension controllers directly, as soon as it is considered as required.
Deployments in the seed clusters are represented by another resource called <code>ControllerInstallation</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: ControllerInstallation
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: provider-local
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  deploymentRef:
</span></span><span style=display:flex><span>    name: provider-local
</span></span><span style=display:flex><span>  registrationRef:
</span></span><span style=display:flex><span>    name: provider-local
</span></span><span style=display:flex><span>  seedRef:
</span></span><span style=display:flex><span>    name: local-1
</span></span></code></pre></div><p>This resource expresses that Gardener requires the <code>provider-local</code> extension controller to run on the <code>local-1</code> seed cluster.</p><p><code>gardener-controller-manager</code> automatically determines which extension controller is required on which seed cluster and will only create <code>ControllerInstallation</code> objects for those.
Also, it will automatically delete <code>ControllerInstallation</code>s referencing extension controllers that are no longer required on a seed (e.g., because all shoots on it have been deleted).
There are additional configuration options, please see the <a href=/docs/gardener/extensions/registration/#deployment-configuration-options>Deployment Configuration Options section</a>.
After <code>gardener-controller-manager</code> has written the <code>ControllerInstallation</code> resource, gardenlet picks it up and installs the controller on the respective <code>Seed</code> using the referenced <code>ControllerDeployment</code>.</p><h3 id=helm-charts>Helm Charts<a class=td-heading-self-link href=#helm-charts aria-label="Heading self-link"></a></h3><p><code>Extension</code>s and <code>ControllerDeployment</code>s both need to specify a reference to an OCI Helm chart that contains the extension controller.
Those charts are usually provided by the extension and allow their deployment to the garden runtime or seed clusters.</p><blockquote class="alert alert-note"><div class=alert-title><svg viewBox="0 0 24 24" width="24" height="24"><title>information-outline</title><path d="M11 9h2V7H11m1 13c-4.41.0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8M12 2A10 10 0 002 12 10 10 0 0012 22 10 10 0 0022 12 10 10 0 0012 2M11 17h2V11H11v6z"/></svg><p>Note</p></div><p>Due to legacy reasons, a <code>ControllerDeployment</code> can work with a <code>rawChart</code> instead of an OCI image reference.
If your extension does not yet offer an OCI image, you may consider using this option as a temporary workaround.
Please note, that <code>rawChart</code> is not supported in <code>Extension</code>s and thus cannot be used for a deployment in the garden runtime cluster.</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>helm:
</span></span><span style=display:flex><span>  ociRepository:
</span></span><span style=display:flex><span>    <span style=color:green># full ref with either tag or digest, or both</span>
</span></span><span style=display:flex><span>    ref: registry.example.com/foo:1.0.0@sha256:abc
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>helm:
</span></span><span style=display:flex><span>  ociRepository:
</span></span><span style=display:flex><span>    <span style=color:green># repository and tag</span>
</span></span><span style=display:flex><span>    repository: registry.example.com
</span></span><span style=display:flex><span>    tag: 1.0.0
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>helm:
</span></span><span style=display:flex><span>  ociRepository:
</span></span><span style=display:flex><span>    <span style=color:green># repository and digest</span>
</span></span><span style=display:flex><span>    repository: registry.example.com
</span></span><span style=display:flex><span>    digest: sha256:abc
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>helm:
</span></span><span style=display:flex><span>  ociRepository:
</span></span><span style=display:flex><span>    <span style=color:green># when specifying both tag and digest, the tag is ignored.</span>
</span></span><span style=display:flex><span>    repository: registry.example.com
</span></span><span style=display:flex><span>    tag: 1.0.0
</span></span><span style=display:flex><span>    digest: sha256:abc
</span></span></code></pre></div><p>If needed, a pull secret can be referenced in the <code>ControllerDeployment.helm.ociRepository.pullSecretRef</code> field.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>helm:
</span></span><span style=display:flex><span>  ociRepository:
</span></span><span style=display:flex><span>    repository: registry.example.com
</span></span><span style=display:flex><span>    tag: 1.0.0
</span></span><span style=display:flex><span>    pullSecretRef:
</span></span><span style=display:flex><span>      name: my-pull-secret
</span></span></code></pre></div><p>The pull secret must be available in the <code>garden</code> namespace of the cluster where the <code>ControllerDeployment</code> is created and must contain the data key <code>.dockerconfigjson</code> with the base64-encoded Docker configuration JSON.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: my-pull-secret
</span></span><span style=display:flex><span>  namespace: garden
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    gardener.cloud/role: helm-pull-secret
</span></span><span style=display:flex><span>type: kubernetes.io/dockerconfigjson
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  .dockerconfigjson: &lt;base64-encoded-docker-config-json&gt;
</span></span></code></pre></div><p>The downloaded chart is cached in memory. It is recommended to always specify a digest, because if it is not specified, the manifest is fetched in every reconciliation to compare the digest with the local cache.</p><h3 id=helm-values>Helm Values<a class=td-heading-self-link href=#helm-values aria-label="Heading self-link"></a></h3><p>No matter where the chart originates from, <code>gardener-operator</code> and <code>gardenlet</code> deploy it with the provided Helm values.
The chart and the values can be updated at any time - Gardener will recognize it and re-trigger the deployment process.
In order to allow extension controller deployments to get information about the garden and the seed cluster, additional properties are mixed into the values (root level) of every deployed Helm chart:</p><ul><li><p>Additional properties for garden deployment</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  gardener:
</span></span><span style=display:flex><span>    runtimeCluster:
</span></span><span style=display:flex><span>      enabled: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>      priorityClassName: &lt;priority-class-name-for-extension&gt;
</span></span></code></pre></div></li><li><p>Additional properties for seed deployment</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>gardener:
</span></span><span style=display:flex><span>  version: &lt;gardener-version&gt;
</span></span><span style=display:flex><span>  garden:
</span></span><span style=display:flex><span>    clusterIdentity: &lt;uuid-of-gardener-installation&gt;
</span></span><span style=display:flex><span>    genericKubeconfigSecretName: &lt;generic-garden-kubeconfig-secret-name&gt;
</span></span><span style=display:flex><span>  seed:
</span></span><span style=display:flex><span>    name:             &lt;seed-name&gt;
</span></span><span style=display:flex><span>    clusterIdentity:  &lt;seed-cluster-identity&gt;
</span></span><span style=display:flex><span>    annotations:      &lt;seed-annotations&gt;
</span></span><span style=display:flex><span>    labels:           &lt;seed-labels&gt;
</span></span><span style=display:flex><span>    provider:         &lt;seed-provider-type&gt;
</span></span><span style=display:flex><span>    region:           &lt;seed-region&gt;
</span></span><span style=display:flex><span>    volumeProvider:   &lt;seed-first-volume-provider&gt;
</span></span><span style=display:flex><span>    volumeProviders:  &lt;seed-volume-providers&gt;
</span></span><span style=display:flex><span>    ingressDomain:    &lt;seed-ingress-domain&gt;
</span></span><span style=display:flex><span>    protected:        &lt;seed-protected-taint&gt;
</span></span><span style=display:flex><span>    visible:          &lt;seed-visible-setting&gt;
</span></span><span style=display:flex><span>    taints:           &lt;seed-taints&gt;
</span></span><span style=display:flex><span>    networks:         &lt;seed-networks&gt;
</span></span><span style=display:flex><span>    blockCIDRs:       &lt;seed-networks-blockCIDRs&gt;
</span></span><span style=display:flex><span>    spec:             &lt;seed-spec&gt;
</span></span><span style=display:flex><span>  gardenlet:
</span></span><span style=display:flex><span>    featureGates: &lt;gardenlet-feature-gates&gt;
</span></span></code></pre></div></li><li><p>If the extension is deployed in an <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/28-autonomous-shoot-clusters.md>autonomous shoot cluster</a>, then the <code>.gardener.autonomousShootCluster</code> field is additionally propagated and set to <code>true</code>.</p></li></ul><p>Extension controller deployments can use this information in their Helm chart in case they require knowledge about the garden and the seed environment.
The list might be extended in the future.</p><h3 id=deployment-configuration-options>Deployment Configuration Options<a class=td-heading-self-link href=#deployment-configuration-options aria-label="Heading self-link"></a></h3><p>The <code>.spec.extension</code> structure allows to configure a deployment <code>policy</code>.
There are the following policies:</p><ul><li><code>OnDemand</code> (default): Gardener will demand the deployment and deletion of the extension controller to/from seed clusters dynamically. It will automatically determine (based on other resources like <code>Shoot</code>s) whether it is required and decide accordingly.</li><li><code>Always</code>: Gardener will demand the deployment of the extension controller to seed clusters independent of whether it is actually required or not. This might be helpful if you want to add a new component/controller to all seed clusters by default. Another use-case is to minimize the durations until extension controllers get deployed and ready in case you have highly fluctuating seed clusters.</li><li><code>AlwaysExceptNoShoots</code>: Similar to <code>Always</code>, but if the seed does not have any shoots, then the extension controller is not being deployed. It will be deleted from a seed after the last shoot has been removed from it.</li></ul><p>Also, the <code>.spec.extension.seedSelector</code> allows to specify a label selector for seed clusters.
Only if it matches the labels of a seed, then it will be deployed to it.
Please note that a seed selector can only be specified for secondary controllers (<code>primary=false</code> for all <code>.spec.resources[]</code>).</p><h3 id=extension-resource-configurations><code>Extension</code> Resource Configurations<a class=td-heading-self-link href=#extension-resource-configurations aria-label="Heading self-link"></a></h3><p>The extensibility contract allows the following configuration options per registered extension resource (see <code>resources</code> below):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: operator.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Extension
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: extension-foo
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>  - kind: Extension
</span></span><span style=display:flex><span>    type: foo
</span></span><span style=display:flex><span>    primary: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    globallyEnabled: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    reconcileTimeout: 30s
</span></span><span style=display:flex><span>    lifecycle:
</span></span><span style=display:flex><span>      reconcile: AfterKubeAPIServer
</span></span><span style=display:flex><span>      delete: BeforeKubeAPIServer
</span></span><span style=display:flex><span>      migrate: BeforeKubeAPIServer
</span></span></code></pre></div><p>The <code>globallyEnabled=true</code> option specifies that the <code>Extension/foo</code> object shall be created by default for all shoots (unless they opted out by setting <code>.spec.extensions[].enabled=false</code> in the <code>Shoot</code> spec).</p><p>The <code>reconcileTimeout</code> tells Gardener how long it should wait during its reconciliation flow for the <code>Extension/foo</code>&rsquo;s reconciliation to finish.</p><p><code>primary</code> specifies whether the extension controller is the main one responsible for the lifecycle of the <code>Extension</code> resource.
Setting <code>primary</code> to <code>false</code> would allow to register additional, secondary controllers that may also watch/react on the <code>Extension/foo</code> resources, however, only the primary controller may change/update the main <code>status</code> of the extension object.
Particularly, only the primary controller may set <code>.status.lastOperation</code>, <code>.status.lastError</code>, <code>.status.observedGeneration</code>, and <code>.status.state</code>.
Secondary controllers may contribute to the <code>.status.conditions[]</code> if they like, of course.</p><p>Secondary controllers might be helpful in scenarios where additional tasks need to be completed which are not part of the reconciliation logic of the primary controller but separated out into a dedicated extension.</p><p>⚠️ There must be exactly one primary controller for every registered kind/type combination.
Also, please note that the <code>primary</code> field cannot be changed after creation of the <code>Extension</code>.</p><h4 id=extension-lifecycle><code>Extension</code> Lifecycle<a class=td-heading-self-link href=#extension-lifecycle aria-label="Heading self-link"></a></h4><p>The <code>lifecycle</code> field tells Gardener when to perform a certain action on the <code>Extension</code> (<code>extensions.gardener.cloud/v1alpha1</code>) resource during the reconciliation flows. If omitted, then the default behaviour will be applied. Please find more information on the defaults in the explanation below. Possible values for each control flow are <code>AfterKubeAPIServer</code>, <code>BeforeKubeAPIServer</code>, and <code>AfterWorker</code>. Let&rsquo;s take the following configuration and explain it.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    lifecycle:
</span></span><span style=display:flex><span>      reconcile: AfterKubeAPIServer
</span></span><span style=display:flex><span>      delete: BeforeKubeAPIServer
</span></span><span style=display:flex><span>      migrate: BeforeKubeAPIServer
</span></span></code></pre></div><ul><li><code>reconcile: AfterKubeAPIServer</code> means that the extension resource will be reconciled after the successful reconciliation of the <code>kube-apiserver</code> during shoot reconciliation. This is also the default behaviour if this value is not specified. During shoot hibernation, the opposite rule is applied, meaning that in this case the reconciliation of the extension will happen before the <code>kube-apiserver</code> is scaled to 0 replicas. On the other hand, if the extension needs to be reconciled before the <code>kube-apiserver</code> and scaled down after it, then the value <code>BeforeKubeAPIServer</code> should be used.</li><li><code>delete: BeforeKubeAPIServer</code> means that the extension resource will be deleted before the <code>kube-apiserver</code> is destroyed during shoot deletion. This is the default behaviour if this value is not specified.</li><li><code>migrate: BeforeKubeAPIServer</code> means that the extension resource will be migrated before the <code>kube-apiserver</code> is destroyed in the source cluster during <a href=/docs/gardener/control_plane_migration/>control plane migration</a>. This is the default behaviour if this value is not specified. The restoration of the control plane follows the reconciliation control flow.</li></ul><p>Due to technical reasons, exceptions apply for different reconcile flows, for example:</p><ul><li>The garden reconciliation doesn&rsquo;t distinguish between <code>AfterKubeAPIServer</code> and <code>AfterWorker</code>.</li><li>The seed reconciliation completely ignores the <code>lifecycle</code> field.</li><li>The lifecycle value <code>AfterWorker</code> is only available during <code>reconcile</code>. When specified, the extension resource will be reconciled after the workers are deployed. This is useful for extensions that want to deploy a workload in the shoot control plane and want to wait for the workload to run and get ready on a node. During shoot creation the extension will start its reconciliation before the first workers have joined the cluster, they will become available at some later point.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-976400864159d95d6036cf8762b0583b>17 - Resource Admission in the Garden Cluster</h1><h1 id=resource-admission-in-the-garden-cluster>Resource Admission in the Garden Cluster<a class=td-heading-self-link href=#resource-admission-in-the-garden-cluster aria-label="Heading self-link"></a></h1><p>The <code>Shoot</code> resource itself can contain some extension-specific data blobs (see <code>providerConfig</code>):</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: Shoot
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: johndoe-aws
</span></span><span style=display:flex><span>  namespace: garden-dev
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  provider:
</span></span><span style=display:flex><span>    type: aws
</span></span><span style=display:flex><span>    providerConfig:
</span></span><span style=display:flex><span>      apiVersion: aws.cloud.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>      kind: InfrastructureConfig
</span></span><span style=display:flex><span>      networks:
</span></span><span style=display:flex><span>        vpc: <span style=color:green># specify either &#39;id&#39; or &#39;cidr&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:green># id: vpc-123456</span>
</span></span><span style=display:flex><span>          cidr: 10.250.0.0/16
</span></span><span style=display:flex><span>        internal:
</span></span><span style=display:flex><span>        - 10.250.112.0/22
</span></span><span style=display:flex><span>        public:
</span></span><span style=display:flex><span>        - 10.250.96.0/22
</span></span><span style=display:flex><span>        workers:
</span></span><span style=display:flex><span>        - 10.250.0.0/19
</span></span><span style=display:flex><span>      zones:
</span></span><span style=display:flex><span>      - eu-west-1a
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>In the above example, Gardener itself does not understand the AWS-specific provider configuration for the infrastructure. However, if this part of the <code>Shoot</code> resource should be validated, then you should run an AWS-specific component in the garden cluster that registers a webhook. The same is true for values defaulting via <code>MutatingWebhookConfiguration</code>. Similarly to how Gardener is deployed to the garden cluster, these components must be deployed and managed by the Gardener administrator.</p><p>Examples of extensions performing validation:</p><ul><li><a href=/docs/extensions/#infrastructure-provider>provider extensions</a> would validate <code>spec.provider.infrastructureConfig</code> and <code>spec.provider.controlPlaneConfig</code> in the <code>Shoot</code> resource and <code>spec.providerConfig</code> in the <code>CloudProfile</code> resource.</li><li><a href=/docs/extensions/#network-plugin>networking extensions</a> would validate <code>spec.networking.providerConfig</code> in the <code>Shoot</code> resource.</li></ul><p>As a best practice, the validation should be performed only if there is a change in the <code>spec</code> of the resource. Please find an exemplary implementation in the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/admission/validator>gardener/gardener-extension-provider-aws</a> repository.</p><h2 id=extensionsgardenercloud-labeling><code>extensions.gardener.cloud</code> Labeling<a class=td-heading-self-link href=#extensionsgardenercloud-labeling aria-label="Heading self-link"></a></h2><p>When an admission relevant resource (e.g., <code>BackupEntry</code>s, <code>BackupBucket</code>s, <code>CloudProfile</code>s, <code>Seed</code>s, <code>SecretBinding</code>s, and <code>Shoot</code>s) is newly created or updated in the garden cluster, Gardener adds an extension label to it. This label is of the form <code>&lt;extension-type>.extensions.gardener.cloud/&lt;extension-name> : "true"</code>. For example, an extension label for a provider extension type <code>aws</code> looks like <code>provider.extensions.gardener.cloud/aws : "true"</code>. The extensions should add object selectors in their admission webhooks for these labels to filter out the objects they are responsible for. Please see the <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/core/v1beta1/constants/types_constants.go>types_constants.go</a> file for the full list of extension labels.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9430c9bf7134bdb61977e8ad24cd789c>18 - Resources</h1></div><div class=td-content><h1 id=pg-726a459affee2db83e184092421ca712>18.1 - BackupBucket</h1><h1 id=contract-backupbucket-resource>Contract: <code>BackupBucket</code> Resource<a class=td-heading-self-link href=#contract-backupbucket-resource aria-label="Heading self-link"></a></h1><p>The Gardener project features a sub-project called <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a> to take periodic backups of etcd backing Shoot clusters. It demands the bucket (or its equivalent in different object store providers) to be created and configured externally with appropriate credentials. The <code>BackupBucket</code> resource takes this responsibility in Gardener.</p><p>Before introducing the <code>BackupBucket</code> extension resource, Gardener was using Terraform in order to create and manage these provider-specific resources (e.g., see <a href=https://github.com/gardener/gardener/tree/0.27.0/charts/seed-terraformer/charts/aws-backup>AWS Backup</a>).
Now, Gardener commissions an external, provider-specific controller to take over this task. You can also refer to <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md>backupInfra proposal documentation</a> to get an idea about how the transition was done and understand the resource in a broader scope.</p><h2 id=what-is-the-scope-of-a-bucket>What Is the Scope of a Bucket?<a class=td-heading-self-link href=#what-is-the-scope-of-a-bucket aria-label="Heading self-link"></a></h2><p>A bucket will be provisioned per <code>Seed</code>. So, a backup of every <code>Shoot</code> created on that <code>Seed</code> will be stored under a different shoot specific prefix under the bucket.
For the backup of the <code>Shoot</code> rescheduled on different <code>Seed</code>, it will continue to use the same bucket.</p><h2 id=what-is-the-lifespan-of-a-backupbucket>What Is the Lifespan of a <code>BackupBucket</code>?<a class=td-heading-self-link href=#what-is-the-lifespan-of-a-backupbucket aria-label="Heading self-link"></a></h2><p>The bucket associated with <code>BackupBucket</code> will be created at the creation of the <code>Seed</code>. And as per current implementation, it will also be deleted on deletion of the <code>Seed</code>, if there isn&rsquo;t any <code>BackupEntry</code> resource associated with it.</p><p>In the future, we plan to introduce a schedule for <code>BackupBucket</code> - the deletion logic for the <code>BackupBucket</code> resource, which will reschedule it on different available <code>Seed</code>s on deletion or failure of a health check for the currently associated <code>seed</code>. In that case, the <code>BackupBucket</code> will be deleted only if there isn&rsquo;t any schedulable <code>Seed</code> available and there isn&rsquo;t any associated <code>BackupEntry</code> resource.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What Needs to Be Implemented to Support a New Infrastructure Provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-infrastructure-provider aria-label="Heading self-link"></a></h2><p>As part of the seed flow, Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: BackupBucket
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: foo
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: azure
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    &lt;some-optional-provider-specific-backupbucket-configuration&gt;
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: backupprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span></code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed resources. This provider secret will be configured by the Gardener operator in the <code>Seed</code> resource and propagated over there by the seed controller.</p><p>After your controller has created the required bucket, if required, it generates the secret to access the objects in the bucket and put a reference to it in <code>status</code>. This secret is supposed to be used by Gardener, or eventually a <code>BackupEntry</code> resource and etcd-backup-restore component, to backup the etcd.</p><p>In order to support a new infrastructure provider, you need to write a controller that watches all <code>BackupBucket</code>s with <code>.spec.type=&lt;my-provider-name></code>. You can take a look at the below referenced example implementation for the Azure provider.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=/docs/gardener/api-reference/extensions/#backupbucket><code>BackupBucket</code> API Reference</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/backupbucket>Exemplary Implementation for the Azure Provider</a></li><li><a href=/docs/gardener/extensions/resources/backupentry/><code>BackupEntry</code> Resource Documentation</a></li><li><a href=https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md>Shared Bucket Proposal</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-251f8a8469da660999f31cc790f740f9>18.2 - BackupEntry</h1><h1 id=contract-backupentry-resource>Contract: <code>BackupEntry</code> Resource<a class=td-heading-self-link href=#contract-backupentry-resource aria-label="Heading self-link"></a></h1><p>The Gardener project features a sub-project called <a href=https://github.com/gardener/etcd-backup-restore>etcd-backup-restore</a> to take periodic backups of etcd backing Shoot clusters. It demands the bucket (or its equivalent in different object store providers) access credentials to be created and configured externally with appropriate credentials. The <code>BackupEntry</code> resource takes this responsibility in Gardener to provide this information by creating a secret specific to the component.</p><p>That being said, the core motivation for introducing this resource was to support retention of backups post deletion of <code>Shoot</code>. The etcd-backup-restore components take responsibility of garbage collecting old backups out of the defined period. Once a shoot is deleted, we need to persist the backups for few days. Hence, Gardener uses the <code>BackupEntry</code> resource for this housekeeping work post deletion of a <code>Shoot</code>. The <code>BackupEntry</code> resource is responsible for shoot specific prefix under referred bucket.</p><p>Before introducing the <code>BackupEntry</code> extension resource, Gardener was using Terraform in order to create and manage these provider-specific resources (e.g., see <a href=https://github.com/gardener/gardener/tree/0.27.0/charts/seed-terraformer/charts/aws-backup>AWS Backup</a>).
Now, Gardener commissions an external, provider-specific controller to take over this task. You can also refer to <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md>backupInfra proposal documentation</a> to get idea about how the transition was done and understand the resource in broader scope.</p><h2 id=what-is-the-lifespan-of-a-backupentry>What Is the Lifespan of a <code>BackupEntry</code>?<a class=td-heading-self-link href=#what-is-the-lifespan-of-a-backupentry aria-label="Heading self-link"></a></h2><p>The bucket associated with <code>BackupEntry</code> will be created by using a <code>BackupBucket</code> resource. The <code>BackupEntry</code> resource will be created as a part of the <code>Shoot</code> creation. But resources might continue to exist post deletion of a <code>Shoot</code> (see <a href=/docs/gardener/concepts/gardenlet/#backupentry-controller>gardenlet</a> for more details).</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What Needs to be Implemented to Support a New Infrastructure Provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-infrastructure-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow, Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: BackupEntry
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: azure
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    &lt;some-optional-provider-specific-backup-bucket-configuration&gt;
</span></span><span style=display:flex><span>  backupBucketProviderStatus:
</span></span><span style=display:flex><span>    &lt;some-optional-provider-specific-backup-bucket-status&gt;
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  bucketName: foo
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: backupprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span></code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed resources. This provider secret will be propagated from the <code>BackupBucket</code> resource by the shoot controller.</p><p>Your controller is supposed to create the <code>etcd-backup</code> secret in the control plane namespace of a shoot. This secret is supposed to be used by Gardener or eventually by the etcd-backup-restore component to backup the etcd. The controller implementation should clean up the objects created under the shoot specific prefix in the bucket equivalent to the name of the <code>BackupEntry</code> resource.</p><p>In order to support a new infrastructure provider, you need to write a controller that watches all the <code>BackupBucket</code>s with <code>.spec.type=&lt;my-provider-name></code>. You can take a look at the below referenced example implementation for the Azure provider.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=/docs/gardener/api-reference/extensions/#backupbucket><code>BackupEntry</code> API Reference</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/backupentry>Exemplary Implementation for the Azure Provider</a></li><li><a href=/docs/gardener/extensions/resources/backupbucket/><code>BackupBucket</code> Resource Documentation</a></li><li><a href=https://github.com/gardener/gardener/blob/master/docs/proposals/02-backupinfra.md>Shared Bucket Proposal</a></li><li><a href=https://github.com/gardener/gardener/blob/master/pkg/controllermanager/apis/config/v1alpha1/types.go>Gardener-controller-manager-component-config API Specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9568268ecec1c9449d169970ad590f31>18.3 - Bastion</h1><h1 id=contract-bastion-resource>Contract: <code>Bastion</code> Resource<a class=td-heading-self-link href=#contract-bastion-resource aria-label="Heading self-link"></a></h1><p>The Gardener project allows users to connect to Shoot worker nodes via SSH. As nodes are usually firewalled and not directly accessible from the public internet, <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/15-manage-bastions-and-ssh-key-pair-rotation.md>GEP-15</a> introduced the concept of &ldquo;Bastions&rdquo;. A bastion is a dedicated server that only serves to allow SSH ingress to the worker nodes.</p><p><code>Bastion</code> resources contain the user&rsquo;s public SSH key and IP address, in order to provision the server accordingly: The public key is put onto the Bastion and SSH ingress is only authorized for the given IP address (in fact, it&rsquo;s not a single IP address, but a set of IP ranges, however for most purposes a single IP is be used).</p><h2 id=what-is-the-lifespan-of-a-bastion>What Is the Lifespan of a <code>Bastion</code>?<a class=td-heading-self-link href=#what-is-the-lifespan-of-a-bastion aria-label="Heading self-link"></a></h2><p>Once a <code>Bastion</code> has been created in the garden, it will be replicated to the appropriate seed cluster, where a controller then reconciles a server and firewall rules etc., on the cloud provider used by the target Shoot. When the Bastion is ready (i.e. has a public IP), that IP is stored in the <code>Bastion</code>&rsquo;s status and from there it is picked up by the garden cluster and <code>gardenctl</code> eventually.</p><p>To make multiple SSH sessions possible, the existence of the <code>Bastion</code> is not directly tied to the execution of <code>gardenctl</code>: users can exit out of <code>gardenctl</code> and use <code>ssh</code> manually to connect to the bastion and worker nodes.</p><p>However, <code>Bastion</code>s have an expiry date, after which they will be garbage collected.</p><p>When SSH access is set to <code>false</code> for the <code>Shoot</code> in the workers settings (see <a href=/docs/gardener/shoot/shoot_workers_settings/>Shoot Worker Nodes Settings</a>), <code>Bastion</code> resources are deleted during <code>Shoot</code> reconciliation and new <code>Bastion</code>s are prevented from being created.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What Needs to Be Implemented to Support a New Infrastructure Provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-infrastructure-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow, Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Bastion
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: mybastion
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: aws
</span></span><span style=display:flex><span>  <span style=color:green># userData is base64-encoded cloud provider user data; this contains the</span>
</span></span><span style=display:flex><span>  <span style=color:green># user&#39;s SSH key</span>
</span></span><span style=display:flex><span>  userData: IyEvYmluL2Jhc2ggL....Nlcgo=
</span></span><span style=display:flex><span>  ingress:
</span></span><span style=display:flex><span>    - ipBlock:
</span></span><span style=display:flex><span>        cidr: 192.88.99.0/32 <span style=color:green># this is most likely the user&#39;s IP address</span>
</span></span></code></pre></div><p>Your controller is supposed to create a new instance at the given cloud provider, firewall it to only allow SSH (TCP port 22) from the given IP blocks, and then configure the firewall for the worker nodes to allow SSH from the bastion instance. When a <code>Bastion</code> is deleted, all these changes need to be reverted.</p><h2 id=implementation-details>Implementation Details<a class=td-heading-self-link href=#implementation-details aria-label="Heading self-link"></a></h2><h3 id=configvalidator-interface><code>ConfigValidator</code> Interface<a class=td-heading-self-link href=#configvalidator-interface aria-label="Heading self-link"></a></h3><p>For bastion controllers, the generic <code>Reconciler</code> also delegates to a <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/bastion/configvalidator.go><code>ConfigValidator</code> interface</a> that contains a single <code>Validate</code> method. This method is called by the generic <code>Reconciler</code> at the beginning of every reconciliation, and can be implemented by the extension to validate the <code>.spec.providerConfig</code> part of the <code>Bastion</code> resource with the respective cloud provider, typically the existence and validity of cloud provider resources such as VPCs, images, etc.</p><p>The <code>Validate</code> method returns a list of errors. If this list is non-empty, the generic <code>Reconciler</code> will fail with an error. This error will have the error code <code>ERR_CONFIGURATION_PROBLEM</code>, unless there is at least one error in the list that has its <code>ErrorType</code> field set to <code>field.ErrorTypeInternal</code>.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=/docs/gardener/api-reference/extensions/#bastion><code>Bastion</code> API Reference</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/bastion>Exemplary Implementation for the AWS Provider</a></li><li><a href=https://github.com/gardener/gardener/blob/master/docs/proposals/15-manage-bastions-and-ssh-key-pair-rotation.md>GEP-15</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b9b82275abd886de2aa659f2356aabdb>18.4 - ContainerRuntime</h1><h1 id=contract-containerruntime-resource>Contract: <code>ContainerRuntime</code> Resource<a class=td-heading-self-link href=#contract-containerruntime-resource aria-label="Heading self-link"></a></h1><p>At the lowest layers of a Kubernetes node is the software that, among other things, starts and stops containers. It is called “Container Runtime”.
The most widely known container runtime is Docker, but it is not alone in this space. In fact, the container runtime space has been rapidly evolving.</p><p>Kubernetes supports different container runtimes using Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes.</p><p>Gardener supports creation of Worker machines using CRI. For more information, see <a href=/docs/gardener/extensions/resources/operatingsystemconfig/#cri-support>CRI Support</a>.</p><h2 id=motivation>Motivation<a class=td-heading-self-link href=#motivation aria-label="Heading self-link"></a></h2><p>Prior to the <code>Container Runtime Extensibility</code> concept, Gardener used Docker as the only
container runtime to use in shoot worker machines. Because of the wide variety of different container runtimes
offering multiple important features (for example, enhanced security concepts), it is important to enable end users to use other container runtimes as well.</p><h2 id=the-containerruntime-extension-resource>The <code>ContainerRuntime</code> Extension Resource<a class=td-heading-self-link href=#the-containerruntime-extension-resource aria-label="Heading self-link"></a></h2><p>Here is what a typical <code>ContainerRuntime</code> resource would look like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: ContainerRuntime
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: my-container-runtime
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  binaryPath: /var/bin/containerruntimes
</span></span><span style=display:flex><span>  type: gvisor
</span></span><span style=display:flex><span>  workerPool:
</span></span><span style=display:flex><span>    name: worker-ubuntu
</span></span><span style=display:flex><span>    selector:
</span></span><span style=display:flex><span>      matchLabels:
</span></span><span style=display:flex><span>        worker.gardener.cloud/pool: worker-ubuntu
</span></span></code></pre></div><p>Gardener deploys one <code>ContainerRuntime</code> resource per worker pool per CRI.
To exemplify this, consider a Shoot having two worker pools (<code>worker-one</code>, <code>worker-two</code>) using <code>containerd</code> as the CRI as well as <code>gvisor</code> and <code>kata</code> as enabled container runtimes.
Gardener would deploy four <code>ContainerRuntime</code> resources. For <code>worker-one</code>: one <code>ContainerRuntime</code> for type <code>gvisor</code> and one for type <code>kata</code>. The same resource are being deployed for <code>worker-two</code>.</p><h2 id=supporting-a-new-container-runtime-provider>Supporting a New Container Runtime Provider<a class=td-heading-self-link href=#supporting-a-new-container-runtime-provider aria-label="Heading self-link"></a></h2><p>To add support for another container runtime (e.g., gvisor, kata-containers), a container runtime extension controller needs to be implemented. It should support Gardener&rsquo;s supported CRI plugins.</p><p>The container runtime extension should install the necessary resources into the shoot cluster (e.g., <code>RuntimeClass</code>es), and it should copy the runtime binaries to the relevant worker machines in path: <code>spec.binaryPath</code>.
Gardener labels the shoot nodes according to the CRI configured: <code>worker.gardener.cloud/cri-name=&lt;value></code> (e.g., <code>worker.gardener.cloud/cri-name=containerd</code>) and multiple labels for each of the container runtimes configured for the shoot Worker machine:
<code>containerruntime.worker.gardener.cloud/&lt;container-runtime-type-value>=true</code> (e.g., <code>containerruntime.worker.gardener.cloud/gvisor=true</code>).
The way to install the binaries is by creating a daemon set which copies the binaries from an image in a docker registry to the relevant labeled Worker&rsquo;s nodes (avoid downloading binaries from the internet to also cater with isolated environments).</p><p>For additional reference, please have a look at the <a href=https://github.com/gardener/gardener-extension-runtime-gvisor>runtime-gvsior</a> provider extension, which provides more information on how to configure the necessary charts, as well as the actuators required to reconcile container runtime inside the <code>Shoot</code> cluster to the desired state.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-def81e56da2846b7d66a8d14fff21357>18.5 - ControlPlane</h1><h1 id=contract-controlplane-resource>Contract: <code>ControlPlane</code> Resource<a class=td-heading-self-link href=#contract-controlplane-resource aria-label="Heading self-link"></a></h1><p>Most Kubernetes clusters require a <code>cloud-controller-manager</code> or CSI drivers in order to work properly.
Before introducing the <code>ControlPlane</code> extension resource Gardener was having several different Helm charts for the <code>cloud-controller-manager</code> deployments for the various providers.
Now, Gardener commissions an external, provider-specific controller to take over this task.</p><h2 id=which-control-plane-resources-are-required>Which control plane resources are required?<a class=td-heading-self-link href=#which-control-plane-resources-are-required aria-label="Heading self-link"></a></h2><p>As mentioned in the <a href=/docs/gardener/extensions/controlplane-webhooks/>controlplane customization webhooks</a> document, Gardener shall not deploy any <code>cloud-controller-manager</code> or any other provider-specific component.
Instead, it creates a <code>ControlPlane</code> CRD that should be picked up by provider extensions.
Its purpose is to trigger the deployment of such provider-specific components in the shoot namespace in the seed cluster.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-infrastructure-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: ControlPlane
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: control-plane
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: openstack
</span></span><span style=display:flex><span>  region: europe-west1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: cloudprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    apiVersion: openstack.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: ControlPlaneConfig
</span></span><span style=display:flex><span>    loadBalancerProvider: provider
</span></span><span style=display:flex><span>    zone: eu-1a
</span></span><span style=display:flex><span>    cloudControllerManager:
</span></span><span style=display:flex><span>      featureGates:
</span></span><span style=display:flex><span>        CustomResourceValidation: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>  infrastructureProviderStatus:
</span></span><span style=display:flex><span>    apiVersion: openstack.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureStatus
</span></span><span style=display:flex><span>    networks:
</span></span><span style=display:flex><span>      floatingPool:
</span></span><span style=display:flex><span>        id: vpc-1234
</span></span><span style=display:flex><span>      subnets:
</span></span><span style=display:flex><span>      - purpose: nodes
</span></span><span style=display:flex><span>        id: subnetid
</span></span></code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used for the shoot cluster.
However, the most important section is the <code>.spec.providerConfig</code> and the <code>.spec.infrastructureProviderStatus</code>.
The first one contains an embedded declaration of the provider specific configuration for the control plane (that cannot be known by Gardener itself).
You are responsible for designing how this configuration looks like.
Gardener does not evaluate it but just copies this part from what has been provided by the end-user in the <code>Shoot</code> resource.
The second one contains the output of the <a href=/docs/gardener/extensions/resources/infrastructure/><code>Infrastructure</code> resource</a> (that might be relevant for the CCM config).</p><p>In order to support a new control plane provider, you need to write a controller that watches all <code>ControlPlane</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the Alicloud provider.</p><p>The control plane controller as part of the <code>ControlPlane</code> reconciliation often deploys resources (e.g. pods/deployments) into the Shoot namespace in the <code>Seed</code> as part of its <code>ControlPlane</code> reconciliation loop.
Because the namespace contains <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>network policies</a> that per default <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic>deny all ingress and egress traffic</a>,
the pods may need to have proper labels matching to the selectors of the network policies in order to allow the required network traffic.
Otherwise, they won&rsquo;t be allowed to talk to certain other components (e.g., the kube-apiserver of the shoot).
For more information, see <a href=/docs/gardener/network_policies/><code>NetworkPolicy</code>s In Garden, Seed, Shoot Clusters</a>.</p><h2 id=non-provider-specific-information-required-for-infrastructure-creation>Non-Provider Specific Information Required for Infrastructure Creation<a class=td-heading-self-link href=#non-provider-specific-information-required-for-infrastructure-creation aria-label="Heading self-link"></a></h2><p>Most providers might require further information that is not provider specific but already part of the shoot resource.
One example for this is the <a href=https://github.com/gardener/gardener-extension-provider-gcp/tree/master/pkg/controller/controlplane>GCP control plane controller</a>, which needs the Kubernetes version of the shoot cluster (because it already uses the in-tree Kubernetes cloud-controller-manager).
As Gardener cannot know which information is required by providers, it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>Infrastructure</code> resource itself.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_controlplane.go><code>ControlPlane</code> API (Golang Specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-alicloud/tree/master/pkg/controller/controlplane>Exemplary Implementation for the Alicloud Provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4ace13d3026eabe4e3300e6d018ed093>18.6 - ControlPlane Exposure</h1><h1 id=contract-controlplane-resource-with-purpose-exposure>Contract: <code>ControlPlane</code> Resource with Purpose <code>exposure</code><a class=td-heading-self-link href=#contract-controlplane-resource-with-purpose-exposure aria-label="Heading self-link"></a></h1><p>Some Kubernetes clusters require an additional deployments required by the seed cloud provider in order to work properly, e.g. AWS Load Balancer Readvertiser.
Before using ControlPlane resources with purpose <code>exposure</code>, Gardener was having different Helm charts for the deployments for the various providers.
Now, Gardener commissions an external, provider-specific controller to take over this task.</p><h2 id=which-control-plane-resources-are-required>Which control plane resources are required?<a class=td-heading-self-link href=#which-control-plane-resources-are-required aria-label="Heading self-link"></a></h2><p>As mentioned in the <a href=/docs/gardener/extensions/resources/controlplane/>controlplane</a> document, Gardener shall not deploy any other provider-specific component.
Instead, it creates a <code>ControlPlane</code> CRD with purpose <code>exposure</code> that should be picked up by provider extensions.
Its purpose is to trigger the deployment of such provider-specific components in the shoot namespace in the seed cluster that are needed to expose the kube-apiserver.</p><p>The shoot cluster&rsquo;s kube-apiserver are exposed via a <code>Service</code> of type <code>LoadBalancer</code> from the shoot provider (you may run the control plane of an Azure shoot in a GCP seed). It&rsquo;s the seed provider extension controller that should act on the <code>ControlPlane</code> resources with purpose <code>exposure</code>.</p><p>If <a href=https://github.com/gardener/gardener/blob/master/docs/proposals/08-shoot-apiserver-via-sni.md>SNI</a> is enabled, then the <code>Service</code> from above is of type <code>ClusterIP</code> and Gardner will not create <code>ControlPlane</code> resources with purpose <code>exposure</code>.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-infrastructure-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow, Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: ControlPlane
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: control-plane-exposure
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: aws
</span></span><span style=display:flex><span>  purpose: exposure
</span></span><span style=display:flex><span>  region: europe-west1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: cloudprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span></code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used for the shoot cluster.
It is most likely not needed, however, still added for some potential corner cases.
If you don&rsquo;t need it, then just ignore it.
The <code>.spec.region</code> contains the region of the seed cluster.</p><p>In order to support a control plane provider with purpose <code>exposure</code>, you need to write a controller or expand the existing <a href=/docs/gardener/extensions/resources/controlplane/>controlplane controller</a> that watches all <code>ControlPlane</code>s with <code>.spec.type=&lt;my-provider-name></code> and purpose <code>exposure</code>.
You can take a look at the below referenced example implementation for the AWS provider.</p><h2 id=non-provider-specific-information-required-for-infrastructure-creation>Non-Provider Specific Information Required for Infrastructure Creation<a class=td-heading-self-link href=#non-provider-specific-information-required-for-infrastructure-creation aria-label="Heading self-link"></a></h2><p>Most providers might require further information that is not provider specific but already part of the shoot resource.
As Gardener cannot know which information is required by providers, it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_controlplane.go><code>ControlPlane</code> API (Golang Specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/controlplane>Exemplary Implementation for the AWS Provider</a></li><li><a href=https://github.com/gardener/aws-lb-readvertiser>AWS Load Balancer Readvertiser</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-83ab5475cb85c0e0d03648790fccc822>18.7 - DNS Record</h1><h1 id=contract-dnsrecord-resources>Contract: <code>DNSRecord</code> Resources<a class=td-heading-self-link href=#contract-dnsrecord-resources aria-label="Heading self-link"></a></h1><p>Every shoot cluster requires external DNS records that are publicly resolvable.
The management of these DNS records requires provider-specific knowledge which is to be developed outside the Gardener&rsquo;s core repository.</p><p>Currently, Gardener uses <code>DNSProvider</code> and <code>DNSEntry</code> resources. However, this introduces undesired coupling of Gardener to a controller that does not adhere to the Gardener extension contracts. Because of this, we plan to stop using <code>DNSProvider</code> and <code>DNSEntry</code> resources for Gardener DNS records in the future and use the <code>DNSRecord</code> resources described here instead.</p><h2 id=what-does-gardener-create-dns-records-for>What does Gardener create DNS records for?<a class=td-heading-self-link href=#what-does-gardener-create-dns-records-for aria-label="Heading self-link"></a></h2><h3 id=internal-domain-name>Internal Domain Name<a class=td-heading-self-link href=#internal-domain-name aria-label="Heading self-link"></a></h3><p>Every shoot cluster&rsquo;s kube-apiserver running in the seed is exposed via a load balancer that has a public endpoint (IP or hostname).
This endpoint is used by end-users and also by system components (that are running in another network, e.g., the kubelet or kube-proxy) to talk to the cluster.
In order to be robust against changes of this endpoint (e.g., caused due to re-creation of the load balancer or move of the DNS record to another seed cluster), Gardener creates a so-called <em>internal domain name</em> for every shoot cluster.
The <em>internal domain name</em> is a publicly resolvable DNS record that points to the load balancer of the kube-apiserver.
Gardener uses this domain name in the kubeconfigs of all system components, instead of using directly the load balancer endpoint.
This way Gardener does not need to recreate all kubeconfigs if the endpoint changes - it just needs to update the DNS record.</p><h3 id=external-domain-name>External Domain Name<a class=td-heading-self-link href=#external-domain-name aria-label="Heading self-link"></a></h3><p>The internal domain name is not configurable by end-users directly but configured by the Gardener administrator.
However, end-users usually prefer to have another DNS name, maybe even using their own domain sometimes, to access their Kubernetes clusters.
Gardener supports that by creating another DNS record, named <em>external domain name</em>, that actually points to the <em>internal domain name</em>.
The kubeconfig handed out to end-users does contain this <em>external domain name</em>, i.e., users can access their clusters with the DNS name they like to.</p><p>As not every end-user has an own domain, it is possible for Gardener administrators to configure so-called <em>default domains</em>.
If configured, shoots that do not specify a domain explicitly get an <em>external domain name</em> based on a default domain (unless explicitly stated that this shoot should not get an external domain name (<code>.spec.dns.provider=unmanaged</code>)).</p><h3 id=ingress-domain-name-deprecated>Ingress Domain Name (Deprecated)<a class=td-heading-self-link href=#ingress-domain-name-deprecated aria-label="Heading self-link"></a></h3><p>Gardener allows to deploy a <code>nginx-ingress-controller</code> into a shoot cluster (deprecated).
This controller is exposed via a public load balancer (again, either IP or hostname).
Gardener creates a wildcard DNS record pointing to this load balancer.
<code>Ingress</code> resources can later use this wildcard DNS record to expose underlying applications.</p><h3 id=seed-ingress>Seed Ingress<a class=td-heading-self-link href=#seed-ingress aria-label="Heading self-link"></a></h3><p>If <code>.spec.ingress</code> is configured in the Seed, Gardener deploys the ingress controller mentioned in <code>.spec.ingress.controller.kind</code> to the seed cluster. Currently, the only supported kind is &ldquo;nginx&rdquo;. If the ingress field is set, then <code>.spec.dns.provider</code> must also be set. Gardener creates a wildcard DNS record pointing to the load balancer of the ingress controller. The <code>Ingress</code> resources of components like Plutono and Prometheus in the <code>garden</code> namespace and the shoot namespaces use this wildcard DNS record to expose their underlying applications.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-dns-provider>What needs to be implemented to support a new DNS provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-dns-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow, Gardener will create a number of <code>DNSRecord</code> resources in the seed cluster (one for each of the DNS records mentioned above) that need to be reconciled by an extension controller.
These resources contain the following information:</p><ul><li>The DNS provider type (e.g., <code>aws-route53</code>, <code>google-clouddns</code>, &mldr;)</li><li>A reference to a <code>Secret</code> object that contains the provider-specific credentials used to communicate with the provider&rsquo;s API.</li><li>The fully qualified domain name (FQDN) of the DNS record, e.g. &ldquo;api.&lt;shoot domain>&rdquo;.</li><li>The DNS record type, one of <code>A</code>, <code>AAAA</code>, <code>CNAME</code>, or <code>TXT</code>.</li><li>The DNS record values, that is a list of IP addresses for A records, a single hostname for CNAME records, or a list of texts for TXT records.</li></ul><p>Optionally, the <code>DNSRecord</code> resource may contain also the following information:</p><ul><li>The region of the DNS record. If not specified, the region specified in the referenced <code>Secret</code> shall be used. If that is also not specified, the extension controller shall use a certain default region.</li><li>The DNS hosted zone of the DNS record. If not specified, it shall be determined automatically by the extension controller by getting all hosted zones of the account and searching for the longest zone name that is a suffix of the fully qualified domain name (FQDN) mentioned above.</li><li>The TTL of the DNS record in seconds. If not specified, it shall be set by the extension controller to 120.</li></ul><p><strong>Example <code>DNSRecord</code></strong>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: dnsrecord-bar-external
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>type: Opaque
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  <span style=color:green># aws-route53 specific credentials here</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: DNSRecord
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: dnsrecord-external
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: aws-route53
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: dnsrecord-bar-external
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span><span style=color:green># region: eu-west-1</span>
</span></span><span style=display:flex><span><span style=color:green># zone: ZFOO</span>
</span></span><span style=display:flex><span>  name: api.bar.foo.my-fancy-domain.com
</span></span><span style=display:flex><span>  recordType: A
</span></span><span style=display:flex><span>  values:
</span></span><span style=display:flex><span>  - 1.2.3.4
</span></span><span style=display:flex><span><span style=color:green># ttl: 600</span>
</span></span></code></pre></div><p>In order to support a new DNS record provider, you need to write a controller that watches all <code>DNSRecord</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the AWS route53 provider.</p><h2 id=key-names-in-secrets-containing-provider-specific-credentials>Key Names in Secrets Containing Provider-Specific Credentials<a class=td-heading-self-link href=#key-names-in-secrets-containing-provider-specific-credentials aria-label="Heading self-link"></a></h2><p>For compatibility with existing setups, extension controllers shall support two different namings of keys in secrets containing provider-specific credentials:</p><ul><li>The naming used by the <a href=https://github.com/gardener/external-dns-management>external-dns-management DNS controller</a>. For example, on AWS the key names are <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, and <code>AWS_REGION</code>.</li><li>The naming used by other provider-specific extension controllers, e.g., for <a href=/docs/gardener/extensions/resources/infrastructure/>infrastructure</a>. For example, on AWS the key names are <code>accessKeyId</code>, <code>secretAccessKey</code>, and <code>region</code>.</li></ul><h2 id=avoiding-reading-the-dns-hosted-zones>Avoiding Reading the DNS Hosted Zones<a class=td-heading-self-link href=#avoiding-reading-the-dns-hosted-zones aria-label="Heading self-link"></a></h2><p>If the DNS hosted zone is not specified in the <code>DNSRecord</code> resource, during the first reconciliation the extension controller shall determine the correct DNS hosted zone for the specified FQDN and write it to the status of the resource:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: DNSRecord
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: dnsrecord-external
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  lastOperation: ...
</span></span><span style=display:flex><span>  zone: ZFOO
</span></span></code></pre></div><p>On subsequent reconciliations, the extension controller shall use the zone from the status and avoid reading the DNS hosted zones from the provider.
If the <code>DNSRecord</code> resource specifies a zone in <code>.spec.zone</code> and the extension controller has written a value to <code>.status.zone</code>, the first one shall be considered with higher priority by the extension controller.</p><h2 id=non-provider-specific-information-required-for-dns-record-creation>Non-Provider Specific Information Required for DNS Record Creation<a class=td-heading-self-link href=#non-provider-specific-information-required-for-dns-record-creation aria-label="Heading self-link"></a></h2><p>Some providers might require further information that is not provider specific but already part of the shoot resource.
As Gardener cannot know which information is required by providers, it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>DNSRecord</code> resource itself.</p><h2 id=using-dnsrecord-resources>Using <code>DNSRecord</code> Resources<a class=td-heading-self-link href=#using-dnsrecord-resources aria-label="Heading self-link"></a></h2><p>gardenlet manages <code>DNSRecord</code> resources for all three DNS records mentioned above (internal, external, and ingress).
In order to successfully reconcile a shoot with the feature gate enabled, extension controllers for <code>DNSRecord</code> resources for types used in the default, internal, and custom domain secrets should be registered via <code>ControllerRegistration</code> resources.</p><blockquote><p><strong>Note:</strong> For compatibility reasons, the <code>spec.dns.providers</code> section is still used to specify additional providers. Only the one marked as <code>primary: true</code> will be used for <code>DNSRecord</code>. All others are considered by the <code>shoot-dns-service</code> extension only (if deployed).</p></blockquote><h3 id=support-for-dnsrecord-resources-in-the-provider-extensions>Support for <code>DNSRecord</code> Resources in the Provider Extensions<a class=td-heading-self-link href=#support-for-dnsrecord-resources-in-the-provider-extensions aria-label="Heading self-link"></a></h3><p>The following table contains information about the provider extension version that adds support for <code>DNSRecord</code> resources:</p><table><thead><tr><th>Extension</th><th>Version</th></tr></thead><tbody><tr><td>provider-alicloud</td><td><code>v1.26.0</code></td></tr><tr><td>provider-aws</td><td><code>v1.27.0</code></td></tr><tr><td>provider-azure</td><td><code>v1.21.0</code></td></tr><tr><td>provider-gcp</td><td><code>v1.18.0</code></td></tr><tr><td>provider-openstack</td><td><code>v1.21.0</code></td></tr><tr><td>provider-vsphere</td><td>N/A</td></tr><tr><td>provider-equinix-metal</td><td>N/A</td></tr><tr><td>provider-kubevirt</td><td>N/A</td></tr><tr><td>provider-openshift</td><td>N/A</td></tr></tbody></table><h3 id=support-for-dnsrecord-ipv6-recordtype-aaaa-in-the-provider-extensions>Support for <code>DNSRecord</code> IPv6 <code>recordType: AAAA</code> in the Provider Extensions<a class=td-heading-self-link href=#support-for-dnsrecord-ipv6-recordtype-aaaa-in-the-provider-extensions aria-label="Heading self-link"></a></h3><p>The following table contains information about the provider extension version that adds support for <code>DNSRecord</code> IPv6 <code>recordType: AAAA</code>:</p><table><thead><tr><th>Extension</th><th>Version</th></tr></thead><tbody><tr><td>provider-alicloud</td><td>N/A</td></tr><tr><td>provider-aws</td><td>N/A</td></tr><tr><td>provider-azure</td><td>N/A</td></tr><tr><td>provider-gcp</td><td>N/A</td></tr><tr><td>provider-openstack</td><td>N/A</td></tr><tr><td>provider-vsphere</td><td>N/A</td></tr><tr><td>provider-equinix-metal</td><td>N/A</td></tr><tr><td>provider-kubevirt</td><td>N/A</td></tr><tr><td>provider-openshift</td><td>N/A</td></tr><tr><td>provider-local</td><td><code>v1.63.0</code></td></tr></tbody></table><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_dnsrecord.go><code>DNSRecord</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/dnsrecord>Sample Implementation for the AWS Route53 Provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-91f9cbe2d031184a3ec1d350c23635ab>18.8 - Extension</h1><h1 id=contract-extension-resource>Contract: <code>Extension</code> Resource<a class=td-heading-self-link href=#contract-extension-resource aria-label="Heading self-link"></a></h1><p>Gardener defines common procedures which must be passed to create a functioning shoot cluster. Well known steps are represented by special resources like <code>Infrastructure</code>, <code>OperatingSystemConfig</code> or <code>DNS</code>. These resources are typically reconciled by dedicated controllers setting up the infrastructure on the hyperscaler or managing DNS entries, etc.</p><p>But, some requirements don&rsquo;t match with those special resources or don&rsquo;t depend on being proceeded at a specific step in the creation / deletion flow of the shoot. They require a more generic hook. Therefore, Gardener offers the <code>Extension</code> resource.</p><h2 id=what-is-required-to-register-and-support-an-extension-type>What is required to register and support an Extension type?<a class=td-heading-self-link href=#what-is-required-to-register-and-support-an-extension-type aria-label="Heading self-link"></a></h2><p>Gardener creates one <code>Extension</code> resource per registered extension type in <code>ControllerRegistration</code> per shoot.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: ControllerRegistration
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: extension-example
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  resources:
</span></span><span style=display:flex><span>  - kind: Extension
</span></span><span style=display:flex><span>    type: example
</span></span><span style=display:flex><span>    globallyEnabled: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    workerlessSupported: <span style=color:#00f>true</span>
</span></span></code></pre></div><p>If <code>spec.resources[].globallyEnabled</code> is <code>true</code>, then the <code>Extension</code> resources of the given <code>type</code> is created for every shoot cluster. Set to <code>false</code>, the <code>Extension</code> resource is only created if configured in the <code>Shoot</code> manifest. In case of workerless <code>Shoot</code>, a globally enabled <code>Extension</code> resource is created only if <code>spec.resources[].workerlessSupported</code> is also set to <code>true</code>. If an extension configured in the spec of a workerless <code>Shoot</code> is not supported yet, the admission request will be rejected.</p><p>The <code>Extension</code> resources are created in the shoot namespace of the seed cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Extension
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: example
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: example
</span></span><span style=display:flex><span>  providerConfig: {}
</span></span></code></pre></div><p>Your controller needs to reconcile <code>extensions.extensions.gardener.cloud</code>. Since there can exist multiple <code>Extension</code> resources per shoot, each one holds a <code>spec.type</code> field to let controllers check their responsibility (similar to all other extension resources of Gardener).</p><h2 id=providerconfig>ProviderConfig<a class=td-heading-self-link href=#providerconfig aria-label="Heading self-link"></a></h2><p>It is possible to provide data in the <code>Shoot</code> resource which is copied to <code>spec.providerConfig</code> of the <code>Extension</code> resource.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: Shoot
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: bar
</span></span><span style=display:flex><span>  namespace: garden-foo
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  extensions:
</span></span><span style=display:flex><span>  - type: example
</span></span><span style=display:flex><span>    providerConfig:
</span></span><span style=display:flex><span>      foo: bar
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>results in</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Extension
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: example
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: example
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    foo: bar
</span></span></code></pre></div><h2 id=shoot-reconciliation-flow-and-extension-status>Shoot Reconciliation Flow and Extension Status<a class=td-heading-self-link href=#shoot-reconciliation-flow-and-extension-status aria-label="Heading self-link"></a></h2><p>Gardener creates Extension resources as part of the Shoot reconciliation. Moreover, it is guaranteed that the <a href=/docs/gardener/extensions/cluster/>Cluster</a> resource exists before the <code>Extension</code> resource is created. <code>Extension</code>s can be reconciled at different stages during Shoot reconciliation depending on the defined extension lifecycle strategy in the respective <code>ControllerRegistration</code> resource. Please consult the <a href=/docs/gardener/extensions/registration/#extension-lifecycle>Extension Lifecycle</a> section for more information.</p><p>For an <code>Extension</code> controller it is crucial to maintain the <code>Extension</code>&rsquo;s status correctly. At the end Gardener checks the status of each <code>Extension</code> and only reports a successful shoot reconciliation if the state of the last operation is <code>Succeeded</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Extension
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  generation: 1
</span></span><span style=display:flex><span>  name: example
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: example
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  lastOperation:
</span></span><span style=display:flex><span>    state: Succeeded
</span></span><span style=display:flex><span>  observedGeneration: 1
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-9fab39308fc7f83d0ed56a33c24a7e39>18.9 - Infrastructure</h1><h1 id=contract-infrastructure-resource>Contract: <code>Infrastructure</code> Resource<a class=td-heading-self-link href=#contract-infrastructure-resource aria-label="Heading self-link"></a></h1><p>Every Kubernetes cluster requires some low-level infrastructure to be setup in order to work properly.
Examples for that are networks, routing entries, security groups, IAM roles, etc.
Before introducing the <code>Infrastructure</code> extension resource Gardener was using Terraform in order to create and manage these provider-specific resources (e.g., see <a href=https://github.com/gardener/gardener/tree/0.20.0/charts/seed-terraformer/charts/aws-infra>here</a>).
Now, Gardener commissions an external, provider-specific controller to take over this task.</p><h2 id=which-infrastructure-resources-are-required>Which infrastructure resources are required?<a class=td-heading-self-link href=#which-infrastructure-resources-are-required aria-label="Heading self-link"></a></h2><p>Unfortunately, there is no general answer to this question as it is highly provider specific.
Consider the above mentioned resources, i.e., VPC, subnets, route tables, security groups, IAM roles, SSH key pairs.
Most of the resources are required in order to create VMs (the shoot cluster worker nodes), load balancers, and volumes.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-infrastructure-provider>What needs to be implemented to support a new infrastructure provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-infrastructure-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Infrastructure
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: infrastructure
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: azure
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: cloudprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureConfig
</span></span><span style=display:flex><span>    resourceGroup:
</span></span><span style=display:flex><span>      name: mygroup
</span></span><span style=display:flex><span>    networks:
</span></span><span style=display:flex><span>      vnet: <span style=color:green># specify either &#39;name&#39; or &#39;cidr&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:green># name: my-vnet</span>
</span></span><span style=display:flex><span>        cidr: 10.250.0.0/16
</span></span><span style=display:flex><span>      workers: 10.250.0.0/19
</span></span></code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed resources.
However, the most important section is the <code>.spec.providerConfig</code>.
It contains an embedded declaration of the provider specific configuration for the infrastructure (that cannot be known by Gardener itself).
You are responsible for designing how this configuration looks like.
Gardener does not evaluate it but just copies this part from what has been provided by the end-user in the <code>Shoot</code> resource.</p><p>After your controller has created the required resources in your provider&rsquo;s infrastructure it needs to generate an output that can be used by other controllers in subsequent steps.
An example for that is the <code>Worker</code> extension resource controller.
It is responsible for creating virtual machines (shoot worker nodes) in this prepared infrastructure.
Everything that it needs to know in order to do that (e.g. the network IDs, security group names, etc. (again: provider-specific)) needs to be provided as output in the <code>Infrastructure</code> resource:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Infrastructure
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: infrastructure
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  lastOperation: ...
</span></span><span style=display:flex><span>  providerStatus:
</span></span><span style=display:flex><span>    apiVersion: azure.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureStatus
</span></span><span style=display:flex><span>    resourceGroup:
</span></span><span style=display:flex><span>      name: mygroup
</span></span><span style=display:flex><span>    networks:
</span></span><span style=display:flex><span>      vnet:
</span></span><span style=display:flex><span>        name: my-vnet
</span></span><span style=display:flex><span>      subnets:
</span></span><span style=display:flex><span>      - purpose: nodes
</span></span><span style=display:flex><span>        name: my-subnet
</span></span><span style=display:flex><span>    availabilitySets:
</span></span><span style=display:flex><span>    - purpose: nodes
</span></span><span style=display:flex><span>      id: av-set-id
</span></span><span style=display:flex><span>      name: av-set-name
</span></span><span style=display:flex><span>    routeTables:
</span></span><span style=display:flex><span>    - purpose: nodes
</span></span><span style=display:flex><span>      name: route-table-name
</span></span><span style=display:flex><span>    securityGroups:
</span></span><span style=display:flex><span>    - purpose: nodes
</span></span><span style=display:flex><span>      name: sec-group-name
</span></span></code></pre></div><p>In order to support a new infrastructure provider you need to write a controller that watches all <code>Infrastructure</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the Azure provider.</p><h2 id=dynamic-nodes-network-for-shoot-clusters>Dynamic nodes network for shoot clusters<a class=td-heading-self-link href=#dynamic-nodes-network-for-shoot-clusters aria-label="Heading self-link"></a></h2><p>Some environments do not allow end-users to statically define a CIDR for the network that shall be used for the shoot worker nodes.
In these cases it is possible for the extension controllers to dynamically provision a network for the nodes (as part of their reconciliation loops), and to provide the CIDR in the <code>status</code> of the <code>Infrastructure</code> resource:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Infrastructure
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: infrastructure
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  lastOperation: ...
</span></span><span style=display:flex><span>  providerStatus: ...
</span></span><span style=display:flex><span>  nodesCIDR: 10.250.0.0/16
</span></span></code></pre></div><p>Gardener will pick this <code>nodesCIDR</code> and use it to configure the VPN components to establish network connectivity between the control plane and the worker nodes.
If the <code>Shoot</code> resource already specifies a nodes CIDR in <code>.spec.networking.nodes</code> and the extension controller provides also a value in <code>.status.nodesCIDR</code> in the <code>Infrastructure</code> resource then the latter one will always be considered with higher priority by Gardener.</p><h2 id=non-provider-specific-information-required-for-infrastructure-creation>Non-provider specific information required for infrastructure creation<a class=td-heading-self-link href=#non-provider-specific-information-required-for-infrastructure-creation aria-label="Heading self-link"></a></h2><p>Some providers might require further information that is not provider specific but already part of the shoot resource.
One example for this is the <a href=https://github.com/gardener/gardener-extension-provider-gcp/tree/master/pkg/controller/infrastructure>GCP infrastructure controller</a> which needs the pod and the service network of the cluster in order to prepare and configure the infrastructure correctly.
As Gardener cannot know which information is required by providers it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>Infrastructure</code> resource itself.</p><h2 id=implementation-details>Implementation details<a class=td-heading-self-link href=#implementation-details aria-label="Heading self-link"></a></h2><h3 id=actuator-interface><code>Actuator</code> interface<a class=td-heading-self-link href=#actuator-interface aria-label="Heading self-link"></a></h3><p>Most existing infrastructure controller implementations follow a common pattern where a generic <code>Reconciler</code> delegates to <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/actuator.go>an <code>Actuator</code> interface</a> that contains the methods <code>Reconcile</code>, <code>Delete</code>, <code>Migrate</code>, and <code>Restore</code>. These methods are called by the generic <code>Reconciler</code> for the respective operations, and should be implemented by the extension according to the contract described here and the <a href=/docs/gardener/extensions/migration/>migration guidelines</a>.</p><h3 id=configvalidator-interface><code>ConfigValidator</code> interface<a class=td-heading-self-link href=#configvalidator-interface aria-label="Heading self-link"></a></h3><p>For infrastructure controllers, the generic <code>Reconciler</code> also delegates to <a href=https://github.com/gardener/gardener/blob/master/extensions/pkg/controller/infrastructure/configvalidator.go>a <code>ConfigValidator</code> interface</a> that contains a single <code>Validate</code> method. This method is called by the generic <code>Reconciler</code> at the beginning of every reconciliation, and can be implemented by the extension to validate the <code>.spec.providerConfig</code> part of the <code>Infrastructure</code> resource with the respective cloud provider, typically the existence and validity of cloud provider resources such as AWS VPCs or GCP Cloud NAT IPs.</p><p>The <code>Validate</code> method returns a list of errors. If this list is non-empty, the generic <code>Reconciler</code> will fail with an error. This error will have the error code <code>ERR_CONFIGURATION_PROBLEM</code>, unless there is at least one error in the list that has its <code>ErrorType</code> field set to <code>field.ErrorTypeInternal</code>.</p><h2 id=references-and-additional-resources>References and additional resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_infrastructure.go><code>Infrastructure</code> API (Golang specification)</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-azure/tree/master/pkg/controller/infrastructure>Sample implementation for the Azure provider</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/infrastructure/configvalidator.go>Sample ConfigValidator implementation</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b1186cfbcb1dcd9fa54c7981efa4b617>18.10 - Network</h1><h1 id=contract-network-resource>Contract: <code>Network</code> Resource<a class=td-heading-self-link href=#contract-network-resource aria-label="Heading self-link"></a></h1><p>Gardener is an open-source project that provides a nested user model. Basically, there are two types of services provided by Gardener to its users:</p><ul><li>Managed: end-users only request a Kubernetes cluster (Clusters-as-a-Service)</li><li>Hosted: operators utilize Gardener to provide their own managed version of Kubernetes (Cluster-Provisioner-as-a-service)</li></ul><p>Whether a user is an operator or an end-user, it makes sense to provide choice. For example, for an end-user it might make sense to
choose a network-plugin that would support enforcing network policies (some plugins does not come with network-policy support by default).
For operators however, choice only matters for delegation purposes, i.e., when providing an own managed-service, it becomes important to also provide choice over which network-plugins to use.</p><p>Furthermore, Gardener provisions clusters on different cloud-providers with different networking requirements. For example, Azure does not support Calico overlay networking with IP in IP [1], this leads to the introduction of manual exceptions in static add-on charts which is error prone and can lead to failures during upgrades.</p><p>Finally, every provider is different, and thus the network always needs to adapt to the infrastructure needs to provide better performance. Consistency does not necessarily lie in the implementation but in the interface.</p><h2 id=motivation>Motivation<a class=td-heading-self-link href=#motivation aria-label="Heading self-link"></a></h2><p>Prior to the <code>Network Extensibility</code> concept, Gardener followed a mono network-plugin support model (i.e., Calico). Although this seemed to be the easier approach, it did not completely reflect the real use-case.
The goal of the Gardener Network Extensions is to support different network plugins, therefore, the specification for the network resource won&rsquo;t be fixed and will be customized based on the underlying network plugin.</p><p>To do so, a <code>ProviderConfig</code> field in the spec will be provided where each plugin will define. Below is an example for how to deploy Calico as the cluster network plugin.</p><h2 id=the-network-extensions-resource>The Network Extensions Resource<a class=td-heading-self-link href=#the-network-extensions-resource aria-label="Heading self-link"></a></h2><p>Here is what a typical <code>Network</code> resource would look-like:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Network
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: my-network
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ipFamilies:
</span></span><span style=display:flex><span>  - IPv4
</span></span><span style=display:flex><span>  podCIDR: 100.244.0.0/16
</span></span><span style=display:flex><span>  serviceCIDR: 100.32.0.0/13
</span></span><span style=display:flex><span>  type: calico
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    apiVersion: calico.networking.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: NetworkConfig
</span></span><span style=display:flex><span>    backend: bird
</span></span><span style=display:flex><span>    ipam:
</span></span><span style=display:flex><span>      cidr: usePodCIDR
</span></span><span style=display:flex><span>      type: host-local
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  ipFamilies:
</span></span><span style=display:flex><span>  - IPv4
</span></span></code></pre></div><p>The spec of above resources is divided into two parts (more information can be found at <a href=/docs/extensions/network-extensions/gardener-extension-networking-calico/usage/>Using the Networking Calico Extension</a>):</p><ul><li>global configuration (e.g., podCIDR, serviceCIDR, and type)</li><li>provider specific config (e.g., for calico we can choose to configure a <code>bird</code> backend)</li></ul><blockquote><p><strong>Note</strong>: Certain cloud-provider extensions might have webhooks that would modify the network-resource to fit into their network specific context. As previously mentioned, Azure does not support IPIP, as a result, the <a href=https://github.com/gardener/gardener-extension-provider-azure>Azure provider extension</a> implements a <a href=https://github.com/gardener/gardener-extension-provider-azure/blob/master/pkg/webhook/network/mutate.go>webhook</a> to mutate the backend and set it to <code>None</code> instead of <code>bird</code>.</p></blockquote><h2 id=supporting-a-new-network-extension-provider>Supporting a New Network Extension Provider<a class=td-heading-self-link href=#supporting-a-new-network-extension-provider aria-label="Heading self-link"></a></h2><p>To add support for another networking provider (e.g., weave, Cilium, Flannel) a network extension controller needs to be implemented which would optionally have its own custom configuration specified in the <code>spec.providerConfig</code> in the <code>Network</code> resource. For example, if support for a network plugin named <code>gardenet</code> is required, the following <code>Network</code> resource would be created:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Network
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: my-network
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ipFamilies:
</span></span><span style=display:flex><span>  - IPv4
</span></span><span style=display:flex><span>  podCIDR: 100.244.0.0/16
</span></span><span style=display:flex><span>  serviceCIDR: 100.32.0.0/13
</span></span><span style=display:flex><span>  type: gardenet
</span></span><span style=display:flex><span>  providerConfig:
</span></span><span style=display:flex><span>    apiVersion: gardenet.networking.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: NetworkConfig
</span></span><span style=display:flex><span>    gardenetCustomConfigField: &lt;value&gt;
</span></span><span style=display:flex><span>    ipam:
</span></span><span style=display:flex><span>      cidr: usePodCIDR
</span></span><span style=display:flex><span>      type: host-local
</span></span></code></pre></div><p>Once applied, the presumably implemented <code>Gardenet</code> extension controller would pick the configuration up, parse the <code>providerConfig</code>, and create the necessary resources in the shoot.</p><p>For additional reference, please have a look at the <a href=https://github.com/gardener/gardener-extension-networking-calico>networking-calico</a> provider extension, which provides more information on how to configure the necessary charts, as well as the actuators required to reconcile networking inside the <code>Shoot</code> cluster to the desired state.</p><h2 id=supporting-kube-proxy-less-service-routing>Supporting <code>kube-proxy</code>-less Service Routing<a class=td-heading-self-link href=#supporting-kube-proxy-less-service-routing aria-label="Heading self-link"></a></h2><p>Some networking extensions support service routing without the <code>kube-proxy</code> component. This is why Gardener supports disabling of <code>kube-proxy</code> for service routing by setting <code>.spec.kubernetes.kubeproxy.enabled</code> to <code>false</code> in the <code>Shoot</code> specification. The implicit contract of the flag is:</p><p><em>If <code>kube-proxy</code> is disabled, then the networking extension is responsible for the service routing.</em></p><p>The networking extensions need to handle this twofold:</p><ol><li>During the reconciliation of the networking resources, the extension needs to check whether <code>kube-proxy</code> takes care of the service routing or the networking extension itself should handle it. In case the networking extension should be responsible according to <code>.spec.kubernetes.kubeproxy.enabled</code> (but is unable to perform the service routing), it should raise an error during the reconciliation. If the networking extension should handle the service routing, it may reconfigure itself accordingly.</li><li>(Optional) In case the networking extension does not support taking over the service routing (in some scenarios), it is recommended to also provide a validating admission webhook to reject corresponding changes early on. The validation may take the current operating mode of the networking extension into consideration.</li></ol><h2 id=supporting-migration-of-ipfamilies>Supporting Migration of <code>ipFamilies</code><a class=td-heading-self-link href=#supporting-migration-of-ipfamilies aria-label="Heading self-link"></a></h2><p>To enable the migration from a shoot cluster with single-stack networking to a cluster with dual-stack networking, the <code>status</code> field of the <code>Network</code> resource includes the <code>ipFamilies</code> field.</p><p>This field reflects the currently deployed configuration and is used to verify whether the migration process has been completed successfully. To support the migration from single-stack to dual-stack networking, a network extension provider must ensure that this field is properly maintained and updated during the migration process.</p><h2 id=related-links>Related Links<a class=td-heading-self-link href=#related-links aria-label="Heading self-link"></a></h2><ul><li>[1] <a href=https://docs.tigera.io/calico/latest/networking/configuring/vxlan-ipip#encapsulation-types>Calico overlay networking on Azure</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4bbb7bebb23dcb225674012a6fcf92e8>18.11 - OperatingSystemConfig</h1><h1 id=contract-operatingsystemconfig-resource>Contract: <code>OperatingSystemConfig</code> Resource<a class=td-heading-self-link href=#contract-operatingsystemconfig-resource aria-label="Heading self-link"></a></h1><p>Gardener uses the machine API and leverages the functionalities of the <a href=https://github.com/gardener/machine-controller-manager>machine-controller-manager</a> (MCM) in order to manage the worker nodes of a shoot cluster.
The machine-controller-manager itself simply takes a reference to an OS-image and (optionally) some user-data (a script or configuration that is executed when a VM is bootstrapped), and forwards both to the provider&rsquo;s API when creating VMs.
MCM does not have any restrictions regarding supported operating systems as it does not modify or influence the machine&rsquo;s configuration in any way - it just creates/deletes machines with the provided metadata.</p><p>Consequently, Gardener needs to provide this information when interacting with the machine-controller-manager.
This means that basically every operating system is possible to be used, as long as there is some implementation that generates the OS-specific configuration in order to provision/bootstrap the machines.</p><p>&#9888;&#xfe0f; Currently, there are a few requirements of pre-installed components that must be present in all OS images:</p><ol><li><a href=https://containerd.io/>containerd</a><ol><li><a href=https://github.com/projectatomic/containerd/blob/master/docs/cli.md/>ctr (client CLI)</a></li><li><code>containerd</code> must listen on its default socket path: <code>unix:///run/containerd/containerd.sock</code></li><li><code>containerd</code> must be configured to work with the default configuration file in: <code>/etc/containerd/config.toml</code> (eventually created by Gardener).</li></ol></li><li><a href=https://www.freedesktop.org/wiki/Software/systemd/>systemd</a></li></ol><p>The reasons for that will become evident later.</p><h2 id=what-does-the-user-data-bootstrapping-the-machines-contain>What does the user-data bootstrapping the machines contain?<a class=td-heading-self-link href=#what-does-the-user-data-bootstrapping-the-machines-contain aria-label="Heading self-link"></a></h2><p>Gardener installs a few components onto every worker machine in order to allow it to join the shoot cluster.
There is the <code>kubelet</code> process, some scripts for continuously checking the health of <code>kubelet</code> and <code>containerd</code>, but also configuration for log rotation, CA certificates, etc.
You can find the complete configuration <a href=https://github.com/gardener/gardener/tree/master/pkg/component/extensions/operatingsystemconfig/original/components>at the components folder</a>. We are calling this the &ldquo;original&rdquo; user-data.</p><h2 id=how-does-gardener-bootstrap-the-machines>How does Gardener bootstrap the machines?<a class=td-heading-self-link href=#how-does-gardener-bootstrap-the-machines aria-label="Heading self-link"></a></h2><p><code>gardenlet</code> makes use of <code>gardener-node-agent</code> to perform the bootstrapping and reconciliation of systemd units and files on the machine.
Please refer to <a href=/docs/gardener/concepts/node-agent/#installation-and-bootstrapping>this document</a> for a first overview.</p><p>Usually, you would submit all the components you want to install onto the machine as part of the user-data during creation time.
However, some providers do have a size limitation (around ~16KB) for that user-data.
That&rsquo;s why we do not send the &ldquo;original&rdquo; user-data to the machine-controller-manager (who then forwards it to the provider&rsquo;s API).
Instead, we only send a small &ldquo;init&rdquo; script that bootstrap the <a href=/docs/gardener/concepts/node-agent/><code>gardener-node-agent</code></a>.
It fetches the &ldquo;original&rdquo; content from a <code>Secret</code> and applies it on the machine directly.
This way we can extend the &ldquo;original&rdquo; user-data without any size restrictions (except for the <code>1 MB</code> limit for <code>Secret</code>s).</p><p>The high-level flow is as follows:</p><ol><li>For every worker pool <code>X</code> in the <code>Shoot</code> specification, Gardener creates a <code>Secret</code> named <code>cloud-config-&lt;X></code> in the <code>kube-system</code> namespace of the shoot cluster. The secret contains the &ldquo;original&rdquo; <code>OperatingSystemConfig</code> (i.e., systemd units and files for <code>kubelet</code>).</li><li>Gardener generates a kubeconfig with minimal permissions just allowing reading these secrets. It is used by the <code>gardener-node-agent</code> later.</li><li>Gardener provides the <code>gardener-node-init.sh</code> bash script and the machine image stated in the <code>Shoot</code> specification to the machine-controller-manager.</li><li>Based on this information, the machine-controller-manager creates the VM.</li><li>After the VM has been provisioned, the <code>gardener-node-init.sh</code> script starts, fetches the <code>gardener-node-agent</code> binary, and starts it.</li><li>The <code>gardener-node-agent</code> will read the <code>gardener-node-agent-&lt;X></code> <code>Secret</code> for its worker pool (containing the &ldquo;original&rdquo; <code>OperatingSystemConfig</code>), and reconciles it.</li></ol><p>The <code>gardener-node-agent</code> can update itself in case of newer Gardener versions, and it performs a continuous reconciliation of the systemd units and files in the provided <code>OperatingSystemConfig</code> (just like any other Kubernetes controller).</p><h2 id=what-needs-to-be-implemented-to-support-a-new-operating-system>What needs to be implemented to support a new operating system?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-operating-system aria-label="Heading self-link"></a></h2><p>As part of the <a href=/docs/gardener/concepts/gardenlet/#shoot-controller><code>Shoot</code> reconciliation flow</a>, <code>gardenlet</code> will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: OperatingSystemConfig
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: pool-01-original
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: &lt;my-operating-system&gt;
</span></span><span style=display:flex><span>  purpose: reconcile
</span></span><span style=display:flex><span>  units:
</span></span><span style=display:flex><span>  - name: containerd.service
</span></span><span style=display:flex><span>    dropIns:
</span></span><span style=display:flex><span>    - name: 10-containerd-opts.conf
</span></span><span style=display:flex><span>      content: |<span style=color:#a31515>
</span></span></span><span style=display:flex><span><span style=color:#a31515>        [Service]
</span></span></span><span style=display:flex><span><span style=color:#a31515>        Environment=&#34;SOME_OPTS=--foo=bar&#34;</span>        
</span></span><span style=display:flex><span>  - name: containerd-monitor.service
</span></span><span style=display:flex><span>    command: start
</span></span><span style=display:flex><span>    enable: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    content: |<span style=color:#a31515>
</span></span></span><span style=display:flex><span><span style=color:#a31515>      [Unit]
</span></span></span><span style=display:flex><span><span style=color:#a31515>      Description=Containerd-monitor daemon
</span></span></span><span style=display:flex><span><span style=color:#a31515>      After=kubelet.service
</span></span></span><span style=display:flex><span><span style=color:#a31515>      [Install]
</span></span></span><span style=display:flex><span><span style=color:#a31515>      WantedBy=multi-user.target
</span></span></span><span style=display:flex><span><span style=color:#a31515>      [Service]
</span></span></span><span style=display:flex><span><span style=color:#a31515>      Restart=always
</span></span></span><span style=display:flex><span><span style=color:#a31515>      EnvironmentFile=/etc/environment
</span></span></span><span style=display:flex><span><span style=color:#a31515>      ExecStart=/opt/bin/health-monitor containerd</span>      
</span></span><span style=display:flex><span>  files:
</span></span><span style=display:flex><span>  - path: /var/lib/kubelet/ca.crt
</span></span><span style=display:flex><span>    permissions: 0644
</span></span><span style=display:flex><span>    encoding: b64
</span></span><span style=display:flex><span>    content:
</span></span><span style=display:flex><span>      secretRef:
</span></span><span style=display:flex><span>        name: default-token-5dtjz
</span></span><span style=display:flex><span>        dataKey: token
</span></span><span style=display:flex><span>  - path: /etc/sysctl.d/99-k8s-general.conf
</span></span><span style=display:flex><span>    permissions: 0644
</span></span><span style=display:flex><span>    content:
</span></span><span style=display:flex><span>      inline:
</span></span><span style=display:flex><span>        data: |<span style=color:#a31515>
</span></span></span><span style=display:flex><span><span style=color:#a31515>          # A higher vm.max_map_count is great for elasticsearch, mongo, or other mmap users
</span></span></span><span style=display:flex><span><span style=color:#a31515>          # See https://github.com/kubernetes/kops/issues/1340
</span></span></span><span style=display:flex><span><span style=color:#a31515>          vm.max_map_count = 135217728</span>          
</span></span></code></pre></div><p>In order to support a new operating system, you need to write a controller that watches all <code>OperatingSystemConfig</code>s with <code>.spec.type=&lt;my-operating-system></code>.
For those it shall generate a configuration blob that fits to your operating system.</p><p><code>OperatingSystemConfig</code>s can have two purposes: either <code>provision</code> or <code>reconcile</code>.</p><h3 id=provision-purpose><code>provision</code> Purpose<a class=td-heading-self-link href=#provision-purpose aria-label="Heading self-link"></a></h3><p>The <code>provision</code> purpose is used by <code>gardenlet</code> for the user-data that it later passes to the machine-controller-manager (and then to the provider&rsquo;s API) when creating new VMs.
It contains the <code>gardener-node-init.sh</code> script and systemd unit.</p><p>The OS controller has to translate the <code>.spec.units</code> and <code>.spec.files</code> into configuration that fits to the operating system.
For example, a Flatcar controller might generate a <a href=https://github.com/flatcar/coreos-cloudinit/blob/flatcar-master/Documentation/cloud-config-examples.md>CoreOS cloud-config</a> or <a href=https://coreos.com/ignition/docs/latest/what-is-ignition.html>Ignition</a>, SLES might generate <a href=https://cloudinit.readthedocs.io/en/latest/>cloud-init</a>, and others might simply generate a bash script translating the <code>.spec.units</code> into <code>systemd</code> units, and <code>.spec.files</code> into real files on the disk.</p><blockquote><p>⚠️ Please avoid mixing in additional systemd units or files - this step should just translate what <code>gardenlet</code> put into <code>.spec.units</code> and <code>.spec.files</code>.</p></blockquote><p>After generation, extension controllers are asked to store their OS config inside a <code>Secret</code> (as it might contain confidential data) in the same namespace.
The secret&rsquo;s <code>.data</code> could look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: osc-result-pool-01-original
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  ownerReferences:
</span></span><span style=display:flex><span>  - apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    blockOwnerDeletion: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    controller: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    kind: OperatingSystemConfig
</span></span><span style=display:flex><span>    name: pool-01-original
</span></span><span style=display:flex><span>    uid: 99c0c5ca-19b9-11e9-9ebd-d67077b40f82
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  cloud_config: base64(generated-user-data)
</span></span></code></pre></div><p>Finally, the secret&rsquo;s metadata must be provided in the <code>OperatingSystemConfig</code>&rsquo;s <code>.status</code> field:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  cloudConfig:
</span></span><span style=display:flex><span>    secretRef:
</span></span><span style=display:flex><span>      name: osc-result-pool-01-original
</span></span><span style=display:flex><span>      namespace: default
</span></span><span style=display:flex><span>  lastOperation:
</span></span><span style=display:flex><span>    description: Successfully generated cloud config
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2019-01-23T07:45:23Z&#34;</span>
</span></span><span style=display:flex><span>    progress: 100
</span></span><span style=display:flex><span>    state: Succeeded
</span></span><span style=display:flex><span>    type: Reconcile
</span></span><span style=display:flex><span>  observedGeneration: 5
</span></span></code></pre></div><h3 id=reconcile-purpose><code>reconcile</code> Purpose<a class=td-heading-self-link href=#reconcile-purpose aria-label="Heading self-link"></a></h3><p>The <code>reconcile</code> purpose contains the &ldquo;original&rdquo; <code>OperatingSystemConfig</code> (which is later stored in <code>Secret</code>s in the shoot&rsquo;s <code>kube-system</code> namespace (see step 1)). This is downloaded and applies late (see step 5).</p><p>The OS controller does not need to translate anything here, but it has the option to provide additional systemd units or files via the <code>.status</code> field:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  extensionUnits:
</span></span><span style=display:flex><span>  - name: my-custom-service.service
</span></span><span style=display:flex><span>    command: start
</span></span><span style=display:flex><span>    enable: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    content: |<span style=color:#a31515>
</span></span></span><span style=display:flex><span><span style=color:#a31515>      [Unit]
</span></span></span><span style=display:flex><span><span style=color:#a31515>      // some systemd unit content</span>      
</span></span><span style=display:flex><span>  extensionFiles:
</span></span><span style=display:flex><span>  - path: /etc/some/file
</span></span><span style=display:flex><span>    permissions: 0644
</span></span><span style=display:flex><span>    content:
</span></span><span style=display:flex><span>      inline:
</span></span><span style=display:flex><span>        data: some-file-content
</span></span><span style=display:flex><span>  lastOperation:
</span></span><span style=display:flex><span>    description: Successfully generated cloud config
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2019-01-23T07:45:23Z&#34;</span>
</span></span><span style=display:flex><span>    progress: 100
</span></span><span style=display:flex><span>    state: Succeeded
</span></span><span style=display:flex><span>    type: Reconcile
</span></span><span style=display:flex><span>  observedGeneration: 5
</span></span></code></pre></div><p>The <code>gardener-node-agent</code> will merge <code>.spec.units</code> and <code>.status.extensionUnits</code> as well as <code>.spec.files</code> and <code>.status.extensionFiles</code> when applying.</p><p>You can find an example implementation <a href=https://github.com/gardener/gardener/blob/master/pkg/provider-local/controller/operatingsystemconfig/actuator.go>here</a>.</p><p>As described above, the &ldquo;original&rdquo; user-data must be re-applicable to allow in-place updates.
The way how this is done is specific to the generated operating system config (e.g., for CoreOS cloud-init the command is <code>/usr/bin/coreos-cloudinit --from-file=&lt;path></code>, whereas SLES would run <code>cloud-init --file &lt;path> single -n write_files --frequency=once</code>).
Consequently, besides the generated OS config, the extension controller must also provide a command for re-application an updated version of the user-data.
As visible in the mentioned examples, the command requires a path to the user-data file.
As soon as Gardener detects that the user data has changed it will reload the systemd daemon and restart all the units provided in the <code>.status.units[]</code> list (see the below example). The same logic applies during the very first application of the whole configuration.</p><p>After generation, extension controllers are asked to store their OS config inside a <code>Secret</code> (as it might contain confidential data) in the same namespace.
The secret&rsquo;s <code>.data</code> could look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: osc-result-pool-01-original
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  ownerReferences:
</span></span><span style=display:flex><span>  - apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    blockOwnerDeletion: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    controller: <span style=color:#00f>true</span>
</span></span><span style=display:flex><span>    kind: OperatingSystemConfig
</span></span><span style=display:flex><span>    name: pool-01-original
</span></span><span style=display:flex><span>    uid: 99c0c5ca-19b9-11e9-9ebd-d67077b40f82
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  cloud_config: base64(generated-user-data)
</span></span></code></pre></div><p>Finally, the secret&rsquo;s metadata, the OS-specific command to re-apply the configuration, and the list of <code>systemd</code> units that shall be considered to be restarted if an updated version of the user-data is re-applied must be provided in the <code>OperatingSystemConfig</code>&rsquo;s <code>.status</code> field:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  cloudConfig:
</span></span><span style=display:flex><span>    secretRef:
</span></span><span style=display:flex><span>      name: osc-result-pool-01-original
</span></span><span style=display:flex><span>      namespace: default
</span></span><span style=display:flex><span>  lastOperation:
</span></span><span style=display:flex><span>    description: Successfully generated cloud config
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2019-01-23T07:45:23Z&#34;</span>
</span></span><span style=display:flex><span>    progress: 100
</span></span><span style=display:flex><span>    state: Succeeded
</span></span><span style=display:flex><span>    type: Reconcile
</span></span><span style=display:flex><span>  observedGeneration: 5
</span></span><span style=display:flex><span>  units:
</span></span><span style=display:flex><span>  - docker-monitor.service
</span></span></code></pre></div><p>Once the <code>.status</code> indicates that the extension controller finished reconciling Gardener will continue with the next step of the shoot reconciliation flow.</p><h3 id=bootstrap-tokens>Bootstrap Tokens<a class=td-heading-self-link href=#bootstrap-tokens aria-label="Heading self-link"></a></h3><p><code>gardenlet</code> adds a file with the content <code>&lt;&lt;BOOTSTRAP_TOKEN>></code> to the <code>OperatingSystemConfig</code> with purpose <code>provision</code> and sets <code>transmitUnencoded=true</code>.
This instructs the responsible OS extension to pass this file (with its content in clear-text) to the corresponding <code>Worker</code> resource.</p><p><code>machine-controller-manager</code> makes sure that:</p><ul><li>a bootstrap token gets created per machine</li><li>the <code>&lt;&lt;BOOTSTRAP_TOKEN>></code> string in the user data of the machine gets replaced by the generated token</li></ul><p>After the machine has been bootstrapped, the token secret in the shoot cluster gets deleted again.</p><p>The token is used to bootstrap <a href=/docs/gardener/concepts/node-agent/>Gardener Node Agent</a> and <code>kubelet</code>.</p><h3 id=in-place-os-updates>In-Place OS Updates<a class=td-heading-self-link href=#in-place-os-updates aria-label="Heading self-link"></a></h3><p>Gardener enables in-place OS updates for worker nodes, allowing OS updates without replacing the node. This feature executes a predefined command on the node to perform the update.</p><p>For an OS to support in-place updates, it must meet the following prerequisites:</p><ul><li>The machine image or operating system must support in-place updates with a tool or utility to initiate the process.</li><li>The update mechanism should ensure reliability by:<ul><li>Booting into the updated version if successful.</li><li>Reverting to the previous version in case of failure.</li></ul></li><li>The update tool may also provide configuration options, including:<ul><li>Retry Configuration: The ability to define the number of retries for the update.</li><li>Registry Configuration: The option to specify the registry from which the OS image is pulled.</li></ul></li></ul><p>An OS supporting in-place updates must define the update configuration in <code>.status.inPlaceUpdates</code> as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  inPlaceUpdates:
</span></span><span style=display:flex><span>    osUpdate:
</span></span><span style=display:flex><span>      command: /update-me
</span></span><span style=display:flex><span>      args:
</span></span><span style=display:flex><span>        - foo
</span></span><span style=display:flex><span>        - bar
</span></span></code></pre></div><ul><li><code>command</code>: Specifies the path to the OS update utility or script to be executed on the node.</li><li><code>args</code>: Provides optional flags or arguments to customize the update behavior.</li></ul><h2 id=cri-support>CRI Support<a class=td-heading-self-link href=#cri-support aria-label="Heading self-link"></a></h2><p>Gardener supports specifying a Container Runtime Interface (CRI) configuration in the <code>OperatingSystemConfig</code> resource. If the <code>.spec.cri</code> section exists, then the <code>name</code> property is mandatory. The only supported value for <code>cri.name</code> at the moment is: <code>containerd</code>.
For example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: OperatingSystemConfig
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: pool-01-original
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: &lt;my-operating-system&gt;
</span></span><span style=display:flex><span>  purpose: reconcile
</span></span><span style=display:flex><span>  cri:
</span></span><span style=display:flex><span>    name: containerd
</span></span><span style=display:flex><span><span style=color:green>#   cgroupDriver: cgroupfs # or systemd</span>
</span></span><span style=display:flex><span>    containerd:
</span></span><span style=display:flex><span>      sandboxImage: registry.k8s.io/pause
</span></span><span style=display:flex><span><span style=color:green>#     registries:</span>
</span></span><span style=display:flex><span><span style=color:green>#     - upstream: docker.io</span>
</span></span><span style=display:flex><span><span style=color:green>#       server: https://registry-1.docker.io</span>
</span></span><span style=display:flex><span><span style=color:green>#       hosts:</span>
</span></span><span style=display:flex><span><span style=color:green>#       - url: http://&lt;service-ip&gt;:&lt;port&gt;]</span>
</span></span><span style=display:flex><span><span style=color:green>#     plugins:</span>
</span></span><span style=display:flex><span><span style=color:green>#     - op: add # add (default) or remove</span>
</span></span><span style=display:flex><span><span style=color:green>#       path: [io.containerd.grpc.v1.cri, containerd]</span>
</span></span><span style=display:flex><span><span style=color:green>#       values: &#39;{&#34;default_runtime_name&#34;: &#34;runc&#34;}&#39;</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>To support <code>containerd</code>, an OS extension must satisfy the following criteria:</p><ol><li>The operating system must have built-in <a href=https://containerd.io/>containerd</a> and <a href=https://github.com/projectatomic/containerd/blob/master/docs/cli.md/>ctr (client CLI)</a>.</li><li><code>containerd</code> must listen on its default socket path: <code>unix:///run/containerd/containerd.sock</code></li><li><code>containerd</code> must be configured to work with the default configuration file in: <code>/etc/containerd/config.toml</code> (Created by Gardener).</li></ol><p>For a convenient handling, <a href=/docs/gardener/concepts/node-agent/>gardener-node-agent</a> can manage various aspects of containerd&rsquo;s config, e.g. the registry configuration, if given in the <code>OperatingSystemConfig</code>.
Any Gardener extension which needs to modify the config, should check the functionality exposed through this API first.
If applicable, adjustments can be implemented through mutating webhooks, acting on the created or updated <code>OperatingSystemConfig</code> resource.</p><p>If CRI configurations are not supported, it is recommended to create a validating webhook running in the garden cluster that prevents specifying the <code>.spec.providers.workers[].cri</code> section in the <code>Shoot</code> objects.</p><h3 id=cgroup-driver>cgroup driver<a class=td-heading-self-link href=#cgroup-driver aria-label="Heading self-link"></a></h3><p>For Shoot clusters using Kubernetes &lt; 1.31, Gardener is setting the kubelet&rsquo;s cgroup driver to <a href=https://kubernetes.io/docs/setup/production-environment/container-runtimes/#cgroupfs-cgroup-driver><code>cgroupfs</code></a> and containerd&rsquo;s cgroup driver is unmanaged. For Shoot clusters using Kubernetes 1.31+, Gardener is setting both kubelet&rsquo;s and containerd&rsquo;s cgroup driver to <a href=https://kubernetes.io/docs/setup/production-environment/container-runtimes/#systemd-cgroup-driver><code>systemd</code></a>.</p><p>The <code>systemd</code> cgroup driver is a requirement for operating systems using <a href=https://kubernetes.io/docs/concepts/architecture/cgroups/>cgroup v2</a>. It&rsquo;s important to ensure that both kubelet and the container runtime (containerd) are using the same cgroup driver to avoid potential issues.</p><p>OS extensions might also overwrite the cgroup driver for containerd and kubelet.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_operatingsystemconfig.go><code>OperatingSystemConfig</code> API (Golang Specification)</a></li><li><a href=/docs/gardener/concepts/node-agent/>Gardener Node Agent</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cb90be03fc1226f8ac3dd89d3a062129>18.12 - Worker</h1><h1 id=contract-worker-resource>Contract: <code>Worker</code> Resource<a class=td-heading-self-link href=#contract-worker-resource aria-label="Heading self-link"></a></h1><p>While the control plane of a shoot cluster is living in the seed and deployed as native Kubernetes workload, the worker nodes of the shoot clusters are normal virtual machines (VMs) in the end-users infrastructure account.
The Gardener project features a sub-project called <a href=https://github.com/gardener/machine-controller-manager>machine-controller-manager</a>.
This controller is extending the Kubernetes API using custom resource definitions to represent actual VMs as <code>Machine</code> objects inside a Kubernetes system.
This approach unlocks the possibility to manage virtual machines in the Kubernetes style and benefit from all its design principles.</p><h2 id=what-is-the-machine-controller-manager-doing-exactly>What is the machine-controller-manager doing exactly?<a class=td-heading-self-link href=#what-is-the-machine-controller-manager-doing-exactly aria-label="Heading self-link"></a></h2><p>Generally, there are provider-specific <code>MachineClass</code> objects (<code>AWSMachineClass</code>, <code>AzureMachineClass</code>, etc.; similar to <code>StorageClass</code>), and <code>MachineDeployment</code>, <code>MachineSet</code>, and <code>Machine</code> objects (similar to <code>Deployment</code>, <code>ReplicaSet</code>, and <code>Pod</code>).
A machine class describes <strong>where</strong> and <strong>how</strong> to create virtual machines (in which networks, region, availability zone, SSH key, user-data for bootstrapping, etc.), while a <code>Machine</code> results in an actual virtual machine.
You can read up <a href=https://github.com/gardener/machine-controller-manager>more information</a> in the machine-controller-manager&rsquo;s <a href=https://github.com/gardener/machine-controller-manager>repository</a>.</p><p>The <code>gardenlet</code> deploys the <code>machine-controller-manager</code>, hence, provider extensions only have to inject their specific out-of-tree <code>machine-controller-manager</code> sidecar container into the <code>Deployment</code>.</p><h2 id=what-needs-to-be-implemented-to-support-a-new-worker-provider>What needs to be implemented to support a new worker provider?<a class=td-heading-self-link href=#what-needs-to-be-implemented-to-support-a-new-worker-provider aria-label="Heading self-link"></a></h2><p>As part of the shoot flow Gardener will create a special CRD in the seed cluster that needs to be reconciled by an extension controller, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Worker
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: bar
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  type: azure
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: cloudprovider
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  infrastructureProviderStatus:
</span></span><span style=display:flex><span>    apiVersion: aws.provider.extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>    kind: InfrastructureStatus
</span></span><span style=display:flex><span>    ec2:
</span></span><span style=display:flex><span>      keyName: shoot--foo--bar-ssh-publickey
</span></span><span style=display:flex><span>    iam:
</span></span><span style=display:flex><span>      instanceProfiles:
</span></span><span style=display:flex><span>      - name: shoot--foo--bar-nodes
</span></span><span style=display:flex><span>        purpose: nodes
</span></span><span style=display:flex><span>      roles:
</span></span><span style=display:flex><span>      - arn: arn:aws:iam::0123456789:role/shoot--foo--bar-nodes
</span></span><span style=display:flex><span>        purpose: nodes
</span></span><span style=display:flex><span>    vpc:
</span></span><span style=display:flex><span>      id: vpc-0123456789
</span></span><span style=display:flex><span>      securityGroups:
</span></span><span style=display:flex><span>      - id: sg-1234567890
</span></span><span style=display:flex><span>        purpose: nodes
</span></span><span style=display:flex><span>      subnets:
</span></span><span style=display:flex><span>      - id: subnet-01234
</span></span><span style=display:flex><span>        purpose: nodes
</span></span><span style=display:flex><span>        zone: eu-west-1b
</span></span><span style=display:flex><span>      - id: subnet-56789
</span></span><span style=display:flex><span>        purpose: public
</span></span><span style=display:flex><span>        zone: eu-west-1b
</span></span><span style=display:flex><span>      - id: subnet-0123a
</span></span><span style=display:flex><span>        purpose: nodes
</span></span><span style=display:flex><span>        zone: eu-west-1c
</span></span><span style=display:flex><span>      - id: subnet-5678a
</span></span><span style=display:flex><span>        purpose: public
</span></span><span style=display:flex><span>        zone: eu-west-1c
</span></span><span style=display:flex><span>  pools:
</span></span><span style=display:flex><span>  - name: cpu-worker
</span></span><span style=display:flex><span>    minimum: 3
</span></span><span style=display:flex><span>    maximum: 5
</span></span><span style=display:flex><span>    maxSurge: 1
</span></span><span style=display:flex><span>    maxUnavailable: 0
</span></span><span style=display:flex><span>    machineType: m4.large
</span></span><span style=display:flex><span>    machineImage:
</span></span><span style=display:flex><span>      name: coreos
</span></span><span style=display:flex><span>      version: 1967.5.0
</span></span><span style=display:flex><span>    nodeAgentSecretName: gardener-node-agent-local-ee46034b8269353b
</span></span><span style=display:flex><span>    nodeTemplate:
</span></span><span style=display:flex><span>      capacity:
</span></span><span style=display:flex><span>        cpu: 2
</span></span><span style=display:flex><span>        gpu: 0
</span></span><span style=display:flex><span>        memory: 8Gi
</span></span><span style=display:flex><span>      virtualCapacity: 
</span></span><span style=display:flex><span>        subdomain.domain.com/resource-name: 1234567
</span></span><span style=display:flex><span>    labels:
</span></span><span style=display:flex><span>      node.kubernetes.io/role: node
</span></span><span style=display:flex><span>      worker.gardener.cloud/cri-name: containerd
</span></span><span style=display:flex><span>      worker.gardener.cloud/pool: cpu-worker
</span></span><span style=display:flex><span>      worker.gardener.cloud/system-components: <span style=color:#a31515>&#34;true&#34;</span>
</span></span><span style=display:flex><span>    userDataSecretRef:
</span></span><span style=display:flex><span>      name: user-data-secret
</span></span><span style=display:flex><span>      key: cloud_config
</span></span><span style=display:flex><span>    volume:
</span></span><span style=display:flex><span>      size: 20Gi
</span></span><span style=display:flex><span>      type: gp2
</span></span><span style=display:flex><span>    zones:
</span></span><span style=display:flex><span>    - eu-west-1b
</span></span><span style=display:flex><span>    - eu-west-1c
</span></span><span style=display:flex><span>    machineControllerManager:
</span></span><span style=display:flex><span>      drainTimeout: 10m
</span></span><span style=display:flex><span>      healthTimeout: 10m
</span></span><span style=display:flex><span>      creationTimeout: 10m
</span></span><span style=display:flex><span>      maxEvictRetries: 30
</span></span><span style=display:flex><span>      nodeConditions:
</span></span><span style=display:flex><span>      - ReadonlyFilesystem
</span></span><span style=display:flex><span>      - DiskPressure
</span></span><span style=display:flex><span>      - KernelDeadlock
</span></span><span style=display:flex><span>    clusterAutoscaler:
</span></span><span style=display:flex><span>      scaleDownUtilizationThreshold: 0.5
</span></span><span style=display:flex><span>      scaleDownGpuUtilizationThreshold: 0.5
</span></span><span style=display:flex><span>      scaleDownUnneededTime: 30m
</span></span><span style=display:flex><span>      scaleDownUnreadyTime: 1h
</span></span><span style=display:flex><span>      maxNodeProvisionTime: 15m
</span></span></code></pre></div><p>The <code>.spec.secretRef</code> contains a reference to the provider secret pointing to the account that shall be used to create the needed virtual machines.
Also, as you can see, Gardener copies the output of the infrastructure creation (<code>.spec.infrastructureProviderStatus</code>, see <a href=/docs/gardener/extensions/resources/infrastructure/><code>Infrastructure</code> resource</a>), into the <code>.spec</code>.</p><p>In the <code>.spec.pools[]</code> field, the desired worker pools are listed.
In the above example, one pool with machine type <code>m4.large</code> and <code>min=3</code>, <code>max=5</code> machines shall be spread over two availability zones (<code>eu-west-1b</code>, <code>eu-west-1c</code>).
This information together with the infrastructure status must be used to determine the proper configuration for the machine classes.</p><p>The <code>spec.pools[].labels</code> map contains all labels that should be added to all nodes of the corresponding worker pool.
Gardener configures kubelet&rsquo;s <code>--node-labels</code> flag to contain all labels that are mentioned here and allowed by the <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction><code>NodeRestriction</code> admission plugin</a>.
This makes sure that kubelet adds all user-specified and gardener-managed labels to the new <code>Node</code> object when registering a new machine with the API server.
Nevertheless, this is only effective when bootstrapping new nodes.
The provider extension (respectively, machine-controller-manager) is still responsible for updating the labels of existing <code>Nodes</code> when the worker specification changes.</p><p>The <code>spec.pools[].nodeTemplate.capacity</code> field contains the resource information of the machine like <code>cpu</code>, <code>gpu</code>, and <code>memory</code>. This info is used by Cluster Autoscaler to generate <code>nodeTemplate</code> during scaling the <code>nodeGroup</code> from zero.</p><p>The <code>spec.pools[].nodeTemplate.virtualCapacity</code> field contains the <em>virtual</em> resource information associated with the machine and used to specify extended resources that are <em>virtual</em> in nature (for specifying real, provisionable resources, <code>nodeTemplate.capacity</code> should be used). This will be applied to the machine class <code>nodeTemplate</code> without triggering a rollout of the cluster and will be used by Cluster Autoscaler for scaling the <code>nodeGroup</code>.</p><p>The <code>spec.pools[].machineControllerManager</code> field allows to configure the settings for machine-controller-manager component. Providers must populate these settings on worker-pool to the related <a href=https://github.com/gardener/machine-controller-manager/blob/master/kubernetes/machine_objects/machine-deployment.yaml#L30-L34>fields</a> in MachineDeployment.</p><p>The <code>spec.pools[].clusterAutoscaler</code> field contains <code>cluster-autoscaler</code> settings that are to be applied only to specific worker group. <code>cluster-autoscaler</code> expects to find these settings as annotations on the <code>MachineDeployment</code>, and so providers must pass these values to the corresponding <code>MachineDeployment</code> via annotations. The keys for these annotations can be found <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_worker.go>here</a> and the values for the corresponding annotations should be the same as what is passed into the field. Providers can use the helper function <a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/helper/worker.go><code>extensionsv1alpha1helper.GetMachineDeploymentClusterAutoscalerAnnotations</code></a> that returns the annotation map to be used.</p><p>The controller must only inject its provider-specific sidecar container into the <code>machine-controller-manager</code> <code>Deployment</code> managed by <code>gardenlet</code>.</p><p>After that, it must compute the desired machine classes and the desired machine deployments.
Typically, one class maps to one deployment, and one class/deployment is created per availability zone.
Following this convention, the created resource would look like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar-cpu-worker-z1-3db65
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    gardener.cloud/purpose: machineclass
</span></span><span style=display:flex><span>type: Opaque
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  providerAccessKeyId: eW91ci1hd3MtYWNjZXNzLWtleS1pZAo=
</span></span><span style=display:flex><span>  providerSecretAccessKey: eW91ci1hd3Mtc2VjcmV0LWFjY2Vzcy1rZXkK
</span></span><span style=display:flex><span>  userData: c29tZSBkYXRhIHRvIGJvb3RzdHJhcCB0aGUgVk0K
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: machine.sapcloud.io/v1alpha1
</span></span><span style=display:flex><span>kind: AWSMachineClass
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar-cpu-worker-z1-3db65
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ami: ami-0123456789 <span style=color:green># Your controller must map the stated version to the provider specific machine image information, in the AWS case the AMI.</span>
</span></span><span style=display:flex><span>  blockDevices:
</span></span><span style=display:flex><span>  - ebs:
</span></span><span style=display:flex><span>      volumeSize: 20
</span></span><span style=display:flex><span>      volumeType: gp2
</span></span><span style=display:flex><span>  iam:
</span></span><span style=display:flex><span>    name: shoot--foo--bar-nodes
</span></span><span style=display:flex><span>  keyName: shoot--foo--bar-ssh-publickey
</span></span><span style=display:flex><span>  machineType: m4.large
</span></span><span style=display:flex><span>  networkInterfaces:
</span></span><span style=display:flex><span>  - securityGroupIDs:
</span></span><span style=display:flex><span>    - sg-1234567890
</span></span><span style=display:flex><span>    subnetID: subnet-01234
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: shoot--foo--bar-cpu-worker-z1-3db65
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  tags:
</span></span><span style=display:flex><span>    kubernetes.io/cluster/shoot--foo--bar: <span style=color:#a31515>&#34;1&#34;</span>
</span></span><span style=display:flex><span>    kubernetes.io/role/node: <span style=color:#a31515>&#34;1&#34;</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: machine.sapcloud.io/v1alpha1
</span></span><span style=display:flex><span>kind: MachineDeployment
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  replicas: 2
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>  strategy:
</span></span><span style=display:flex><span>    type: RollingUpdate
</span></span><span style=display:flex><span>    rollingUpdate:
</span></span><span style=display:flex><span>      maxSurge: 1
</span></span><span style=display:flex><span>      maxUnavailable: 0
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      class:
</span></span><span style=display:flex><span>        kind: AWSMachineClass
</span></span><span style=display:flex><span>        name: shoot--foo--bar-cpu-worker-z1-3db65
</span></span></code></pre></div><p>for the first availability zone <code>eu-west-1b</code>, and</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Secret
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar-cpu-worker-z2-5z6as
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    gardener.cloud/purpose: machineclass
</span></span><span style=display:flex><span>type: Opaque
</span></span><span style=display:flex><span>data:
</span></span><span style=display:flex><span>  providerAccessKeyId: eW91ci1hd3MtYWNjZXNzLWtleS1pZAo=
</span></span><span style=display:flex><span>  providerSecretAccessKey: eW91ci1hd3Mtc2VjcmV0LWFjY2Vzcy1rZXkK
</span></span><span style=display:flex><span>  userData: c29tZSBkYXRhIHRvIGJvb3RzdHJhcCB0aGUgVk0K
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: machine.sapcloud.io/v1alpha1
</span></span><span style=display:flex><span>kind: AWSMachineClass
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar-cpu-worker-z2-5z6as
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ami: ami-0123456789 <span style=color:green># Your controller must map the stated version to the provider specific machine image information, in the AWS case the AMI.</span>
</span></span><span style=display:flex><span>  blockDevices:
</span></span><span style=display:flex><span>  - ebs:
</span></span><span style=display:flex><span>      volumeSize: 20
</span></span><span style=display:flex><span>      volumeType: gp2
</span></span><span style=display:flex><span>  iam:
</span></span><span style=display:flex><span>    name: shoot--foo--bar-nodes
</span></span><span style=display:flex><span>  keyName: shoot--foo--bar-ssh-publickey
</span></span><span style=display:flex><span>  machineType: m4.large
</span></span><span style=display:flex><span>  networkInterfaces:
</span></span><span style=display:flex><span>  - securityGroupIDs:
</span></span><span style=display:flex><span>    - sg-1234567890
</span></span><span style=display:flex><span>    subnetID: subnet-0123a
</span></span><span style=display:flex><span>  region: eu-west-1
</span></span><span style=display:flex><span>  secretRef:
</span></span><span style=display:flex><span>    name: shoot--foo--bar-cpu-worker-z2-5z6as
</span></span><span style=display:flex><span>    namespace: shoot--foo--bar
</span></span><span style=display:flex><span>  tags:
</span></span><span style=display:flex><span>    kubernetes.io/cluster/shoot--foo--bar: <span style=color:#a31515>&#34;1&#34;</span>
</span></span><span style=display:flex><span>    kubernetes.io/role/node: <span style=color:#a31515>&#34;1&#34;</span>
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: machine.sapcloud.io/v1alpha1
</span></span><span style=display:flex><span>kind: MachineDeployment
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  replicas: 1
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    matchLabels:
</span></span><span style=display:flex><span>      name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>  strategy:
</span></span><span style=display:flex><span>    type: RollingUpdate
</span></span><span style=display:flex><span>    rollingUpdate:
</span></span><span style=display:flex><span>      maxSurge: 1
</span></span><span style=display:flex><span>      maxUnavailable: 0
</span></span><span style=display:flex><span>  template:
</span></span><span style=display:flex><span>    metadata:
</span></span><span style=display:flex><span>      labels:
</span></span><span style=display:flex><span>        name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>    spec:
</span></span><span style=display:flex><span>      class:
</span></span><span style=display:flex><span>        kind: AWSMachineClass
</span></span><span style=display:flex><span>        name: shoot--foo--bar-cpu-worker-z2-5z6as
</span></span></code></pre></div><p>for the second availability zone <code>eu-west-1c</code>.</p><p>Another convention is the 5-letter hash at the end of the machine class names.
Most controllers compute a checksum out of the specification of the machine class.
Any change to the value of the <code>nodeAgentSecretName</code> field must result in a change of the machine class name.
The checksum in the machine class name helps to trigger a rolling update of the worker nodes if, for example, the machine image version changes.
In this case, a new checksum will be generated which results in the creation of a new machine class.
The <code>MachineDeployment</code>&rsquo;s machine class reference (<code>.spec.template.spec.class.name</code>) is updated, which triggers the rolling update process in the machine-controller-manager.
However, all of this is only a convention that eases writing the controller, but you can do it completely differently if you desire - as long as you make sure that the described behaviours are implemented correctly.</p><p>After the machine classes and machine deployments have been created, the machine-controller-manager will start talking to the provider&rsquo;s IaaS API and create the virtual machines.
Gardener makes sure that the content of the <code>Secret</code> referenced in the <code>userDataSecretRef</code> field that is used to bootstrap the machines contains the required configuration for installation of the kubelet and registering the VM as worker node in the shoot cluster.
The <code>Worker</code> extension controller shall wait until all the created <code>MachineDeployment</code>s indicate healthiness/readiness before it ends the control loop.</p><h2 id=does-gardener-need-some-information-that-must-be-returned-back>Does Gardener need some information that must be returned back?<a class=td-heading-self-link href=#does-gardener-need-some-information-that-must-be-returned-back aria-label="Heading self-link"></a></h2><p>Another important benefit of the machine-controller-manager&rsquo;s design principles (extending the Kubernetes API using CRDs) is that the <a href=https://github.com/gardener/autoscaler>cluster-autoscaler</a> can be used <strong>without</strong> any provider-specific implementation.
We have forked the <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler>upstream Kubernetes community&rsquo;s cluster-autoscaler</a> and extended it so that it understands the machine API.
Definitely, we will merge it back into the community&rsquo;s versions once it has been adapted properly.</p><p>Our cluster-autoscaler only needs to know the minimum and maximum number of replicas <strong>per</strong> <code>MachineDeployment</code> and is ready to act. Without knowing that, it needs to talk to the provider APIs (it just modifies the <code>.spec.replicas</code> field in the <code>MachineDeployment</code> object).
Gardener deploys this autoscaler if there is at least one worker pool that specifies <code>max>min</code>.
In order to know how it needs to configure it, the provider-specific <code>Worker</code> extension controller must expose which <code>MachineDeployment</code>s it has created and how the <code>min</code>/<code>max</code> numbers should look like.</p><p>Consequently, your controller should write this information into the <code>Worker</code> resource&rsquo;s <code>.status.machineDeployments</code> field. It should also update the <code>.status.machineDeploymentsLastUpdateTime</code> field along with <code>.status.machineDeployments</code>, so that gardener is able to deploy Cluster-Autoscaler right after the status is updated with the latest <code>MachineDeployment</code>s and does not wait for the reconciliation to be completed:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>---
</span></span><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: Worker
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: worker
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  lastOperation: ...
</span></span><span style=display:flex><span>  machineDeployments:
</span></span><span style=display:flex><span>  - name: shoot--foo--bar-cpu-worker-z1
</span></span><span style=display:flex><span>    minimum: 2
</span></span><span style=display:flex><span>    maximum: 3
</span></span><span style=display:flex><span>  - name: shoot--foo--bar-cpu-worker-z2
</span></span><span style=display:flex><span>    minimum: 1
</span></span><span style=display:flex><span>    maximum: 2
</span></span><span style=display:flex><span>  machineDeploymentsLastUpdateTime: <span style=color:#a31515>&#34;2023-05-01T12:44:27Z&#34;</span>
</span></span></code></pre></div><p>In order to support a new worker provider, you need to write a controller that watches all <code>Worker</code>s with <code>.spec.type=&lt;my-provider-name></code>.
You can take a look at the below referenced example implementation for the AWS provider.</p><h2 id=that-sounds-like-a-lot-that-needs-to-be-done-can-you-help-me>That sounds like a lot that needs to be done, can you help me?<a class=td-heading-self-link href=#that-sounds-like-a-lot-that-needs-to-be-done-can-you-help-me aria-label="Heading self-link"></a></h2><p>All of the described behaviour is mostly the same for every provider.
The only difference is maybe the version/configuration of the provider-specific <code>machine-controller-manager</code> sidecar container, and the machine class specification itself.
You can take a look at our <a href=https://github.com/gardener/gardener/tree/master/extensions>extension library</a>, especially the <a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker>worker controller</a> part where you will find a lot of utilities that you can use.
Note that there are also utility functions for getting the default sidecar container specification or corresponding VPA container policy in the <a href=https://github.com/gardener/gardener/tree/master/pkg/component/nodemanagement/machinecontrollermanager><code>machinecontrollermanager</code> package</a> called <code>ProviderSidecarContainer</code> and <code>ProviderSidecarVPAContainerPolicy</code>.
Also, using the library you only need to implement your provider specifics - all the things that can be handled generically can be taken for free and do not need to be re-implemented.
Take a look at the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/worker>AWS worker controller</a> for finding an example.</p><h2 id=non-provider-specific-information-required-for-worker-creation>Non-provider specific information required for worker creation<a class=td-heading-self-link href=#non-provider-specific-information-required-for-worker-creation aria-label="Heading self-link"></a></h2><p>All the providers require further information that is not provider specific but already part of the shoot resource.
One example for such information is whether the shoot is hibernated or not.
In this case, all the virtual machines should be deleted/terminated, and after that the machine controller-manager should be scaled down.
You can take a look at the <a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/worker>AWS worker controller</a> to see how it reads this information and how it is used.
As Gardener cannot know which information is required by providers, it simply mirrors the <code>Shoot</code>, <code>Seed</code>, and <code>CloudProfile</code> resources into the seed.
They are part of the <a href=/docs/gardener/extensions/cluster/><code>Cluster</code> extension resource</a> and can be used to extract information that is not part of the <code>Worker</code> resource itself.</p><h2 id=references-and-additional-resources>References and Additional Resources<a class=td-heading-self-link href=#references-and-additional-resources aria-label="Heading self-link"></a></h2><ul><li><a href=https://github.com/gardener/gardener/blob/master/pkg/apis/extensions/v1alpha1/types_worker.go><code>Worker</code> API (Golang Specification)</a></li><li><a href=https://github.com/gardener/gardener/tree/master/extensions>Extension Controller Library</a></li><li><a href=https://github.com/gardener/gardener/tree/master/extensions/pkg/controller/worker>Generic Worker Controller</a></li><li><a href=https://github.com/gardener/gardener-extension-provider-aws/tree/master/pkg/controller/worker>Exemplary Implementation for the AWS Provider</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0a10283207035fd65241bff1e92982ef>19 - Shoot Health Status Conditions</h1><h1 id=contributing-to-shoot-health-status-conditions>Contributing to Shoot Health Status Conditions<a class=td-heading-self-link href=#contributing-to-shoot-health-status-conditions aria-label="Heading self-link"></a></h1><p>Gardener checks regularly (every minute by default) the health status of all shoot clusters.
It categorizes its checks into five different types:</p><ul><li><code>APIServerAvailable</code>: This type indicates whether the shoot&rsquo;s kube-apiserver is available or not.</li><li><code>ControlPlaneHealthy</code>: This type indicates whether the core components of the Shoot controlplane (ETCD, KAPI, KCM..) are healthy.</li><li><code>EveryNodeReady</code>: This type indicates whether all <code>Node</code>s and all <code>Machine</code> objects report healthiness.</li><li><code>ObservabilityComponentsHealthy</code>: This type indicates whether the observability components of the Shoot control plane (Prometheus, Vali, Plutono..) are healthy.</li><li><code>SystemComponentsHealthy</code>: This type indicates whether all system components deployed to the <code>kube-system</code> namespace in the shoot do exist and are running fine.</li></ul><p>In case of workerless <code>Shoot</code>, <code>EveryNodeReady</code> condition is not present in the <code>Shoot</code>&rsquo;s conditions since there are no nodes in the cluster.</p><p>Every <code>Shoot</code> resource has a <code>status.conditions[]</code> list that contains the mentioned types, together with a <code>status</code> (<code>True</code>/<code>False</code>) and a descriptive message/explanation of the <code>status</code>.</p><p>Most extension controllers are deploying components and resources as part of their reconciliation flows into the seed or shoot cluster.
A prominent example for this is the <code>ControlPlane</code> controller that usually deploys a cloud-controller-manager or CSI controllers as part of the shoot control plane.
Now that the extensions deploy resources into the cluster, especially resources that are essential for the functionality of the cluster, they might want to contribute to Gardener&rsquo;s checks mentioned above.</p><h2 id=what-can-extensions-do-to-contribute-to-gardeners-health-checks>What can extensions do to contribute to Gardener&rsquo;s health checks?<a class=td-heading-self-link href=#what-can-extensions-do-to-contribute-to-gardeners-health-checks aria-label="Heading self-link"></a></h2><p>Every extension resource in Gardener&rsquo;s <code>extensions.gardener.cloud/v1alpha1</code> API group also has a <code>status.conditions[]</code> list (like the <code>Shoot</code>).
Extension controllers can write conditions to the resource they are acting on and use a type that also exists in the shoot&rsquo;s conditions.
One exception is that <code>APIServerAvailable</code> can&rsquo;t be used, as Gardener clearly can identify the status of this condition and it doesn&rsquo;t make sense for extensions to try to contribute/modify it.</p><p>As an example for the <code>ControlPlane</code> controller, let&rsquo;s take a look at the following resource:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: extensions.gardener.cloud/v1alpha1
</span></span><span style=display:flex><span>kind: ControlPlane
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: control-plane
</span></span><span style=display:flex><span>  namespace: shoot--foo--bar
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  conditions:
</span></span><span style=display:flex><span>  - type: ControlPlaneHealthy
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;False&#34;</span>
</span></span><span style=display:flex><span>    reason: DeploymentUnhealthy
</span></span><span style=display:flex><span>    message: &#39;Deployment cloud-controller-manager is unhealthy: condition &#34;Available&#34; has
</span></span><span style=display:flex><span>      invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
</span></span><span style=display:flex><span>      does not have minimum availability.&#39;
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:44:27Z&#34;</span>
</span></span><span style=display:flex><span>  - type: ConfigComputedSuccessfully
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>    reason: ConfigCreated
</span></span><span style=display:flex><span>    message: The cloud-provider-config has been successfully computed.
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:43:27Z&#34;</span>
</span></span></code></pre></div><p>The extension controller has declared in its extension resource that one of the deployments it is responsible for is unhealthy.
Also, it has written a second condition using a type that is unknown by Gardener.</p><p>Gardener will pick the list of conditions and recognize that there is one with a type <code>ControlPlaneHealthy</code>.
It will merge it with its own <code>ControlPlaneHealthy</code> condition and report it back to the <code>Shoot</code>&rsquo;s status:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>apiVersion: core.gardener.cloud/v1beta1
</span></span><span style=display:flex><span>kind: Shoot
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    shoot.gardener.cloud/status: unhealthy
</span></span><span style=display:flex><span>  name: some-shoot
</span></span><span style=display:flex><span>  namespace: garden-core
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  conditions:
</span></span><span style=display:flex><span>  - type: APIServerAvailable
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;True&#34;</span>
</span></span><span style=display:flex><span>    reason: HealthzRequestSucceeded
</span></span><span style=display:flex><span>    message: API server /healthz endpoint responded with success status code. [response_time:31ms]
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-23T08:26:52Z&#34;</span>
</span></span><span style=display:flex><span>    lastTransitionTime: <span style=color:#a31515>&#34;2014-05-25T12:45:13Z&#34;</span>
</span></span><span style=display:flex><span>  - type: ControlPlaneHealthy
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;False&#34;</span>
</span></span><span style=display:flex><span>    reason: ControlPlaneUnhealthyReport
</span></span><span style=display:flex><span>    message: &#39;Deployment cloud-controller-manager is unhealthy: condition &#34;Available&#34; has
</span></span><span style=display:flex><span>      invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
</span></span><span style=display:flex><span>      does not have minimum availability.&#39;
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:45:13Z&#34;</span>
</span></span><span style=display:flex><span>    lastTransitionTime: <span style=color:#a31515>&#34;2014-05-25T12:45:13Z&#34;</span>
</span></span><span style=display:flex><span>  ...
</span></span></code></pre></div><p>Hence, the only duty extensions have is to maintain the health status of their components in the extension resource they are managing.
This can be accomplished using the <a href=/docs/gardener/extensions/healthcheck-library/>health check library for extensions</a>.</p><h2 id=error-codes>Error Codes<a class=td-heading-self-link href=#error-codes aria-label="Heading self-link"></a></h2><p>The Gardener API includes some well-defined error codes, e.g., <code>ERR_INFRA_UNAUTHORIZED</code>, <code>ERR_INFRA_DEPENDENCIES</code>, etc.
Extension may set these error codes in the <code>.status.conditions[].codes[]</code> list in case it makes sense.
Gardener will pick them up and will similarly merge them into the <code>.status.conditions[].codes[]</code> list in the <code>Shoot</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>status:
</span></span><span style=display:flex><span>  conditions:
</span></span><span style=display:flex><span>  - type: ControlPlaneHealthy
</span></span><span style=display:flex><span>    status: <span style=color:#a31515>&#34;False&#34;</span>
</span></span><span style=display:flex><span>    reason: DeploymentUnhealthy
</span></span><span style=display:flex><span>    message: &#39;Deployment cloud-controller-manager is unhealthy: condition &#34;Available&#34; has
</span></span><span style=display:flex><span>      invalid status False (expected True) due to MinimumReplicasUnavailable: Deployment
</span></span><span style=display:flex><span>      does not have minimum availability.&#39;
</span></span><span style=display:flex><span>    lastUpdateTime: <span style=color:#a31515>&#34;2014-05-25T12:44:27Z&#34;</span>
</span></span><span style=display:flex><span>    codes:
</span></span><span style=display:flex><span>    - ERR_INFRA_UNAUTHORIZED 
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-a2e99bb1eae354d266924368862541f8>20 - Shoot Maintenance</h1><h1 id=shoot-maintenance>Shoot Maintenance<a class=td-heading-self-link href=#shoot-maintenance aria-label="Heading self-link"></a></h1><p>There is a general <a href=/docs/gardener/shoot/shoot_maintenance/>document about shoot maintenance</a> that you might want to read.
Here, we describe how you can influence certain operations that happen during a shoot maintenance.</p><h2 id=restart-control-plane-controllers>Restart Control Plane Controllers<a class=td-heading-self-link href=#restart-control-plane-controllers aria-label="Heading self-link"></a></h2><p>As outlined in the above linked document, Gardener offers to restart certain control plane controllers running in the seed during a shoot maintenance.</p><p>Extension controllers can extend the amount of pods being affected by these restarts.
If your Gardener extension manages pods of a shoot&rsquo;s control plane (shoot namespace in seed) and it could potentially profit from a regular restart, please consider labeling it with <code>maintenance.gardener.cloud/restart=true</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-be099eb6107ce0525e229d5cfa5bf30b>21 - Shoot Webhooks</h1><h1 id=shoot-resource-customization-webhooks>Shoot Resource Customization Webhooks<a class=td-heading-self-link href=#shoot-resource-customization-webhooks aria-label="Heading self-link"></a></h1><p>Gardener deploys several components/resources into the shoot cluster.
Some of these resources are essential (like the <code>kube-proxy</code>), others are optional addons (like the <code>kubernetes-dashboard</code> or the <code>nginx-ingress-controller</code>).
In either case, some provider extensions might need to mutate these resources and inject provider-specific bits into it.</p><h2 id=whats-the-approach-to-implement-such-mutations>What&rsquo;s the approach to implement such mutations?<a class=td-heading-self-link href=#whats-the-approach-to-implement-such-mutations aria-label="Heading self-link"></a></h2><p>Similar to how <a href=/docs/gardener/extensions/controlplane-webhooks/>control plane components in the seed</a> are modified, we are using <code>MutatingWebhookConfiguration</code>s to achieve the same for resources in the shoot.
Both the provider extension and the kube-apiserver of the shoot cluster are running in the same seed.
Consequently, the kube-apiserver can talk cluster-internally to the provider extension webhook, which makes such operations even faster.</p><h2 id=how-is-the-mutatingwebhookconfiguration-object-created-in-the-shoot>How is the <code>MutatingWebhookConfiguration</code> object created in the shoot?<a class=td-heading-self-link href=#how-is-the-mutatingwebhookconfiguration-object-created-in-the-shoot aria-label="Heading self-link"></a></h2><p>The preferred approach is to use a <code>ManagedResource</code> (see also <a href=/docs/gardener/extensions/managedresources/>Deploy Resources to the Shoot Cluster</a>) in the seed cluster.
This way the <code>gardener-resource-manager</code> ensures that end-users cannot delete/modify the webhook configuration.
The provider extension doesn&rsquo;t need to care about the same.</p><h2 id=what-else-is-needed>What else is needed?<a class=td-heading-self-link href=#what-else-is-needed aria-label="Heading self-link"></a></h2><p>The shoot&rsquo;s kube-apiserver must be allowed to talk to the provider extension.
To achieve this, you need to make sure that the relevant <code>NetworkPolicy</code> get created for allowing the network traffic.
Please refer to <a href=/docs/gardener/network_policies/#webhook-servers>this guide</a> for more information.</p><h2 id=autonomous-shoot-clusters>Autonomous Shoot Clusters<a class=td-heading-self-link href=#autonomous-shoot-clusters aria-label="Heading self-link"></a></h2><p>If running in an autonomous shoot cluster, the shoot webhooks should be merged into the seed webhooks.
You can do so by setting the <code>mergeShootWebhooksIntoSeedWebhooks</code> to <code>true</code> in the <code>extensions/pkg/webhook/cmd.AddToManager</code> function.
Take a look at <a href=/docs/gardener/extensions/registration/#helm-values>this document</a> in order to determine whether the extension runs in an autonomous shoot cluster.</p></div></main></div></div><footer class="footer row d-print-none"><div class="container-fluid footer-wrapper"><ul class=nav><li><a href=https://gardener.cloud/blog/>Blogs</a></li><li><a href=https://gardener.cloud/community/>Community</a></li><li><a href=https://gardener.cloud/adopter/>Adopters</a></li><li><a href=/docs/>Documentation</a></li></ul><img src=/images/lp/gardener-logo.svg alt="Logo Gardener" class=logo><ul class=media-wr><li><a target=_blank href=https://gardener-cloud.slack.com/><img src=/images/branding/slack-logo-white.svg class=media-icon><div class=media-text>Slack</div></a></li><li><a target=_blank href=https://github.com/gardener><img src=/images/branding/github-mark-logo.png class=media-icon><div class=media-text>GitHub</div></a></li><li><a target=_blank href=https://www.youtube.com/channel/UCwUhwKFREV8Su0gwAJQX7tw><img src=/images/branding/youtube-logo-dark.svg class=media-icon><div class=media-text>YouTube</div></a></li><li><a target=_blank href=https://x.com/GardenerProject><img src=/images/branding/x-logo-white.svg class=media-icon><div class=media-text>X</div></a></li></ul><span class=copyright>Copyright 2019-2025 Gardener project authors.
<a href=https://www.sap.com/about/legal/terms-of-use.html>Terms of Use
<i class="fa fa-external-link" aria-hidden=true></i>
</a>|
<a href=https://www.sap.com/about/legal/terms-of-use.html>Privacy Statement
<i class="fa fa-external-link" aria-hidden=true></i>
</a>|
<a href=https://www.sap.com/about/legal/terms-of-use.html>Legal Disclosure
<i class="fa fa-external-link" aria-hidden=true></i></a></span></div></footer></div><script src=/js/main.min.69e2c1ae9320465ab10236d9ef752c6a4442c54b48b883b17c497b7c7d96a796.js integrity="sha256-aeLBrpMgRlqxAjbZ73UsakRCxUtIuIOxfEl7fH2Wp5Y=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script><script src=/js/navbar.js></script><script src=/js/filtering.js></script><script src=/js/page-content.js></script></body></html>